//----------------------------------------------------------------------------
// Shared functions.
//----------------------------------------------------------------------------
void GetDirectionalLightFactors
(
 float3    kModelPosition,
 float3    kModelNormal,
 float3    kCameraPosition,
 float3    kLightDirection,
 float     fSpecularExponent,
 out float fDiffuseFactor,
 out float fSpecularFactor)
{
    float fDiff = 0;
    float fSpec = 0;

    fDiff = -dot(kModelNormal,kLightDirection);
    if (fDiff > 0.0f)
    {
        float3 kViewVector = normalize(kCameraPosition - kModelPosition);
        float3 kHalfVector = normalize(kViewVector - kLightDirection);
        fSpec = dot(kModelNormal,kHalfVector);
        if (fSpec > 0.0f)
        {
            fSpec = pow(fSpec,fSpecularExponent);
        }
        else
        {
            fSpec = 0.0f;
        }
    }
    else
    {
        fDiff = 0.0f;
        fSpec = 0.0f;
    }
    
    fDiffuseFactor = fDiff;
    fSpecularFactor = fSpec;
}
//----------------------------------------------------------------------------
void GetPointLightFactors
(
 float3    kModelPosition,
 float3    kModelNormal,
 float3    kCameraPosition,
 float3    kLightPosition,
 float     fSpecularExponent,
 out float fDiffuseFactor,
 out float fSpecularFactor)
{
    float fDiff, fSpec;

    float3 kVertexDirection = normalize(kModelPosition - kLightPosition);
    fDiff = -dot(kModelNormal,kVertexDirection);
    if (fDiff > 0.0f)
    {
        float3 kViewVector = normalize(kCameraPosition - kModelPosition);
        float3 kHalfVector = normalize(kViewVector - kVertexDirection);
        fSpec = dot(kModelNormal,kHalfVector);
        if (fSpec > 0.0f)
        {
            fSpec = pow(fSpec,fSpecularExponent);
        }
        else
        {
            fSpec = 0.0f;
        }
    }
    else
    {
        fDiff = 0.0f;
        fSpec = 0.0f;
    }

    fDiffuseFactor = fDiff;
    fSpecularFactor = fSpec;
}
//----------------------------------------------------------------------------
void GetSpotLightFactors
(
 float3    kModelPosition,
 float3    kModelNormal,
 float3    kCameraPosition,
 float3    kLightPosition,
 float     fSpecularExponent,
 float3    kSpotAxis,
 float     fSpotCosAngle,
 float     fSpotExponent,
 out float fDiffuseFactor,
 out float fSpecularFactor,
 out float fSpotFactor)
{
    float fDiff, fSpec, fSpot;

    float3 kVertexDirection = normalize(kModelPosition - kLightPosition);
    float fVertexCosAngle = dot(kSpotAxis,kVertexDirection);
    if (fVertexCosAngle >= fSpotCosAngle)
    {
        fDiff = -dot(kModelNormal,kVertexDirection);
        if (fDiff > 0.0f)
        {
            float3 kViewVector = normalize(kCameraPosition - kModelPosition);
            float3 kHalfVector = normalize(kViewVector - kVertexDirection);
            fSpec = dot(kModelNormal,kHalfVector);
            if (fSpec > 0.0f)
            {
                fSpec = pow(fSpec,fSpecularExponent);
            }
            else
            {
                fSpec = 0.0f;
            }
            fSpot = pow(fVertexCosAngle,fSpotExponent);
        }
        else
        {
            fDiff = 0.0f;
            fSpec = 0.0f;
            fSpot = 0.0f;
        }
    }
    else
    {
        fDiff = 0.0f;
        fSpec = 0.0f;
        fSpot = 0.0f;
    }

    fDiffuseFactor = fDiff;
    fSpecularFactor = fSpec;
    fSpotFactor = fSpot;
}

float GetAttenuation
(
 float3   kModelPos,
 float3   kLightPos, 
 float4   kAttenuation)
{
    // Attenuate the color (x=constant, y=linear, z=quadratic, w=intensity).
    // Attenuation is not active when the x component is zero.  The distance
    // must be computed in *world* coordinates.  The distance in camera
    // coordinates is not correct when the MVP matrix has nonunit scaling
    // factors.
    
    float3 kVertexWorldDir = kModelPos - kLightPos;
    //float3 kVertexModelDir = kModelPos - kLightPos;
    //float3 kVertexWorldDir = mul(kVertexModelDir,kWMatrix);
    float fDistance = sqrt(
                           kVertexWorldDir.x*kVertexWorldDir.x +
                           kVertexWorldDir.y*kVertexWorldDir.y +
                           kVertexWorldDir.z*kVertexWorldDir.z);

    float fAttn = kAttenuation.w/(kAttenuation.x + fDistance*(kAttenuation.y
                                                              + fDistance*kAttenuation.z));
    
    return fAttn;
}

void AmbientLight( uniform float3   MaterialEmissive,
                   uniform float3   MaterialAmbient,
                   uniform float3   LightAmbient,
                   uniform float4   LightAttenuation,
                   out     float4 kVertexColor)

{
    float3 kLAmb = LightAttenuation.w*LightAmbient;
    kVertexColor.rgb = MaterialEmissive + MaterialAmbient*kLAmb;
    kVertexColor.a = 1.0;
}

void DirectionalLight( uniform float3 kModelPosition,
                       uniform float3 kModelNormal,
                       uniform float3   CameraWorldPosition,
                       uniform float3   MaterialEmissive,
                       uniform float3   MaterialAmbient,
                       uniform float4   MaterialDiffuse,
                       uniform float4   MaterialSpecular,
                       uniform float3   LightDirection,
                       uniform float3   LightAmbient,
                       uniform float3   LightDiffuse,
                       uniform float3   LightSpecular,
                       uniform float4   LightAttenuation,
                       out     float4 kVertexColor)
    
{
    float fDiff, fSpec;
    GetDirectionalLightFactors(kModelPosition,kModelNormal,
                               CameraWorldPosition,LightDirection,MaterialSpecular.a,
                               fDiff,fSpec);
    float3 kColor = MaterialAmbient*LightAmbient;
    if (fDiff > 0.0f)
    {
        kColor += fDiff*MaterialDiffuse.rgb*LightDiffuse;
        if (fSpec > 0.0f)
        {
            kColor += fSpec*MaterialSpecular.rgb*LightSpecular;
        }
    }

    kVertexColor.rgb = MaterialEmissive + LightAttenuation.w*kColor;
    kVertexColor.a = 1.0;
}

void PointLight(    uniform float3 kModelPosition,
                    uniform float3 kModelNormal,
                    uniform float3   CameraWorldPosition,
                    uniform float3   MaterialEmissive,
                    uniform float3   MaterialAmbient,
                    uniform float4   MaterialDiffuse,
                    uniform float4   MaterialSpecular,
                    uniform float3   LightWorldPosition,
                    uniform float3   LightAmbient,
                    uniform float3   LightDiffuse,
                    uniform float3   LightSpecular,
                    uniform float4   LightAttenuation,
                    out     float4 kVertexColor)
{
    float fDiff, fSpec;
    GetPointLightFactors(kModelPosition.xyz,kModelNormal,
                         CameraWorldPosition,LightWorldPosition,MaterialSpecular.a,
                         fDiff,fSpec);

    float fAttn = GetAttenuation(kModelPosition.xyz,
                                 LightWorldPosition,LightAttenuation);

    float3 kColor = MaterialAmbient*LightAmbient;
    if (fDiff > 0.0f)
    {
        kColor += fDiff*MaterialDiffuse.xyz*LightDiffuse;
        if (fSpec > 0.0f)
        {
            kColor += fSpec*MaterialSpecular.xyz*LightSpecular;
        }
    }

    kVertexColor.rgb = MaterialEmissive + fAttn*kColor;
    kVertexColor.a = MaterialDiffuse.a;
}

void SpotLight(    uniform float3 kModelPosition,
                   uniform float3 kModelNormal,
                   uniform float3 CameraWorldPosition,
                   uniform float3 MaterialEmissive,
                   uniform float3 MaterialAmbient,
                   uniform float4 MaterialDiffuse,
                   uniform float4 MaterialSpecular,
                   uniform float3 LightWorldPosition,
                   uniform float3 LightWorldDirection,
                   uniform float3 LightAmbient,
                   uniform float3 LightDiffuse,
                   uniform float3 LightSpecular,
                   uniform float4 LightSpotCutoff,
                   uniform float4 LightAttenuation,
                   out     float4 kVertexColor)
{
    float fDiff, fSpec, fSpot;
    GetSpotLightFactors(kModelPosition.xyz,kModelNormal,
                        CameraWorldPosition,LightWorldPosition,MaterialSpecular.a,
                        LightWorldDirection,LightSpotCutoff.y,LightSpotCutoff.w,fDiff,
                        fSpec,fSpot);

    float fAttn = GetAttenuation(kModelPosition.xyz,
                                 LightWorldPosition,LightAttenuation);

    float3 kColor = MaterialAmbient*LightAmbient;
    if (fSpot > 0.0f)
    {
        if (fDiff > 0.0f)
        {
            kColor += (fSpot*fDiff)*MaterialDiffuse.rgb*LightDiffuse;
            if (fSpec > 0.0f)
            {
                kColor += (fSpot*fSpec)*MaterialSpecular.rgb*LightSpecular;
            }
        }
    }
    
    kVertexColor.rgb = MaterialEmissive + fAttn*kColor;
    kVertexColor.a = MaterialDiffuse.a;
}


/**
 * Compute the surface color based on lighting.
 */
void computeColor( float3 kModelPosition, float3 kModelNormal, float3 CameraWorldPosition, 
                   float3 MaterialEmissive, float3 MaterialAmbient, float4 MaterialDiffuse, float4 MaterialSpecular,
                   float4 LightAmbient, float4 LightDiffuse, float4 LightSpecular,
                   float4 LightWorldPosition, float4 LightWorldDirection,
                   float4 LightSpotCutoff, float4 LightAttenuation,
                   float LightType,
                   float Composite,
                   inout float4 color_sample)
{
    if ( LightType == -1 )
    {
//         color_sample.r = kModelNormal.x;
//         color_sample.g = kModelNormal.y;
//         color_sample.b = kModelNormal.z;
        color_sample.r = 0;
        color_sample.g = 0;
        color_sample.b = 0;
    }
    else
    {
        //float3 local_normal = kModelNormal.xyz - (0.5, 0.5, 0.5);
        float3 local_normal = (2.0* kModelNormal.xyz) - (1.0, 1.0, 1.0);
        local_normal = normalize( local_normal );

        float3 LocalMaterialAmbient = MaterialAmbient;
        float4 LocalMaterialDiffuse = MaterialDiffuse;
        float3 LocalMaterialEmissive = MaterialEmissive;
        float4 LocalMaterialSpecular = MaterialSpecular;

        if ( Composite != 0 )
        {
            LocalMaterialAmbient = color_sample.xyz * MaterialAmbient;
            LocalMaterialDiffuse = color_sample * MaterialDiffuse;
            LocalMaterialEmissive = color_sample.xyz * MaterialEmissive;
            LocalMaterialSpecular = color_sample * MaterialSpecular;
        }

        if ( LightType == 0 )
        {
            AmbientLight( LocalMaterialEmissive,
                          LocalMaterialAmbient,
                          LightAmbient,
                          LightAttenuation,
                          color_sample );
        }
        else if ( LightType == 1 )
        {
            DirectionalLight(  kModelPosition,
                               local_normal,
                               CameraWorldPosition,
                               LocalMaterialEmissive,
                               LocalMaterialAmbient,
                               LocalMaterialDiffuse,
                               LocalMaterialSpecular,
                               LightWorldDirection,
                               LightAmbient,
                               LightDiffuse,
                               LightSpecular,
                               LightAttenuation,
                               color_sample);

        }
        else if ( LightType == 2 )
        {
            PointLight( kModelPosition,
                        local_normal,
                        CameraWorldPosition,
                        LocalMaterialEmissive,
                        LocalMaterialAmbient,
                        LocalMaterialDiffuse,
                        LocalMaterialSpecular,
                        LightWorldPosition,
                        LightAmbient,
                        LightDiffuse,
                        LightSpecular,
                        LightAttenuation,
                        color_sample);
        }
        else
        {
            SpotLight( kModelPosition,
                       local_normal,
                       CameraWorldPosition,
                       LocalMaterialEmissive,
                       LocalMaterialAmbient,
                       LocalMaterialDiffuse,
                       LocalMaterialSpecular,
                       LightWorldPosition,
                       LightWorldDirection,
                       LightAmbient,
                       LightDiffuse,
                       LightSpecular,
                       LightSpotCutoff,
                       LightAttenuation,
                       color_sample);
        }
    }
}

/**
 * Clip the volume based on the x,y,z axes.
 * returns 1 when the volume is clipped, 0 when not clipped.
 */
bool myClip ( float3 myVec,
              float clipX,
              float clipXInv,
              float clipY,
              float clipYInv,
              float clipZ,
              float clipZInv )
{
    if ( myVec.x > clipX )
    {
        return true;
    }
    if ( myVec.x < clipXInv )
    {
        return true;
    }
    if ( myVec.y > clipY )
    {
        return true;
    }
    if ( myVec.y < clipYInv )
    {
        return true;
    }
    if ( myVec.z > clipZ )
    {
        return true;
    }
    if ( myVec.z < clipZInv )
    {
        return true;
    }
    return false;
}


/** Raycasting fragment program implementation */
void p_VolumeShaderSUR(  in float3 inTexCoord1    : TEXCOORD0,
                         in float4 inPos,
                         out float4 kColor	    : COLOR0,
                         uniform sampler2D SceneImage : TEXUNIT0, 

                         uniform sampler3D VolumeImageA : TEXUNIT1, 
                         uniform sampler1D ColorMapA : TEXUNIT2, 
                         uniform sampler1D OpacityMapA : TEXUNIT3, 
                         uniform sampler3D NormalMapA: TEXUNIT4, 
                         uniform sampler3D VolumeImageGMA: TEXUNIT5, 
                         uniform sampler1D OpacityMapA_GM : TEXUNIT6, 
                         uniform sampler3D VolumeImageGMGMA: TEXUNIT7, 

                         uniform sampler3D VolumeImageB : TEXUNIT8, 
                         uniform sampler1D ColorMapB : TEXUNIT9, 
                         uniform sampler1D OpacityMapB : TEXUNIT10, 
                         uniform sampler3D NormalMapB: TEXUNIT11, 
                         uniform sampler3D VolumeImageGMB: TEXUNIT12, 
                         uniform sampler1D OpacityMapB_GM : TEXUNIT13, 
                         uniform sampler3D VolumeImageGMGMB: TEXUNIT14, 

                         uniform float ShowB,
                         uniform float ABBlend,
                         uniform float blend,
                         uniform float stepsize,
                         uniform float4 steps,
                         uniform float IsColor,
                         uniform float IsColorB,
                         uniform float DoClip,
                         uniform float SelfShadow,
                         uniform float GradientMagnitude,
                         uniform float GradientMagnitudeB,
                         uniform float Composite,
                         uniform float4 BackgroundColor,
                         uniform float3 Translation,

                         uniform float clipX,
                         uniform float clipXInv,
                         uniform float clipY,
                         uniform float clipYInv,
                         uniform float clipZ,
                         uniform float clipZInv,
                         uniform float4 clipArb,
                         uniform float4 clipEye,
                         uniform float4 clipEyeInv,

                         uniform float3 MaterialEmissive,
                         uniform float3 MaterialAmbient,
                         uniform float4 MaterialDiffuse,
                         uniform float4 MaterialSpecular,

                         uniform float  Light0Type,
                         uniform float4 Light0Ambient,
                         uniform float4 Light0Diffuse,
                         uniform float4 Light0Specular,
                         uniform float4 Light0SpotCutoff,
                         uniform float4 Light0Attenuation,
                         uniform float4 Light0ModelPosition,
                         uniform float4 Light0ModelDirection,

                         uniform float4 Light1Ambient,
                         uniform float4 Light1Attenuation,

                         uniform float  Light2Type,
                         uniform float4 Light2Ambient,
                         uniform float4 Light2Diffuse,
                         uniform float4 Light2Specular,
                         uniform float4 Light2SpotCutoff,
                         uniform float4 Light2Attenuation,
                         uniform float4 Light2WorldPosition,
                         uniform float4 Light2WorldDirection,

                         uniform float  Light3Type,
                         uniform float4 Light3Ambient,
                         uniform float4 Light3Diffuse,
                         uniform float4 Light3Specular,
                         uniform float4 Light3SpotCutoff,
                         uniform float4 Light3Attenuation,
                         uniform float4 Light3WorldPosition,
                         uniform float4 Light3WorldDirection,

                         uniform float3 CameraModelPosition,
                         uniform float3 CameraWorldPosition,
                         uniform float4x4 WMatrix,
                         uniform float4x4 WVPMatrix)
{
    // find the right place to lookup in the backside buffer
    float2 texc = ((inPos.xy / inPos.w) + 1) / 2.0;
    float4 back_position  = tex2D(SceneImage, texc);

    // the start position of the ray is stored in the texturecoordinate
    float3 start = inTexCoord1; 

    // the ray direction
    float3 dir = back_position.xyz - start;

    // the length from front to back is calculated and used to terminate the ray
    float len = length(dir.xyz); 

    // normalized direction vector:
    float3 norm_dir = normalize(dir);

    // current position along the ray: 
    float3 position = start.xyz;

    // The accumulated color and alpha values:
    float4 color_acc = float4(0,0,0,0);
    float alpha_acc = 0;

    float4 color_accB = float4(0,0,0,0);
    float alpha_accB = 0;

    // output color:
    kColor = BackgroundColor;
    if ( (back_position.x == 0) && (back_position.y == 0) && (back_position.z == 0) )
    {
        return;
    }

    // limit the number of iterations to STEPS, make sure that the stepsize will
    // cover the entire ray:
    if ( (len/stepsize) > steps[0] )
    {
        stepsize = len/steps[0];
    }

    // The color at the current position along the ray:
    float4 color = (0,0,0,0);
    float4 colorB = (0,0,0,0);

    // The opacity at the current position along the ray:
    float opacity = 0;
    float opacityB = 0;
    // Gradient magnitude values along the ray:
    float colorGM = 0;
    float opacityGM = 0;
    float colorGM_B = 0;
    float opacityGM_B = 0;

    // The normal at the current position along the ray:
    float4 normal = (0,0,0,0);

    float alpha_sample = stepsize;
    float delta = stepsize;
    float3 delta_dir = norm_dir * delta;
    float delta_dir_len = length(delta_dir);
    float length_acc = 0;
    bool bClipped = false;

    float4 worldNormal;
    float4 color0 = (0,0,0,0);
    float4 color1 = (0,0,0,0);
    float4 color2 = (0,0,0,0);
    float4 color3 = (0,0,0,0);


    float3 LocalMaterialAmbient = MaterialAmbient;
    float3 LocalMaterialEmissive = MaterialEmissive;

    // For some profiles the number of loop iterations must be determined at
    // compile time:
    for( int i = 0; i < 450; i++ )
    {
        // axis-aligned clipping:
        if ( (DoClip != 0) && myClip( position, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
        {
            color = (0,0,0,0);
            opacity = 0;
        }
        else
        {
            bClipped = false;
            if ( DoClip != 0 )
            {
                // eye clipping and arbitrary clipping:
                float4 aPosition = float4(0,0,0,0);
                aPosition.xyz = position.xyz - (.5,.5,.5);
                aPosition = mul( aPosition, WVPMatrix );
                aPosition.xyz = aPosition.xyz + (.5,.5,.5);
                float fDot = dot( aPosition.xyz, clipEye.xyz );
                float fDotInv = dot( aPosition.xyz, clipEyeInv.xyz );
                float fDotArb = dot( position.xyz, clipArb.xyz );
                if ( (fDot < clipEye.w) || (fDotInv > clipEyeInv.w) || (fDotArb > clipArb.w) )
                {
                    color = (0,0,0,0);
                    opacity = 0;
                    bClipped = true;
                }
            }
            // The value is not clipped, compute the color:
            if ( !bClipped )
            {
                color = tex3D(VolumeImageA,position);
                opacity = tex1D(OpacityMapA,color.r).r;
                if ( GradientMagnitude != 0 )
                {
                    colorGM = tex3D(VolumeImageGMA,position).r;
                    opacityGM = tex1D(OpacityMapA_GM,colorGM).r;
                    opacity = opacity * opacityGM;
                }

                if ( IsColor != 0 )
                {
                    color.r = tex1D(ColorMapA,color.r).r;
                    color.g = tex1D(ColorMapA,color.g).g;
                    color.b = tex1D(ColorMapA,color.b).b;
                }
                else
                {
                    color = tex1D(ColorMapA,color.r);
                }
                if ( ShowB != 0 )
                {
                    colorB = tex3D(VolumeImageB,position);
                    opacityB = tex1D(OpacityMapB,colorB.r).r;
                    if ( GradientMagnitude != 0 )
                    {
                        colorGM_B = tex3D(VolumeImageGMB,position).b;
                        opacityGM_B = tex1D(OpacityMapB_GM,colorGM_B).r;
                        opacityB = opacityB * opacityGM_B;
                    }

                    if ( IsColorB != 0 )
                    {
                        colorB.r = tex1D(ColorMapB,colorB.r).r;
                        colorB.g = tex1D(ColorMapB,colorB.g).g;
                        colorB.b = tex1D(ColorMapB,colorB.b).b;
                    }
                    else
                    {
                        colorB = tex1D(ColorMapB,colorB.r);
                    }
                }
            }
        }
        // If the opacity is not zero:
        if ( (opacity > 0) && (alpha_acc < 1) )
        {
            // Surface and Composite surface display:
            normal = tex3D(NormalMapA,position);
            normal.w = 0;

            // First light is static light:
            color0 = color;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light0Ambient, Light0Diffuse, Light0Specular,
                          Light0ModelPosition, Light0ModelDirection,
                          Light0SpotCutoff, Light0Attenuation,
                          Light0Type,
                          Composite, color0 );

            // Assume second light is alwasy an ambient light:
            color1 = color;
            if ( Composite != 0 )
            {
                LocalMaterialAmbient = color1 * MaterialAmbient;
                LocalMaterialEmissive = color1 * MaterialEmissive;
            }
            AmbientLight( LocalMaterialEmissive,
                          LocalMaterialAmbient,
                          Light1Ambient,
                          Light1Attenuation,
                          color1 );

            // Remaining lights:
            color2 = color;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light2Ambient, Light2Diffuse, Light2Specular,
                          Light2WorldPosition, Light2WorldDirection,
                          Light2SpotCutoff, Light2Attenuation,
                          Light2Type,
                          Composite, color2 );

            color3 = color;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light3Ambient, Light3Diffuse, Light3Specular,
                          Light3WorldPosition, Light3WorldDirection,
                          Light3SpotCutoff, Light3Attenuation,
                          Light3Type,
                          Composite, color3 );

            color = color0 + color1 + color2 + color3;

            // Composite surface:
            if ( Composite != 0 )
            {
                color_acc   = (1.0 - alpha_acc) * color * opacity + color_acc;
                alpha_acc += (1 - alpha_acc) * opacity;
            }
            // Surface:
            else if ( (color.x != 0) || (color.y != 0) || (color.z != 0) )
            {
                color_acc   = color;
                alpha_acc = 1.0;
            }
        }

        // If the opacity is not zero:
        if ( (opacityB > 0) && (alpha_accB < 1) )
        {
            // Surface and Composite surface display:
            normal = tex3D(NormalMapB,position);
            normal.w = 0;

            // First light is static light:
            color0 = colorB;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light0Ambient, Light0Diffuse, Light0Specular,
                          Light0ModelPosition, Light0ModelDirection,
                          Light0SpotCutoff, Light0Attenuation,
                          Light0Type,
                          Composite, color0 );

            // Assume second light is alwasy an ambient light:
            color1 = colorB;
            if ( Composite != 0 )
            {
                LocalMaterialAmbient = color1 * MaterialAmbient;
                LocalMaterialEmissive = color1 * MaterialEmissive;
            }
            AmbientLight( LocalMaterialEmissive,
                          LocalMaterialAmbient,
                          Light1Ambient,
                          Light1Attenuation,
                          color1 );

            // Remaining lights:
            color2 = colorB;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light2Ambient, Light2Diffuse, Light2Specular,
                          Light2WorldPosition, Light2WorldDirection,
                          Light2SpotCutoff, Light2Attenuation,
                          Light2Type,
                          Composite, color2 );

            color3 = colorB;
            computeColor( position, normal, CameraModelPosition,
                          MaterialEmissive,  MaterialAmbient, MaterialDiffuse, MaterialSpecular,
                          Light3Ambient, Light3Diffuse, Light3Specular,
                          Light3WorldPosition, Light3WorldDirection,
                          Light3SpotCutoff, Light3Attenuation,
                          Light3Type,
                          Composite, color3 );

            colorB = color0 + color1 + color2 + color3;

            // Composite surface:
            if ( Composite != 0 )
            {
                color_accB   = (1.0 - alpha_accB) * colorB * opacityB + color_accB;
                alpha_accB += (1 - alpha_accB) * opacityB;
            }
            // Surface:
            else if ( (colorB.x != 0) || (colorB.y != 0) || (colorB.z != 0) )
            {
                color_accB   = colorB;
                alpha_accB = 1.0;
            }
        }


        // Increment position along the ray:
        position += delta_dir;
        length_acc += delta_dir_len;
        // Break when the end of the ray is reached, or if alpha >= 1;
        if ( length_acc >= len )
        {
            break;
        }
        if ( (ShowB == 0) && (alpha_acc >= 1) )
        {
            break;
        }
        if ( (ShowB != 0) && (alpha_acc >= 1) && (alpha_accB >= 1) )
        {
            break;
        } 
    }

//     // Self-shadowing is possible for Surface mode:
//     if ( (SelfShadow != 0) && (Composite == 0) && (alpha_acc == 1.0) ) {
//         // Use the normal at the start position:
//         float3 local_normal = normal.xyz - (0.5, 0.5, 0.5);
//         local_normal = normalize( local_normal );

//         // normal at occluding position:
//         float4 normal2;
//         float3 local_normal2;

//         // for each light, determine whether it is blocked by an opaque surface.
//         // start at position + incr, step to light position

//         // save start position, reuse for the next light
//         start = position;

//         // for each light that can cause shadows:
//         // Light0:
//         float3 dir1 = Light0ModelPosition.xyz - start;
//         float3 norm_dir1 = normalize(dir1);
//         float3 delta_dir1 = norm_dir1 * stepsize;
//         float3 delta_dir_len1 = length(delta_dir1);
//         float3 position1 = start;
//         // Light2:
//         float3 dir2 = Light2WorldPosition.xyz - start;
//         float3 norm_dir2 = normalize(dir2);
//         float3 delta_dir2 = norm_dir2 * stepsize;
//         float3 delta_dir_len2 = length(delta_dir2);
//         float3 position2 = start;
//         // Light3:
//         float3 dir3 = Light3WorldPosition.xyz - start;
//         float3 norm_dir3 = normalize(dir3);
//         float3 delta_dir3 = norm_dir3 * stepsize;
//         float3 delta_dir_len3 = length(delta_dir3);
//         float3 position3 = start;

//         bool break1 = false;
//         bool break2 = false;
//         bool break3 = false;

//         if ( Light0Type == -1 )
//         {
//             break1 = true;
//         }
//         if ( Light2Type == -1 )
//         {
//             break2 = true;
//         }
//         if ( Light3Type == -1 )
//         {
//             break3 = true;
//         }

//         for( int i = 0; i < 450; i++ )
//         {
//             // Light0:
//             if ( !break1 )
//             {
//                 // If we find a non-zero opacity, remove the color contribution
//                 color = tex3D(VolumeImageA,position1);
//                 opacity = tex1D(OpacityMapA,color.r).r;
//                 if (opacity > 0)
//                 {
//                     normal2 = tex3D(NormalMapA,position1);
//                     local_normal2 = normal2.xyz - (0.5, 0.5, 0.5);
//                     local_normal2 = normalize( local_normal2 );
//                     if ( dot(local_normal.xyz, local_normal2.xyz) < 0 )
//                     {
//                         color_acc -= color0;
//                         break1 = true;
//                     }
//                 }
//                 // Increment position along the ray:
//                 if ( Light0Type == 1 )
//                 {
//                     position1 -= delta_dir1;
//                 }
//                 else
//                 {
//                     position1 += delta_dir1;
//                 }
//                 if ( (position1.x < 0.0) || (position1.x > 1.0) ||
//                      (position1.y < 0.0) || (position1.y > 1.0) ||
//                      (position1.z < 0.0) || (position1.z > 1.0)    )
//                 {
//                     break1 = true;
//                 }
//             }

//             // Light2:
//             if ( !break2 )
//             {
//                 // If we find a non-zero opacity, remove the color contribution
//                 color = tex3D(VolumeImageA,position2);
//                 opacity = tex1D(OpacityMapA,color.r).r;
//                 if (opacity > 0)
//                 {
//                     normal2 = tex3D(NormalMapA,position2);
//                     local_normal2 = normal2.xyz - (0.5, 0.5, 0.5);
//                     local_normal2 = normalize( local_normal2 );
//                     if ( dot(local_normal.xyz, local_normal2.xyz) < 0 )
//                     {
//                         color_acc -= color2;
//                         break2 = true;
//                     }
//                 }
//                 // Increment position along the ray:
//                 if ( Light2Type == 1 )
//                 {
//                     position2 -= delta_dir2;
//                 }
//                 else
//                 {
//                     position2 += delta_dir2;
//                 }
//                 if ( (position2.x < 0.0) || (position2.x > 1.0) ||
//                      (position2.y < 0.0) || (position2.y > 1.0) ||
//                      (position2.z < 0.0) || (position2.z > 1.0)    )
//                 {
//                     break2 = true;
//                 }
//             }            
//             // Light3:
//             if ( !break3 )
//             {
//                 // If we find a non-zero opacity, remove the color contribution
//                 color = tex3D(VolumeImageA,position3);
//                 opacity = tex1D(OpacityMapA,color.r).r;
//                 if (opacity > 0)
//                 {
//                     normal2 = tex3D(NormalMapA,position3);
//                     local_normal2 = normal2.xyz - (0.5, 0.5, 0.5);
//                     local_normal2 = normalize( local_normal2 );
//                     if ( dot(local_normal.xyz, local_normal2.xyz) < 0 )
//                     {
//                         color_acc -= color3;
//                         break3 = true;
//                     }
//                 }
//                 // Increment position along the ray:
//                 if ( Light3Type == 1 )
//                 {
//                     position3 -= delta_dir3;
//                 }
//                 else
//                 {
//                     position3 += delta_dir3;
//                 }
//                 if ( (position3.x < 0.0) || (position3.x > 1.0) ||
//                      (position3.y < 0.0) || (position3.y > 1.0) ||
//                      (position3.z < 0.0) || (position3.z > 1.0)    )
//                 {
//                     break3 = true;
//                 }
//             }            

//             if ( break1 && break2 && break3 )
//             {
//                 break;
//             }
//         }
//     }

    if ( ShowB != 0 )
    {
        kColor.rgb = ABBlend * color_acc.rgb + (1 - ABBlend) * color_accB.rgb;
        float fAlpha = ABBlend * alpha_acc + (1 - ABBlend) * alpha_accB;
        kColor.rgb = fAlpha * kColor.rgb + (1-fAlpha)*BackgroundColor.rgb;
        kColor.a = blend;
    }
    else
    {
        kColor.rgb = alpha_acc * color_acc.rgb + (1 - alpha_acc)*BackgroundColor.rgb;
        kColor.a = blend * alpha_acc;
    }
}
