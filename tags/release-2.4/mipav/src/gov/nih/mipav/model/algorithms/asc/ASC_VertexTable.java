package gov.nih.mipav.model.algorithms.asc;

import java.util.*;

/**
 * A vertex-edge data structure that is used to store the vertices and edges
 * that are extract for the six faces of a voxel.  The data structure
 * supports the ear-clipping algorithm for locating triangles in the mesh.
 * It also supports the triangle fanning that is necessary to deal with
 * crack avoidance on shared faces of two monoregions.
 */

public class ASC_VertexTable
{
    /**
     * A representation of a vertex in the vertex-edge mesh for a voxel.
     * Each vertex stores an (x,y,z) triple for location.  The number of
     * edges sharing the vertex is either 2 (an edge point) or 4 (a face
     * center point), so the adjacency array (of vertex indices) is allocated
     * to the maximum of 4.  The validity flag is used when removing
     * vertices as part of the ear-clipping process.
     */
    public class Vertex
    {
        /**
         * Create a vertex for the vertex-edge mesh.
         */
        public Vertex ()
        {
            m_iAdjQuantity = 0;
            m_aiAdj = new int[4];
            m_bValid = false;
        }

        public Vertex (float fX, float fY, float fZ)
        {
            m_fX = fX;
            m_fY = fY;
            m_fZ = fZ;
            m_iAdjQuantity = 0;
            m_aiAdj = new int[4];
            m_bValid = true;
        }

        // the vertex location in the voxel
        public float m_fX, m_fY, m_fZ;

        // the adjacency array (indices of neighboring vertices)
        public int m_iAdjQuantity;
        public int m_aiAdj[/*4*/];

        // 'true' if and only if the vertex is still considered to be in
        // the vertex-edge mesh
        boolean m_bValid;
    }

    /**
     * Create a vertex-edge table.
     */
    public ASC_VertexTable ()
    {
        m_kVertex = new Vector();
        for (int i = 0; i < 18; i++)
            m_kVertex.add(new Vertex());

        m_aiAdj = new int[4];
    }

    /**
     * A simple accessor to the validity flag of the specified vertex.
     *
     * @param i the index of the vertex in m_kVertex
     * @return 'true' if and only if the vertex is valid
     */
    public boolean isValidVertex (int i)
    {
        Vertex kV = (Vertex)m_kVertex.get(i);
        return kV.m_bValid;
    }

    /**
     * Get the number of vertices stored in the table.
     *
     * @return the number of vertices
     */
    public int getVertexQuantity ()
    {
        return m_kVertex.size();
    }

    /**
     * Get a point in the vertex array.
     *
     * @param i the index of the vertex in m_akVertex (0 <= i < 18)
     * @return the vertex
     */
    public Vertex getVertex (int i)
    {
        return (Vertex)m_kVertex.get(i);
    }

    /**
     * Insert a point into the vertex array at the specified location.  This
     * function is used only for those vertices that are on the edges of the
     * cube (12 possibilities) or on the faces because of a branch point
     * (6 possibilities).
     *
     * @param i   the index of the vertex in m_kVertex, 0 <= i < 18
     * @param fX  the x component of the point
     * @param fY  the y component of the point
     * @param fZ  the z component of the point
     */
    public void insert (int i, float fX, float fY, float fZ)
    {
        Vertex kV = (Vertex)m_kVertex.get(i);

        kV.m_fX = fX;
        kV.m_fY = fY;
        kV.m_fZ = fZ;
        kV.m_bValid = true;
    }

    /**
     * Insert a point into the vertex array.  This function is used for
     * those vertices generated by subdividing edges to avoid cracks.  The
     * vertex is appended to the array.
     *
     * @param fX  the x component of the point
     * @param fY  the y component of the point
     * @param fZ  the z component of the point
     */
    public void insert (float fX, float fY, float fZ)
    {
        m_kVertex.add(new Vertex(fX,fY,fZ));
    }

    /**
     * Remove a point from the vertex array.  The specified vertex must have
     * only two edges sharing it (m_iAdjQuantity is exactly 2).
     *
     * @param i the index of the vertex in m_akVertex (0 <= i < 18)
     */
    public void removeVertex (int i)
    {
        // the vertex to be removed
        Vertex kV0 = (Vertex)m_kVertex.get(i);

        // the adjacent vertices of the one to be removed
        int iA0 = kV0.m_aiAdj[0], iA1 = kV0.m_aiAdj[1];
        Vertex kVA0 = (Vertex)m_kVertex.get(iA0);
        Vertex kVA1 = (Vertex)m_kVertex.get(iA1);

        // Break the edge to vertex i and reconnect to the other adjacent
        // vertex.
        int j;
        for (j = 0; j < kVA0.m_iAdjQuantity; j++)
        {
            if ( kVA0.m_aiAdj[j] == i )
            {
                kVA0.m_aiAdj[j] = iA1;
                break;
            }
        }
        // assert: j != kVA0.m_iAdjQuantity

        // Break the edge to vertex i and reconnect to the other adjacent
        // vertex.
        for (j = 0; j < kVA1.m_iAdjQuantity; j++)
        {
            if ( kVA1.m_aiAdj[j] == i )
            {
                kVA1.m_aiAdj[j] = iA0;
                break;
            }
        }
        // assert: j != kVA1.m_iAdjQuantity

        // remove the vertex by making it 'invalid'
        kV0.m_bValid = false;

        // If the triangle is isolated from the rest of the vertex-edge mesh,
        // the removal of the vertex will leave a single edge.  Remove such
        // edges.
        if ( kVA0.m_iAdjQuantity == 2 )
        {
            if ( kVA0.m_aiAdj[0] == kVA0.m_aiAdj[1] )
                kVA0.m_bValid = false;
        }

        if ( kVA1.m_iAdjQuantity == 2 )
        {
            if ( kVA1.m_aiAdj[0] == kVA1.m_aiAdj[1] )
                kVA1.m_bValid = false;
        }
    }

    /**
     * Insert an edge into the vertex-edge mesh.
     *
     * @param i0 the index of the first end point (0 <= i0 < 18)
     * @param i1 the index of the second end point (0 <= i1 < 18)
     */
    public void insert (int i0, int i1)
    {
        Vertex kV0 = (Vertex)m_kVertex.get(i0);
        Vertex kV1 = (Vertex)m_kVertex.get(i1);

        // assert: kV0.m_iAdjQuantity < 4 && kV1.m_iAdjQuantity < 4
        kV0.m_aiAdj[kV0.m_iAdjQuantity++] = i1;
        kV1.m_aiAdj[kV1.m_iAdjQuantity++] = i0;
    }

    /**
     * Get the vertex indices for the edges sharing vertex i.  The indices
     * are stored in the class member m_aiAdj[] and the number of indices
     * in this array is stored in the class member m_iAdjQuantity.
     *
     * @param i the index of the vertex in m_akVertex (0 <= i < 18)
     */
    public void getEdges (int i)
    {
        // assert: 0 <= i && i < 18
        Vertex kV = (Vertex)m_kVertex.get(i);

        m_iAdjQuantity = kV.m_iAdjQuantity;
        for (int j = 0; j < 4; j++)
            m_aiAdj[j] = kV.m_aiAdj[j];
    }

    /**
     * Clip an ear from the vertex-edge mesh.  The triple of indices for
     * the removed triangle are stored in the class members m_i0, m_i1, and
     * m_i2.
     *
     * @return 'true' if and only if a triangle was removed.  This function
     *    is called repeatedly until it returns 'false', at which point all
     *    the triangles have been removed.
     */
    private boolean removeEC ()
    {
        for (int i = 0; i < m_kVertex.size(); i++)
        {
            Vertex kV = (Vertex)m_kVertex.get(i);
            if ( kV.m_bValid && kV.m_iAdjQuantity == 2 )
            {
                m_i0 = i;
                m_i1 = kV.m_aiAdj[0];
                m_i2 = kV.m_aiAdj[1];
                removeVertex(i);
                return true;
            }
        }

        return false;
    }

    /**
     * Remove the triangles from the vertex-edge mesh for a box using
     * ear-clipping.  This function is used when no subdivision is required
     * on box faces, that is, when no cracking occurs with the natural edges
     * of intersection of box and level surface.
     *
     * @param kVArray the vertices of the triangles obtained by ear-clipping
     * @param kTArray the triangles obtained by ear-clipping
     */
    public void removeTrianglesEC (Vector kVArray, Vector kTArray)
    {
        // ear-clip the wireframe to get the triangles
        while ( removeEC() )
        {
            int iV0 = kVArray.size(), iV1 = iV0+1, iV2 = iV1+1;
            kTArray.add(new ASC_Triangle3(iV0,iV1,iV2));

            Vertex kV0 = getVertex(m_i0);
            Vertex kV1 = getVertex(m_i1);
            Vertex kV2 = getVertex(m_i2);

            kVArray.add(new ASC_Vertex3(kV0.m_fX,kV0.m_fY,kV0.m_fZ));
            kVArray.add(new ASC_Vertex3(kV1.m_fX,kV1.m_fY,kV1.m_fZ));
            kVArray.add(new ASC_Vertex3(kV2.m_fX,kV2.m_fY,kV2.m_fZ));
        }
    }

    /**
     * Remove the triangles from the vertex-edge mesh for a box that needed
     * subdivision of edges to avoid cracking.  The simplest triangulation
     * adds a new vertex, the centroid of the vertices on the box faces.  The
     * triangles are formed by fanning with common origin at the centroid.
     *
     * @param kVArray the vertices of the triangles obtained by ear-clipping
     * @param kTArray the triangles obtained by ear-clipping
     */
    public void removeTrianglesSE (Vector kVArray, Vector kTArray)
    {
        int iVMax = m_kVertex.size();  // assert( iVMax > 18 );

        // compute centroid of vertices
        ASC_Vertex3 kCentroid = new ASC_Vertex3(0.0f,0.0f,0.0f);
        int i, iQuantity = 0;
        for (i = 0; i < iVMax; i++)
        {
            Vertex kV = (Vertex)m_kVertex.get(i);
            if ( kV.m_bValid )
            {
                // assert( kV.m_iAdjQuantity == 2 );
                kCentroid.m_fX += kV.m_fX;
                kCentroid.m_fY += kV.m_fY;
                kCentroid.m_fZ += kV.m_fZ;
                iQuantity++;
            }
        }
        float fInvQuantity = 1.0f/iQuantity;
        kCentroid.m_fX *= fInvQuantity;
        kCentroid.m_fY *= fInvQuantity;
        kCentroid.m_fZ *= fInvQuantity;

        int iV0 = kVArray.size();
        kVArray.add(kCentroid);

        // construct a triangle fan whose common origin is the centroid
        int iI1 = 18;
        int iV1 = iV0+1;
        Vertex kVI1 = (Vertex)m_kVertex.get(iI1);
        kVArray.add(new ASC_Vertex3(kVI1.m_fX,kVI1.m_fY,kVI1.m_fZ));

        int iI2 = kVI1.m_aiAdj[1], iV2;
        for (i = 0; i < iQuantity-1; i++)
        {
            iV2 = iV1+1;
            Vertex kVI2 = (Vertex)m_kVertex.get(iI2);
            kVArray.add(new ASC_Vertex3(kVI2.m_fX,kVI2.m_fY,kVI2.m_fZ));
            kTArray.add(new ASC_Triangle3(iV0,iV1,iV2));
            if ( kVI2.m_aiAdj[1] != iI1 )
            {
                iI1 = iI2;
                iI2 = kVI2.m_aiAdj[1];
            }
            else
            {
                iI1 = iI2;
                iI2 = kVI2.m_aiAdj[0];
            }
            iV1 = iV2;
        }

        // assert( iI2 == 18 );
        iV2 = iV0+1;
        kTArray.add(new ASC_Triangle3(iV0,iV1,iV2));
    }

    // table of vertices, edges are part of the Vertex data structure
    Vector m_kVertex;  // Vector of nested class Vertex

    // return values for getEdges
    public int m_iAdjQuantity;
    public int m_aiAdj[/*4*/];

    // return values for removeTriangle
    public int m_i0, m_i1, m_i2;
}
