package gov.nih.mipav.model.algorithms;


import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.*;

import java.io.*;

import java.util.*;


/**
 * Fuzzy C-Means Segmentation algorithm
 *
 * <p>Segmentation divides an image into distinct classes or types, such as segmenting the brain into 3 tissue types:
 * gray matter, white matter, and cerebrospinal fluid. There are 2 types of segmentation: hard and soft or fuzzy. In
 * hard segmentation a pixel is simply assigned to 1 of the classes. However, often in medical images, there cannot be
 * absolute classification of a pixel because of partial volume effects where multiple tissues contribute to a pixel or
 * voxel causing intensity blurring across boundaries. Fuzzy segmentation allows for the uncertainty in the location of
 * object boundaries. In fuzzy segmentation a membership function exists for each class at every pixel location. At each
 * pixel location a class membership function will have a value of 0 if there is absolutely no chance of that pixel
 * belonging to the class. At each pixel location a class membership function will have a value of 1 if the pixel
 * belongs to the class with absolute certainty. Membership functions can vary from 0 to 1, with the constraint that at
 * any pixel location the sum of the membership functions of all the classes must add up to 1. The fuzzy membership
 * function reflects the similarity between the data value at that pixel and the value of the class centroid. As a pixel
 * data value becomes closer to the class centroid, the class membership function approaches unity.</p>
 *
 * <p>The fuzzy C-Means algorithm is an unsupervised method; it works without the use of training data. This algorithm,
 * allowing for soft segmentation based on fuzzy set theory, generalizes the K-means algorithm. The technique clusters
 * data by iteratively computing a fuzzy membrship function and mean value estimates for each tissue class. The
 * algorithm works by minimizing the sum over all pixels j and all classes k of: (ujk**q) * ((yj - vk)**2)</p>
 *
 * <p>nClass = number of classes. ujk is the membership value at pixel location j for class k such that that sum over k
 * from k = 1 to k = nClass for ujk = 1. q is a weighing exponent on each membership value and determines the amount of
 * "fuzziness" of the resulting segmentation. q is required to be greater than 1 and is typically set to 2. yj is the
 * observed single channel image intensity at location j. vk is the centroid of class k.</p>
 *
 * <p>The user provides initial centroid values or simply uses default evenly spread pixel values generated by:
 *
 * <pre><code>
    for (i = 0; i < nClass; i++)
        centroid[i] = minimum + (maximum - minimum)*(i + 1)/(nClass + 1);
    </code></pre>
 * </p>
 *
 * <p>Minimization is achieved by an interative process which:<br>
 * 1.)Computes the membership functions using a current estimate of the centroids.<br>
 * numerator = (yj - vk)**(-2/(q-1))<br>
 * denominator = Sum over l from l = 1 to l = nClass of (yj - vl)**(-2/(q-1))<br>
 * ujk = numerator/denominator for all pixels j and all classes k<br>
 * <br>
 * 2.) Computes the centroids using current estimates of the membership functions.<br>
 * numerator = sum over all pixels j of (ujk**q) * yj<br>
 * denominator = sum over all pixels j of (ujk**q)<br>
 * vk = numerator/denominator for all classes k<br>
 * </p>
 *
 * <p>The iteration continues until either the user specified maximum number of iterations has occcured or until
 * convergence has been detected. Convergence occurs when all membership functions over all pixel locations j change by
 * less than the tolerance value between 2 iterations. The default maximum iteration number is 100. The default
 * tolerance is 0.01.</p>
 *
 * <p>/** <b>Fuzzy C-Means Segmentation algorithm</b></p>
 *
 * <p>Segmentation divides an image into distinct classes or types, such as segmenting the brain into 3 tissue types:
 * gray matter, white matter, and cerebrospinal fluid. There are 2 types of segmentation: hard and soft or fuzzy. In
 * hard segmentation a pixel is simply assigned to 1 of the classes. However, often in medical images, there cannot be
 * absolute classification of a pixel because of partial volume effects where multiple tissues contribute to a pixel or
 * voxel causing intensity blurring across boundaries. Fuzzy segmentation allows for the uncertainty in the location of
 * object boundaries. In fuzzy segmentation a membership function exists for each class at every pixel location. At each
 * pixel location a class membership function will have a value of 0 if there is absolutely no chance of that pixel
 * belonging to the class. At each pixel location a class membership function will have a value of 1 if the pixel
 * belongs to the class with absolute certainty. Membership functions can vary from 0 to 1, with the constraint that at
 * any pixel location the sum of the membership functions of all the classes must add up to 1. The fuzzy membership
 * function reflects the similarity between the data value at that pixel and the value of the class centroid. As a pixel
 * data value becomes closer to the class centroid, the class membership function approaches unity.</p>
 *
 * <p>The fuzzy C-Means algorithm is an unsupervised method; it works without the use of training data. This algorithm,
 * allowing for soft segmentation based on fuzzy set theory, generalizes the K-means algorithm. The technique clusters
 * data by iteratively computing a fuzzy membrship function and mean value estimates for each tissue class. The
 * algorithm works by minimizing the sum over all pixels j and all classes k of: (ujk**q) * ((yj - vk)**2)</p>
 *
 * <p>nClass = number of classes. ujk is the membership value at pixel location j for class k such that that sum over k
 * from k = 1 to k = nClass for ujk = 1. q is a weighing exponent on each membership value and determines the amount of
 * "fuzziness" of the resulting segmentation. q is required to be greater than 1 and is typically set to 2. yj is the
 * observed single channel image intensity at location j. vk is the centroid of class k.</p>
 *
 * <p>The user provides initial centroid values or simply uses default evenly spread pixel values generated by:
 *
 * <pre><code>
    for (i = 0; i < nClass; i++)
        centroid[i] = minimum + (maximum - minimum)*(i + 1)/(nClass + 1);
    </code></pre>
 * </p>
 *
 * <p>Minimization is achieved by an interative process which:<br>
 * 1.)Computes the membership functions using a current estimate of the centroids.<br>
 * numerator = (yj - vk)**(-2/(q-1))<br>
 * denominator = Sum over l from l = 1 to l = nClass of (yj - vl)**(-2/(q-1))<br>
 * ujk = numerator/denominator for all pixels j and all classes k<br>
 * <br>
 * 2.) Computes the centroids using current estimates of the membership functions.<br>
 * numerator = sum over all pixels j of (ujk**q) * yj<br>
 * denominator = sum over all pixels j of (ujk**q)<br>
 * vk = numerator/denominator for all classes k<br>
 * </p>
 *
 * <p>The iteration continues until either the user specified maximum number of iterations has occcured or until
 * convergence has been detected. Convergence occurs when all membership functions over all pixel locations j change by
 * less than the tolerance value between 2 iterations. The default maximum iteration number is 100. The default
 * tolerance is 0.01.</p>
 *
 * <p>A dialog for each image will ask the user for a threshold value for that image. The default value is the image
 * minimum value. In the centroid calculation only those pixels whose values equal or exceed threshold in all of the
 * images are used in the centroid calculation. In the hard segmentation pixels whose values are less than threshold in
 * any of the images or not in the selected first image VOI if the whole image is not used are set to a to a
 * segmentation value of 0, meaning that these pixels are outside of the specified classes.</p>
 *
 * <p>The initial dialog has a checkbox for Boundary noise cropping which is unchecked by default. This function finds
 * the smallest bounding box outside of which all first image pixel values are below the first image threshold. Values
 * inside the bounding box are copied to a smaller array to save space and calculations are performed with this reduced
 * array. However, these pixels outside the box are restored for the production of the hard and fuzzy segmented images.
 * In the hard segmentation case values outisde the box all have a value of 0. In the fuzzy segmentation case values
 * outside the box all have a value equal to the first image minimum. If the cropping checkbox is selected, the user is
 * constrained to select the whole image rather than VOI regions.</p>
 *
 * <p>There are 3 choices for produced output images:<br>
 * 1.) HARD ONLY<br>
 * 2.) FUZZY ONLY<br>
 * 3.) HARD & FUZZY BOTH<br>
 * </p>
 *
 * <p>Hard segmentation produces only 1 unsigned byte output image which assigns pixels which do not meet threshold
 * requirements values of 0. The first class is assigned a value of 255/nClass, the second class is assigned a pixel
 * value of 2*255/nClass, and so on. The last class has a value of 255.</p>
 *
 * <p>Fuzzy segmentation produces 1 image of the same type as the source image for every segmentation class. The
 * membership function is scaled so that the minimum membership value scales to the source image minimum value and the
 * maximum membership value scales to the source image maximum value. If boundary cropping is used, pixels outside the
 * bounding box are all assigned the source image minimum value.</p>
 *
 * <p>The first dialog provides buttons for loading and removing images. The multispectral dialog has a list of loaded
 * images. The button labeled Load another image causes an Open File dialog to appear. An opened file will only cause an
 * image to be added to the loaded images list if it has the same dimensionality as the original image and if the length
 * of each dimension is the same as that of the original image. Also, if the original image is not color, then the later
 * loaded images cannot be color.</p>
 *
 * <p>The button labeled Remove selected image can be used to remove one image from the list. However, the original
 * image that was present when the multispectral file menu command was invoked(the first image in the list) cannot be
 * removed. This button will only be enabled when at least 2 images are in the list.</p>
 *
 * <p>If the first loaded image is color, checkboxes appear allowing the user to select red, green, and blue components.
 * The default is all components selected.</p>
 *
 * <p>A later dialog appears for every black and white image and for every selected component of every color image and
 * the signal thresholds and initial centroids are entered on these later dialogs.</p>
 *
 * <p>Image Types:<br>
 * This algorithm can be applied to 2D and 3D data sets that are not COMPLEX.<br>
 * </p>
 *
 * <p>References: This code is not original - it is simply a ported subset of code written and kindly provided by Dzung
 * Pham. Note that our code is not the adaptive fuzzy C-means segmentation, which the Dzung Pham code is. Our code is
 * not adaptive - it does not correct intensity inhomogeneities, also known as shading artifacts.<br>
 * 1.) Dzung L. Pham, Chenyang Xu, and Jerry L. Prince, "A Survey of Current Methods in Medical Image Segmentation",
 * Department of Electrical and Computer Engineering, The Johns Hopkins University, Baltimore, Maryland, 21218,
 * Technical Report JHU/ECE 99-01.<br>
 * 2.) Alberto F. Goldszal and Dzung L. Pham, "Volumetric Segmentation", Chapter 12, Academic Press, copyright 2000.<br>
 * 3.) Dzung L. Pham and Jerry L. Prince, "Adaptive Fuzzy Segmentation of Magnetic Resonance Images", IEEE Transactions
 * on Medical Imaging, Vol. 18, No. 9, September, 1999, pp. 737 - 752.<br>
 * </p>
 *
 * @version  0.1 June 15, 2000 conversion of Dzung Pham's C code
 * @see      gov.nih.mipav.view.dialogs.JDialogMSFuzzyCMeans
 * @see      AlgorithmMSpectralFuzzyCMeans
 * @see      gov.nih.mipav.view.dialogs.JDialogCentroidThreshold
 */
public class AlgorithmMSpectralFuzzyCMeans extends AlgorithmBase {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** possible values for segmentation. */
    public static final int BOTH_FUZZY_HARD = 0;

    /** DOCUMENT ME! */
    public static final int FUZZY_ONLY = 1;

    /** DOCUMENT ME! */
    public static final int HARD_ONLY = 2;

    /** DOCUMENT ME! */
    private static final float MAX_FLOAT = 1e30f;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** DOCUMENT ME! */
    private float[] buffer2;

    /** DOCUMENT ME! */
    private float[] centroids;

    /** DOCUMENT ME! */
    private boolean cropBackground = false; // When cropBackground is true,

    /** Fuzzy images require 1 image for each class Hard images 1 image with assigned clusters. */
    private ModelImage[] destImage;

    /** DOCUMENT ME! */
    private int destNum = 0; // number of the destination image

    /** DOCUMENT ME! */
    private boolean doBlue;

    /** DOCUMENT ME! */
    private boolean doGreen;

    /** DOCUMENT ME! */
    private boolean doRed;

    /** DOCUMENT ME! */
    private float exponent; // 1/(qVal - 1)

    /** DOCUMENT ME! */
    private int imageNumber;

    /** DOCUMENT ME! */
    private int iterations;

    /** jacobiIters1 and jacobiIter2 are only used with gain field correction. */
    private int jacobiIters1 = 2;

    /** DOCUMENT ME! */
    private int jacobiIters2 = 3;

    /** DOCUMENT ME! */
    private float maxChange;

    /** DOCUMENT ME! */
    private int maxIter = 100;

    /** DOCUMENT ME! */
    private float[] mems;

    /** DOCUMENT ME! */
    private float[] memsBuffer;

    /** DOCUMENT ME! */
    private int memSize;

    /** DOCUMENT ME! */
    private float[] minimum, maximum;

    /** DOCUMENT ME! */
    private int nClass = 3;

    /** DOCUMENT ME! */
    private int newSliceSize;

    /** DOCUMENT ME! */
    private int newVolSize;

    /** DOCUMENT ME! */
    private int newXDim, newYDim, newZDim;

    /** DOCUMENT ME! */
    private BitSet objMask;

    /** DOCUMENT ME! */
    private int oldX, oldY, oldZ;

    /** DOCUMENT ME! */
    private int orgSlice;

    /** DOCUMENT ME! */
    private int orgVol;

    /** DOCUMENT ME! */
    private int orgXDim;

    /** DOCUMENT ME! */
    private boolean outputGainField = false;

    /** DOCUMENT ME! */
    private boolean powEIntFlag = true;

    /** pyramidLevels is only used with gain correction. */
    private int pyramidLevels = 4;

    /** DOCUMENT ME! */
    private float qVal = 2.0f;

    /** DOCUMENT ME! */
    private byte[] segBuffer;

    /** DOCUMENT ME! */
    private int segmentation = FUZZY_ONLY;

    /** DOCUMENT ME! */
    private int sliceSize;

    /** smooth1 and smooth2 are only used with gain field correction. */
    private float smooth1 = 5e4f;

    /** DOCUMENT ME! */
    private float smooth2 = 5e5f;

    /** DOCUMENT ME! */
    private int spectraNumber;

    /** DOCUMENT ME! */
    private ModelImage[] srcImage;

    /** DOCUMENT ME! */
    private float[] threshold;

    /** DOCUMENT ME! */
    private float tolerance = 0.01f;

    /** DOCUMENT ME! */
    private int volSize;

    /** wholeImage is constrained to be true. */
    private boolean wholeImage = true; // true = apply algorithm to the whole image

    // false = apply algorithm only to VOI regions

    /** DOCUMENT ME! */
    private int xDim, yDim, zDim;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * AlgorithmMSpectralFuzzyCMeans - Constructor.
     *
     * @param  destImg           list of image models where result image is to stored
     * @param  srcImg            list of source image models
     * @param  _nClass           number of classes into which the image will be segmented
     * @param  _pyramidLevels    number of levels
     * @param  _jacobiIters1     DOCUMENT ME!
     * @param  _jacobiIters2     DOCUMENT ME!
     * @param  _q                DOCUMENT ME!
     * @param  _smooth1          DOCUMENT ME!
     * @param  _smooth2          DOCUMENT ME!
     * @param  _outputGainField  DOCUMENT ME!
     * @param  _segmentation     DOCUMENT ME!
     * @param  _cropBackground   DOCUMENT ME!
     * @param  _maxIter          DOCUMENT ME!
     * @param  _tolerance        DOCUMENT ME!
     * @param  _doRed            DOCUMENT ME!
     * @param  _doGreen          DOCUMENT ME!
     * @param  _doBlue           DOCUMENT ME!
     * @param  _wholeImage       DOCUMENT ME!
     */
    public AlgorithmMSpectralFuzzyCMeans(ModelImage[] destImg, ModelImage[] srcImg, int _nClass, int _pyramidLevels,
                                         int _jacobiIters1, int _jacobiIters2, float _q, float _smooth1, float _smooth2,
                                         boolean _outputGainField, int _segmentation, boolean _cropBackground,
                                         int _maxIter, float _tolerance, boolean _doRed, boolean _doGreen,
                                         boolean _doBlue, boolean _wholeImage) {

        int i;

        // super(null, srcImg);
        destImage = destImg; // Put results in destination image.
        srcImage = srcImg;
        doRed = _doRed;
        doGreen = _doGreen;
        doBlue = _doBlue;
        imageNumber = srcImage.length;
        spectraNumber = 0;

        for (i = 0; i < srcImage.length; i++) {

            if (srcImage[i].isColorImage()) {

                if (doRed) {
                    spectraNumber++;
                }

                if (doGreen) {
                    spectraNumber++;
                }

                if (doBlue) {
                    spectraNumber++;
                }
            } else {
                spectraNumber++;
            }
        }

        nClass = _nClass;
        pyramidLevels = _pyramidLevels;
        jacobiIters1 = _jacobiIters1;
        jacobiIters2 = _jacobiIters2;
        qVal = _q;
        exponent = 1.0f / (qVal - 1.0f);
        smooth1 = _smooth1;
        smooth2 = _smooth2;
        outputGainField = _outputGainField;
        segmentation = _segmentation;
        cropBackground = _cropBackground;
        maxIter = _maxIter;
        tolerance = _tolerance;
        wholeImage = _wholeImage;

        if ((exponent - Math.floor(exponent)) < 0.01) {
            powEIntFlag = true;
        } else {
            powEIntFlag = false;
        }
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Prepares this class for destruction.
     */
    public void finalize() {

        cleanUp();

        destImage = null;
        srcImage = null;
        super.finalize();
    }

    /**
     * Start algorithm.
     */
    public void runAlgorithm() {

        if (srcImage == null) {
            displayError("MSpectral Fuzzy C-means: Source Image is null");

            return;
        }

        constructLog();

        if (srcImage[0].getNDims() == 2) {
            cMeans2();
        } else if (srcImage[0].getNDims() == 3) {
            cMeans3();
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  centroids  DOCUMENT ME!
     */
    public void setCentroids(float[] centroids) {
        this.centroids = centroids;
    }

    /**
     * DOCUMENT ME!
     *
     * @param  threshold  DOCUMENT ME!
     */
    public void setThreshold(float[] threshold) {
        this.threshold = threshold;
    }

    /**
     * Writes the logString to the appropriate log area. Overrides the AlgorithmBase <code>writeLog()</code> to append
     * the history to all of the destination images we've created.
     */
    protected void writeLog() {

        // write to the history area
        if (Preferences.is(Preferences.PREF_LOG) && completed) {

            if (destImage != null) {

                for (int i = 0; i < destImage.length; i++) {

                    if ((destImage[i] != null) && (destImage[i].getHistoryArea() != null)) {

                        if (srcImage != null) {
                            destImage[i].getHistoryArea().setText(srcImage[Math.min(i, srcImage.length - 1)].getHistoryArea().getText());
                        }

                        if (historyString != null) {
                            destImage[i].getHistoryArea().append(historyString);
                        }
                    }
                }
            } else if (srcImage != null) {

                if (historyString != null) {

                    for (int i = 0; i < srcImage.length; i++) {
                        srcImage[i].getHistoryArea().append(historyString);
                    }
                }
            }
        }
    }

    /**
     * Cleans up the memory usage.
     */
    private void cleanUp() {

        memsBuffer = null;
        segBuffer = null;
        buffer2 = null;
        objMask = null;
        mems = null;
    }

    /**
     * DOCUMENT ME!
     */
    private void cMeans2() {

        int c;
        int x, y;
        float[] tBuffer;
        float[] buffer;
        int index;
        int xLow, xHigh;
        int yLow, yHigh;
        int i, j, k, m;
        int yStepIn, yStepOut, mStepIn, mStepOut;
        float dtemp;
        int indexM;
        float offset;
        int kSlice, mSlice;
        float minClass, maxClass;
        float scaleFactor;
        int totalSize;

        xDim = srcImage[0].getExtents()[0];
        yDim = srcImage[0].getExtents()[1];
        orgXDim = xDim;
        sliceSize = xDim * yDim;
        orgSlice = sliceSize;

        try {
            minimum = new float[spectraNumber];
            maximum = new float[spectraNumber];
            tBuffer = new float[sliceSize];
            buffer = new float[spectraNumber * sliceSize];

            for (i = 0, j = 0; i < imageNumber; i++) {
                srcImage[i].calcMinMax();

                if (srcImage[i].isColorImage()) {

                    if (doRed) {
                        minimum[j] = (float) srcImage[i].getMinR();
                        maximum[j] = (float) srcImage[i].getMaxR();
                        j++;
                    }

                    if (doGreen) {
                        minimum[j] = (float) srcImage[i].getMinG();
                        maximum[j] = (float) srcImage[i].getMaxG();
                        j++;
                    }

                    if (doBlue) {
                        minimum[j] = (float) srcImage[i].getMinB();
                        maximum[j] = (float) srcImage[i].getMaxB();
                        j++;
                    }
                } else {
                    minimum[j] = (float) srcImage[i].getMin();
                    maximum[j] = (float) srcImage[i].getMax();
                    j++;
                }
            } // for (i = 0,j = 0; i < imageNumber;i++)

        } catch (OutOfMemoryError error) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("Algorithm FuzzyCMeans reports:\n" + error.toString());
            setCompleted(false);

            return;
        }

        buildProgressBar(srcImage[0].getImageName(), "Importing source image...", 0, 100);
        initProgressBar();

        for (i = 0, k = 0; i < imageNumber; i++) {

            try {

                if (srcImage[i].isColorImage()) {

                    if (doRed) {
                        progressBar.setMessage("Importing red from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(1, 0, sliceSize, tBuffer);

                        kSlice = k * sliceSize;

                        for (j = 0; j < sliceSize; j++) {
                            buffer[kSlice + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doRed)

                    if (doGreen) {
                        progressBar.setMessage("Importing green from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(2, 0, sliceSize, tBuffer);

                        kSlice = k * sliceSize;

                        for (j = 0; j < sliceSize; j++) {
                            buffer[kSlice + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doGreen)

                    if (doBlue) {
                        progressBar.setMessage("Importing blue from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(3, 0, sliceSize, tBuffer);

                        kSlice = k * sliceSize;

                        for (j = 0; j < sliceSize; j++) {
                            buffer[kSlice + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doBlue)
                } else { // not color
                    progressBar.setMessage("Importing " + srcImage[i].getImageName());
                    srcImage[i].exportData(0, sliceSize, tBuffer);

                    kSlice = k * sliceSize;

                    for (j = 0; j < sliceSize; j++) {
                        buffer[kSlice + j] = tBuffer[j];
                    }

                    k++;
                } // else not color
            } catch (IOException ioe) {
                cleanUp();
                MipavUtil.displayError("Algorithm MSpectralFuzzyCMeans reports:\n" + ioe.toString());
                progressBar.dispose();
                setCompleted(false);

                return;
            }
        } // for (i = 0, k = 0; i < imageNumber; i++)

        if (!wholeImage) {

            for (k = 0; k < spectraNumber; k++) {
                maximum[k] = -Float.MAX_VALUE;
                minimum[k] = Float.MAX_VALUE;
                kSlice = k * sliceSize;

                for (i = 0; i < sliceSize; i++) {

                    if (mask.get(i)) {

                        if (buffer[i + kSlice] > maximum[k]) {
                            maximum[k] = buffer[i + kSlice];
                        }

                        if (buffer[i + kSlice] < minimum[k]) {
                            minimum[k] = buffer[i + kSlice];
                        }
                    }
                }
            } // for (k = 0; k < spectraNumber; k++)
        } // if (!wholeImage)

        tBuffer = null;
        System.gc();

        try {
            xLow = 0;
            yLow = 0;
            xHigh = xDim - 1;
            yHigh = yDim - 1;

            if (cropBackground) {

                // Find the smallest bounding box for the 1st data set
                // If cropBackground is true wholeImage is constrained to be true
                progressBar.setMessage("Cropping background");
                xLow = xDim - 1;
                yLow = yDim - 1;
                xHigh = 0;
                yHigh = 0;

                for (y = 0; y < yDim; y++) {
                    yStepIn = y * xDim;

                    for (x = 0; x < xDim; x++) {
                        index = x + yStepIn;

                        if (buffer[index] >= threshold[0]) {

                            if (x < xLow) {
                                xLow = x;
                            }

                            if (x > xHigh) {
                                xHigh = x;
                            }

                            if (y < yLow) {
                                yLow = y;
                            }

                            if (y > yHigh) {
                                yHigh = y;
                            }
                        } // if (buffer[index] > threshold[0])
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)

                if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1))) {

                    // A smaller bounding box has been found for the data
                    // Recopy area to smaller data array to save space
                    newXDim = xHigh - xLow + 1;
                    newYDim = yHigh - yLow + 1;
                    newSliceSize = newXDim * newYDim;
                    buffer2 = new float[spectraNumber * newSliceSize];

                    for (m = 0; m < spectraNumber; m++) {
                        mStepOut = m * sliceSize;
                        mStepIn = (m * newSliceSize) - xLow - (yLow * newXDim);

                        for (y = yLow; y <= yHigh; y++) {
                            yStepOut = (y * xDim) + mStepOut;
                            yStepIn = (y * newXDim) + mStepIn;

                            for (x = xLow; x <= xHigh; x++) {
                                buffer2[x + yStepIn] = buffer[x + yStepOut];
                            } // for (x = xLow; x <= xHigh; x++)
                        } // for (y = yLow; y <= yHigh; y++)
                    } // for (m = 0; m < spectraNumber; m++)

                    xDim = newXDim;
                    yDim = newYDim;
                    sliceSize = xDim * yDim;
                    totalSize = spectraNumber * sliceSize;
                    buffer = new float[totalSize];

                    for (i = 0; i < totalSize; i++) {
                        buffer[i] = buffer2[i];
                    }

                    buffer2 = null;

                    // Find the new minimum
                    for (m = 0; m < spectraNumber; m++) {
                        minimum[m] = Float.MAX_VALUE;
                        mSlice = m * sliceSize;

                        for (i = 0; i < sliceSize; i++) {

                            if (buffer[mSlice + i] < minimum[m]) {
                                minimum[m] = buffer[mSlice + i];
                            } // if (buffer[mSlice + i] < minimum[m])
                        } // for (i = 0; i < sliceSize; i++)
                    } // for (m = 0; m < spectralNumber; m++) {
                } // if ((xLow > 0) || (xHigh < (xDim-1)) || (yLow > 0) || (yHigh < (yDim - 1)))
            } // if (cropBackground)

            // Create object mask
            objMask = new BitSet(sliceSize);

            for (i = 0; i < sliceSize; i++) {
                objMask.set(i);

                for (m = 0; m < spectraNumber; m++) {

                    if (buffer[(m * sliceSize) + i] < threshold[m]) {
                        objMask.clear(i);
                    }
                } // for (m = 0; m < spectraNumber; m++)
            } // for (i = 0; i < sliceSize; i++)

            if (wholeImage == false) {

                // If not in the VOI, clear the objMask
                for (i = 0; i < sliceSize; i++) {

                    if (!mask.get(i)) {
                        objMask.clear(i);
                    }
                }
            } // if (wholeImage == false)

            // Initialize membership and multiplier arrays
            memSize = nClass * sliceSize;
            mems = new float[memSize];

            for (i = 0; i < memSize; i++) {
                mems[i] = 0.0f;
            } // for (i = 0; i < memSize; i++)

            iterations = 1;
            maxChange = 1.0f;
        } catch (OutOfMemoryError error) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("Algorithm FuzzyCMeans reports:\n" + error.toString());
            progressBar.dispose();
            setCompleted(false);

            return;
        }

        /************************************************/

        /* MAIN LOOP                      */

        /* Perform adaptive fuzzy clustering           */

        /************************************************/
        ComputeMemberships2D(buffer, centroids, mems, exponent);

        while ((iterations <= maxIter) && (maxChange > tolerance)) {
            progressBar.setMessage("Iteration = " + iterations + " maxChange = " + maxChange);

            ComputeCentroids2D(buffer, centroids, mems, qVal);

            ComputeMemberships2D(buffer, centroids, mems, exponent);

            iterations += 1;
        } // while ((iterations <= maxIter) && (maxChange > tolerance))

        if (threadStopped) {
            finalize();

            return;
        }

        progressBar.setMessage("Finished iterations");
        buffer = null;
        centroids = null;
        buffer2 = null;
        System.gc();

        /* Output results and assign clusters if necessary */
        if (segmentation != HARD_ONLY) {

            try {
                memsBuffer = new float[orgSlice];
            } catch (OutOfMemoryError e) {
                cleanUp();
                System.gc();
                MipavUtil.displayError("FuzzyCMeans: Out of memory");
                progressBar.dispose();
                setCompleted(false);

                return;
            }

            for (i = 0; i < nClass; i++) {

                for (j = 0; j < orgSlice; j++) {
                    memsBuffer[j] = minimum[0];
                } // for (j = 0; j < orgSlice; j++)

                // Find the maximum value in the class
                maxClass = -Float.MAX_VALUE;
                minClass = Float.MAX_VALUE;

                for (j = 0; j < sliceSize; j++) {

                    if ((wholeImage) || (mask.get(j))) {
                        indexM = (i * sliceSize) + j;

                        if (mems[indexM] > maxClass) {
                            maxClass = mems[indexM];
                        }

                        if (mems[indexM] < minClass) {
                            minClass = mems[indexM];
                        }
                    } // if ((wholeImage) || (mask.get(j)))
                } // for (j = 0; j < sliceSize; j++)

                // Scale the data so that the scaled data has the same original minimum
                // and the same original maximum as the first source image
                if (maxClass != minClass) {
                    scaleFactor = (maximum[0] - minimum[0]) / (maxClass - minClass);
                    offset = ((maxClass * minimum[0]) - (maximum[0] * minClass)) / (maxClass - minClass);
                } else {
                    scaleFactor = 1;
                    offset = 0;
                }

                // restore the image to the original dimensions
                indexM = i * sliceSize;

                for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                    yStepOut = indexM + (y * xDim);
                    yStepIn = oldY * orgXDim;

                    for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {
                        index = oldX + yStepIn;

                        if ((wholeImage) || (mask.get(index))) {
                            memsBuffer[index] = (mems[x + yStepOut] * scaleFactor) + offset;
                        } // if ((wholeImage) || (mask.get(index)))
                    } // for (oldX = xLow, x = 0; oldX <= xHigh;oldX++,x++)
                } // for (oldY = yLow, y = 0; oldY <= yHigh;oldY++,y++)

                try {
                    destImage[destNum].importData(0, memsBuffer, true);
                } catch (IOException error) {
                    cleanUp();
                    MipavUtil.displayError("MSpectralFuzzyCMeans: IOException on destImage[" + destNum +
                                           "].importData(0,memsBuffer,true)");
                    progressBar.dispose();
                    setCompleted(false);

                    return;
                }

                destNum++;
            } // for (i = 0; i < nClass; i++)

            memsBuffer = null;
            System.gc();

            if (threadStopped) {
                finalize();

                return;
            }

        } // if (segmentation != HARD_ONLY)

        if (segmentation != FUZZY_ONLY) {

            try {
                int range = 255 / nClass;

                segBuffer = new byte[orgSlice];

                for (i = 0; i < orgSlice; i++) {
                    segBuffer[i] = 0;
                } // for (i = 0; i < orgSlice; i++)

                for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                    yStepOut = y * xDim;
                    yStepIn = oldY * orgXDim;

                    for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {

                        if (!objMask.get(x + yStepOut)) {
                            c = 0;
                        } // if (!objMask.get(x + yStepOut))
                        else {
                            c = range;
                            dtemp = mems[x + yStepOut];

                            for (i = 1; i < nClass; i++) {
                                indexM = (i * sliceSize) + x + yStepOut;

                                if (mems[indexM] > dtemp) {
                                    dtemp = mems[indexM];
                                    c = ((i + 1) * range);
                                } // if (mems[indexM] > dtemp)
                            } // for (i = 1; i < nClass; i++)
                        } // else

                        segBuffer[oldX + yStepIn] = (byte) c;
                    } // for (oldX = xLow, oldX = 0; x <= xHigh; oldX++, x++)
                } // for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++)

                destImage[destNum].importData(0, segBuffer, true);
            } catch (IOException error) {
                cleanUp();
                MipavUtil.displayError("MSpectralFuzzyCMeans: IOException on destImage[" + destNum +
                                       "].importData(0,segBuffer,true)");
                progressBar.dispose();
                setCompleted(false);

                return;
            } catch (OutOfMemoryError e) {
                cleanUp();
                System.gc();
                MipavUtil.displayError("MSpectralFuzzyCMeans: Out of memory on destImage[" + destNum +
                                       "].importData(0,segBuffer,true)");
                progressBar.dispose();
                setCompleted(false);

                return;
            }
        } // if (segmentation != FUZZY_ONLY)

        mems = null;
        objMask = null;
        progressBar.dispose();
        setCompleted(true);

        return;
    }

    /**
     * DOCUMENT ME!
     */
    private void cMeans3() {
        float[] buffer;
        float[] tBuffer;
        int c;
        int x, y, z;
        int index;
        int xLow, xHigh;
        int yLow, yHigh;
        int zLow, zHigh;
        int i, j, k, m;
        int yStepIn, yStepOut, zStepIn, zStepOut, mStepIn, mStepOut;
        float dtemp;
        int indexM;
        float offset;
        int kVol, mVol;
        float minClass, maxClass;
        float scaleFactor;
        int totalSize;

        xDim = srcImage[0].getExtents()[0];
        yDim = srcImage[0].getExtents()[1];
        zDim = srcImage[0].getExtents()[2];
        orgXDim = xDim;
        sliceSize = xDim * yDim;
        volSize = xDim * yDim * zDim;
        orgSlice = sliceSize;
        orgVol = volSize;

        try {
            minimum = new float[spectraNumber];
            maximum = new float[spectraNumber];
            tBuffer = new float[volSize];
            buffer = new float[spectraNumber * volSize];

            for (i = 0, j = 0; i < imageNumber; i++) {
                srcImage[i].calcMinMax();

                if (srcImage[i].isColorImage()) {

                    if (doRed) {
                        minimum[j] = (float) srcImage[i].getMinR();
                        maximum[j] = (float) srcImage[i].getMaxR();
                        j++;
                    }

                    if (doGreen) {
                        minimum[j] = (float) srcImage[i].getMinG();
                        maximum[j] = (float) srcImage[i].getMaxG();
                        j++;
                    }

                    if (doBlue) {
                        minimum[j] = (float) srcImage[i].getMinB();
                        maximum[j] = (float) srcImage[i].getMaxB();
                        j++;
                    }
                } else {
                    minimum[j] = (float) srcImage[i].getMin();
                    maximum[j] = (float) srcImage[i].getMax();
                    j++;
                }
            } // for (i = 0,j = 0; i < imageNumber;i++)
        } catch (OutOfMemoryError error) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("Algorithm FuzzyCMeans reports:\n" + error.toString());
            setCompleted(false);

            return;
        }

        buildProgressBar(srcImage[0].getImageName(), "Importing source image...", 0, 100);
        initProgressBar();

        for (i = 0, k = 0; i < imageNumber; i++) {

            try {

                if (srcImage[i].isColorImage()) {

                    if (doRed) {
                        progressBar.setMessage("Importing red from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(1, 0, volSize, tBuffer);

                        kVol = k * volSize;

                        for (j = 0; j < volSize; j++) {
                            buffer[kVol + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doRed)

                    if (doGreen) {
                        progressBar.setMessage("Importing green from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(2, 0, volSize, tBuffer);

                        kVol = k * volSize;

                        for (j = 0; j < volSize; j++) {
                            buffer[kVol + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doGreen)

                    if (doBlue) {
                        progressBar.setMessage("Importing blue from " + srcImage[i].getImageName());
                        srcImage[i].exportRGBData(3, 0, volSize, tBuffer);

                        kVol = k * volSize;

                        for (j = 0; j < volSize; j++) {
                            buffer[kVol + j] = tBuffer[j];
                        }

                        k++;
                    } // if (doBlue)
                } else { // not color
                    progressBar.setMessage("Importing " + srcImage[i].getImageName());
                    srcImage[i].exportData(0, volSize, tBuffer);

                    kVol = k * volSize;

                    for (j = 0; j < volSize; j++) {
                        buffer[kVol + j] = tBuffer[j];
                    }

                    k++;
                } // else not color
            } catch (IOException ioe) {
                cleanUp();
                MipavUtil.displayError("Algorithm MSpectralFuzzyCMeans reports:\n" + ioe.toString());
                progressBar.dispose();
                setCompleted(false);

                return;
            }
        } // for (i = 0, k = 0; i < imageNumber; i++)

        if (!wholeImage) {

            for (k = 0; k < spectraNumber; k++) {
                maximum[k] = -Float.MAX_VALUE;
                minimum[k] = Float.MAX_VALUE;
                kVol = k * volSize;

                for (i = 0; i < volSize; i++) {

                    if (mask.get(i)) {

                        if (buffer[i + kVol] > maximum[k]) {
                            maximum[k] = buffer[i + kVol];
                        }

                        if (buffer[i + kVol] < minimum[k]) {
                            minimum[k] = buffer[i + kVol];
                        }
                    }
                }
            } // for (k = 0; k < spectraNumber; k++)
        } // if (!wholeImage)

        tBuffer = null;
        System.gc();

        try {
            xLow = 0;
            yLow = 0;
            zLow = 0;
            xHigh = xDim - 1;
            yHigh = yDim - 1;
            zHigh = zDim - 1;

            if (cropBackground) {

                // Find the smallest bounding box for the 1st data set
                // If cropBackground is true wholeImage is constrained to be true
                progressBar.setMessage("Cropping background");
                xLow = xDim - 1;
                yLow = yDim - 1;
                zLow = zDim - 1;
                xHigh = 0;
                yHigh = 0;
                zHigh = 0;

                for (z = 0; z < zDim; z++) {
                    zStepIn = z * sliceSize;

                    for (y = 0; y < yDim; y++) {
                        yStepIn = (y * xDim) + zStepIn;

                        for (x = 0; x < xDim; x++) {
                            index = x + yStepIn;

                            if (buffer[index] >= threshold[0]) {

                                if (x < xLow) {
                                    xLow = x;
                                }

                                if (x > xHigh) {
                                    xHigh = x;
                                }

                                if (y < yLow) {
                                    yLow = y;
                                }

                                if (y > yHigh) {
                                    yHigh = y;
                                }

                                if (z < zLow) {
                                    zLow = z;
                                }

                                if (z > zHigh) {
                                    zHigh = z;
                                }
                            } // if (buffer[index] > threshold[0])
                        } // for (x = 0; x < xDim; x++)
                    } // for (y = 0; y < yDim; y++)
                } // for (z = 0; z < zDim; z++)

                if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1)) || (zLow > 0) ||
                        (zHigh < (zDim - 1))) {

                    // A smaller bounding box has been found for the data
                    // Recopy area to smaller data array to save space
                    newXDim = xHigh - xLow + 1;
                    newYDim = yHigh - yLow + 1;
                    newZDim = zHigh - zLow + 1;
                    newSliceSize = newXDim * newYDim;
                    newVolSize = newSliceSize * newZDim;
                    buffer2 = new float[spectraNumber * newVolSize];

                    for (m = 0; m < spectraNumber; m++) {
                        mStepOut = m * volSize;
                        mStepIn = (m * newVolSize) - xLow - (yLow * newXDim) - (zLow * newSliceSize);

                        for (z = zLow; z <= zHigh; z++) {
                            zStepOut = (z * sliceSize) + mStepOut;
                            zStepIn = (z * newSliceSize) + mStepIn;

                            for (y = yLow; y <= yHigh; y++) {
                                yStepOut = (y * xDim) + zStepOut;
                                yStepIn = (y * newXDim) + zStepIn;

                                for (x = xLow; x <= xHigh; x++) {
                                    buffer2[x + yStepIn] = buffer[x + yStepOut];
                                } // for (x = xLow; x <= xHigh; x++)
                            } // for (y = yLow; y <= yHigh; y++)
                        } // for (z = zLow; z <= zHigh; z++)
                    } // for (m = 0; m < spectraNumber; m++)

                    xDim = newXDim;
                    yDim = newYDim;
                    zDim = newZDim;
                    sliceSize = xDim * yDim;
                    volSize = sliceSize * zDim;
                    totalSize = spectraNumber * volSize;
                    buffer = new float[totalSize];

                    for (i = 0; i < totalSize; i++) {
                        buffer[i] = buffer2[i];
                    }

                    buffer2 = null;

                    // Find the new minimum
                    for (m = 0; m < spectraNumber; m++) {
                        minimum[m] = Float.MAX_VALUE;
                        mVol = m * volSize;

                        for (i = 0; i < volSize; i++) {

                            if (buffer[mVol + i] < minimum[m]) {
                                minimum[m] = buffer[mVol + i];
                            } // if (buffer[mVol + i] < minimum[m])
                        } // for (i = 0; i < volSize; i++)
                    } // for (m = 0; m < spectraNumber; m++)
                } // if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1)) ||
                // (zLow > 0) || (zHigh < (zDim - 1)))
            } // if (cropBackground)

            // Create object mask
            objMask = new BitSet(volSize);

            for (i = 0; i < volSize; i++) {
                objMask.set(i);

                for (m = 0; m < spectraNumber; m++) {

                    if (buffer[(m * volSize) + i] < threshold[m]) {
                        objMask.clear(i);
                    }
                } // for (m = 0; m < spectraNumber; m++)
            } // for (i = 0; i < volSize; i++)

            if (wholeImage == false) {

                // If not in the VOI, clear the objMask
                for (i = 0; i < volSize; i++) {

                    if (!mask.get(i)) {
                        objMask.clear(i);
                    }
                }
            } // if (wholeImage == false)

            // Initialize membership and multiplier arrays
            memSize = nClass * volSize;
            mems = new float[memSize];

            for (i = 0; i < memSize; i++) {
                mems[i] = 0.0f;
            } // for (i = 0; i < memSize; i++)

            iterations = 1;
            maxChange = 1.0f;
        } catch (OutOfMemoryError error) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("FuzzyCMeans reports: Out of memory.");
            progressBar.dispose();
            setCompleted(false);

            return;
        }

        /************************************************/

        /* MAIN LOOP                      */

        /* Perform adaptive fuzzy clustering           */

        /************************************************/
        // ComputeMemberships3D(buffer,centroids,mems,mult,exponent);
        ComputeMemberships3D(buffer, centroids, mems, exponent);

        while ((iterations <= maxIter) && (maxChange > tolerance)) {
            progressBar.setMessage("Iteration = " + iterations + " maxChange = " + maxChange);
            ComputeCentroids3D(buffer, centroids, mems, qVal);
            ComputeMemberships3D(buffer, centroids, mems, exponent);
            iterations += 1;
        } // while ((iterations <= maxIter) && (maxChange > tolerance))

        if (threadStopped) {
            buffer = null;
            finalize();

            return;
        }

        progressBar.setMessage("Iterations finished");
        buffer = null;
        centroids = null;
        buffer2 = null;
        System.gc();

        try {

            /* Output results and assign clusters if necessary */
            if (segmentation != HARD_ONLY) {
                memsBuffer = new float[orgVol];

                for (i = 0; i < nClass; i++) {

                    for (j = 0; j < orgVol; j++) {
                        memsBuffer[j] = minimum[0];
                    } // for (j = 0; j < orgVol; j++)

                    // Find the maximum value in the class
                    maxClass = -Float.MAX_VALUE;
                    minClass = Float.MAX_VALUE;

                    for (j = 0; j < volSize; j++) {

                        if ((wholeImage) || (mask.get(j))) {
                            indexM = (i * volSize) + j;

                            if (mems[indexM] > maxClass) {
                                maxClass = mems[indexM];
                            }

                            if (mems[indexM] < minClass) {
                                minClass = mems[indexM];
                            }
                        } // if ((wholeImage) || (mask.get(j)))
                    } // for (j = 0; j < volSize; j++)

                    // Scale the data so that the scaled data has the same original minimum
                    // and the same original maximum as the first source image
                    if (maxClass != minClass) {
                        scaleFactor = (maximum[0] - minimum[0]) / (maxClass - minClass);
                        offset = ((maxClass * minimum[0]) - (maximum[0] * minClass)) / (maxClass - minClass);
                    } else {
                        scaleFactor = 1;
                        offset = 0;
                    }

                    // restore the image to the original dimensions
                    indexM = i * volSize;

                    for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++) {
                        zStepOut = indexM + (z * sliceSize);
                        zStepIn = oldZ * orgSlice;

                        for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                            yStepOut = (y * xDim) + zStepOut;
                            yStepIn = (oldY * orgXDim) + zStepIn;

                            for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {
                                index = oldX + yStepIn;

                                if ((wholeImage) || (mask.get(index))) {
                                    memsBuffer[index] = (mems[x + yStepOut] * scaleFactor) + offset;
                                } // if ((wholeImage) || (mask.get(index)))
                            } // for (oldX = xLow, x = 0; oldX <= xHigh;oldX++,x++)
                        } // for (oldY = yLow, y = 0; oldY <= yHigh;oldY++,y++)
                    } // for (oldZ = zLow, z = 0; oldZ <= zHigh;oldZ++, z++)

                    try {
                        destImage[destNum].importData(0, memsBuffer, true);
                    } catch (IOException error) {
                        cleanUp();
                        MipavUtil.displayError("MSpectralFuzzyCMeans: IOException on destImage[" + destNum +
                                               "].importData(0,memsBuffer,true)");
                        progressBar.dispose();
                        setCompleted(false);

                        return;
                    }

                    destNum++;
                } // for (i = 0; i < nClass; i++)

                memsBuffer = null;
            } // if (segmentation != HARD_ONLY)

            if (segmentation != FUZZY_ONLY) {
                int range = 255 / nClass;

                segBuffer = new byte[orgVol];

                for (i = 0; i < orgVol; i++) {
                    segBuffer[i] = 0;
                } // for (i = 0; i < orgVol; i++)

                for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++) {
                    zStepOut = z * sliceSize;
                    zStepIn = oldZ * orgSlice;

                    for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                        yStepOut = (y * xDim) + zStepOut;
                        yStepIn = (oldY * orgXDim) + zStepIn;

                        for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {

                            if (!objMask.get(x + yStepOut)) {
                                c = 0;
                            } // if (!objMask.get(x + yStepOut))
                            else {
                                c = range;
                                dtemp = mems[x + yStepOut];

                                for (i = 1; i < nClass; i++) {
                                    indexM = (i * volSize) + x + yStepOut;

                                    if (mems[indexM] > dtemp) {
                                        dtemp = mems[indexM];
                                        c = ((i + 1) * range);
                                    } // if (mems[indexM] > dtemp)
                                } // for (i = 1; i < nClass; i++)
                            } // else

                            segBuffer[oldX + yStepIn] = (byte) c;
                        } // for (oldX = xLow, oldX = 0; x <= xHigh; oldX++, x++)
                    } // for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++)
                } // for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++)

                try {
                    destImage[destNum].importData(0, segBuffer, true);
                } catch (IOException error) {
                    cleanUp();
                    MipavUtil.displayError("MSpectralFuzzyCMeans: IOException on destImage[" + destNum +
                                           "].importData(0,segBuffer,true)");
                    progressBar.dispose();
                    setCompleted(false);

                    return;
                }
            } // if (segmentation != FUZZY_ONLY)
        } catch (OutOfMemoryError e) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("FuzzyCMeans: Out of memory !");
            progressBar.dispose();
            setCompleted(false);

            return;
        }

        cleanUp();
        progressBar.dispose();
        setCompleted(true);

        return;
    }

    /**
     * ComputeCentroids2D - Determine the centroids of each cluster given fuzzy membership values.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     * @param  qVal       DOCUMENT ME!
     */
    private void ComputeCentroids2D(float[] buffer, float[] centroids, float[] mems,

                                    // float[] mult, float qVal) {
                                    float qVal) {
        int c; /* Cluster counter */
        float numer, denom; /* Used to compute new centroids */
        int x, y;
        int i, j;
        int m;
        float minC;
        int indexM;
        int indexB;
        float tempFloat = 0;
        int index = 0;
        int yStepOut;
        int mClass;

        for (c = 0; (c < nClass) && !threadStopped; c++) {

            for (m = 0; (m < spectraNumber) && !threadStopped; m++) {
                denom = 0.0f;
                numer = 0.0f;

                for (y = 0; (y < yDim) && !threadStopped; y++) {
                    yStepOut = y * xDim;

                    for (x = 0; (x < xDim) && !threadStopped; x++) {
                        index = x + yStepOut;
                        indexM = (c * sliceSize) + index;
                        indexB = (m * sliceSize) + index;

                        if (objMask.get(index)) {

                            if (powEIntFlag == true) {
                                tempFloat = 1;

                                for (int v = 0; v < (int) qVal; v++) {
                                    tempFloat *= mems[indexM];
                                }
                            } else {
                                tempFloat = (float) Math.pow(mems[indexM], qVal);
                            }

                            numer += tempFloat * buffer[index];
                            denom += tempFloat;
                        } // if (objMask.get(index))
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)

                if (denom != 0.0f) {
                    centroids[(m * nClass) + c] = numer / denom;
                } else {
                    MipavUtil.displayError("MSpectralFuzzyCMeans: Overflow in ComputeCentroids2D");
                    progressBar.dispose();
                    setCompleted(false);

                    return;
                }
            } // for (m = 0; m < spectraNumber; m++)
        } // for (c = 0; c < nClass; c++)

        if (threadStopped) {
            return;
        }

        /* Sort the centroids in ascending order */
        float[] sCentroids = new float[nClass];
        boolean[] unusedCentroids = new boolean[nClass];

        for (m = 0; m < spectraNumber; m++) {
            mClass = m * nClass;

            for (i = 0; i < nClass; i++) {
                unusedCentroids[i] = true;
            } // for (i = 0; i < nClass; i++)

            for (i = 0; i < nClass; i++) {
                minC = Float.MAX_VALUE;

                for (j = 0; j < nClass; j++) {

                    if ((unusedCentroids[j]) && (centroids[mClass + j] < minC)) {
                        minC = centroids[mClass + j];
                        index = j;
                    } // if ((unusedCentroids[j]) && (centroids[mClass + j] < minC))
                } // for (j = 0; j < nClass; j++)

                sCentroids[i] = minC;
                unusedCentroids[index] = false;
            } // for (i = 0; i < nClass; i++)

            for (i = 0; i < nClass; i++) {
                centroids[mClass + i] = sCentroids[i];
            }
        } // for (m = 0; m < spectraNumber; m++)

        sCentroids = null;
    }

    /**
     * ComputeCentroids3D - Determine the centroids of each cluster given fuzzy membership values.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     * @param  qVal       DOCUMENT ME!
     */
    private void ComputeCentroids3D(float[] buffer, float[] centroids, float[] mems,

                                    // float[] mult, float qVal) {
                                    float qVal) {
        int c; /* Cluster counter */
        float numer, denom; /* Used to compute new centroids */
        int x, y, z;
        int i, j;
        float minC;
        int indexM;
        int indexB;
        int m;
        float tempFloat = 0;
        int index = 0;
        int yStepOut, zStepOut;
        int mClass;

        for (c = 0; c < nClass; c++) {

            for (m = 0; m < spectraNumber; m++) {
                denom = 0.0f;
                numer = 0.0f;

                for (z = 0; z < zDim; z++) {
                    zStepOut = z * sliceSize;

                    for (y = 0; y < yDim; y++) {
                        yStepOut = (y * xDim) + zStepOut;

                        for (x = 0; x < xDim; x++) {
                            index = x + yStepOut;
                            indexM = (c * volSize) + index;
                            indexB = (m * volSize) + index;

                            if (objMask.get(index)) {

                                if (powEIntFlag == true) {
                                    tempFloat = 1;

                                    for (int v = 0; v < (int) qVal; v++) {
                                        tempFloat *= mems[indexM];
                                    }
                                } else {
                                    tempFloat = (float) Math.pow(mems[indexM], qVal);
                                }

                                numer += tempFloat * buffer[index];
                                denom += tempFloat;
                            } // if (objMask.get(index)
                        } // for (x = 0; x < xDim; x++)
                    } // for (y = 0; y < yDim; y++)
                } // for (z = 0; z < zDim; z++)

                if (denom != 0.0f) {
                    centroids[(m * nClass) + c] = numer / denom;
                } else {
                    MipavUtil.displayError("MSpectralFuzzyCMeans: Overflow in ComputeCentroids2D");
                    progressBar.dispose();
                    setCompleted(false);

                    return;
                }
            } // for (m = 0; m < spectraNumber; m++)
        } // for (c = 0; c < nClass; c++)

        /* Sort the centroids in ascending order */
        float[] sCentroids = new float[nClass];
        boolean[] unusedCentroids = new boolean[nClass];

        for (m = 0; m < spectraNumber; m++) {
            mClass = m * nClass;

            for (i = 0; i < nClass; i++) {
                unusedCentroids[i] = true;
            } // for (i = 0; i < nClass; i++)

            for (i = 0; i < nClass; i++) {
                minC = Float.MAX_VALUE;

                for (j = 0; j < nClass; j++) {

                    if ((unusedCentroids[j]) && (centroids[mClass + j] < minC)) {
                        minC = centroids[mClass + j];
                        index = j;
                    } // if ((unusedCentroids[j]) && (centroids[mClass + j] < minC))
                } // for (j = 0; j < nClass; j++)

                sCentroids[i] = minC;
                unusedCentroids[index] = false;
            } // for (i = 0; i < nClass; i++)

            for (i = 0; i < nClass; i++) {
                centroids[mClass + i] = sCentroids[i];
            }
        } // for (m = 0; m < spectraNumber; m++)

        sCentroids = null;
    }

    /**
     * ComputerMemberships2D - Determine membership of each feature vector in each cluster.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     * @param  exponent   DOCUMENT ME!
     */
    private void ComputeMemberships2D(float[] buffer, float[] centroids, float[] mems,

                                      // float[] mult, float exponent) {
                                      float exponent) {
        int c; /* cluster counter */
        float total; /* Used to normalize memberships */
        float difference2; /* Distance between pixel and centroid squared */
        float[] oldMember; /* Save old values to get difference */
        float dtemp;
        int x, y;
        int index;
        int indexM;
        int yStepOut;

        oldMember = new float[nClass];

        maxChange = 0.0f;

        for (y = 0; y < yDim; y++) {
            yStepOut = y * xDim;
            progressBar.updateValue((int) (y * (100.0f / yDim)), activeImage);

            for (x = 0; (x < xDim) && !threadStopped; x++) {

                /* Iterate over each cluster for the current intensity value */
                index = x + yStepOut;

                if ((wholeImage) || (mask.get(index))) {
                    total = 0.0f;

                    for (c = 0; c < nClass; c++) {
                        indexM = (c * sliceSize) + index;
                        oldMember[c] = mems[indexM];
                        difference2 = distancems2(buffer, index, centroids, c);

                        if (difference2 == 0.0f) {
                            mems[indexM] = (MAX_FLOAT / nClass);
                        } else if (powEIntFlag == true) {
                            mems[indexM] = 1;
                            difference2 = 1.0f / difference2;

                            for (int v = 0; v < (int) exponent; v++) {
                                mems[indexM] *= difference2;
                            }
                        } else {
                            mems[indexM] = (float) Math.pow(1.0 / (double) difference2, (double) exponent);
                        }

                        total += mems[indexM];
                    } // for (c = 0; c < nClass; c++)

                    if (total == 0.0f) {
                        cleanUp();
                        MipavUtil.displayError("MSpectralFuzzyCMeans: Overflow in ComputeMemberships");
                        progressBar.dispose();
                        setCompleted(false);

                        return;
                    } // if (total == 0.0f)

                    /* Normalize the distances so they form a pseudodistribution and update maxChange */

                    for (c = 0; c < nClass; c++) {
                        indexM = (c * sliceSize) + index;
                        mems[indexM] /= total;
                        dtemp = Math.abs(oldMember[c] - mems[indexM]);

                        if (maxChange < dtemp) {
                            maxChange = dtemp;
                        }
                    } // for (c = 0; c < nClass; c++)
                } // if ((wholeImage) || (mask.get(index)))
            } // for (x = 0; x < xDim; x++)
        } // for (y = 0; y < yDim; y++)

        if (threadStopped) {
            return;
        }

        oldMember = null;
    }

    /**
     * ComputerMemberships3D - Determine membership of each feature vector in each cluster.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     * @param  exponent   DOCUMENT ME!
     */
    private void ComputeMemberships3D(float[] buffer, float[] centroids, float[] mems,

                                      // float[] mult, float exponent) {
                                      float exponent) {
        int c; /* cluster counter */
        float total; /* Used to normalize memberships */
        float difference2; /* Distance between pixel and centroid squared */
        float[] oldMember; /* Save old values to get difference */
        float dtemp;
        int x, y, z;
        int index;
        int indexM;
        int yStepOut, zStepOut;

        oldMember = new float[nClass];

        maxChange = 0.0f;

        for (z = 0; (z < zDim) && !threadStopped; z++) {
            zStepOut = z * sliceSize;
            progressBar.updateValue((int) (z * (100.0f / zDim)), activeImage);

            for (y = 0; (y < yDim) && !threadStopped; y++) {
                yStepOut = (y * xDim) + zStepOut;

                for (x = 0; (x < xDim) && !threadStopped; x++) {

                    /* Iterate over each cluster for the current intensity value */
                    index = x + yStepOut;

                    if ((wholeImage) || (mask.get(index))) {
                        total = 0.0f;

                        for (c = 0; c < nClass; c++) {
                            indexM = (c * volSize) + index;
                            oldMember[c] = mems[indexM];

                            // difference2 = distance1d(buffer[index],mult[index]*centroids[c]);
                            difference2 = distancems3(buffer, index, centroids, c);

                            if (difference2 == 0.0f) {
                                mems[indexM] = (MAX_FLOAT / nClass);
                            } else if ((powEIntFlag == true) && (exponent <= 3)) {
                                difference2 = 1.0f / difference2;
                                mems[indexM] = 1.0f;

                                for (int v = 0; v < (int) exponent; v++) {
                                    mems[indexM] *= difference2;
                                }
                            } else {
                                mems[indexM] = (float) Math.pow(1.0 / (double) difference2, (double) exponent);
                            }

                            total += mems[indexM];
                        } // for (c = 0; c < nClass; c++)

                        if (total == 0.0f) {
                            MipavUtil.displayError("MSpectralFuzzyCMeans: Overflow in ComputeMemberships");
                            progressBar.dispose();
                            setCompleted(false);

                            return;
                        } // if (total == 0.0f)

                        /* Normalize the distances so they form a pseudodistribution and update maxChange */

                        for (c = 0; c < nClass; c++) {
                            indexM = (c * volSize) + index;
                            mems[indexM] /= total;
                            dtemp = Math.abs(oldMember[c] - mems[indexM]);

                            if (maxChange < dtemp) {
                                maxChange = dtemp;
                            }
                        } // for (c = 0; c < nClass; c++)
                    } // if ((wholeImage) || (mask.get(index)))
                } // for (x = 0; x < xDim; x++)
            } // for (y = 0; y < yDim; y++)
        } // for (z = 0; z < zDim; z++)

        oldMember = null;

        if (threadStopped) {
            return;
        }
    }

    /**
     * Constructs a string of the contruction parameters and out puts the string to the messsage frame if the logging
     * procedure is turned on.
     */
    private void constructLog() {
        historyString = new String("Fuzzy C-means(" + String.valueOf(nClass) + ", " + String.valueOf(pyramidLevels) +
                                   ", " + String.valueOf(jacobiIters1) + ", " + String.valueOf(jacobiIters2) + ", " +
                                   String.valueOf(qVal) + ", " + String.valueOf(exponent) + ", " +
                                   String.valueOf(smooth1) + ", " + String.valueOf(smooth2) + ", " +
                                   String.valueOf(outputGainField) + ", " + String.valueOf(segmentation) + ", " +
                                   String.valueOf(cropBackground) + ", " + String.valueOf(threshold) + ", " +
                                   String.valueOf(maxIter) + ", " + String.valueOf(tolerance) + ", " +
                                   String.valueOf(doRed) + ", " + String.valueOf(doGreen) + ", " +
                                   String.valueOf(doBlue) + ", " + String.valueOf(wholeImage) + ")" + "\n");
    }

    /**
     * Next functions are used in the Adaptive Fuzzy C Means that we do NOT yet support.
     *
     * @param   buffer     DOCUMENT ME!
     * @param   index      DOCUMENT ME!
     * @param   centroids  DOCUMENT ME!
     * @param   c          DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */

    /* private void computeMultiplier2D(float[] buffer, float[] centroids, float[] mems, float[] mult,
     * float smooth1, float smooth2, float qVal) { // Only use scalar multiplier field here float[] f; float[] w; int
     * x,y; int i;
     *
     * f = new float[sliceSize]; w = new float[sliceSize];
     *
     * for (x = 0; x < xDim; x++) { for (y = 0; y < yDim; y++) { ComputeFW2(f,w,buffer,centroids,mems,x,y,qVal); } // for
     * (y = 0; y < yDim; y++) } // for (x = 0; x < xDim; x++)
     * fmvtrunc2(mult,f,w,smooth1,smooth2,jacobiIters1,jacobiIters2,truncLevel);
     *
     * // Compute max and minimum of multiplier field maxMult = 0.0f; minMult = 1e6f; for (i = 0; i < sliceSize; i++) { if
     * (mult[i] > maxMult) maxMult = mult[i]; if (mult[i] < minMult) minMult = mult[i]; }
     *
     * f = null; w = null; }
     */

    /*
     * private void computeFW2(float[] f, float[] w, float[] buffer, float[]centroids, float[] mems, int x, int y, float
     * qVal) { int c; float temp1,temp2; int index; int fg; int indexM;
     *
     * index = x + y*xDim; f[index] = 0.0f; w[index] = 0.0f; for (c = 0; c < nClass; c++) { indexM = c*sliceSize + index;
     * // Compute dot products: cTC and yTc temp1 = centroids[c] * centroids[c]; temp2 = buffer[index] * centroids[c];
     * w[index] += (float)Math.pow((double)mems[indexM],(double)qVal) * temp1; f[index] +=
     * (float)Math.pow((double)mems[indexM],(double)qVal) * temp2; } // for (c = 0; c < nClass; c++) //if (buffer[index]
     * < threshold) { //w[index] = 0.0f; //} // if (buffer[index] < threshold) }
     */

    /**
     * This function performs a truncated FMV cycle. It stops performing V-cycles at the pyramid level given by
     * 'truncLevel'.
     *
     * @param   buffer     DOCUMENT ME!
     * @param   index      DOCUMENT ME!
     * @param   centroids  DOCUMENT ME!
     * @param   c          DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */

    /* private void fmvtrunc2(float[] mult, float[] f, float[] w, float smooth1, float smooth2,
     * int jacobiIters1, int jacobiIters2, int truncLevel) { float[] fpyr,wpyr; int i; float[] temp; float[] u2; int
     * u2x,u2y; int x,y; int u2Length; float[] fp; int index;
     *
     * // Allocate pyramids fpyr = new float[pyramidLevels * sliceSize]; wpyr = new float[pyramidLevels * sliceSize]; //
     * Keep track of the sizes of each level sizesX = new int[pyramidLevels]; sizesY = new int[pyramidLevels]; for (i =
     * 0; i < sliceSize; i++) { fpyr[i] = f[i]; wpyr[i] = w[i]; } // for (i = 0; i < sliceSize; i++) sizesX[0] = xDim;
     * sizesY[0] = yDim; temp = new float[sliceSize]; for (i = 0; i < sliceSize; i++) { temp[i] = mult[i]; } // for (i =
     * 0; i < sliceSize; i++)
     *
     * u2 = new float[(xDim/2 + xDim%2) * (yDim/2 + yDim%2)]; u2x = xDim/2 + xDim%2; u2y = yDim/2 + yDim%2; for (i = 1; i
     * < pyramidLevels; i++) { u2 = reduce2d(temp,sizesX,sizesY,i-1); u2x = sizesX[i]; u2y = sizesY[i]; u2Length = u2x *
     * u2y; temp = null; temp = new float[u2Length]; for (j = 0; j < u2Length; j++) { temp[j] = u2[j]; }
     * reduce2db(fpyr,sizesX,sizesY,i-1); reduce2db(wpyr,sizesX,sizesY,i-1); } // for (i = 1; i < pyramidLevels; i++) fp
     * = new float[sliceSize]; index = (pyramidLevels - 1) * sliceSize; for (i = 0; i < sliceSize; i++) { fp[i] =
     * fpyr[index + i]; } vcycle2(u2,u2x,u2y,fp,wpyr,smooth1,smooth2,pyramidLevels-1,jacobiIters1,jacobiIters2); for (i
     * = pyramidLevels-2; i>=0; i--) { temp = expand2d(u2,u2x,sizesX,sizesY,i); u2x = sizesX[i]; u2y = sizesY[i];
     * u2Length = u2x * u2y; u2 = null; u2 = new float[u2Length]; for (j = 0; j < u2Length; j++) { u2[j] = temp[j]; } if
     * (i >= truncLevel) { // Stop doing V-cycles if necessary index = sliceSize*i; for (j = 0; j < sliceSize; j++) {
     * fp[j] = fpyr[index + j]; } vcycle2(u2,u2x,u2y,fp,wpyr,smooth1,smooth2,i,jacobiIters1,jacobiIters2); } } // for (i
     * = pyramidLevels-2; i>=0; i--)
     *
     * for (i = 0; i < sliceSize; i++) { mult[i] = u2[i]; }
     *
     * u2 = null; fpyr = null; wpyr = null; sizesX = null; sizesY = null;
     *
     * }
     */

    /*
     * private void vcycle2(float[] u, int ux, int uy, float[] f, float[] wpyr, float smooth1, float smooth2, int level,
     * int jacobiIters1, int jacobiIters2) { float h; float mask[]; float smooth1b,smooth2b; float r[]; float temp[];
     * float dummy; int x,y; int sizesXU[]; int sizesYU[]; float r2[]; int u2x,u2y; float u2[]; float v[]; int
     * uLength,u2Length; int index;
     *
     * // Initialize h = (float)Math.pow(2.0,(double)level); smooth1b = smooth1/(h*h); smooth2b = smooth2/(h*h); mask =
     * new float[25]; setMask52(mask,smooth1b,smooth2b);
     *
     * jacobi2(u,ux,uy,f,wpyr,level,smooth1b,smooth2b,jacobiIters1); uLength = ux * uy; if (level != (pyramidLevels-1)) {
     * // Compute residual r = f - wpyr*u - smooth*Laplace(u) r = new float[uLength]; temp = conv2d5(u,ux,uy,mask);
     * dummy = 0.0f; for (i = 0; i < uLength; i++) { index = level*sliceSize + i; r[i] = f[i] - wpyr[index] * u[i]
     * -temp[i]; }
     *
     * sizesXU = new int[2]; sizesYU = new int[2]; sizesXU[0] = ux; sizesYU[0] = uy; r2 = reduce2d(r,sizesXU,sizesYU,0);
     * temp = null; r = null; u2x = sizesXU[1]; u2y = sizesYU[1]; u2Length = u2x*u2y; u2 = new float[u2Length]; for (i =
     * 0; i < u2Length; i++) { u2[i] = 0.0f; }
     *
     * // Recursive call vcycle2(u2,u2x,u2y,r2,wpyr,smooth1,smooth2,level+1,jacobiIters1,jacobiIters2); v =
     * expand2d(u2,u2x,sizesX,sizesY,level);
     *
     * for (i = 0; i < uLength; i++) { u[i] += v[i]; } u2 = null; r2 = null; v = null; } // if (level !=
     * (pyramidLevels-1)) jacobi2(u,ux,uy,f,wpyr,level,smooth1,smooth2,jacobiIters2); }
     */


    /* Expand 2D area */

    /* private float[] expand2d(float[] in, int inx, int sizesX[], int sizesY[], int level) {
     * int outx,outy; float out[]; int x,y,l,m;
     *
     * outx = sizesX[level]; outy = sizesY[level]; out = new float[outx * outy]; for (x = 0; x < outx; x++) { l =
     * (int)((double)x/2.0); for (y = 0; y < outy; y++) { m = (int)((double)y/2.0); out[x + y*outx] = in[l + m*inx]; } }
     * return(out); }
     */

    /* Jacobi iterations */

    /*
     * private void jacobi2(float[] u, int ux, int uy, float[] f, float[] wpyr, int level, float smooth1, float smooth2,
     * int iter) { float alpha; float[] mask; int x,y; float[] temp; float Dinv; int i; int uLength;
     *
     * alpha = ALPHA;
     *
     * // Set up the mask mask = new float[25]; setMask52(mask, smooth1, smooth2); for (i = 0; i < 25; i++) { mask[i] *=
     * -1.0f; } mask[12] = 0.0f;
     *
     * temp = conv2d5(u,ux,uy,mask);
     *
     * uLength = ux*uy; for (i = 0; i < uLength; i++) { Dinv = 1.0f/(wpyr[level*sliceSize + i] + 6.0f*smooth1 +
     * 42.0f*smooth2); u[i] = (1.0f - alpha) *u[i] + alpha * Dinv * temp[i] + alpha * Dinv * f[i]; } temp = null;
     *
     * }
     */

    /* 2D convolutions with 5X5 mask */

    /*
     * private float[] conv2d5(float[] in, int inx, int iny, float[] mask) { float[] out; int x,y; int l,m; int
     * lind,mind; int outLength; int i;
     *
     * outLength = inx*iny; out = new float[outLength]; for (i = 0; i < outLength; i++) { out[i] = 0.0f; }
     *
     * for (x = 0; x < inx; x++) { for (y = 0; y < iny; y++) { // Now apply mask for (l = -2; l <=2; l++) { if ((x+l) < 0)
     * lind = 0; else if ((x+l) > (inx-1)) lind = inx-1; else lind = (x+l); for (m = -2; m <= 2; m++) { if ((y+m) < 0)
     * mind = 0; else if ((y+m) > (iny-1)) mind = iny-1; else mind = (y+m); out[x + y*inx] += mask[l+2 +
     * 5*(m+2)]*in[lind + mind*inx]; } } } }
     *
     * return(out); }
     */


    /*
     * private void setMask52(float[] mask, float smooth1, float smooth2) { int i; float mask1[]; float mask2[];
     *
     * mask1 = new float[25]; mask2 = new float[25];
     *
     *
     * for (i = 0; i < 25; i++) { mask1[i] = 0.0f; mask2[i] = 0.0f; }
     *
     * mask1[12] = 4.0f; mask1[7] = mask1[11] = mask1[17] = mask1[13] = -1.0f;
     *
     * mask2[2]  =  1.0f; mask2[6]  =  2.0f; mask2[7]  = -8.0f; mask2[8]  =  2.0f; mask2[10] =  1.0f; mask2[11] = -8.0f;
     * mask2[12] =  20.0f; mask2[13] = -8.0f; mask2[14] =  1.0f; mask2[16] =  2.0f; mask2[17] = -8.0f; mask2[18] =
     * 2.0f; mask2[22] =  1.0f;
     *
     * for (i = 0; i < 25; i++) { mask[i] = smooth1*mask1[i] + smooth2*mask2[i]; } }
     */

    /*
     * private float[] reduce2d(float[] in, int[] sizesX, int[] sizesY, int iLevel) { float[] out; int xNew,yNew; int
     * x,y; int x2,x2p,y2,y2p;
     *
     * xNew = sizesX[iLevel]/2 + sizesX[iLevel]%2; yNew = sizesY[iLevel]/2 + sizesY[iLevel]%2; out = new float[xNew *
     * yNew]; sizesX[iLevel+1] = xNew; sizesY[iLevel+1] = yNew; for (x = 0; x < xNew; x++) { x2 = 2*x; x2p = x2+1; if
     * (x2p > (sizesX[iLevel]-1)) { x2p = sizesX[iLevel] - 1; } for (y = 0; y < yNew; y++) { y2 = 2*y; y2p = y2+1; if
     * (y2p > (sizesY[iLevel]-1)) { y2p = sizesY[iLevel] - 1; } out[x + y*xNew] = (in[x2 + y2*sizesX[iLevel]]  + in[x2p
     * + y2*sizesX[iLevel]] + in[x2 + y2p*sizesX[iLevel]] + in[x2p + y2p*sizesX[iLevel]])/4; } // for (y = 0; y < yNew;
     * y++) } // for (x = 0; x < xNew; x++)
     *
     * return(out); }
     */

    /*
     * private void reduce2db(float[] in, int[] sizesX, int[] sizesY, int iLevel) { int xNew,yNew; int x,y; int
     * x2,x2p,y2,y2p; int i; int i1,i2,i3,i4; int tmp; int tmp1; int tmp2;
     *
     * xNew = sizesX[iLevel+1]; yNew = sizesY[iLevel+1];
     *
     * for (x = 0; x < xNew; x++) { x2 = 2*x; x2p = x2+1; if (x2p > (sizesX[iLevel]-1)) { x2p = sizesX[iLevel] - 1; } for
     * (y = 0; y < yNew; y++) { y2 = 2*y; y2p = y2+1; if (y2p > (sizesY[iLevel]-1)) { y2p = sizesY[iLevel] - 1; } tmp  =
     * iLevel*sliceSize; tmp1 = y2*sizesX[iLevel]; tmp2 = y2p*sizesX[iLevel];
     *
     * i = (iLevel+1)*sliceSize + x + y*xNew; i1 = tmp + x2  + tmp1; i2 = tmp + x2p + tmp1; i3 = tmp + x2  + tmp2; i4 =
     * tmp + x2p + tmp2; in[i] = (in[i1] + in[i2] + in[i3] + in[i4])/4; } // for (y = 0; y < yNew; y++) } // for (x = 0;
     * x < xNew; x++) }
     */

    /*
     * private float distance1d(float pos, float centroid) { float temp; float result;
     *
     * temp = pos - centroid; result = temp * temp; return result; }
     */
    private float distancems2(float[] buffer, int index, float[] centroids, int c) {
        float result;
        double temp;
        int m;

        result = 0.0f;

        for (m = 0; m < spectraNumber; m++) {
            temp = (double) (buffer[(m * sliceSize) + index] - centroids[(m * nClass) + c]);
            result += (float) (temp * temp);
        } // (m = 0; m < spectraNumber; m++)

        return (result);
    }

    /**
     * DOCUMENT ME!
     *
     * @param   buffer     DOCUMENT ME!
     * @param   index      DOCUMENT ME!
     * @param   centroids  DOCUMENT ME!
     * @param   c          DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private float distancems3(float[] buffer, int index, float[] centroids, int c) {
        float result;
        double temp;
        int m;

        result = 0.0f;

        for (m = 0; m < spectraNumber; m++) {
            temp = (double) (buffer[(m * volSize) + index] - centroids[(m * nClass) + c]);
            result += (float) (temp * temp);
        } // (m = 0; m < spectraNumber; m++)

        return (result);
    }

}
