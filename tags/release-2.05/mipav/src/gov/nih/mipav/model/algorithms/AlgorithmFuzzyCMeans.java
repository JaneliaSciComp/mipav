package gov.nih.mipav.model.algorithms;


import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.*;

import java.io.*;

import java.util.*;


/**
 * Fuzzy C-Means Segmentation algorithm
 *
 * <p>Segmentation divides an image into distinct classes or types, such as segmenting the brain into 3 tissue types:
 * gray matter, white matter, and cerebrospinal fluid. There are 2 types of segmentation: hard and soft or fuzzy. In
 * hard segmentation a pixel is simply assigned to 1 of the classes. However, often in medical images, there cannot be
 * absolute classification of a pixel because of partial volume effects where multiple tissues contribute to a pixel or
 * voxel causing intensity blurring across boundaries. Fuzzy segmentation allows for the uncertainty in the location of
 * object boundaries. In fuzzy segmentation a membership function exists for each class at every pixel location. At each
 * pixel location a class membership function will have a value of 0 if there is absolutely no chance of that pixel
 * belonging to the class. At each pixel location a class membership function will have a value of 1 if the pixel
 * belongs to the class with absolute certainty. Membership functions can vary from 0 to 1, with the constraint that at
 * any pixel location the sum of the membership functions of all the classes must add up to 1. The fuzzy membership
 * function reflects the similarity between the data value at that pixel and the value of the class centroid. As a pixel
 * data value becomes closer to the class centroid, the class membership function approaches unity.</p>
 *
 * <p>The fuzzy C-Means algorithm is an unsupervised method; it works without the use of training data. This algorithm,
 * allowing for soft segmentation based on fuzzy set theory, generalizes the K-means algorithm. The technique clusters
 * data by iteratively computing a fuzzy membrship function and mean value estimates for each tissue class. The
 * algorithm works by minimizing the sum over all pixels j and all classes k of: (ujk**q) * ((yj - vk)**2)</p>
 *
 * <p>nClass = number of classes. ujk is the membership value at pixel location j for class k such that that sum over k
 * from k = 1 to k = nClass for ujk = 1. q is a weighing exponent on each membership value and determines the amount of
 * "fuzziness" of the resulting segmentation. q is required to be greater than 1 and is typically set to 2. yj is the
 * observed single channel image intensity at location j. vk is the centroid of class k.</p>
 *
 * <p>The user provides initial centroid values or simply uses default evenly spread pixel values generated by:
 *
 * <pre><code>
    for (i = 0; i < nClass; i++)
        centroid[i] = minimum + (maximum - minimum)*(i + 1)/(nClass + 1);
    </code></pre>
 * </p>
 *
 * <p>Minimization is achieved by an interative process which:<br>
 * 1.)Computes the membership functions using a current estimate of the centroids.<br>
 * numerator = (yj - vk)**(-2/(q-1))<br>
 * denominator = Sum over l from l = 1 to l = nClass of (yj - vl)**(-2/(q-1))<br>
 * ujk = numerator/denominator for all pixels j and all classes k<br>
 * <br>
 * 2.) Computes the centroids using current estimates of the membership functions.<br>
 * numerator = sum over all pixels j of (ujk**q) * yj<br>
 * denominator = sum over all pixels j of (ujk**q)<br>
 * vk = numerator/denominator for all classes k<br>
 * </p>
 *
 * <p>The iteration continues until either the user specified maximum number of iterations has occcured or until
 * convergence has been detected. Convergence occurs when all membership functions over all pixel locations j change by
 * less than the tolerance value between 2 iterations. The default maximum iteration number is 100. The default
 * tolerance is 0.01.</p>
 *
 * <p>The initial dialog asks the user for a signal threshold value. The default value is the image minimum value. In
 * the centroid calculation only those pixels whose values equal or exceed threshold are used in the centroid
 * calculaton. In the hard segmentation pixels whose values are less than threshold or not in a selected VOI if if the
 * whole image is not used are set to a segmentation value of 0, meaning that these pixels are outside of the specified
 * classes.</p>
 *
 * <p>The initial dialog has a checkbox for Boundary noise cropping which is unchecked by default. This function finds
 * the smallest bounding box outside of which all image pixel values are below the image threshold. Values inside the
 * bounding box are copied to a smaller array to save space and calculations are performed with this reduced array.
 * However, these pixels outside the box are restored for the production of the hard and fuzzy segmented images. In the
 * hard segmentation case values outside the box all have a value of 0. In the fuzzy segmentation case values outside
 * the box all have a value equal to the image minimum. If the cropping checkbox is selected, the user is constrained to
 * select whole image rather than VOI region(s).</p>
 *
 * <p>There are 3 choices for produced output images:<br>
 * 1.) HARD ONLY<br>
 * 2.) FUZZY ONLY<br>
 * 3.) HARD & FUZZY BOTH<br>
 * </p>
 *
 * <p>Hard segmentation produces only 1 unsigned byte output image which assigns pixels which do not meet threshold
 * requirements values of 0. The first class is assigned a value of 255/nClass, the second class is assigned a pixel
 * value of 2*255/nClass, and so on. The last class has a value of 255.</p>
 *
 * <p>Fuzzy segmentation produces 1 image of the same type as the source image for every segmentation class. The
 * membership function is scaled so that the minimum membership value scales to the source image minimum value and the
 * maximum membership value scales to the source image maximum value. If boundary cropping is used, pixels outside the
 * bounding box are all assigned the source image minimum value.</p>
 *
 * <p>The signal threshold value is entered on the initial dialog and the image centroids are entered on a later dialog.
 * </p>
 *
 * <p>Image Types:<br>
 * This algorithm can be applied to 2D and 3D data sets that are not color or COMPLEX.<br>
 * </p>
 *
 * <p>References: This code is a ported subset of C-code written and kindly provided by Dzung Pham. Note that our code
 * is not the adaptive fuzzy C-means segmentation, which the Dzung Pham code is. Our code is not adaptive - it does not
 * correct intensity inhomogeneities, also known as shading artifacts.<br>
 * 1.) Dzung L. Pham, Chenyang Xu, and Jerry L. Prince, "A Survey of Current Methods in Medical Image Segmentation",
 * Department of Electrical and Computer Engineering, The Johns Hopkins University, Baltimore, Maryland, 21218,
 * Technical Report JHU/ECE 99-01.<br>
 * 2.) Alberto F. Goldszal and Dzung L. Pham, "Volumetric Segmentation", Chapter 12, Academic Press, copyright 2000.<br>
 * 3.) Dzung L. Pham and Jerry L. Prince, "Adaptive Fuzzy Segmentation of Magnetic Resonance Images", IEEE Transactions
 * on Medical Imaging, Vol. 18, No. 9, September, 1999, pp. 737 - 752.<br>
 * </p>
 *
 * @version  0.1 June 15, 2000 conversion of Dzung Pham's C code
 * @see      gov.nih.mipav.view.dialogs.JDialogFuzzyCMeans
 * @see      AlgorithmFuzzyCMeans
 * @see      gov.nih.mipav.view.dialogs.JDialogInitialCentroids
 */
public class AlgorithmFuzzyCMeans extends AlgorithmBase {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** possible values for segmentation. */
    public static final int BOTH_FUZZY_HARD = 0;

    /** DOCUMENT ME! */
    public static final int FUZZY_ONLY = 1;

    /** DOCUMENT ME! */
    public static final int HARD_ONLY = 2;

    /** DOCUMENT ME! */
    public static final float MAX_FLOAT = 1e30f;

    /** DOCUMENT ME! */
    public static final float ALPHA = 0.3f;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** DOCUMENT ME! */
    private float[] buffer2;

    /** DOCUMENT ME! */
    private float[] centroids;

    /** DOCUMENT ME! */
    private int[] classNumber;

    /** DOCUMENT ME! */
    private boolean cropBackground = false; // When cropBackground is true,

    /** Fuzzy images require 1 image for each class Hard images 1 image with assigned clusters. */
    private ModelImage[] destImage;

    /** DOCUMENT ME! */
    private int destNum = 0; // number of the destination image

    /** 1/(qValue - 1). */
    private double exponent;

    /** DOCUMENT ME! */
    private int iterations;

    /** jacobiIters1 and jacobiIter2 are only used with gain correction. */
    private int jacobiIters1 = 1;

    /** DOCUMENT ME! */
    private int jacobiIters2 = 2;

    /** DOCUMENT ME! */
    private float maxChange;

    /** DOCUMENT ME! */
    private int maxIter = 100;

    /** DOCUMENT ME! */
    private float[] mems;

    /** DOCUMENT ME! */
    private float[] memsBuffer;

    /** DOCUMENT ME! */
    private int memSize;

    /** DOCUMENT ME! */
    private float minimum, maximum;

    /** DOCUMENT ME! */
    private int nClass = 3;

    /** DOCUMENT ME! */
    private int newSliceSize;

    /** DOCUMENT ME! */
    private int newXDim, newYDim, newZDim;

    /** DOCUMENT ME! */
    private BitSet objMask;

    /** DOCUMENT ME! */
    private float[] oldMember;

    /** DOCUMENT ME! */
    private int oldX, oldY, oldZ;

    /** DOCUMENT ME! */
    private int orgSlice;

    /** DOCUMENT ME! */
    private int orgVol;

    /** DOCUMENT ME! */
    private int orgXDim;

    /** DOCUMENT ME! */
    private boolean outputGainField = false;

    /** DOCUMENT ME! */
    private boolean powEIntFlag = true;

    /** pyramidLevels is only used with gain correction. */
    private int pyramidLevels = 4;

    /** DOCUMENT ME! */
    private double qValue = 2.0f;

    /** DOCUMENT ME! */
    private float[] sCentroids;

    /** DOCUMENT ME! */
    private byte[] segBuffer;

    /** DOCUMENT ME! */
    private int segmentation = FUZZY_ONLY;

    /** DOCUMENT ME! */
    private int sliceSize;

    /** smooth1 and smooth2 are only used with gain field correction. */
    private float smooth1 = 20000;

    /** DOCUMENT ME! */
    private float smooth2 = 200000;

    /** DOCUMENT ME! */
    private float threshold = 1.0f;

    /** DOCUMENT ME! */
    private float tolerance = 0.01f;

    /** DOCUMENT ME! */
    private ViewUserInterface UI;

    /** DOCUMENT ME! */
    private boolean[] unusedCentroids;

    /** DOCUMENT ME! */
    private int volSize;

    /** wholeImage is constrained to be true. */
    private boolean wholeImage = true; // true = apply algorithm to the whole image

    // false = apply algorithm only to VOI regions

    /** DOCUMENT ME! */
    private int xDim, yDim, zDim;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Creates a new AlgorithmFuzzyCMeans object.
     *
     * @param  srcImg            source image model
     * @param  _nClass           number of classes into which the image will be segmented
     * @param  _pyramidLevels    number of levels
     * @param  _jacobiIters1     DOCUMENT ME!
     * @param  _jacobiIters2     DOCUMENT ME!
     * @param  _q                DOCUMENT ME!
     * @param  _smooth1          DOCUMENT ME!
     * @param  _smooth2          DOCUMENT ME!
     * @param  _outputGainField  DOCUMENT ME!
     * @param  _segmentation     DOCUMENT ME!
     * @param  _cropBackground   DOCUMENT ME!
     * @param  _threshold        DOCUMENT ME!
     * @param  _max_iter         DOCUMENT ME!
     * @param  _tolerance        DOCUMENT ME!
     * @param  _wholeImage       DOCUMENT ME!
     */
    public AlgorithmFuzzyCMeans(ModelImage srcImg, int _nClass, int _pyramidLevels, int _jacobiIters1,
                                int _jacobiIters2, float _q, float _smooth1, float _smooth2, boolean _outputGainField,
                                int _segmentation, boolean _cropBackground, float _threshold, int _max_iter,
                                float _tolerance, boolean _wholeImage) {
        super(null, srcImg);

        nClass = _nClass;
        pyramidLevels = _pyramidLevels;
        jacobiIters1 = _jacobiIters1;
        jacobiIters2 = _jacobiIters2;
        qValue = _q;
        exponent = 1.0f / (qValue - 1.0f);
        smooth1 = _smooth1;
        smooth2 = _smooth2;
        outputGainField = _outputGainField;
        segmentation = _segmentation;
        cropBackground = _cropBackground;
        threshold = _threshold;
        maxIter = _max_iter;
        tolerance = _tolerance;
        wholeImage = _wholeImage;
        oldMember = new float[nClass];
        sCentroids = new float[nClass];
        unusedCentroids = new boolean[nClass];
        UI = srcImage.getUserInterface();
        classNumber = new int[nClass];

        if ((exponent - Math.floor(exponent)) < 0.01) {
            powEIntFlag = true;
        } else {
            powEIntFlag = false;
        }
    }

    /**
     * Creates a new AlgorithmFuzzyCMeans object.
     *
     * @param  destImg           list of image models where result image is to stored
     * @param  srcImg            source image model
     * @param  _nClass           number of classes into which the image will be segmented
     * @param  _pyramidLevels    number of levels
     * @param  _jacobiIters1     DOCUMENT ME!
     * @param  _jacobiIters2     DOCUMENT ME!
     * @param  _q                DOCUMENT ME!
     * @param  _smooth1          DOCUMENT ME!
     * @param  _smooth2          DOCUMENT ME!
     * @param  _outputGainField  DOCUMENT ME!
     * @param  _segmentation     DOCUMENT ME!
     * @param  _cropBackground   DOCUMENT ME!
     * @param  _threshold        DOCUMENT ME!
     * @param  _max_iter         DOCUMENT ME!
     * @param  _tolerance        DOCUMENT ME!
     * @param  _wholeImage       DOCUMENT ME!
     */
    public AlgorithmFuzzyCMeans(ModelImage[] destImg, ModelImage srcImg, int _nClass, int _pyramidLevels,
                                int _jacobiIters1, int _jacobiIters2, float _q, float _smooth1, float _smooth2,
                                boolean _outputGainField, int _segmentation, boolean _cropBackground, float _threshold,
                                int _max_iter, float _tolerance, boolean _wholeImage) {
        super(null, srcImg);
        destImage = destImg; // Put results in destination image.

        nClass = _nClass;
        pyramidLevels = _pyramidLevels;
        jacobiIters1 = _jacobiIters1;
        jacobiIters2 = _jacobiIters2;
        qValue = _q;
        exponent = 1.0f / (qValue - 1.0f);
        smooth1 = _smooth1;
        smooth2 = _smooth2;
        outputGainField = _outputGainField;
        segmentation = _segmentation;
        cropBackground = _cropBackground;
        threshold = _threshold;
        maxIter = _max_iter;
        tolerance = _tolerance;
        wholeImage = _wholeImage;
        oldMember = new float[nClass];
        sCentroids = new float[nClass];
        unusedCentroids = new boolean[nClass];
        UI = srcImage.getUserInterface();
        classNumber = new int[nClass];

        if ((exponent - Math.floor(exponent)) < 0.01) {
            powEIntFlag = true;
        } else {
            powEIntFlag = false;
        }
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Prepares this class for destruction.
     */
    public void finalize() {

        cleanUp();

        destImage = null;
        srcImage = null;
        super.finalize();
    }

    /**
     * Starts the algorithm.
     */
    public void runAlgorithm() {

        if (srcImage == null) {
            displayError("Fuzzy C-means: Source Image is null");

            return;
        }

        constructLog();

        if (srcImage.getNDims() == 2) {
            cMeans2();
        } else if (srcImage.getNDims() == 3) {
            cMeans3();
        }
    }


    /**
     * Accessor to set the centroids.
     *
     * @param  cent  Centroids to set.
     */
    public void setCentroids(float[] cent) {
        centroids = new float[cent.length];

        for (int i = 0; i < centroids.length; i++) {
            centroids[i] = cent[i];
        }
    }

    /**
     * Writes the logString to the appropriate log area. Overrides the AlgorithmBase <code>writeLog()</code> to append
     * the history to all of the destination images we've created.
     */
    protected void writeLog() {

        // write to the history area
        if (Preferences.is(Preferences.PREF_LOG) && completed) {

            if (destImage != null) {

                for (int i = 0; i < destImage.length; i++) {

                    if ((destImage[i] != null) && (destImage[i].getHistoryArea() != null)) {

                        if (srcImage != null) {
                            destImage[i].getHistoryArea().setText(srcImage.getHistoryArea().getText());
                        }

                        if (historyString != null) {
                            destImage[i].getHistoryArea().append(historyString);
                        }
                    }
                }
            } else if (srcImage != null) {

                if (historyString != null) {
                    srcImage.getHistoryArea().append(historyString);
                }
            }
        }
    }

    /**
     * Cleans up the memory usage.
     */
    private void cleanUp() {

        memsBuffer = null;
        segBuffer = null;
        buffer2 = null;
        objMask = null;
        mems = null;
        classNumber = null;
        oldMember = null;
        sCentroids = null;
        unusedCentroids = null;
        centroids = null;
    }

    /**
     * DOCUMENT ME!
     */
    private void cMeans2() {
        int xLow;
        int xHigh;
        int yLow;
        int yHigh;
        int c;
        int x, y;
        int i, j;
        float dTemp;
        int indexM;
        int index;
        float minClass, maxClass;
        float offset;
        float scaleFactor;
        int yStepIn, yStepOut;

        float[] buffer;
        int classType;

        srcImage.calcMinMax();
        minimum = (float) srcImage.getMin();
        maximum = (float) srcImage.getMax();
        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        orgXDim = xDim;
        sliceSize = xDim * yDim;
        orgSlice = sliceSize;

        buildProgressBar(srcImage.getImageName(), "Importing source image...", 0, 100);
        initProgressBar();

        try {
            buffer = new float[sliceSize];
            srcImage.exportData(0, sliceSize, buffer);

            if ((destImage == null) && (srcImage.getType() != ModelStorageBase.UBYTE)) {
                srcImage.reallocate(ModelStorageBase.UBYTE);
            }

            if (!wholeImage) {
                maximum = -Float.MAX_VALUE;
                minimum = Float.MAX_VALUE;

                for (i = 0; i < sliceSize; i++) {

                    if (mask.get(i)) {

                        if (buffer[i] > maximum) {
                            maximum = buffer[i];
                        }

                        if (buffer[i] < minimum) {
                            minimum = buffer[i];
                        }
                    }
                }
            } // if (!wholeImage)

            xLow = 0;
            yLow = 0;
            xHigh = xDim - 1;
            yHigh = yDim - 1;

            if (cropBackground) {

                // If cropBackground is true wholeImage is constrained to be true
                if (progressBar != null) {
                    progressBar.setMessage("Cropping background");
                }

                // Find the smallest bounding box for the data
                xLow = xDim - 1;
                yLow = yDim - 1;
                xHigh = 0;
                yHigh = 0;

                for (y = 0; y < yDim; y++) {
                    yStepIn = y * xDim;

                    for (x = 0; x < xDim; x++) {
                        index = x + yStepIn;

                        if (buffer[index] >= threshold) {

                            if (x < xLow) {
                                xLow = x;
                            }

                            if (x > xHigh) {
                                xHigh = x;
                            }

                            if (y < yLow) {
                                yLow = y;
                            }

                            if (y > yHigh) {
                                yHigh = y;
                            }
                        } // if (buffer[index] > threshold)
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)

                if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1))) {

                    // A smaller bounding box has been found for the data
                    // Recopy area to smaller data array to save space
                    newXDim = xHigh - xLow + 1;
                    newYDim = yHigh - yLow + 1;
                    buffer2 = new float[newXDim * newYDim];

                    for (y = yLow; y <= yHigh; y++) {
                        yStepIn = ((y - yLow) * newXDim) - xLow;
                        yStepOut = y * xDim;

                        for (x = xLow; x <= xHigh; x++) {
                            buffer2[x + yStepIn] = buffer[x + yStepOut];
                        } // for (x = xLow; x <= xHigh; x++)
                    } // for (y = yLow; y <= yHigh; y++)

                    xDim = newXDim;
                    yDim = newYDim;
                    sliceSize = xDim * yDim;
                    buffer = new float[sliceSize];

                    for (i = 0; i < sliceSize; i++) {
                        buffer[i] = buffer2[i];
                    }

                    buffer2 = null;

                    // Find the new minimum
                    minimum = maximum;

                    for (i = 0; i < sliceSize; i++) {

                        if (buffer[i] < minimum) {
                            minimum = buffer[i];
                        } // if (buffer[i] < minimum)
                    } // for (i = 0; i < sliceSize; i++)
                } // if ((xLow > 0) || (xHigh < (xDim-1)) || (yLow > 0) || (yHigh < (yDim - 1)))
            } // if (cropBackground)

            // Create object mask
            objMask = new BitSet(sliceSize);

            for (i = 0; i < sliceSize; i++) {

                if (buffer[i] >= threshold) {
                    objMask.set(i);
                } else {
                    objMask.clear(i);
                }
            }

            if (wholeImage == false) {

                // If not in the VOI, clear the objMask
                for (i = 0; i < sliceSize; i++) {

                    if (!mask.get(i)) {
                        objMask.clear(i);
                    }
                }
            } // if (wholeImage == false)

            // Initialize membership and multiplier arrays
            memSize = nClass * sliceSize;
            mems = new float[memSize];
            iterations = 1;
            maxChange = 1.0f;
        } catch (IOException ioe) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("algorithm FuzzyCMeans reports:\n" + ioe.toString());

            if (progressBar != null) {
                progressBar.dispose();
            }

            setCompleted(false);

            return;
        } catch (OutOfMemoryError error) {
            cleanUp();
            System.gc();
            MipavUtil.displayError("Algorithm FuzzyCMeans reports:\n" + error.toString());

            if (progressBar != null) {
                progressBar.dispose();
            }

            setCompleted(false);

            return;
        }

        /************************************************/

        /* MAIN LOOP                      */

        /* Perform fuzzy clustering               */

        /************************************************/
        computeMemberships2D(buffer, centroids, mems, exponent);

        while ((iterations <= maxIter) && (maxChange > tolerance) && !threadStopped) {

            if (progressBar != null) {
                progressBar.setMessage("iteration = " + iterations + " maxChange = " + maxChange);
            }

            computeCentroids2D(buffer, centroids, mems);
            computeMemberships2D(buffer, centroids, mems, exponent);
            iterations += 1;
        } // while ((iterations <= maxIter) && (maxChange > tolerance))

        if (threadStopped) {
            finalize();

            return;
        }

        if (progressBar != null) {
            progressBar.setMessage("Finished iterations");
        }

        buffer = null;
        centroids = null;
        buffer2 = null;
        System.gc();

        /* Output results and assign clusters if necessary */
        if (segmentation != HARD_ONLY) {

            try {
                memsBuffer = new float[orgSlice];
            } catch (OutOfMemoryError e) {
                cleanUp();
                System.gc();
                MipavUtil.displayError("FuzzyCMeans: Out of memory");

                if (progressBar != null) {
                    progressBar.dispose();
                }

                setCompleted(false);

                return;
            }

            for (i = 0; (i < nClass) && !threadStopped; i++) {

                for (j = 0; j < orgSlice; j++) {
                    memsBuffer[j] = minimum;
                } // for (j = 0; j < orgSlice; j++)
                // Find the maximum value in the class

                maxClass = -Float.MAX_VALUE;
                minClass = Float.MAX_VALUE;

                for (j = 0; j < sliceSize; j++) {

                    if ((wholeImage) || (mask.get(j))) {
                        indexM = (i * sliceSize) + j;

                        if (mems[indexM] > maxClass) {
                            maxClass = mems[indexM];
                        }

                        if (mems[indexM] < minClass) {
                            minClass = mems[indexM];
                        }
                    } // if ((wholeImage) || (mask.get(j)))
                } // for (j = 0; j < sliceSize; j++)

                // Scale the data so that the scaled data has the same original minimum
                // and the same original maximum as the source image
                if (maxClass != minClass) {
                    scaleFactor = (maximum - minimum) / (maxClass - minClass);
                    offset = ((maxClass * minimum) - (maximum * minClass)) / (maxClass - minClass);
                } else {
                    scaleFactor = 1;
                    offset = 0;
                }

                // System.out.println("old y = " + oldY);
                // restore the image to the original dimensions
                indexM = i * sliceSize;

                try {

                    for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                        yStepIn = oldY * orgXDim;
                        yStepOut = indexM + (y * xDim);

                        for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {
                            index = oldX + yStepIn;

                            if ((wholeImage) || (mask.get(index))) {
                                memsBuffer[index] = (mems[x + yStepOut] * scaleFactor) + offset;
                            }
                        } // for (oldX = xLow, x = 0; oldX <= xHigh;oldX++,x++)
                    } // for (oldY = yLow, y = 0; oldY <= yHigh;oldY++,y++)
                } catch (ArrayIndexOutOfBoundsException e) {
                    Preferences.debug("error = " + e);
                }

                try {

                    if (destImage != null) {
                        destImage[destNum].importData(0, memsBuffer, true);
                    } else {
                        srcImage.importData(0, memsBuffer, true);
                    }
                } catch (IOException error) {
                    cleanUp();

                    if (destImage != null) {
                        MipavUtil.displayError("FuzzyCMeans: IOException on destImage[" + destNum +
                                               "].importData(0,memsBuffer,true)");
                    } else {
                        MipavUtil.displayError("FuzzyCMeans: IOException on srcImage.importData(0,memsBuffer,true)");
                    }

                    if (progressBar != null) {
                        progressBar.dispose();
                    }

                    setCompleted(false);

                    return;
                }

                destNum++;
            } // for (i = 0; i < nClass; i++)

            memsBuffer = null;
            System.gc();

            if (threadStopped) {
                finalize();

                return;
            }

        } // if (segmentation != HARD_ONLY)

        if (segmentation != FUZZY_ONLY) {

            try {
                int range = 255 / nClass;

                segBuffer = new byte[orgSlice];

                for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {

                    yStepOut = y * xDim;
                    yStepIn = oldY * orgXDim;

                    for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {

                        if (!objMask.get(x + yStepOut)) {
                            c = 0;
                            classType = -1;
                        } // if (!objMask.get(x + yStepOut))
                        else {
                            c = range;
                            classType = 0;
                            dTemp = mems[x + yStepOut];

                            for (i = 1; i < nClass; i++) {
                                indexM = (i * sliceSize) + x + yStepOut;

                                if (mems[indexM] > dTemp) {
                                    dTemp = mems[indexM];
                                    c = ((i + 1) * range);
                                    classType = i;
                                } // if (mems[indexM] > dtemp)
                            } // for (i = 1; i < nClass; i++)
                        } // else

                        segBuffer[oldX + yStepIn] = (byte) c;

                        if (classType >= 0) {
                            classNumber[classType]++;
                        }
                    } // for (oldX = xLow, oldX = 0; x <= xHigh; oldX++, x++)
                } // for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++)

                int[] units = srcImage.getFileInfo()[0].getUnitsOfMeasure();

                if ((units[0] != FileInfoBase.UNKNOWN_MEASURE) && (units[0] == units[1])) {
                    float[] res = srcImage.getFileInfo()[0].getResolutions();
                    float pixelSize = res[0] * res[1];
                    String unitsStr = FileInfoBase.getUnitsOfMeasureStr(units[0]);

                    for (i = 0; i < nClass; i++) {
                        UI.setDataText(srcImage.getImageName() + " intensity = " + (range * (i + 1)) + " count = " +
                                       classNumber[i] + " area = " + (pixelSize * classNumber[i]) + " square " +
                                       unitsStr + "\n");
                    } // for (i = 0; i < nClass; i++)
                } else {

                    for (i = 0; i < nClass; i++) {
                        UI.setDataText(srcImage.getImageName() + " intensity = " + (range * (i + 1)) + " count = " +
                                       classNumber[i] + "\n");
                    } // for (i = 0; i < nClass; i++)
                } // else

                if (destImage != null) {
                    destImage[destNum].importData(0, segBuffer, true);
                } else {
                    srcImage.importData(0, segBuffer, true);
                }
            } catch (IOException error) {
                cleanUp();
                System.gc();

                if (destImage != null) {
                    MipavUtil.displayError("FuzzyCMeans: IOException on destImage[" + destNum +
                                           "].importData(0,segBuffer,true)");
                } else {
                    MipavUtil.displayError("FuzzyCMeans: IOException on srcImage.importData(0,segBuffer,true)");

                }

                if (progressBar != null) {
                    progressBar.dispose();
                }

                setCompleted(false);

                return;
            } catch (OutOfMemoryError e) {
                cleanUp();
                System.gc();

                if (destImage != null) {
                    MipavUtil.displayError("FuzzyCMeans: Out of memory on destImage[" + destNum +
                                           "].importData(0,segBuffer,true)");
                } else {
                    MipavUtil.displayError("FuzzyCMeans: Out of memory on srcImage.importData(0,segBuffer,true)");

                }

                if (progressBar != null) {
                    progressBar.dispose();
                }

                setCompleted(false);

                return;
            }
        } // if (segmentation != FUZZY_ONLY)

        mems = null;
        objMask = null;

        if (progressBar != null) {
            progressBar.dispose();
        }

        setCompleted(true);

        return;
    }

    /**
     * cMeans3.
     */
    private void cMeans3() {
        int xLow, xHigh;
        int yLow, yHigh;
        int zLow, zHigh;
        int c;
        int x, y, z;
        int i, j;
        float dTemp;
        int indexM;
        int index;
        float minClass, maxClass;
        float offset;
        float scaleFactor;
        int yStepIn, yStepOut, zStepIn, zStepOut;

        float[] buffer;

        srcImage.calcMinMax();
        minimum = (float) srcImage.getMin();
        maximum = (float) srcImage.getMax();
        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        zDim = srcImage.getExtents()[2];
        orgXDim = xDim;
        sliceSize = xDim * yDim;
        volSize = xDim * yDim * zDim;
        orgSlice = sliceSize;
        orgVol = volSize;

        int classType;

        buildProgressBar(srcImage.getImageName(), "Importing source image...", 0, 100);
        initProgressBar();

        try {
            buffer = new float[volSize];
            srcImage.exportData(0, volSize, buffer);
        } catch (IOException ioe) {
            cleanUp();
            MipavUtil.displayError("algorithm FuzzyCMeans reports:\n" + ioe.toString());

            if (progressBar != null) {
                progressBar.dispose();
            }

            setCompleted(false);

            return;
        } catch (OutOfMemoryError e) {
            cleanUp();
            System.gc();
            displayError("Algorithm FuzzyCMeans: Out of memory");
            setCompleted(false);
            disposeProgressBar();

            return;
        }

        if ((destImage == null) && (srcImage.getType() != ModelStorageBase.UBYTE)) {
            srcImage.reallocate(ModelStorageBase.UBYTE);
        }

        try {

            if (!wholeImage) {
                maximum = -Float.MAX_VALUE;
                minimum = Float.MAX_VALUE;

                for (i = 0; i < volSize; i++) {

                    if (mask.get(i)) {

                        if (buffer[i] > maximum) {
                            maximum = buffer[i];
                        }

                        if (buffer[i] < minimum) {
                            minimum = buffer[i];
                        }
                    }
                }
            } // if (!wholeImage)

            xLow = 0;
            yLow = 0;
            zLow = 0;
            xHigh = xDim - 1;
            yHigh = yDim - 1;
            zHigh = zDim - 1;

            if (cropBackground) {

                // If cropBackground is true wholeImage is constrained to be true
                // Find the smallest bounding box for the data
                if (progressBar != null) {
                    progressBar.setMessage("Cropping background");
                }

                xLow = xDim - 1;
                yLow = yDim - 1;
                zLow = zDim - 1;
                xHigh = 0;
                yHigh = 0;
                zHigh = 0;

                for (z = 0; z < zDim; z++) {
                    zStepIn = z * sliceSize;

                    for (y = 0; y < yDim; y++) {
                        yStepIn = (y * xDim) + zStepIn;

                        for (x = 0; x < xDim; x++) {
                            index = x + yStepIn;

                            if (buffer[index] >= threshold) {

                                if (x < xLow) {
                                    xLow = x;
                                }

                                if (x > xHigh) {
                                    xHigh = x;
                                }

                                if (y < yLow) {
                                    yLow = y;
                                }

                                if (y > yHigh) {
                                    yHigh = y;
                                }

                                if (z < zLow) {
                                    zLow = z;
                                }

                                if (z > zHigh) {
                                    zHigh = z;
                                }
                            } // if (buffer[index] > threshold)
                        } // for (x = 0; x < xDim; x++)
                    } // for (y = 0; y < yDim; y++)
                } // for (z = 0; z < zDim; z++)

                if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1)) || (zLow > 0) ||
                        (zHigh < (zDim - 1))) {

                    // A smaller bounding box has been found for the data
                    // Recopy area to smaller data array to save space
                    newXDim = xHigh - xLow + 1;
                    newYDim = yHigh - yLow + 1;
                    newZDim = zHigh - zLow + 1;
                    buffer2 = new float[newXDim * newYDim * newZDim];
                    newSliceSize = newXDim * newYDim;

                    for (z = zLow; z <= zHigh; z++) {
                        zStepOut = z * sliceSize;
                        zStepIn = ((z - zLow) * newSliceSize) - xLow - (yLow * newXDim);

                        for (y = yLow; y <= yHigh; y++) {
                            yStepOut = (y * xDim) + zStepOut;
                            yStepIn = (y * newXDim) + zStepIn;

                            for (x = xLow; x <= xHigh; x++) {
                                buffer2[x + yStepIn] = buffer[x + yStepOut];
                            } // for (x = xLow; x <= xHigh; x++)
                        } // for (y = yLow; y <= yHigh; y++)
                    } // for (z = zLow; z <= zHigh; z++)

                    xDim = newXDim;
                    yDim = newYDim;
                    zDim = newZDim;
                    sliceSize = xDim * yDim;
                    volSize = sliceSize * zDim;
                    buffer = new float[volSize];

                    for (i = 0; i < volSize; i++) {
                        buffer[i] = buffer2[i];
                    }

                    buffer2 = null;

                    // Find the new minimum
                    minimum = maximum;

                    for (i = 0; i < volSize; i++) {

                        if (buffer[i] < minimum) {
                            minimum = buffer[i];
                        } // if (buffer[i] < minimum)
                    } // for (i = 0; i < volSize; i++)
                } // if ((xLow > 0) || (xHigh < (xDim - 1)) || (yLow > 0) || (yHigh < (yDim - 1)) ||
                // (zLow > 0) || (zHigh < (zDim - 1)))
            } // if (cropBackground)

            // Create object mask
            objMask = new BitSet(volSize);

            for (i = 0; i < volSize; i++) {

                if (buffer[i] >= threshold) {
                    objMask.set(i);
                } else {
                    objMask.clear(i);
                }
            }

            if (wholeImage == false) {

                // If not in the VOI, clear the objMask
                for (i = 0; i < volSize; i++) {

                    if (!mask.get(i)) {
                        objMask.clear(i);
                    }
                }
            } // if (wholeImage == false)

            // Initialize membership and multiplier arrays
            memSize = nClass * volSize;
            mems = new float[memSize];
            iterations = 1;
            maxChange = 1.0f;
        } catch (OutOfMemoryError e) {
            cleanUp();
            System.gc();
            displayError("Algorithm FuzzyCMeans: Out of memory");
            setCompleted(false);
            disposeProgressBar();

            return;
        }

        /************************************************/
        // MAIN LOOP  Perform fuzzy clustering
        /************************************************/

        computeMemberships3D(buffer);

        while ((iterations <= maxIter) && (maxChange > tolerance) && !threadStopped) {

            if (progressBar != null) {
                progressBar.setMessage("Iteration = " + iterations + " maxChange = " + maxChange);
            }

            computeCentroids3D(buffer);
            computeMemberships3D(buffer);
            iterations += 1;
        } // while ((iterations <= maxIter) && (maxChange > tolerance))

        if (threadStopped) {
            buffer = null;
            finalize();

            return;
        }

        if (progressBar != null) {
            progressBar.setMessage("Iterations finished");
        }

        for (int m = 0; m < centroids.length; m++) {
            Preferences.debug(" Centoid " + i + " = " + centroids[m], Preferences.DEBUG_ALGORITHM);
        }

        buffer = null;
        centroids = null;
        buffer2 = null;
        System.gc();

        try {

            /* Output results and assign clusters if necessary */
            if (segmentation != HARD_ONLY) {
                memsBuffer = new float[orgVol];

                for (i = 0; i < nClass; i++) {

                    for (j = 0; j < orgVol; j++) {
                        memsBuffer[j] = minimum;
                    } // for (j = 0; j < orgVol; j++)

                    // Find the maximum value in the class
                    maxClass = -Float.MAX_VALUE;
                    minClass = Float.MAX_VALUE;

                    for (j = 0; j < volSize; j++) {

                        if ((wholeImage) || (mask.get(j))) {
                            indexM = (i * volSize) + j;

                            if (mems[indexM] > maxClass) {
                                maxClass = mems[indexM];
                            }

                            if (mems[indexM] < minClass) {
                                minClass = mems[indexM];
                            }
                        } // if ((wholeImage) || (mask.get(j)))
                    } // for (j = 0; j < volSize; j++)

                    // Scale the data so that the scaled data has the same original minimum
                    // and the same original maximum as the source image
                    if (maxClass != minClass) {
                        scaleFactor = (maximum - minimum) / (maxClass - minClass);
                        offset = ((maxClass * minimum) - (maximum * minClass)) / (maxClass - minClass);
                    } else {
                        scaleFactor = 1;
                        offset = 0;
                    }

                    // restore the image to the original dimensions
                    indexM = i * volSize;

                    for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++) {
                        zStepOut = indexM + (z * sliceSize);
                        zStepIn = oldZ * orgSlice;

                        for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                            yStepOut = (y * xDim) + zStepOut;
                            yStepIn = (oldY * orgXDim) + zStepIn;

                            for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {
                                index = oldX + yStepIn;

                                if ((wholeImage) || (mask.get(index))) {
                                    memsBuffer[index] = (mems[x + yStepOut] * scaleFactor) + offset;
                                } // if ((wholeImage) || (mask.get(index)))
                            } // for (oldX = xLow, x = 0; oldX <= xHigh;oldX++,x++)
                        } // for (oldY = yLow, y = 0; oldY <= yHigh;oldY++,y++)
                    } // for (oldZ = zLow, z = 0; oldZ <= zHigh;oldZ++, z++)

                    try {

                        if (destImage != null) {
                            destImage[destNum].importData(0, memsBuffer, true);
                        } else {
                            srcImage.importData(0, memsBuffer, true);
                        }
                    } catch (IOException error) {
                        cleanUp();

                        if (destImage != null) {
                            MipavUtil.displayError("FuzzyCMeans: IOException on destImage[" + destNum +
                                                   "].importData(0,memsBuffer,true)");
                        } else {
                            MipavUtil.displayError("FuzzyCMeans: IOException on srcImage.importData(0,memsBuffer,true)");

                        }

                        if (progressBar != null) {
                            progressBar.dispose();
                        }

                        setCompleted(false);

                        return;
                    }

                    destNum++;
                } // for (i = 0; i < nClass; i++)

                memsBuffer = null;
            } // if (segmentation != HARD_ONLY)

            if (segmentation != FUZZY_ONLY) {
                int range = 255 / nClass;

                segBuffer = new byte[orgVol];

                for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++) {
                    zStepOut = z * sliceSize;
                    zStepIn = oldZ * orgSlice;

                    for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++) {
                        yStepOut = (y * xDim) + zStepOut;
                        yStepIn = (oldY * orgXDim) + zStepIn;

                        for (oldX = xLow, x = 0; oldX <= xHigh; oldX++, x++) {

                            if (!objMask.get(x + yStepOut)) {
                                c = 0;
                                classType = -1;
                            } // if (!objMask.get(x + yStepOut))
                            else {
                                c = range;
                                classType = 0;
                                dTemp = mems[x + yStepOut];

                                for (i = 1; i < nClass; i++) {
                                    indexM = (i * volSize) + x + yStepOut;

                                    if (mems[indexM] > dTemp) {
                                        dTemp = mems[indexM];
                                        c = ((i + 1) * range); // preCalc  temp = 255/nClass
                                        classType = i;
                                    } // if (mems[indexM] > dtemp)
                                } // for (i = 1; i < nClass; i++)
                            } // else

                            segBuffer[oldX + yStepIn] = (byte) c;

                            if (classType >= 0) {
                                classNumber[classType]++;
                            }
                        } // for (oldX = xLow, oldX = 0; x <= xHigh; oldX++, x++)
                    } // for (oldY = yLow, y = 0; oldY <= yHigh; oldY++, y++)
                } // for (oldZ = zLow, z = 0; oldZ <= zHigh; oldZ++, z++)

                int[] units = srcImage.getFileInfo()[0].getUnitsOfMeasure();

                if ((units[0] != FileInfoBase.UNKNOWN_MEASURE) && (units[0] == units[1]) && (units[0] == units[2])) {
                    float[] res = srcImage.getFileInfo()[0].getResolutions();
                    float voxelSize = res[0] * res[1] * res[2];
                    String unitsStr = FileInfoBase.getUnitsOfMeasureStr(units[0]);

                    for (i = 0; i < nClass; i++) {
                        UI.setDataText(srcImage.getImageName() + " intensity = " + (range * (i + 1)) + " count = " +
                                       classNumber[i] + " volume = " + (voxelSize * classNumber[i]) + " cubic " +
                                       unitsStr + "\n");
                    } // for (i = 0; i < nClass; i++)
                } else {

                    for (i = 0; i < nClass; i++) {
                        UI.setDataText(srcImage.getImageName() + " intensity = " + (range * (i + 1)) + " count = " +
                                       classNumber[i] + "\n");
                    } // for (i = 0; i < nClass; i++)
                }

                try {

                    if (destImage != null) {
                        destImage[destNum].importData(0, segBuffer, true);
                    } else {
                        srcImage.importData(0, segBuffer, true);
                    }
                } catch (IOException error) {
                    cleanUp();

                    if (destImage != null) {
                        MipavUtil.displayError("FuzzyCMeans: IOException on destImage[" + destNum +
                                               "].importData(0,segBuffer,true)");
                    } else {
                        MipavUtil.displayError("FuzzyCMeans: IOException on destImage[" + destNum +
                                               "].importData(0,segBuffer,true)");

                    }

                    if (progressBar != null) {
                        progressBar.dispose();
                    }

                    setCompleted(false);

                    return;
                }
            } // if (segmentation != FUZZY_ONLY)
        } catch (OutOfMemoryError e) {
            cleanUp();
            System.gc();

            if (destImage != null) {
                MipavUtil.displayError("FuzzyCMeans: Out of memory on destImage[" + destNum +
                                       "].importData(0,segBuffer,true)");
            } else {
                MipavUtil.displayError("FuzzyCMeans: Out of memory on srcImage.importData(0,segBuffer,true)");

            }

            if (progressBar != null) {
                progressBar.dispose();
            }

            setCompleted(false);

            return;
        }

        cleanUp();

        if (progressBar != null) {
            progressBar.dispose();
        }

        setCompleted(true);

        return;
    }

    /**
     * Determines the centroids of each cluster given fuzzy membership values.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     */
    private void computeCentroids2D(float[] buffer, float[] centroids, float[] mems) {
        int c; /* Cluster counter */
        float numer, denom; /* Used to compute new centroids */
        int x, y;
        int i, j;
        float minC;
        int indexM;
        int index = 0;
        float tempFloat = 0;
        int yStepOut;

        for (c = 0; c < nClass; c++) {
            denom = 0.0f;
            numer = 0.0f;

            for (y = 0; y < yDim; y++) {
                yStepOut = y * xDim;

                for (x = 0; (x < xDim) && !threadStopped; x++) {
                    index = x + yStepOut;
                    indexM = (c * sliceSize) + index;

                    if (((wholeImage) || (mask.get(index))) && (objMask.get(index))) {

                        if (powEIntFlag == true) {
                            tempFloat = 1;

                            for (int v = 0; v < (int) qValue; v++) {
                                tempFloat *= mems[indexM];
                            }
                        } else {
                            tempFloat = (float) Math.pow(mems[indexM], qValue);
                        }

                        numer += tempFloat * buffer[index];
                        denom += tempFloat;
                    } // if (objMask.get(index)
                } // for (x = 0; x < xDim; x++)
            } // for (y = 0; y < yDim; y++)

            if (denom != 0.0f) {
                centroids[c] = numer / denom;
            } else {
                cleanUp();
                MipavUtil.displayError("FuzzyCMeans: Overflow in ComputeCentroids2D");

                if (progressBar != null) {
                    progressBar.dispose();
                }

                setCompleted(false);

                return;
            }
        } // for (c = 0; c < nClass; c++)

        /* Sort the centroids in ascending order */
        float[] sCentroids = new float[nClass];
        boolean[] unusedCentroids = new boolean[nClass];

        for (i = 0; i < nClass; i++) {
            unusedCentroids[i] = true;
        } // for (i = 0; i < nClass; i++)

        for (i = 0; i < nClass; i++) {
            minC = Float.MAX_VALUE;

            for (j = 0; j < nClass; j++) {

                if ((unusedCentroids[j]) && (centroids[j] < minC)) {
                    minC = centroids[j];
                    index = j;
                } // if ((unusedCentroids[j]) && (centroids[j] < minC))
            } // for (j = 0; j < nClass; j++)

            sCentroids[i] = minC;
            unusedCentroids[index] = false;
        } // for (i = 0; i < nClass; i++)

        for (i = 0; i < nClass; i++) {
            centroids[i] = sCentroids[i];
        }

        sCentroids = null;
    }

    /**
     * Determines the centroids of each cluster given fuzzy membership values.
     *
     * @param  buffer  DOCUMENT ME!
     */
    private void computeCentroids3D(float[] buffer) {
        int c; /* Cluster counter */
        float numer, denom; /* Used to compute new centroids */
        int x, y, z;
        int i, j;
        float minC;
        int cIndex, cIndexTemp = 0;
        int index = 0;
        float tempFloat = 0;
        int zStepOut;

        for (c = 0; (c < nClass) && !threadStopped; c++) {
            denom = 0.0f;
            numer = 0.0f;
            cIndex = c * volSize;

            for (z = 0; (z < zDim) && !threadStopped; z++) {
                zStepOut = z * sliceSize;

                for (y = 0; y < yDim; y++) {
                    index = (y * xDim) + zStepOut;
                    cIndexTemp = cIndex + index;

                    for (x = 0; x < xDim; x++) {

                        if (((wholeImage) || (mask.get(index))) && (objMask.get(index))) {

                            if (powEIntFlag == true) {
                                tempFloat = 1;

                                for (int v = 0; v < (int) qValue; v++) {
                                    tempFloat *= mems[cIndexTemp];
                                }
                            } else {
                                tempFloat = (float) Math.pow(mems[cIndexTemp], qValue);
                            }

                            numer += tempFloat * buffer[index];
                            denom += tempFloat;
                        } // if (objMask.get(index)

                        index++;
                        cIndexTemp++;
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)
            } // for (z = 0; z < zDim; z++)

            if (denom != 0.0f) {
                centroids[c] = numer / denom;
            } else {
                MipavUtil.displayError("FuzzyCMeans: Overflow in ComputeCentroids3D");

                if (progressBar != null) {
                    progressBar.dispose();
                }

                setCompleted(false);

                return;
            }
        } // for (c = 0; c < nClass; c++)

        if (threadStopped) {
            return;
        }

        /* Sort the centroids in ascending order */
        // float   sCentroids[]        = new float[nClass];
        // boolean unusedCentroids[]   = new boolean[nClass];
        for (i = 0; i < nClass; i++) {
            unusedCentroids[i] = true;
        } // for (i = 0; i < nClass; i++)

        for (i = 0; i < nClass; i++) {
            minC = Float.MAX_VALUE;

            for (j = 0; j < nClass; j++) {

                if ((unusedCentroids[j]) && (centroids[j] < minC)) {
                    minC = centroids[j];
                    index = j;
                } // if ((unusedCentroids[j]) && (centroids[j] < minC))
            } // for (j = 0; j < nClass; j++)

            sCentroids[i] = minC;
            unusedCentroids[index] = false;
        } // for (i = 0; i < nClass; i++)

        for (i = 0; i < nClass; i++) {
            centroids[i] = sCentroids[i];
        }
    }

    /**
     * Determines the membership of each feature vector in each cluster.
     *
     * @param  buffer     DOCUMENT ME!
     * @param  centroids  DOCUMENT ME!
     * @param  mems       DOCUMENT ME!
     * @param  exponent   DOCUMENT ME!
     */
    private void computeMemberships2D(float[] buffer, float[] centroids, float[] mems, double exponent) {
        int cIdx; // Cluster counter
        float total; // Used to normalize memberships
        float difference2; // Distance between pixel and centroid squared
        float[] oldMember; // Save old values to get difference
        float dtemp;
        int x, y;
        int index;
        int indexM;
        int yStepper;

        oldMember = new float[nClass];

        maxChange = 0.0f;

        for (y = 0; y < yDim; y++) {
            yStepper = y * xDim;

            if (progressBar != null) {
                progressBar.updateValue((int) (y * (100.0f / yDim)), activeImage);
            }

            for (x = 0; (x < xDim) && !threadStopped; x++) {

                // Iterate over each cluster for the current intensity value
                index = x + yStepper;

                if (((wholeImage) || (mask.get(index))) && (objMask.get(index))) {
                    total = 0.0f;

                    for (cIdx = 0; cIdx < nClass; cIdx++) {
                        indexM = (cIdx * sliceSize) + index;
                        oldMember[cIdx] = mems[indexM];

                        difference2 = (buffer[index] - centroids[cIdx]);
                        difference2 = difference2 * difference2;

                        if (difference2 == 0.0f) {
                            mems[indexM] = (MAX_FLOAT / nClass);
                        } else {

                            if (powEIntFlag == true) {
                                mems[indexM] = 1;

                                for (int v = 0; v < (int) exponent; v++) {
                                    mems[indexM] *= 1.0 / difference2;
                                }
                            } else {
                                mems[indexM] = (float) Math.pow(1.0 / difference2, exponent);
                            }
                        }

                        total += mems[indexM];
                    }

                    if (total == 0.0f) {
                        cleanUp();
                        MipavUtil.displayError("FuzzyCMeans: Overflow in ComputeMemberships");

                        if (progressBar != null) {
                            progressBar.dispose();
                        }

                        setCompleted(false);

                        return;
                    }

                    /* Normalize the distances so they form a pseudodistribution and update maxChange */

                    for (cIdx = 0; cIdx < nClass; cIdx++) {
                        indexM = (cIdx * sliceSize) + index;
                        mems[indexM] /= total;
                        dtemp = Math.abs(oldMember[cIdx] - mems[indexM]);

                        if (maxChange < dtemp) {
                            maxChange = dtemp;
                        }
                    } // for (c = 0; c < nClass; c++)
                } // if ((wholeImage) || (mask.get(index)))
            } // for (x = 0; x < xDim; x++)
        } // for (y = 0; y < yDim; y++)

        if (threadStopped) {
            return;
        }

        oldMember = null;
    }

    /**
     * Determines the membership of each feature vector in each cluster.
     *
     * @param  buffer  DOCUMENT ME!
     */
    private void computeMemberships3D(float[] buffer) {
        int c; /* cluster counter */
        float total; /* Used to normalize memberships */
        float difference2; /* Distance between pixel and centroid squared */
        float dtemp;
        int x, y, z;
        int index;
        int indexM;
        int zStepOut;

        float constantMax = MAX_FLOAT / nClass;

        maxChange = 0.0f;

        for (z = 0; (z < zDim) && !threadStopped; z++) {
            zStepOut = z * sliceSize;

            if (progressBar != null) {
                progressBar.updateValue((int) (z * (100.0f / zDim)), activeImage);
            }

            for (y = 0; (y < yDim) && !threadStopped; y++) {
                index = (y * xDim) + zStepOut;

                for (x = 0; x < xDim; x++) {

                    /* Iterate over each cluster for the current intensity value */
                    if (((wholeImage) || (mask.get(index))) && (objMask.get(index))) {
                        total = 0.0f;
                        indexM = index;

                        for (c = 0; c < nClass; c++) {
                            oldMember[c] = mems[indexM];

                            difference2 = (buffer[index] - centroids[c]);
                            difference2 = difference2 * difference2;

                            if (difference2 == 0.0f) {
                                mems[indexM] = constantMax;
                            } else if ((powEIntFlag == true) && (exponent <= 3)) {
                                difference2 = 1.0f / difference2;
                                mems[indexM] = 1.0f;

                                for (int v = 0; v < (int) exponent; v++) {
                                    mems[indexM] *= difference2;
                                }
                            } else {
                                mems[indexM] = (float) Math.pow(1.0 / (double) difference2, (double) exponent);
                            }

                            total += mems[indexM];
                            indexM += volSize;
                        } // for (c = 0; c < nClass; c++)

                        if (total == 0.0f) {
                            MipavUtil.displayError("FuzzyCMeans: Overflow in ComputeMemberships");

                            if (progressBar != null) {
                                progressBar.dispose();
                            }

                            setCompleted(false);

                            return;
                        } // if (total == 0.0f)

                        /* Normalize the distances so they form a pseudodistribution and update maxChange */
                        indexM = index;

                        float invTotal = 1.0f / total;

                        for (c = 0; c < nClass; c++) {
                            mems[indexM] *= invTotal;
                            dtemp = oldMember[c] - mems[indexM];

                            if (dtemp < 0) {
                                dtemp = -dtemp;
                            }

                            if (maxChange < dtemp) {
                                maxChange = dtemp;
                            }

                            indexM += volSize;
                        } // for (c = 0; c < nClass; c++)
                    } // if ((wholeImage) || (mask.get(index)))

                    index++;
                } // for (x = 0; x < xDim; x++)
            } // for (y = 0; y < yDim; y++)
        } // for (z = 0; z < zDim; z++)

        // oldMember = null;
        if (threadStopped) {
            return;
        }
    }

    /**
     * Constructs a string of the contruction parameters and out puts the string to the messsage frame if the logging
     * procedure is turned on.
     */
    private void constructLog() {
        historyString = new String("Fuzzy C-means(" + String.valueOf(nClass) + ", " + String.valueOf(pyramidLevels) +
                                   ", " + String.valueOf(jacobiIters1) + ", " + String.valueOf(jacobiIters2) + ", " +
                                   String.valueOf(qValue) + ", " + String.valueOf(exponent) + ", " +
                                   String.valueOf(smooth1) + ", " + String.valueOf(smooth2) + ", " +
                                   String.valueOf(outputGainField) + ", " + String.valueOf(segmentation) + ", " +
                                   String.valueOf(cropBackground) + ", " + String.valueOf(threshold) + ", " +
                                   String.valueOf(maxIter) + ", " + String.valueOf(tolerance) + ", " +
                                   String.valueOf(wholeImage) + ")" + "\n");
    }

    /******************* Next functions are used in the Adaptive Fuzzy C Means that we do NOT yet support  ***********/

    /**
     *
     * @param buffer  @param centroids  @param mems  @param mult  @param smooth1  @param smooth2  @param qValue
     *
     */

    /* private void ComputeMultiplier2D(float[] buffer, float[] centroids, float[] mems, float[] mult,
     * float smooth1, float smooth2, float qValue) { // Only use scalar multiplier field here float[] f; float[] w; int
     * x,y; int i; int index;
     *
     * f = new float[sliceSize]; w = new float[sliceSize];
     *
     * for (x = 0; x < xDim; x++) { for (y = 0; y < yDim; y++) { ComputeFW2(f,w,buffer,centroids,mems,x,y,qValue); } //
     * for (y = 0; y < yDim; y++) } // for (x = 0; x < xDim; x++)
     * fmvtrunc2(mult,f,w,smooth1,smooth2,jacobiIters1,jacobiIters2,truncLevel);
     *
     * // Compute max and minimum of multiplier field maxMult = 0.0f; minMult = 1e6f; for (i = 0; i < sliceSize; i++) { if
     * (mult[i] > maxMult) maxMult = mult[i]; if (mult[i] < minMult) minMult = mult[i]; }
     *
     * f = null; w = null; }
     */

    /**
     *
     * @param f  @param w  @param buffer  @param centroids  @param mems  @param x  @param y  @param qValue
     */

    /* private void ComputeFW2(float[] f, float[] w, float[] buffer, float[]centroids, float[] mems,
     * int x, int y, float qValue) { int c; float temp1,temp2; int index; int fg; int indexM;
     *
     * index = x + y*xDim; f[index] = 0.0f; w[index] = 0.0f; for (c = 0; c < nClass; c++) { indexM = c*sliceSize + index;
     * // Compute dot products: cTC and yTc temp1 = centroids[c] * centroids[c]; temp2 = buffer[index] * centroids[c];
     * w[index] += (float)Math.pow((double)mems[indexM],(double)qValue) * temp1; f[index] +=
     * (float)Math.pow((double)mems[indexM],(double)qValue) * temp2; } // for (c = 0; c < nClass; c++) if (buffer[index]
     * < threshold) { w[index] = 0.0f; } // if (buffer[index] < threshold) }
     */

    /**
     *   This function performs a truncated FMV cycle.  It stops performing  V-cycles at the pyramid level given by
     * 'truncLevel'.  @param mult  @param f  @param w  @param smooth1  @param smooth2  @param jacobiIters1  @param
     * jacobiIters2  @param truncLevel
     */

    /* private void fmvtrunc2(float[] mult, float[] f, float[] w, float smooth1, float smooth2,
     * int jacobiIters1, int jacobiIters2, int truncLevel) { float[] fpyr,wpyr; int i; float[] temp; float[] u2; int
     * u2x,u2y; int x,y; int u2Length; float[] fp; int index;
     *
     * // Allocate pyramids fpyr = new float[pyramidLevels * sliceSize]; wpyr = new float[pyramidLevels * sliceSize]; //
     * Keep track of the sizes of each level sizesX = new int[pyramidLevels]; sizesY = new int[pyramidLevels]; for (i =
     * 0; i < sliceSize; i++) { fpyr[i] = f[i]; wpyr[i] = w[i]; } // for (i = 0; i < sliceSize; i++) sizesX[0] = xDim;
     * sizesY[0] = yDim; temp = new float[sliceSize]; for (i = 0; i < sliceSize; i++) { temp[i] = mult[i]; } // for (i =
     * 0; i < sliceSize; i++)
     *
     * u2 = new float[(xDim/2 + xDim%2) * (yDim/2 + yDim%2)]; u2x = xDim/2 + xDim%2; u2y = yDim/2 + yDim%2; for (i = 1; i
     * < pyramidLevels; i++) { u2 = reduce2d(temp,sizesX,sizesY,i-1); u2x = sizesX[i]; u2y = sizesY[i]; u2Length = u2x *
     * u2y; temp = null; temp = new float[u2Length]; for (j = 0; j < u2Length; j++) { temp[j] = u2[j]; }
     * reduce2db(fpyr,sizesX,sizesY,i-1); reduce2db(wpyr,sizesX,sizesY,i-1); } // for (i = 1; i < pyramidLevels; i++) fp
     * = new float[sliceSize]; index = (pyramidLevels - 1) * sliceSize; for (i = 0; i < sliceSize; i++) { fp[i] =
     * fpyr[index + i]; } vcycle2(u2,u2x,u2y,fp,wpyr,smooth1,smooth2,pyramidLevels-1,jacobiIters1,jacobiIters2); for (i
     * = pyramidLevels-2; i>=0; i--) { temp = expand2d(u2,u2x,sizesX,sizesY,i); u2x = sizesX[i]; u2y = sizesY[i];
     * u2Length = u2x * u2y; u2 = null; u2 = new float[u2Length]; for (j = 0; j < u2Length; j++) { u2[j] = temp[j]; } if
     * (i >= truncLevel) { // Stop doing V-cycles if necessary index = sliceSize*i; for (j = 0; j < sliceSize; j++) {
     * fp[j] = fpyr[index + j]; } vcycle2(u2,u2x,u2y,fp,wpyr,smooth1,smooth2,i,jacobiIters1,jacobiIters2); } } // for (i
     * = pyramidLevels-2; i>=0; i--)
     *
     * for (i = 0; i < sliceSize; i++) { mult[i] = u2[i]; }
     *
     * u2 = null; fpyr = null; wpyr = null; sizesX = null; sizesY = null;
     *
     * }
     */

    /**
     *
     * @param u  @param ux  @param uy  @param f  @param wpyr  @param smooth1  @param smooth2  @param level  @param
     * jacobiIters1  @param jacobiIters2
     *
     */

    /* private void vcycle2(float[] u, int ux, int uy, float[] f, float[] wpyr,
     * float smooth1, float smooth2, int level, int jacobiIters1, int jacobiIters2) { float h; float mask[]; float
     * smooth1b,smooth2b; float r[]; float temp[]; float dummy; int x,y; int sizesXU[]; int sizesYU[]; float r2[]; int
     * u2x,u2y; float u2[]; float v[]; int uLength,u2Length; int index;
     *
     * // Initialize h = (float)Math.pow(2.0,(double)level); smooth1b = smooth1/(h*h); smooth2b = smooth2/(h*h); mask =
     * new float[25]; setMask52(mask,smooth1b,smooth2b);
     *
     * jacobi2(u,ux,uy,f,wpyr,level,smooth1b,smooth2b,jacobiIters1); uLength = ux * uy; if (level != (pyramidLevels-1)) {
     * // Compute residual r = f - wpyr*u - smooth*Laplace(u) r = new float[uLength]; temp = conv2d5(u,ux,uy,mask);
     * dummy = 0.0f; for (i = 0; i < uLength; i++) { index = level*sliceSize + i; r[i] = f[i] - wpyr[index] * u[i]
     * -temp[i]; }
     *
     * sizesXU = new int[2]; sizesYU = new int[2]; sizesXU[0] = ux; sizesYU[0] = uy; r2 = reduce2d(r,sizesXU,sizesYU,0);
     * temp = null; r = null; u2x = sizesXU[1]; u2y = sizesYU[1]; u2Length = u2x*u2y; u2 = new float[u2Length]; for (i =
     * 0; i < u2Length; i++) { u2[i] = 0.0f; }
     *
     * // Recursive call vcycle2(u2,u2x,u2y,r2,wpyr,smooth1,smooth2,level+1,jacobiIters1,jacobiIters2); v =
     * expand2d(u2,u2x,sizesX,sizesY,level);
     *
     * for (i = 0; i < uLength; i++) { u[i] += v[i]; } u2 = null; r2 = null; v = null; } // if (level !=
     * (pyramidLevels-1)) jacobi2(u,ux,uy,f,wpyr,level,smooth1,smooth2,jacobiIters2); }
     */

    /**
     *   Expand 2D area for ...  @param in  @param inx  @param sizesX  @param sizesY  @param level  @return
     */

    /* private float[] expand2d(float[] in, int inx, int sizesX[], int sizesY[], int level) {
     * int outx,outy; float out[]; int x,y,l,m;
     *
     * outx = sizesX[level]; outy = sizesY[level]; out = new float[outx * outy]; for (x = 0; x < outx; x++) { l =
     * (int)((double)x/2.0); for (y = 0; y < outy; y++) { m = (int)((double)y/2.0); out[x + y*outx] = in[l + m*inx]; } }
     * return(out); }
     */

    /* Jacobi iterations */

    /**
     *   @param u  @param ux  @param uy  @param f  @param wpyr  @param level  @param smooth1  @param smooth2  @param
     * iter
     */

    /* private void jacobi2(float[] u, int ux, int uy, float[] f, float[] wpyr,
     * int level, float smooth1, float smooth2, int iter) { float alpha; float[] mask; int x,y; float[] temp; float
     * Dinv; int i; int uLength;
     *
     * alpha = ALPHA;
     *
     * // Set up the mask mask = new float[25];                                   // Make out permanent to speed up.
     * setMask52(mask, smooth1, smooth2); for (i = 0; i < 25; i++) { mask[i] *= -1.0f; } mask[12] = 0.0f;
     *
     * temp = conv2d5(u,ux,uy,mask);
     *
     * uLength = ux*uy; for (i = 0; i < uLength; i++) { Dinv = 1.0f/(wpyr[level*sliceSize + i] + 6.0f*smooth1 +
     * 42.0f*smooth2); u[i] = (1.0f - alpha) *u[i] + alpha * Dinv * temp[i] + alpha * Dinv * f[i]; } temp = null; }
     */

    /**
     *   Convolves a 2D dataset with a 5 x 5 mask  @param in  @param inx  @param iny  @param mask  @return
     */

    /* private float[] conv2d5(float[] in, int inx, int iny, float[] mask) {
     * float[] out; int x,y; int l,m; int lind,mind; int outLength; int i; int offset;
     *
     * outLength = inx*iny; out = new float[outLength];               // Make out permanent to speed up. for (i = 0; i <
     * outLength; i++) { out[i] = 0.0f; }
     *
     * for (x = 0; x < inx; x++) { for (y = 0; y < iny; y++) { // Now apply mask offset = x +y*inx; for (l = -2; l <=2;
     * l++) { if ((x+l) < 0) lind = 0; else if ((x+l) > (inx-1)) lind = inx-1; else lind = (x+l); for (m = -2; m <= 2;
     * m++) { if ((y+m) < 0) mind = 0; else if ((y+m) > (iny-1)) mind = iny-1; else mind = (y+m); out[offset] +=
     * mask[l+2 + 5*(m+2)]*in[lind + mind*inx]; } } } }
     *
     * return(out); }
     */

    /**
     *
     * @param mask  @param smooth1  @param smooth2
     */

    /* private void setMask52(float[] mask, float smooth1, float smooth2) {
     * int i; float mask1[]; float mask2[];
     *
     * mask1 = new float[25]; mask2 = new float[25];
     *
     *
     * for (i = 0; i < 25; i++) { mask1[i] = 0.0f; mask2[i] = 0.0f; }
     *
     * mask1[12] = 4.0f; mask1[7] = mask1[11] = mask1[17] = mask1[13] = -1.0f;
     *
     * mask2[2]  =  1.0f; mask2[6]  =  2.0f; mask2[7]  = -8.0f; mask2[8]  =  2.0f; mask2[10] =  1.0f; mask2[11] = -8.0f;
     * mask2[12] =  20.0f; mask2[13] = -8.0f; mask2[14] =  1.0f; mask2[16] =  2.0f; mask2[17] = -8.0f; mask2[18] =
     * 2.0f; mask2[22] =  1.0f;
     *
     * for (i = 0; i < 25; i++) { mask[i] = smooth1*mask1[i] + smooth2*mask2[i]; } }
     */

    /**
     *
     * @param in  @param sizesX  @param sizesY  @param iLevel  @return
     */

    /* private float[] reduce2d(float[] in, int[] sizesX, int[] sizesY, int iLevel) {
     * float[] out; int xNew,yNew; int x,y; int x2,x2p,y2,y2p;
     *
     * xNew = sizesX[iLevel]/2 + sizesX[iLevel]%2; yNew = sizesY[iLevel]/2 + sizesY[iLevel]%2; out = new float[xNew *
     * yNew]; sizesX[iLevel+1] = xNew; sizesY[iLevel+1] = yNew; for (x = 0; x < xNew; x++) { x2 = 2*x; x2p = x2+1; if
     * (x2p > (sizesX[iLevel]-1)) { x2p = sizesX[iLevel] - 1; } for (y = 0; y < yNew; y++) { y2 = 2*y; y2p = y2+1; if
     * (y2p > (sizesY[iLevel]-1)) { y2p = sizesY[iLevel] - 1; } out[x + y*xNew] = (in[x2 +  y2*sizesX[iLevel]] + in[x2p
     * +  y2*sizesX[iLevel]] + in[x2 + y2p*sizesX[iLevel]] + in[x2p + y2p*sizesX[iLevel]])/4; } // for (y = 0; y < yNew;
     * y++) } // for (x = 0; x < xNew; x++)
     *
     * return(out); }*/

    /**
     *
     * @param in  @param sizesX  @param sizesY  @param iLevel
     */

    /* private void reduce2db(float[] in, int[] sizesX, int[] sizesY, int iLevel) {
     * int xNew,yNew; int x,y; int x2,x2p,y2,y2p; int i; int i1,i2,i3,i4; int tmp; int tmp1; int tmp2;
     *
     * xNew = sizesX[iLevel+1]; yNew = sizesY[iLevel+1];
     *
     * for (x = 0; x < xNew; x++) { x2 = 2*x; x2p = x2+1; if (x2p > (sizesX[iLevel]-1)) { x2p = sizesX[iLevel] - 1; } for
     * (y = 0; y < yNew; y++) { y2 = 2*y; y2p = y2+1; if (y2p > (sizesY[iLevel]-1)) { y2p = sizesY[iLevel] - 1; }
     *
     * tmp  = iLevel*sliceSize; tmp1 = y2*sizesX[iLevel]; tmp2 = y2p*sizesX[iLevel];
     *
     * i = (iLevel+1)*sliceSize + x + y*xNew; i1 = tmp + x2  + tmp1; i2 = tmp + x2p + tmp1; i3 = tmp + x2  + tmp2; i4 =
     * tmp + x2p + tmp2; in[i] = (in[i1] + in[i2] + in[i3] + in[i4])/4; } // for (y = 0; y < yNew; y++) } // for (x = 0;
     * x < xNew; x++) }
     */

    /**
     *
     * @param pos  @param cnetroid  @return
     */

    /* private float distance1d(float pos, float centroid) {
     * float temp; float result;
     *
     * temp = pos - centroid; result = temp * temp; return result; }
     */
}
