package gov.nih.mipav.model.algorithms;

import WildMagic.LibFoundation.Mathematics.Vector2f;
import WildMagic.LibFoundation.Mathematics.Vector3f;

import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.view.*;

import java.awt.*;
import java.io.*;
import java.util.*;


/**
 * Snake-like algorithm derivative using BSplines. The algorithm is supplied a polygon (VOI - contour) and that polygon
 * is allowed to evolve to edge of the object generated by calculating the the gradient vector field. The
 * user/programmer supplies the sigmas (scales) at which to calculate the edge map f = |grad(Gsigma(x,y)*I(x,y))|
 *
 * <p>2 iterative processes are used. The first calculates the gradient vector field. The gradient of the edge map is
 * used to initialize the iterative equation for the gradient vector field. In the second iterative process which
 * calculates the boundary, the point is moved by the gradient vector field</p>
 *
 * <p>This original GVF algorithm has:<br>
 * u[i] += mu*del2(u[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(u[i] - fx[i]);<br>
 * v[i] += mu*del2(v[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(v[i] - fy[i]);<br>
 * This program uses the generalized GVF algorithm with:<br>
 * du/dt = g(|grad f|)del2xy(u) - h(|grad f|)*(u - fx) dv/dt = g(|grad f|)del2xy(v) - h(|grad f|)*(v - fy) g[i] =
 * Math.exp(-(fx[i]*fx[i] + fy[i]*fy[i])/(k*k))<br>
 * h[i] = 1 - g[i] du/dt = u(i,j,n+1) - u(i,j,n)/(delta t) del2xy(u) = (1/((delta x)(delta y)))* (u(i+1,j,n) +
 * u(i,j+1,n) + u(i-1,j,n) + u(i,j-1,n) - 4u(i,j,n) = del2(u)/((delta x)*(delta y)) u(i,j,n+1) = u(i,j,n) + g(|grad
 * f|)*(delta t)/((delta x)*(delta y)) * del2(u) - (1 - g(|grad f|)*(u - fx)*delta t Letting detla x = 1, delta y = 1,
 * and delta t = 0.25: u[i] += 0.25f*(g[i]*del2(u[i]) - (1 - g[i])*(u[i] - fx[i]));<br>
 * v[i] += 0.25f*(g[i]*del2(v[i]) - (1 - g[i])*(v[i] - fy[i]));<br>
 * Stability for the original GVF algorithm requires mu <= 0.25f and stability for the generalized GVF algorithm
 * requires that delta t <= (delta x * delta y)/(4 * gmax) = 1/4. For 3D: delta t <= (delta x * delta y * delta z)/(6*
 * gmax) = 1/6.</p>
 *
 * <p>A large scale slows the snake and causes the snake to conform to large scale structure. A small sigma value causes
 * the snake to conform to the small scale structure is therefore more sensitive to noise. The three-dimensional version
 * is really a two-and-half dimensional algorithm where resultant contour in a slice is projected into the adjacent
 * slice and is used as an initialization to the evolution in the new slice.</p>
 *
 * <p>Useful references on gradient vector field:<br>
 * 1.) "Gradient Vector Flow: A New External Force For Snakes", Chenyang Xu and Jerry L. Prince, IEEE Proc. Conf. on
 * Comp. Vis. Patt. Recog. (CVPR'97), pp. 66- 71.<br>
 * 2.) "Snakes, Shapes, and Gradient Vector Flow", Chenyang Xu and Jerry L. Prince, IEEE Transactions on Image
 * Processing, March, 1998, pp. 359-369.<br>
 * 3.) "Generalized gradient vector flow external forces for active contours", Chenyang Xu and Jerry Prince, Signal
 * Processing, 71(2), December, 1998, pp. 131-139.<br>
 * 4.) "Gradient Vector Flow Deformable Models", Handbook of Medical Imaging, ChenYang Xu and Jerry Prince, edited by I.
 * Bankman, Academic Press, 2000, pp. 159-169.<br>
 * 5.) "Image Segmentation Using Deformable Models", Handbook of Medical Imaging -- Volume 2: Medical Imaging and
 * Analysis, Chenyang Xu, Dzung Pham, and Jerry Prince, edited by J.M. Fitzpatrick and M. Sonka, SPIE Press, May, 2000,
 * pp. 129-174.<br>
 * More information on gradient vector field can be found at Chenyang Xu's homepage at http://iacl.ece.jhu.edu/~chenyang
 * </p>
 *
 * @see  GenerateGaussian
 */

public class AlgorithmGVF extends AlgorithmBase implements AlgorithmInterface {

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** Maximum iterations to generate new boundary. */
    private int boundaryIterations = 300;

    /** Only applies to 3D, if true do slice by slice. */
    private boolean do25D = true;

    /** DOCUMENT ME! */
    private float[] expGvfBuffer;

    /** DOCUMENT ME! */
    private int[] extents;

    /** DOCUMENT ME! */
    private float[] fx;

    /** DOCUMENT ME! */
    private float[] fy;

    /** DOCUMENT ME! */
    private float[] fz;

    /** DOCUMENT ME! */
    private float[] gVal;

    /** DOCUMENT ME! */
    private float[] gvfBuffer;

    /** Maximum iterations to generate generalized gradient vector field. */
    private int gvfIterations = 200;

    /** Storage location of the first derivative of the Gaussian in the X direction. */
    private float[] GxData;

    /** Storage location of the first derivative of the Gaussian in the Y direction. */
    private float[] GyData;

    /** Storage location of the first derivative of the Gaussian in the Z direction. */
    private float[] GzData;

    /** Dimensionality of the kernel. */
    private int[] kExtents;

    /**
     * In the paper "Generalized gradient vector flow external forces for active contours" by Chenyang Xu and Jerry
     * Prince values of 0.05, 0.15, and 0.2 were used for k.
     */
    private float kValue = 0.15f;

    /** DOCUMENT ME! */
    private int length;

    /** If true propagate the contour to an adjacent slice. */
    private boolean propagationFlag = true;

    /** The resultant polygon and the evolution has completed. */
    private VOI resultVOI;

    /** Standard deviations of the gaussian used to calculate the kernels. */
    private float[] sigmas;

    /** The initial VOI to initialize the evolution process. */
    private VOI srcVOI;

    /** Starting slice to evolve contour. */
    private int stSlice;

    /** DOCUMENT ME! */
    private float[] uVal;

    /** DOCUMENT ME! */
    private float[] vVal;

    /** DOCUMENT ME! */
    private float[] wVal;

    /** DOCUMENT ME! */
    private int xDim, yDim, zDim;
    
    //  Storage for result of AlgorithmConvolver
    private float[] outputBuffer = null;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Creates a new AlgorithmGVF object.
     *
     * @param  destImage           image of GVF field magnitude
     * @param  srcImg              2D or 3D source image
     * @param  sigmas              describe the scale of the gaussian in each dimension
     * @param  gvfIterations       iterations in calculating GVF field
     * @param  boundaryIterations  iterations in calculating boundary
     * @param  k                   GVF constant
     * @param  srcVOI              VOI that is to be evolved
     * @param  do25D               only applies to 3D, if true do slice by slice
     */
    public AlgorithmGVF(ModelImage destImage, ModelImage srcImg, float[] sigmas, int gvfIterations,
                        int boundaryIterations, float k, VOI srcVOI, boolean do25D) {
        super(destImage, srcImg);
        this.srcVOI = srcVOI;
        this.sigmas = sigmas;
        this.gvfIterations = gvfIterations;
        this.boundaryIterations = boundaryIterations;
        this.kValue = k;
        this.do25D = do25D;

        if (srcImg.getNDims() == 2) {
            makeKernels2D();
            resultVOI = new VOI((short) srcImage.getVOIs().size(), "GVF_VOI", VOI.CONTOUR, -1.0f);
        } else if (srcImg.getNDims() > 2) {

            if (do25D) {
                makeKernels2D();
                resultVOI = new VOI((short) srcImage.getVOIs().size(), "GVF_VOI", VOI.CONTOUR,
                                    -1.0f);
            } else {
                makeKernels3D();
                resultVOI = new VOI((short) srcImage.getVOIs().size(), "GVF_VOI", VOI.CONTOUR,
                                    -1.0f);
            }

        } // else if (srcImage.getNDims() > 2)
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Prepares this class for destruction.
     */
    public void finalize() {
        uVal = null;
        vVal = null;
        wVal = null;

        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        srcImage = null;
        destImage = null;
        sigmas = null;
        extents = null;
        super.finalize();
    }

    /**
     * Accessor that returns the resultant VOI.
     *
     * @return  resultant VOI that has localized to the boundaries of the object
     */
    public VOI getResultVOI() {
        return resultVOI;
    }

    /**
     * Starts the snake algorithm.
     */
    public void runAlgorithm() {
        AlgorithmConvolver convolver;
        
        if (srcImage == null) {
            displayError("Source Image is null");

            return;
        } else {
            fireProgressStateChanged(srcImage.getImageName(), "GVF: Evolving boundary ...");
            if (((srcImage.getNDims() == 2) || do25D) && ((sigmas[0] != 0.0) || (sigmas[1] != 0.0))) {
                if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0)) {
                    boolean entireImage = true;
                    boolean sqrtXY = true;
                    convolver = new AlgorithmConvolver(srcImage, GxData, GyData, kExtents, entireImage, sqrtXY);
                }
                else if (sigmas[0] != 0.0) {
                    convolver = new AlgorithmConvolver(srcImage, GxData, kExtents, true, true);
                }
                else { // sigmas[1] != 0.0
                    convolver = new AlgorithmConvolver(srcImage, GyData, kExtents, true, true);
                }
                convolver.setMinProgressValue(0);
                convolver.setMaxProgressValue(10);
                linkProgressToAlgorithm(convolver);
                convolver.addListener(this);
                convolver.run();
                convolver.finalize();    
            } // if (((srcImage.getNDims() == 2) || do25D) && ((sigmas[0] != 0.0) || (sigmas[1] != 0.0)))
            else if ((srcImage.getNDims() == 3) && (sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0)) {
                convolver = new AlgorithmConvolver(srcImage, GxData, GyData, GzData, kExtents, true); 
                convolver.setMinProgressValue(0);
                convolver.setMaxProgressValue(10);
                linkProgressToAlgorithm(convolver);
                convolver.addListener(this);
                convolver.run();
                convolver.finalize();    
            } // else if ((srcImage.getNDims() == 3) && (sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0))

            if (srcImage.getNDims() == 2) {
                calc2D();
            } else if (srcImage.getNDims() > 2) {

                if (do25D) {
                    calc25D();
                } else {
                    calc3D();
                }
            }
        }
    }

    /**
     * Sets the propagation flag.
     *
     * @param  flag  if true result contour from a slice is propagated to the adjacent slice and used to initialize the
     *               snake algorithm for that slice. If false the snake algorithm stops after optimizing the boundary in
     *               the present slice.
     */
    public void setPropagation(boolean flag) {
        propagationFlag = flag;
    }

    /**
     * Performs bilinear interpolation of image data.
     *
     * @param   i         index into image
     * @param   dx        change in x from integer
     * @param   dy        change in y from integer
     * @param   iExtents  dimensions of image
     * @param   image     image data
     *
     * @return  DOCUMENT ME!
     */
    private static float getBilinear(int i, float dx, float dy, int[] iExtents, float[] image) {

        int xDim = iExtents[0];
        float x1, x2;
        int ix, iy;

        // The below code prevents an out of bounds index being used for image
        // when the y coordinate is exactly equal to ydim - 1.
        if (dx == 0.0f) {
            ix = i;
        } else {
            ix = i + 1;
        }

        if (dy == 0.0f) {
            iy = 0;
        } else {
            iy = xDim;
        }

        x1 = ((1 - dx) * image[i]) + (dx * image[ix]);
        x2 = ((1 - dx) * image[i + iy]) + (dx * image[ix + iy]);

        return (float) (((1 - dy) * x1) + (dy * x2));
    }

    /**
     * Prepares the data and runs the algorithm for a 3D image on a slice by slice basis.
     */
    private void calc25D() {

        float[] imgBuffer;
        int slice;
        int nPts;
        float[] xB, yB, zB;
        int i;
        int sliceNum;
        int slicesDone = 0;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        sliceNum = srcImage.getExtents()[2];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;

        try {
            xB = new float[2];
            yB = new float[2];
            zB = new float[2];
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2)];

        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm GVF: Out of memory");
            setCompleted(false);

            return;
        }

        Vector<VOIBase> contours = srcVOI.getCurves();
        fireProgressStateChanged(30);

        srcVOI.getBounds(xB, yB, zB);
        VOIContour resultContour = null;
        for (slice = (int) zB[0]; slice <= (float) zB[1]; slice++) {
            fireProgressStateChanged(30 + (70 *  slice) / (sliceNum - 1));

            try {
                srcImage.exportData(slice * length, length, imgBuffer);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmGVF: IOException on srcImage");

                setCompleted(false);

                return;
            }

            calcGVF(slice, imgBuffer);

            if (destFlag == true) {

                for (i = 0; i < length; i++) {
                    gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                }

                try {
                    destImage.importData(slice * length, gvfBuffer, false);
                } catch (IOException error) {
                    cleanup();
                    MipavUtil.displayError("AlgorithmGVF: IOException on destImage" +
                                           ".importData(slice*length,gvfBuffer,false)");

                    setCompleted(false);

                    return;
                }
            }

            int nContours = contours.size();

            for (int j = 0; j < nContours; j++) {

                if (((VOIContour) (contours.elementAt(j))).isActive()) {
                    int nPoints = contours.elementAt(j).size();
                    float[] xPoints = new float[nPoints + 5];
                    float[] yPoints = new float[nPoints + 5];
                    float[] zPoints = new float[nPoints + 5];
                    setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));
                    resultContour = new VOIContour( false, true );
                    runSnake(xPoints, yPoints, zPoints, uVal, vVal, resultContour);
                    resultContour.trimPoints(Preferences.getTrim(),
                            Preferences.getTrimAdjacient());
                    if ( resultContour.size() > 0 )
                    {
                        resultContour.update();
                        resultVOI.importCurve(resultContour);
                    }
                    stSlice = slice;
                } else {
                    resultVOI.importCurve(contours.elementAt(j));
                }
            }
        }

        if (threadStopped) {
            finalize();

            return;
        }

        if (propagationFlag == false || resultContour == null) {
            cleanup();
            fireProgressStateChanged(100);

            setCompleted(true);

            return;
        }

        slice = stSlice;
        VOIContour tempContour = new VOIContour(resultContour, 1);
        slice++;
        if (slice < sliceNum) {

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, imgBuffer);
                } catch (IOException error) {
                    cleanup();
                    displayError("Algorithm GVF: Image(s) locked");
                    setCompleted(false);


                    return;
                }

                uVal = new float[(xDim + 2) * (yDim + 2)];
                vVal = new float[(xDim + 2) * (yDim + 2)];
                calcGVF(slice, imgBuffer);

                if (destFlag == true) {

                    for (i = 0; i < length; i++) {
                        gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                    }

                    try {
                        destImage.importData(slice * length, gvfBuffer, false);
                    } catch (IOException error) {
                        cleanup();
                        MipavUtil.displayError("AlgorithmGVF: IOException on destImage" +
                                               ".importData(slice*length,gvfBuffer,false)");

                        setCompleted(false);

                        return;
                    }
                }
                int nPoints = tempContour.size();
                float[] xPoints = new float[nPoints + 5];
                float[] yPoints = new float[nPoints + 5];
                float[] zPoints = new float[nPoints + 5];
                setPoints(xPoints, yPoints, zPoints, tempContour);
                tempContour.clear();
                // this is where I need to add simplex optimization algo stuff
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, tempContour);
                slicesDone++;
                fireProgressStateChanged(slicesDone * 100 / sliceNum);
                nPts = tempContour.size();
                Preferences.debug(" Points = " + nPts, Preferences.DEBUG_ALGORITHM);

                if (nPts < 8) {
                    break;
                } else {
                    tempContour.trimPoints(Preferences.getTrim(), Preferences.getTrimAdjacient());
                    resultVOI.importCurve(tempContour);
                }
                slice++;
                if (slice >= srcImage.getExtents()[2]) {
                    break;
                }
                tempContour = new VOIContour( tempContour, 1);
                
            } // while(!threadStopped)
        } // if (slice < sliceNum)

        if (threadStopped) {
            finalize();

            return;
        }

        slice = stSlice - 1;
        tempContour = new VOIContour(resultContour, -1);
        slicesDone = sliceNum - stSlice;
        fireProgressStateChanged(slicesDone * 100 / sliceNum);
        Preferences.debug("Going down", Preferences.DEBUG_ALGORITHM);

        if (slice >= 0) {

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, imgBuffer);
                } catch (IOException error) {
                    cleanup();
                    displayError("Algorithm GVF: Image(s) locked");
                    setCompleted(false);


                    return;
                }

                uVal = new float[(xDim + 2) * (yDim + 2)];
                vVal = new float[(xDim + 2) * (yDim + 2)];
                calcGVF(slice, imgBuffer);

                if (destFlag == true) {

                    for (i = 0; i < length; i++) {
                        gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                    }

                    try {
                        destImage.importData(slice * length, gvfBuffer, false);
                    } catch (IOException error) {
                        cleanup();
                        MipavUtil.displayError("AlgorithmGVF: IOException on destImage" +
                                               ".importData(slice*length,gvfBuffer,false)");

                        setCompleted(false);

                        return;
                    }
                }
                int nPoints = tempContour.size();
                float[] xPoints = new float[nPoints + 5];
                float[] yPoints = new float[nPoints + 5];
                float[] zPoints = new float[nPoints + 5];
                setPoints(xPoints, yPoints, zPoints, tempContour);
                tempContour.clear();
                // this is where I need to add simplex optimization algo stuff
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, tempContour);
                slicesDone++;
                fireProgressStateChanged(slicesDone * 100 / sliceNum);
                nPts = tempContour.size();

                if (nPts < 8) {
                    break;
                } else {
                    tempContour.trimPoints(Preferences.getTrim(), Preferences.getTrimAdjacient());
                    resultVOI.importCurve(tempContour);
                }
                slice--;
                if (slice < 0) {
                    break;
                }

                tempContour = new VOIContour( tempContour, -1 );
            } // while (!threadStopped)
        } // if (slice >= 0)

        if (threadStopped) {
            finalize();

            return;
        }

        if (destFlag == true) {
            destImage.calcMinMax();
        }

        cleanup();
        fireProgressStateChanged(100);

        setCompleted(true);
    }

    /**
     * Prepares the data and runs the algorithm for a 2D image.
     */
    private void calc2D() {

        float[] imgBuffer;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;

        try {
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2)];
            srcImage.exportData(0, length, imgBuffer); // locks and releases lock

        } catch (IOException error) {
            cleanup();

            displayError("Algorithm GVF: Image(s) locked");
            setCompleted(false);

            return;
        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm GVF:  Out of Memory");
            setCompleted(false);

            return;
        }

        fireProgressStateChanged(25);

        calcGVF(0, imgBuffer);
        expGvfBuffer = null;
        fx = null;
        fy = null;
        gVal = null;
        System.gc();

        if (destFlag == true) {

            for (int i = 0; i < length; i++) {
                gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
            }

            try {
                destImage.importData(0, gvfBuffer, true);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)");

                setCompleted(false);

                return;
            }
        }

        gvfBuffer = null;
        System.gc();

        Vector<VOIBase> contours = srcVOI.getCurves();
        int nContours = contours.size();
        fireProgressStateChanged(30);

        for (int j = 0; j < nContours; j++) {

            if (((VOIContour) (contours.elementAt(j))).isActive()) {
                int nPoints = contours.elementAt(j).size();
                float[] xPoints = new float[nPoints + 5];
                float[] yPoints = new float[nPoints + 5];
                float[] zPoints = new float[nPoints + 5];
                setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));
                VOIContour resultContour = new VOIContour( false, true );
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, resultContour);
                resultContour.trimPoints(Preferences.getTrim(),
                        Preferences.getTrimAdjacient());
                if ( resultContour.size() > 0 )
                {
                    resultContour.update();
                    resultVOI.importCurve(resultContour);
                }
            } else {
                resultVOI.importCurve(contours.elementAt(j));
            }

            fireProgressStateChanged(30 + (((j / nContours) - 1) * 70));
        }

        fireProgressStateChanged(100);

        if (threadStopped) {
            finalize();

            return;
        }

        cleanup();

        setCompleted(true);
    }

    /**
     * Prepares the data and runs the algorithm for a 3D image.
     */
    private void calc3D() {

        float[] imgBuffer;
        int i;
        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        zDim = srcImage.getExtents()[2];
        extents = new int[3];
        extents[0] = xDim;
        extents[1] = yDim;
        extents[2] = zDim;

        try {
            length = xDim * yDim * zDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fz = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            wVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];

        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm GVF: Out of memory");
            setCompleted(false);

            return;
        }

        try {
            srcImage.exportData(0, length, imgBuffer);
        } catch (IOException error) {
            cleanup();
            MipavUtil.displayError("AlgorithmGVF: IOException on srcImage.exportData");

            setCompleted(false);

            return;
        }

        fireProgressStateChanged("Calculating 3D GVF");
        calcGVF3D(imgBuffer);

        if (destFlag == true) {

            for (i = 0; i < length; i++) {
                gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]) + (wVal[i] * wVal[i]));
            }

            try {
                destImage.importData(0, gvfBuffer, true);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)");

                setCompleted(false);

                return;
            }
        } // if (destFlag == true)


        if (threadStopped) {
            finalize();

            return;
        }

        if (destFlag == true) {
            destImage.calcMinMax();
        }

        cleanup();
        fireProgressStateChanged(100);

        setCompleted(true);
    }

    /**
     * Calculate GVF from image buffer.
     *
     * @param sliceNum
     * @param  imgBuffer  DOCUMENT ME!
     */
    private void calcGVF(int sliceNum, float[] imgBuffer) {
        float ix, iy;
        float gvfMin, gvfMax;
        int x, y;
        float del2;
        int iteration;
        int i;
        int sliceSize = xDim * yDim;
        int offset = sliceSize *sliceNum;

        uVal = new float[(xDim + 2) * (yDim + 2)];
        vVal = new float[(xDim + 2) * (yDim + 2)];

        if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0)) {
            for (i = 0; i < sliceSize; i++) {
                gvfBuffer[i] = outputBuffer[offset + i];
            }
        } // if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0))
        else if (sigmas[0] != 0.0) {
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y);
                    ix = outputBuffer[offset + i];
                    if (y == 0) {
                        iy = imgBuffer[x + xDim] - imgBuffer[i];
                    } else if (y == (yDim - 1)) {
                        iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim)];
                    } else {
                        iy = (imgBuffer[x + ((y + 1) * xDim)] - imgBuffer[x + ((y - 1) * xDim)]) / 2.0f;
                    }
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        } // else if (sigmas[0] != 0.0)
        else if (sigmas[1] != 0.0) {
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y);
                    if (x == 0) {
                        ix = imgBuffer[1 + (y * xDim)] - imgBuffer[i];
                    } else if (x == (xDim - 1)) {
                        ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim)];
                    } else {
                        ix = (imgBuffer[(x + 1) + (y * xDim)] - imgBuffer[(x - 1) + (y * xDim)]) / 2.0f;
                    }
                    iy = outputBuffer[offset + i];
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        } // else if (sigmas[1] != 0.0)
        else { // ((sigmas[0] == 0.0) && (sigmas[1] == 0.0))
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y);
                    if (x == 0) {
                        ix = imgBuffer[1 + (y * xDim)] - imgBuffer[i];
                    } else if (x == (xDim - 1)) {
                        ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim)];
                    } else {
                        ix = (imgBuffer[(x + 1) + (y * xDim)] - imgBuffer[(x - 1) + (y * xDim)]) / 2.0f;
                    } 
                    if (y == 0) {
                        iy = imgBuffer[x + xDim] - imgBuffer[i];
                    } else if (y == (yDim - 1)) {
                        iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim)];
                    } else {
                        iy = (imgBuffer[x + ((y + 1) * xDim)] - imgBuffer[x + ((y - 1) * xDim)]) / 2.0f;
                    }
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        }  // else ((sigmas[0] == 0.0) && (sigmas[1] == 0.0))
        
       
        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];

        for (i = 1; i < length; i++) {

            if (gvfBuffer[i] > gvfMax) {
                gvfMax = gvfBuffer[i];
            }

            if (gvfBuffer[i] < gvfMin) {
                gvfMin = gvfBuffer[i];
            }
        }

        for (i = 0; i < length; i++) {
            gvfBuffer[i] = (gvfBuffer[i] - gvfMin) / (gvfMax - gvfMin);
        }

        // Take care of the boundary condition
        for (y = 0; y < yDim; y++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[(x + 1) + ((y + 1) * (xDim + 2))] = gvfBuffer[x + (y * xDim)];
            }
        }

        // Create a mirror at the corners
        expGvfBuffer[0] = gvfBuffer[1 + xDim];
        expGvfBuffer[xDim + 1] = gvfBuffer[(xDim - 2) + xDim];
        expGvfBuffer[(yDim + 1) * (xDim + 2)] = gvfBuffer[((yDim - 2) * xDim) + 1];
        expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) * xDim) + xDim - 2];

        // Mirror left and right boundaries
        for (y = 0; y < yDim; y++) {
            expGvfBuffer[(y + 1) * (xDim + 2)] = gvfBuffer[(y * xDim) + 1];
            expGvfBuffer[((y + 1) * (xDim + 2)) + xDim + 1] = gvfBuffer[(y * xDim) + xDim - 2];
        }

        // Mirror top and bottom boundaries
        for (x = 0; x < xDim; x++) {
            expGvfBuffer[x + 1] = gvfBuffer[xDim + x];
            expGvfBuffer[((yDim + 1) * (xDim + 2)) + x + 1] = gvfBuffer[((yDim - 2) * xDim) + x];
        }

        // Calculate the x and y gradients
        for (y = 0; y < (yDim + 2); y++) {

            for (x = 0; x < (xDim + 2); x++) {

                if (x == 0) {
                    fx[y * (xDim + 2)] = expGvfBuffer[1 + (y * (xDim + 2))] - expGvfBuffer[y * (xDim + 2)];
                } else if (x == (xDim + 1)) {
                    fx[xDim + 1 + (y * (xDim + 2))] = expGvfBuffer[xDim + 1 + (y * (xDim + 2))] -
                                                      expGvfBuffer[xDim + (y * (xDim + 2))];
                } else {
                    fx[x + (y * (xDim + 2))] = (expGvfBuffer[(x + 1) + (y * (xDim + 2))] -
                                                expGvfBuffer[(x - 1) + (y * (xDim + 2))]) / 2.0f;
                }

                if (y == 0) {
                    fy[x] = expGvfBuffer[x + (xDim + 2)] - expGvfBuffer[x];
                } else if (y == (yDim + 1)) {
                    fy[x + ((yDim + 1) * (xDim + 2))] = expGvfBuffer[x + ((yDim + 1) * (xDim + 2))] -
                                                        expGvfBuffer[x + (yDim * (xDim + 2))];
                } else {
                    fy[x + (y * (xDim + 2))] = (expGvfBuffer[x + ((y + 1) * (xDim + 2))] -
                                                expGvfBuffer[x + ((y - 1) * (xDim + 2))]) / 2.0f;
                }
            } // for (x = 0; x < (xDim+2); x++)
        } // for (y = 0; y < (yDim+2); y++)

        // Initialize GVF to the gradient
        for (i = 0; i < fx.length; i++) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
        }

        for (i = 0; i < fx.length; i++) {
            gVal[i] = (float) Math.exp(-((fx[i] * fx[i]) + (fy[i] * fy[i])) / (kValue * kValue));
        }

        for (iteration = 0; (iteration < gvfIterations) && (!threadStopped); iteration++) {

            // Create a mirror at the u boundaries
            // Create a mirror at the corners
            uVal[0] = uVal[2 + (2 * (xDim + 2))];
            uVal[xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2))];
            uVal[(yDim + 1) * (xDim + 2)] = uVal[((yDim - 1) * (xDim + 2)) + 2];
            uVal[((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1];

            // Mirror left and right boundaries
            for (y = 1; y < (yDim + 1); y++) {
                uVal[y * (xDim + 2)] = uVal[(y * (xDim + 2)) + 2];
                uVal[(y * (xDim + 2)) + xDim + 1] = uVal[(y * (xDim + 2)) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for (x = 1; x < (xDim + 1); x++) {
                uVal[x] = uVal[(2 * (xDim + 2)) + x];
                uVal[((yDim + 1) * (xDim + 2)) + x] = uVal[((yDim - 1) * (xDim + 2)) + x];
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the corners
            vVal[0] = vVal[2 + (2 * (xDim + 2))];
            vVal[xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2))];
            vVal[(yDim + 1) * (xDim + 2)] = vVal[((yDim - 1) * (xDim + 2)) + 2];
            vVal[((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1];

            // Mirror left and right boundaries
            for (y = 1; y < (yDim + 1); y++) {
                vVal[y * (xDim + 2)] = vVal[(y * (xDim + 2)) + 2];
                vVal[(y * (xDim + 2)) + xDim + 1] = vVal[(y * (xDim + 2)) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for (x = 1; x < (xDim + 1); x++) {
                vVal[x] = vVal[(2 * (xDim + 2)) + x];
                vVal[((yDim + 1) * (xDim + 2)) + x] = vVal[((yDim - 1) * (xDim + 2)) + x];
            }

            for (y = 0; y < (yDim + 2); y++) {

                for (x = 0; x < (xDim + 2); x++) {
                    del2 = 0.0f;
                    i = x + (y * (xDim + 2));

                    if (x == 0) {
                        del2 += 2 * uVal[(x + 1) + (y * (xDim + 2))];
                    } else if (x == (xDim + 1)) {
                        del2 += 2 * uVal[(x - 1) + (y * (xDim + 2))];
                    } else {
                        del2 += uVal[(x + 1) + (y * (xDim + 2))] + uVal[(x - 1) + (y * (xDim + 2))];
                    }

                    if (y == 0) {
                        del2 += 2 * uVal[x + ((y + 1) * (xDim + 2))];
                    } else if (y == (yDim + 1)) {
                        del2 += 2 * uVal[x + ((y - 1) * (xDim + 2))];
                    } else {
                        del2 += uVal[x + ((y + 1) * (xDim + 2))] + uVal[x + ((y - 1) * (xDim + 2))];
                    }

                    del2 -= 4 * uVal[i];
                    uVal[i] += 0.25f * ((gVal[i] * del2) - ((1 - gVal[i]) * (uVal[i] - fx[i])));

                    del2 = 0.0f;

                    if (x == 0) {
                        del2 += 2 * vVal[(x + 1) + (y * (xDim + 2))];
                    } else if (x == (xDim + 1)) {
                        del2 += 2 * vVal[(x - 1) + (y * (xDim + 2))];
                    } else {
                        del2 += vVal[(x + 1) + (y * (xDim + 2))] + vVal[(x - 1) + (y * (xDim + 2))];
                    }

                    if (y == 0) {
                        del2 += 2 * vVal[x + ((y + 1) * (xDim + 2))];
                    } else if (y == (yDim + 1)) {
                        del2 += 2 * vVal[x + ((y - 1) * (xDim + 2))];
                    } else {
                        del2 += vVal[x + ((y + 1) * (xDim + 2))] + vVal[x + ((y - 1) * (xDim + 2))];
                    }

                    del2 -= 4 * vVal[i];
                    vVal[i] += 0.25f * ((gVal[i] * del2) - ((1 - gVal[i]) * (vVal[i] - fy[i])));
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for (y = 1; y < (yDim + 1); y++) {

            for (x = 1; x < (xDim + 1); x++) {
                gvfBuffer[(x - 1) + ((y - 1) * xDim)] = uVal[x + (y * (xDim + 2))];
            }
        }

        uVal = new float[length];

        for (i = 0; i < length; i++) {
            uVal[i] = gvfBuffer[i];
        }

        for (y = 1; y < (yDim + 1); y++) {

            for (x = 1; x < (xDim + 1); x++) {
                gvfBuffer[(x - 1) + ((y - 1) * xDim)] = vVal[x + (y * (xDim + 2))];
            }
        }

        vVal = new float[length];

        for (i = 0; i < length; i++) {
            vVal[i] = gvfBuffer[i];
        }

        return;
    }

    /**
     * Calculate GVF from 3D image buffer.
     *
     * @param  imgBuffer  DOCUMENT ME!
     */
    private void calcGVF3D(float[] imgBuffer) {
        float ix, iy, iz;
        float gvfMin, gvfMax;
        int x, y, z;
        float del2;
        int iteration;
        int totalLength = xDim * yDim * zDim;

        // float       k = 0.15f;
        int i, i1, i2;
        int sliceSize = xDim * yDim;
        int expSliceSize = (xDim + 2) * (yDim + 2);

        if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0)) {
            for (i = 0; i < totalLength; i++) {
                gvfBuffer[i] = outputBuffer[i];
            }
        } // if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0))
        else {
            for (z = 0; z < zDim; z++) {
                i1 = z * sliceSize;
    
                for (y = 0; y < yDim; y++) {
                    i2 = i1 + (xDim * y);
    
                    for (x = 0; x < xDim; x++) {
                        i = i2 + x;
                        ;
    
                        if (sigmas[0] != 0.0f) {
                            ix = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GxData);
                        } // if (sigmas[0] != 0.0f)
                        else { // (sigmas[0] == 0.0f)
    
                            if (x == 0) {
                                ix = imgBuffer[1 + (y * xDim) + (z * sliceSize)] - imgBuffer[i];
                            } else if (x == (xDim - 1)) {
                                ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim) + (z * sliceSize)];
                            } else {
                                ix = (imgBuffer[(x + 1) + (y * xDim) + (z * sliceSize)] -
                                      imgBuffer[(x - 1) + (y * xDim) + (z * sliceSize)]) / 2.0f;
                            }
                        } // else (sigmas[0] == 0.0f)
    
                        if (sigmas[1] != 0.0f) {
                            iy = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GyData);
                        } // if (sigmas[1] != 0.0f)
                        else { // sigmas[1] == 0.0f
    
                            if (y == 0) {
                                iy = imgBuffer[x + xDim + (z * sliceSize)] - imgBuffer[i];
                            } else if (y == (yDim - 1)) {
                                iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim) + (z * sliceSize)];
                            } else {
                                iy = (imgBuffer[x + ((y + 1) * xDim) + (z * sliceSize)] -
                                      imgBuffer[x + ((y - 1) * xDim) + (z * sliceSize)]) / 2.0f;
                            }
                        } // else sigmas[1] == 0.0f
    
                        if (sigmas[2] != 0.0) {
                            iz = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GzData);
                        } // if (sigmas[2] != 0.0f)
                        else { // sigmas[2] == 0.0f
    
                            if (z == 0) {
                                iz = imgBuffer[x + (y * xDim) + sliceSize] - imgBuffer[x + (y * xDim)];
                            } else if (z == (zDim - 1)) {
                                iz = imgBuffer[x + (y * xDim) + ((zDim - 1) * sliceSize)] -
                                     imgBuffer[x + (y * xDim) + ((zDim - 2) * sliceSize)];
                            } else {
                                iz = (imgBuffer[x + (y * xDim) + ((z + 1) * sliceSize)] -
                                      imgBuffer[x + (y * xDim) + ((z - 1) * sliceSize)]) / 2.0f;
                            }
                        } // else sigmas[2] == 0.0f
    
                        gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy) + (iz * iz));
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)
            } // for (z = 0; z < zDim; z++)
        } // else 

        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];

        for (i = 1; i < length; i++) {

            if (gvfBuffer[i] > gvfMax) {
                gvfMax = gvfBuffer[i];
            }

            if (gvfBuffer[i] < gvfMin) {
                gvfMin = gvfBuffer[i];
            }
        }

        for (i = 0; i < length; i++) {
            gvfBuffer[i] = (gvfBuffer[i] - gvfMin) / (gvfMax - gvfMin);
        }

        // Take care of the boundary condition
        for (z = 0; z < zDim; z++) {

            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    expGvfBuffer[(x + 1) + ((y + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[x +
                                                                                                          (y * xDim) +
                                                                                                          (z *
                                                                                                               sliceSize)];
                }
            }
        }

        // Create a mirror at the 8 corner points
        expGvfBuffer[0] = gvfBuffer[1 + xDim + sliceSize];
        expGvfBuffer[xDim + 1] = gvfBuffer[(xDim - 2) + xDim + sliceSize];
        expGvfBuffer[(yDim + 1) * (xDim + 2)] = gvfBuffer[((yDim - 2) * xDim) + 1 + sliceSize];
        expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) * xDim) + xDim - 2 + sliceSize];
        expGvfBuffer[(xDim + 2) * (yDim + 2) * (zDim + 1)] = gvfBuffer[1 + xDim + (sliceSize * (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + xDim + 1] = gvfBuffer[(xDim - 2) + xDim +
                                                                                    (sliceSize * (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + ((yDim + 1) * (xDim + 2))] = gvfBuffer[((yDim - 2) *
                                                                                                          xDim) + 1 +
                                                                                                     (sliceSize *
                                                                                                          (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + ((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) *
                                                                                                              xDim) +
                                                                                                         xDim - 2 +
                                                                                                         (sliceSize *
                                                                                                              (zDim -
                                                                                                                   2))];

        // Create a mirror at the corner line segments from x = 1 to x = xDim slices
        for (x = 0; x < xDim; x++) {
            expGvfBuffer[x + 1] = gvfBuffer[x + xDim + sliceSize];
            expGvfBuffer[x + 1 + ((yDim + 1) * (xDim + 2))] = gvfBuffer[x + ((yDim - 2) * xDim) + sliceSize];
            expGvfBuffer[x + 1 + ((zDim + 1) * expSliceSize)] = gvfBuffer[x + xDim + ((zDim - 2) * sliceSize)];
            expGvfBuffer[x + 1 + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[x +
                                                                                                      ((yDim - 2) *
                                                                                                           xDim) +
                                                                                                      ((zDim - 2) *
                                                                                                           sliceSize)];
        }

        // Create a mirror at the corner line segments from y = 1 to y = yDim slices
        for (y = 0; y < yDim; y++) {
            expGvfBuffer[(y + 1) * (xDim + 2)] = gvfBuffer[1 + (y * xDim) + sliceSize];
            expGvfBuffer[xDim + 1 + ((y + 1) * (xDim + 2))] = gvfBuffer[xDim - 2 + (y * xDim) + sliceSize];
            expGvfBuffer[((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[1 + (y * xDim) +
                                                                                           ((zDim - 2) * sliceSize)];
            expGvfBuffer[xDim + 1 + ((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[xDim - 2 +
                                                                                                      (y * xDim) +
                                                                                                      ((zDim - 2) *
                                                                                                           sliceSize)];
        }

        // Create a mirror at the corner line segments from z = 1 to z = zDim slices
        for (z = 0; z < zDim; z++) {
            expGvfBuffer[(z + 1) * expSliceSize] = gvfBuffer[1 + xDim + (z * sliceSize)];
            expGvfBuffer[xDim + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(xDim - 2) + xDim + (z * sliceSize)];
            expGvfBuffer[((yDim + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[((yDim - 2) * xDim) + 1 +
                                                                                           (z * sliceSize)];
            expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1 + ((z + 1) * expSliceSize)] = gvfBuffer[((yDim - 2) * xDim) +
                                                                                               xDim - 2 +
                                                                                               (z * sliceSize)];
        }

        // Mirror left and right x boundaries
        for (z = 0; z < zDim; z++) {

            for (y = 0; y < yDim; y++) {
                expGvfBuffer[((y + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                            (y * xDim) + 1];
                expGvfBuffer[((y + 1) * (xDim + 2)) + xDim + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                                       (y * xDim) +
                                                                                                       xDim - 2];
            }
        }

        // Mirror top and bottom y boundaries
        for (z = 0; z < zDim; z++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[x + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) + xDim + x];
                expGvfBuffer[((yDim + 1) * (xDim + 2)) + x + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                                       ((yDim - 2) *
                                                                                                            xDim) + x];
            }
        }

        // Mirror front and back z boundaries
        for (y = 0; y < yDim; y++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[x + 1 + ((y + 1) * (xDim + 2))] = gvfBuffer[sliceSize + (y * xDim) + x];
                expGvfBuffer[x + 1 + ((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[((zDim - 2) *
                                                                                                            sliceSize) +
                                                                                                       (y * xDim) + x];
            }
        }

        // Calculate the x and y and z gradients
        for (z = 0; z < (zDim + 2); z++) {

            for (y = 0; y < (yDim + 2); y++) {

                for (x = 0; x < (xDim + 2); x++) {

                    if (x == 0) {
                        fx[(y * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[1 + (y * (xDim + 2)) +
                                                                                 (z * expSliceSize)] -
                                                                    expGvfBuffer[(y * (xDim + 2)) + (z * expSliceSize)];
                    } else if (x == (xDim + 1)) {
                        fx[xDim + 1 + (y * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[xDim + 1 +
                                                                                            (y * (xDim + 2)) +
                                                                                            (z * expSliceSize)] -
                                                                               expGvfBuffer[xDim + (y * (xDim + 2)) +
                                                                                            (z * expSliceSize)];
                    } else {
                        fx[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[(x + 1) + (y * (xDim + 2)) +
                                                                                      (z * expSliceSize)] -
                                                                         expGvfBuffer[(x - 1) + (y * (xDim + 2)) +
                                                                                      (z * expSliceSize)]) / 2.0f;
                    }

                    if (y == 0) {
                        fy[x + (z * expSliceSize)] = expGvfBuffer[x + (xDim + 2) + (z * expSliceSize)] -
                                                     expGvfBuffer[x + (z * expSliceSize)];
                    } else if (y == (yDim + 1)) {
                        fy[x + ((yDim + 1) * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[x +
                                                                                              ((yDim + 1) *
                                                                                                   (xDim + 2)) +
                                                                                              (z * expSliceSize)] -
                                                                                 expGvfBuffer[x + (yDim * (xDim + 2)) +
                                                                                              (z * expSliceSize)];
                    } else {
                        fy[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[x + ((y + 1) * (xDim + 2)) +
                                                                                      (z * expSliceSize)] -
                                                                         expGvfBuffer[x + ((y - 1) * (xDim + 2)) +
                                                                                      (z * expSliceSize)]) / 2.0f;
                    }

                    if (z == 0) {
                        fz[x + (y * (xDim + 2))] = expGvfBuffer[x + (y * (xDim + 2)) + expSliceSize] -
                                                   expGvfBuffer[x + (y * (xDim + 2))];
                    } else if (z == (zDim + 1)) {
                        fz[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                              ((zDim + 1) *
                                                                                                   expSliceSize)] -
                                                                                 expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                              (zDim * expSliceSize)];
                    } else {
                        fz[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                      ((z + 1) * expSliceSize)] -
                                                                         expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                      ((z - 1) * expSliceSize)]) / 2.0f;
                    }
                } // for (x = 0; x < (xDim+2); x++)
            } // for (y = 0; y < (yDim+2); y++)
        } // for (z = 0; z < (zDim+2); z++)

        // Initialize GVF to the gradient
        for (i = 0; i < fx.length; i++) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
            wVal[i] = fz[i];
        }

        for (i = 0; i < fx.length; i++) {
            gVal[i] = (float) Math.exp(-((fx[i] * fx[i]) + (fy[i] * fy[i]) + (fz[i] * fz[i])) / (kValue * kValue));
        }

        for (iteration = 0; (iteration < gvfIterations) && (!threadStopped); iteration++) {

            // Create a mirror at the u boundaries
            // Create a mirror at the 8 corner points of the cube
            uVal[0] = uVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            uVal[xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            uVal[(yDim + 1) * (xDim + 2)] = uVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            uVal[((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            uVal[(zDim + 1) * expSliceSize] = uVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = uVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                uVal[x] = uVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                uVal[x + ((yDim + 1) * (xDim + 2))] = uVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                uVal[x + ((zDim + 1) * expSliceSize)] = uVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                uVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                uVal[y * (xDim + 2)] = uVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                uVal[xDim + 1 + (y * (xDim + 2))] = uVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                uVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                uVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                uVal[z * expSliceSize] = uVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                uVal[(z * expSliceSize) + xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                uVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = uVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                uVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries for z = 1 to z = zDim
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    uVal[(z * expSliceSize) + (y * (xDim + 2))] = uVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    uVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = uVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    uVal[(z * expSliceSize) + x] = uVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    uVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = uVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    uVal[x + (y * (xDim + 2))] = uVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    uVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the 8 corners
            vVal[0] = vVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            vVal[xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            vVal[(yDim + 1) * (xDim + 2)] = vVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            vVal[((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            vVal[(zDim + 1) * expSliceSize] = vVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = vVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                vVal[x] = vVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                vVal[x + ((yDim + 1) * (xDim + 2))] = vVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                vVal[x + ((zDim + 1) * expSliceSize)] = vVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                vVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                vVal[y * (xDim + 2)] = vVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                vVal[xDim + 1 + (y * (xDim + 2))] = vVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                vVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                vVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                vVal[z * expSliceSize] = vVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                vVal[(z * expSliceSize) + xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                vVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = vVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                vVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    vVal[(z * expSliceSize) + (y * (xDim + 2))] = vVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    vVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = vVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    vVal[(z * expSliceSize) + x] = vVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    vVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = vVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    vVal[x + (y * (xDim + 2))] = vVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    vVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            // Create a mirror at the w boundaries
            // Create a mirror at the 8 corner points
            wVal[0] = wVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            wVal[xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            wVal[(yDim + 1) * (xDim + 2)] = wVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            wVal[((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            wVal[(zDim + 1) * expSliceSize] = wVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = wVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                wVal[x] = wVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                wVal[x + ((yDim + 1) * (xDim + 2))] = wVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                wVal[x + ((zDim + 1) * expSliceSize)] = wVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                wVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                wVal[y * (xDim + 2)] = wVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                wVal[xDim + 1 + (y * (xDim + 2))] = wVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                wVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                wVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments for z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                wVal[z * expSliceSize] = wVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                wVal[(z * expSliceSize) + xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                wVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = wVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                wVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    wVal[(z * expSliceSize) + (y * (xDim + 2))] = wVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    wVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = wVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    wVal[(z * expSliceSize) + x] = wVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    wVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = wVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    wVal[x + (y * (xDim + 2))] = wVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    wVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            for (z = 0; z < (zDim + 2); z++) {
                i1 = z * expSliceSize;

                for (y = 0; y < (yDim + 2); y++) {
                    i2 = i1 + (y * (xDim + 2));

                    for (x = 0; x < (xDim + 2); x++) {
                        del2 = 0.0f;
                        i = x + i2;

                        if (x == 0) {
                            del2 += 2 * uVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * uVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += uVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    uVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * uVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * uVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += uVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    uVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];

                        }

                        if (z == 0) {
                            del2 += 2 * uVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * uVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += uVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +uVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * uVal[i];
                        uVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (uVal[i] - fx[i])));

                        del2 = 0.0f;

                        if (x == 0) {
                            del2 += 2 * vVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * vVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += vVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    vVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * vVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * vVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += vVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    vVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (z == 0) {
                            del2 += 2 * vVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * vVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += vVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +vVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * vVal[i];
                        vVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (vVal[i] - fy[i])));

                        del2 = 0.0f;

                        if (x == 0) {
                            del2 += 2 * wVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * wVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += wVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    wVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * wVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * wVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += wVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    wVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (z == 0) {
                            del2 += 2 * wVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * wVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += wVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +wVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * wVal[i];
                        wVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (wVal[i] - fz[i])));
                    }
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = uVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        uVal = new float[length];

        for (i = 0; i < length; i++) {
            uVal[i] = gvfBuffer[i];
        }

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = vVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        vVal = new float[length];

        for (i = 0; i < length; i++) {
            vVal[i] = gvfBuffer[i];
        }

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = wVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        wVal = new float[length];

        for (i = 0; i < length; i++) {
            wVal[i] = gvfBuffer[i];
        }

        ModelImage gvfImage = new ModelImage(ModelImage.FLOAT, srcImage.getExtents(), srcImage.getImageName() + "_uvf");

        try {
            gvfImage.importData(0, uVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_uvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.importData(0, vVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_vvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.importData(0, wVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_wvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        gvfImage.disposeLocal();
        gvfImage = null;

        return;
    }

    /**
     * Sets the structures to null.
     */
    private void cleanup() {
        uVal = null;
        vVal = null;
        wVal = null;
        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        System.gc();
    }

    /**
     * Calculates the distance between two points.
     *
     * @param   x1  first x coord.
     * @param   x2  second x coord.
     * @param   y1  first y1 coord.
     * @param   y2  second y2 coord.
     *
     * @return  DOCUMENT ME!
     */
    @SuppressWarnings("unused")
    private double distance(int x1, int x2, int y1, int y2) {
        return Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
    }

    /**
     * Makes 2D derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels2D() {
        int xkDim, ykDim;
        int[] derivOrder = new int[2];

        kExtents = new int[2];
        derivOrder[0] = 1;
        derivOrder[1] = 0;

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        GxData = new float[xkDim * ykDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);

        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        GyData = new float[xkDim * ykDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);

        Gy.calc(true);
    }

    /**
     * Makes 3D derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels3D() {
        int xkDim, ykDim, zkDim;
        int[] derivOrder = new int[3];

        kExtents = new int[3];

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        zkDim = Math.round(5 * sigmas[2]);

        if ((zkDim % 2) == 0) {
            zkDim++;
        }

        kExtents[2] = zkDim;

        derivOrder[0] = 1;
        derivOrder[1] = 0;
        derivOrder[2] = 0;
        GxData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);

        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        derivOrder[2] = 0;
        GyData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);

        Gy.calc(true);

        derivOrder[0] = 0;
        derivOrder[1] = 0;
        derivOrder[2] = 1;
        GzData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gz = new GenerateGaussian(GzData, kExtents, sigmas, derivOrder);

        Gz.calc(true);
    }
    
    /**
     * Actual function that evolves the boundary.
     *
     * @param  xPoints    x coordinates that describe the contour
     * @param  yPoints    y coordinates that describe the contour
     * @param  u          gradient vector field x component
     * @param  v          gradient vector field y component
     * @param  resultGon  resultant polygon energy is too much extra computation to be worth computing energy is given
     *                    by the sum over 0.5*alpha*|first order derivative|**2 + Eext, where v = -grad(Eext). The first
     *                    derivative of the curve and Eext would also have to be calculated to obtain the energy.
     */
    @SuppressWarnings("unused")
    private void runSnake(float[] xPoints, float[] yPoints, float[] u, float[] v, Polygon resultGon) {
        int i, j;
        int nPts;
        float pct;
        float index;
        Vector2f interpPt = new Vector2f();
        float[] newXPts, newYPts;
        int position;
        boolean finished = false;
        int z;

        AlgorithmArcLength arcLength = new AlgorithmArcLength(xPoints, yPoints);
        AlgorithmBSpline bSpline = new AlgorithmBSpline();

        nPts = Math.round(arcLength.getTotalArcLength() * 2);
        newXPts = new float[nPts + 5];
        newYPts = new float[nPts + 5];

        for (z = 0; (z < boundaryIterations) && (!finished) && (!threadStopped); z++) {
            finished = true;

            for (i = 0; i < nPts; i++) {
                pct = i / (float) (nPts);

                // Note that a pct of 0 gives an index of 2 and
                // a pct of 1 gives an index 2 less than the maximum
                // possible
                index = arcLength.invlen(pct);
                interpPt = bSpline.bSplineJetXY(0, index, xPoints, yPoints);
                // The first and second derivatives were seen to be unscaled deriv2Dir   = bSpline.bSplineJetXY(2,
                // index, xPoints, yPoints);

                position = (int) interpPt.X + (xDim * (int) interpPt.Y);

                newXPts[i + 2] = interpPt.X +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, u);

                newYPts[i + 2] = interpPt.Y +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, v);

                if ((Math.abs(newXPts[i + 2] - interpPt.X) >= 0.02f) ||
                        (Math.abs(newYPts[i + 2] - interpPt.Y) >= 0.02f)) {
                    finished = false;
                }

            }

            // After an interation the first point starts at an index of 2
            // and the last points is present at an index of nPts + 1
            // The first point at an index of 2 must be used twice -
            // once for the segment going from the first to the second
            // point and once for the segment going from the last to the
            // first point.  The last 2 points at each end then provide
            // wrap around segments.
            newXPts[0] = newXPts[nPts];
            newYPts[0] = newYPts[nPts];
            newXPts[1] = newXPts[nPts + 1];
            newYPts[1] = newYPts[nPts + 1];
            newXPts[nPts + 2] = newXPts[2];
            newYPts[nPts + 2] = newYPts[2];
            newXPts[nPts + 3] = newXPts[3];
            newYPts[nPts + 3] = newYPts[3];
            newXPts[nPts + 4] = newXPts[4];
            newYPts[nPts + 4] = newYPts[4];

            xPoints = newXPts;
            yPoints = newYPts;

            arcLength.setPoints(xPoints, yPoints);

            newXPts = new float[xPoints.length];
            newYPts = new float[xPoints.length];
        }

        System.out.println("Iterations performed = " + z);

        for (j = 2; j < (yPoints.length - 3); j++) {
            resultGon.addPoint(Math.round(xPoints[j]), Math.round(yPoints[j]));
        }

        return;
    }


    /**
     * Actual function that evolves the boundary.
     *
     * @param  xPoints    x coordinates that describe the contour
     * @param  yPoints    y coordinates that describe the contour
     * @param  u          gradient vector field x component
     * @param  v          gradient vector field y component
     * @param  resultGon  resultant polygon energy is too much extra computation to be worth computing energy is given
     *                    by the sum over 0.5*alpha*|first order derivative|**2 + Eext, where v = -grad(Eext). The first
     *                    derivative of the curve and Eext would also have to be calculated to obtain the energy.
     */
    private void runSnake(float[] xPoints, float[] yPoints, float[] zPoints, float[] u, float[] v, VOIBase resultContour) {
        int i, j;
        int nPts;
        float pct;
        float index;
        int position;
        boolean finished = false;
        int z;

        AlgorithmArcLength arcLength = new AlgorithmArcLength(xPoints, yPoints, zPoints);
        AlgorithmBSpline bSpline = new AlgorithmBSpline();

        nPts = Math.round(arcLength.getTotalArcLength() * 2);
        float[] newXPts = new float[nPts + 5];
        float[] newYPts = new float[nPts + 5];
        float[] newZPts = new float[nPts + 5];

        for (z = 0; (z < boundaryIterations) && (!finished) && (!threadStopped); z++) {
            finished = true;

            for (i = 0; i < nPts; i++) {
                pct = i / (float) (nPts);

                // Note that a pct of 0 gives an index of 2 and
                // a pct of 1 gives an index 2 less than the maximum
                // possible
                index = arcLength.invlen(pct);
                Vector3f interpPt = bSpline.bSplineJetXYZ(0, index, xPoints, yPoints, zPoints);
                // The first and second derivatives were seen to be unscaled deriv2Dir   = bSpline.bSplineJetXY(2,
                // index, xPoints, yPoints);

                position = (int) interpPt.X + (xDim * (int) interpPt.Y);

                newXPts[i + 2] = interpPt.X +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, u);

                newYPts[i + 2] = interpPt.Y +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, v);
                newZPts[i + 2] = interpPt.Z;

                if ((Math.abs(newXPts[i + 2] - interpPt.X) >= 0.02f) ||
                        (Math.abs(newYPts[i + 2] - interpPt.Y) >= 0.02f)) {
                    finished = false;
                }

            }

            // After an interation the first point starts at an index of 2
            // and the last points is present at an index of nPts + 1
            // The first point at an index of 2 must be used twice -
            // once for the segment going from the first to the second
            // point and once for the segment going from the last to the
            // first point.  The last 2 points at each end then provide
            // wrap around segments.
            newXPts[0] = newXPts[nPts];
            newYPts[0] = newYPts[nPts];
            newZPts[0] = newZPts[nPts];
            newXPts[1] = newXPts[nPts + 1];
            newYPts[1] = newYPts[nPts + 1];
            newZPts[1] = newZPts[nPts + 1];
            newXPts[nPts + 2] = newXPts[2];
            newYPts[nPts + 2] = newYPts[2];
            newZPts[nPts + 2] = newZPts[2];
            newXPts[nPts + 3] = newXPts[3];
            newYPts[nPts + 3] = newYPts[3];
            newZPts[nPts + 3] = newZPts[3];
            newXPts[nPts + 4] = newXPts[4];
            newYPts[nPts + 4] = newYPts[4];
            newZPts[nPts + 4] = newZPts[4];

            xPoints = newXPts;
            yPoints = newYPts;
            zPoints = newZPts;

            arcLength.setPoints(xPoints, yPoints, zPoints);

            newXPts = new float[xPoints.length];
            newYPts = new float[xPoints.length];
            newZPts = new float[xPoints.length];
        }

        System.out.println("Iterations performed = " + z);

        for (j = 2; j < (yPoints.length - 3); j++) {
            resultContour.add( new Vector3f(Math.round(xPoints[j]), Math.round(yPoints[j]), Math.round(zPoints[j])) );
        }

        return;
    }

    /**
     * Takes the polygon and forms two special arrarys for use in the Bspline.
     *
     * @param  xPoints  storage location of array of x coord. points
     * @param  yPoints  storage location array of y coord. points
     * @param  gon      initial polygon
     */
    @SuppressWarnings("unused")
    private void setPoints(float[] xPoints, float[] yPoints, Polygon gon) {
        int i;

        /** Note that 0 is used twice - once in the 0 to 1 segment and once
         * in the n-1 to zero segment. */
        xPoints[0] = gon.xpoints[gon.npoints - 2];
        yPoints[0] = gon.ypoints[gon.npoints - 2];

        xPoints[1] = gon.xpoints[gon.npoints - 1];
        yPoints[1] = gon.ypoints[gon.npoints - 1];

        for (i = 0; i < gon.npoints; i++) {
            xPoints[i + 2] = gon.xpoints[i];
            yPoints[i + 2] = gon.ypoints[i];
        }

        xPoints[gon.npoints + 2] = gon.xpoints[0];
        yPoints[gon.npoints + 2] = gon.ypoints[0];

        xPoints[gon.npoints + 3] = gon.xpoints[1];
        yPoints[gon.npoints + 3] = gon.ypoints[1];

        xPoints[gon.npoints + 4] = gon.xpoints[2];
        yPoints[gon.npoints + 4] = gon.ypoints[2];
    }
    
    /**
     * Takes the polygon and forms two special arrays for use in the Bspline.
     *
     * @param  xPoints  storage location of array of x coord. points
     * @param  yPoints  storage location array of y coord. points
     * @param  gon      initial polygon
     */
    private void setPoints(float[] xPoints, float[] yPoints, float[] zPoints, VOIBase contour) {
        xPoints[0] = contour.get(contour.size() - 2).X;
        yPoints[0] = contour.get(contour.size() - 2).Y;
        zPoints[0] = contour.get(contour.size() - 2).Z;
        
        xPoints[1] = contour.get(contour.size() - 1).X;
        yPoints[1] = contour.get(contour.size() - 1).Y;
        zPoints[1] = contour.get(contour.size() - 1).Z;

        for (int i = 0; i < contour.size(); i++) {
            xPoints[i + 2] = contour.get(i).X;
            yPoints[i + 2] = contour.get(i).Y;
            zPoints[i + 2] = contour.get(i).Z;
        }

        xPoints[contour.size() + 2] = contour.get(0).X;
        yPoints[contour.size() + 2] = contour.get(0).Y;
        zPoints[contour.size() + 2] = contour.get(0).Z;

        xPoints[contour.size() + 3] = contour.get(1).X;
        yPoints[contour.size() + 3] = contour.get(1).Y;
        zPoints[contour.size() + 3] = contour.get(1).Z;

        xPoints[contour.size() + 4] = contour.get(2).X;
        yPoints[contour.size() + 4] = contour.get(2).Y;
        zPoints[contour.size() + 4] = contour.get(2).Z;
    }

    
    public void algorithmPerformed(AlgorithmBase algorithm){
        if(!algorithm.isCompleted()){
            finalize();
            return;
        }
        if (algorithm instanceof AlgorithmConvolver) {
            AlgorithmConvolver convolver = (AlgorithmConvolver) algorithm;
            outputBuffer = convolver.getOutputBuffer();
        }
    }
    
}
