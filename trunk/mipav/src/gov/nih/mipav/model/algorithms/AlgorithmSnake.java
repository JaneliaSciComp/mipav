package gov.nih.mipav.model.algorithms;

import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.view.*;

import java.awt.*;
import java.io.*;
import java.util.*;

/**
 * Snake-like algorithm deriviative. The algorithm is supplied
 * a polygon (VOI - contour) and that polygon is allowed to evolve to the edge of
 * the object generated by calculating the gradient magnitude (i.e. the energy
 * function) at scale define by the user. The user/programmer supplies the
 * sigmas (scales) at which to calculate the gradient magnitude. A large scale
 * slows the snake and causes the snake to conform to large scale structure.
 * A small sigma value causes the snake to conform to the small scale structure
 * is therefore more sensitive to noise. The three-dimensional version  is really
 * a two-and-half dimensional algorithm where the resultant contour in a slice is
 * projected into the adjacent slice and is used as an initialization to the
 * evolution in the new slice.
 *
 * @version 0.1 Feb 11, 1998
 * @author Matthew J. McAuliffe, Ph.D.
 * @see AlgorithmBSpline
 * @see GenerateGaussian
 * @see AlgorithmVOISimplexOpt
 * @see AlgorithmBSnake
 */
public class AlgorithmSnake extends AlgorithmBase {

    /**
     *   Source image.
     */
    private ModelImage srcImage;

    /**
     *   Starting slice to evolve contour.
     */
    private int stSlice;

    /**
     *   The initial VOI to initialize the evolution process.
     */
    private VOI srcVOI;

    /**
     *   The resultant polygon and the evolution has completed.
     */
    private VOI resultVOI;

    /**
     *   Do not propagate the VOI to any slices (2D).
     */
    public static final int PROP_SINGLE = 0;

    /**
     * Propagate the source VOI to slices above its current slice in the volume.
     */
    public static final int PROP_NEXT = 1;

    /**
     * Propagate the source VOI to slices below its current slice in the volume.
     */
    public static final int PROP_PREV = 2;

    /**
     * Propagate the source VOI to slices above and below its current slice.
     */
    public static final int PROP_ALL = 3;

    /**
     * The VOI propagation mode to use.
     */
    private int propagationType = PROP_ALL;

    /**
     * Maximum number of snake iterations.
     */
    private int boundaryIterations = 20;

    /**
     * The maximum angle we want to have between points in the result VOI.
     */
    private float smoothness;

    /**
     * Indicates boundary can move in or out.
     */
    public static final int ANY_DIR = 0;

    /**
     * Indicates boundary can move in.
     */
    public static final int IN_DIR = 1;

    /**
     * Indicates boundary can move out.
     */
    public static final int OUT_DIR = 2;

    /**
     * Indicates boundary how the VOI boundary can move - in and/or out.
     */
    private int evolveDirection = ANY_DIR;

    /**
     *   Dimensionality of the kernel.
     */
    private int[] kExtents;

    /**
     *   Standard deviations of the gaussian used to calculate the kernels.
     */
    private float[] sigmas;

    /**
     *   Storage location of the first derivative of the Gaussian in the X direction.
     */
    private float[] GxData;

    /**
     *   Storage location of the first derivative of the Gaussian in the Y direction.
     */
    private float[] GyData;

    /**
     *   Storage location of the first derivative of the Gaussian in the Z direction.
     */
    private float[] GzData;

    /**
     * The maximum ratio of change in the energy under the VOI after propagation.
     */
    private static final float PROP_THRESHOLD = 0.5f;

    /**
     * Set up the snake algorithm so that it can be run.
     *   @param _srcImg  2D or 3D source image
     *   @param _sigmas  describe the scale of the gaussian in each dimension
     *   @param _boundaryIterations  maximum number of snake iterations
     *   @param _smoothness  the boundary smoothness parameter
     *   @param srcVOI  VOI that is to be evolved
     *   @param boundDir  indicates the boundary direction (in and/or out)
     */
    public AlgorithmSnake( ModelImage _srcImg, float[] _sigmas, int _boundaryIterations,
            float _smoothness, VOI srcVOI, int boundDir ) {

        srcImage = _srcImg;
        sigmas = _sigmas;
        boundaryIterations = _boundaryIterations;
        smoothness = _smoothness;
        evolveDirection = boundDir;

        this.srcVOI = srcVOI;
        if ( srcImage.getNDims() == 2 ) {
            makeKernels2D();
            resultVOI = new VOI( (short) srcImage.getVOIs().size(), "SnakeVOI", 1, VOI.CONTOUR, -1.0f );

        } else if ( srcImage.getNDims() > 2 ) {
            if ( sigmas[2] == 0.0f ) {
                makeKernels2D();
            } else {
                makeKernels3D();
            }
            resultVOI = new VOI( (short) srcImage.getVOIs().size(), "snakeVOI", srcImage.getExtents()[2], VOI.CONTOUR,
                    -1.0f );
        }
    }

    /**
     *   Returns the resultant VOI.
     *   @return        resultant VOI that has localized to the boundaries of the object
     */
    public VOI getResultVOI() {
        return resultVOI;
    }

    /**
     *   Sets the propagation type
     *   @param type  if PROP_ALL, result contour from a slice is propagated to the
     *                adjacent slice and used to initialize the snake algorithm
     *                for that slice. If PROP_NEXT, result contour from the original slice
     *                is propagated to the next slice and used to initialize the snake
     *                algorithm for that slice.  If PROP_PREV, result contour from the
     *                orginal slice is propagated to the previous slice.
     *                If PROP_SINGLE, the snake algorithm stops after
     *                optimizing the boundary in the present slice.
     */
    public void setPropagation( int type ) {
        propagationType = type;
    }

    /**
     *   Prepares this class for destruction
     */
    public void finalize() {
        GxData = null;
        GyData = null;
        GzData = null;
        srcImage = null;
        sigmas = null;
        kExtents = null;
        super.finalize();
    }

    /**
     *   Makes derivative kernels to be used in the calculation
     *   of the gradient magnitude.
     */
    private void makeKernels2D() {
        int xkDim, ykDim;
        int[] derivOrder = new int[2];

        kExtents = new int[2];
        derivOrder[0] = 1;
        derivOrder[1] = 0;

        xkDim = Math.round( 5 * sigmas[0] );
        if ( xkDim % 2 == 0 ) {
            xkDim++;
        }
        kExtents[0] = xkDim;

        ykDim = Math.round( 5 * sigmas[1] );
        if ( ykDim % 2 == 0 ) {
            ykDim++;
        }
        kExtents[1] = ykDim;

        GxData = new float[xkDim * ykDim];
        GenerateGaussian Gx = new GenerateGaussian( GxData, kExtents, sigmas, derivOrder );

        Gx.calc( false );

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        GyData = new float[xkDim * ykDim];
        GenerateGaussian Gy = new GenerateGaussian( GyData, kExtents, sigmas, derivOrder );

        Gy.calc( true );
    }

    /**
     *   Makes derivative kernels to be used in the calculation
     *   of the gradient magnitude.
     */
    private void makeKernels3D() {
        int xkDim, ykDim, zkDim;
        int[] derivOrder = new int[3];

        kExtents = new int[3];

        xkDim = Math.round( 5 * sigmas[0] );
        if ( xkDim % 2 == 0 ) {
            xkDim++;
        }
        kExtents[0] = xkDim;

        ykDim = Math.round( 5 * sigmas[1] );
        if ( ykDim % 2 == 0 ) {
            ykDim++;
        }
        kExtents[1] = ykDim;

        zkDim = Math.round( 5 * sigmas[2] );
        if ( zkDim % 2 == 0 ) {
            zkDim++;
        }
        kExtents[2] = zkDim;

        derivOrder[0] = 1;
        derivOrder[1] = 0;
        derivOrder[2] = 0;
        GxData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gx = new GenerateGaussian( GxData, kExtents, sigmas, derivOrder );

        Gx.calc( false );

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        derivOrder[2] = 0;
        GyData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gy = new GenerateGaussian( GyData, kExtents, sigmas, derivOrder );

        Gy.calc( true );

        derivOrder[0] = 0;
        derivOrder[1] = 0;
        derivOrder[2] = 1;
        GzData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gz = new GenerateGaussian( GzData, kExtents, sigmas, derivOrder );

        Gz.calc( true );
    }

    /**
     *   run - starts the snake algorithm
     */
    public void runAlgorithm() {

        if ( srcImage == null ) {
            displayError( "Source Image is null" );
            return;
        } else {
            if ( srcImage.getNDims() == 2 ) {
                calc2D();
            } else if ( srcImage.getNDims() > 2 ) {
                calc3D();
            }
        }
    }

    /**
     *   Prepares the data and runs the algorithm for a 2D image
     */
    private void calc2D() {

        float[] imgBuffer;
        int xDim, yDim, length;
        float[] xPoints = null;
        float[] yPoints = null;
        Polygon resultGon = null;
        Polygon[] gons = null;
        Vector[] contours;
        int nContours;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        try {
            length = xDim * yDim;
            imgBuffer = new float[length];
            srcImage.exportData( 0, length, imgBuffer ); // locks and releases lock

            buildProgressBar( srcImage.getImageName(), "Evolving boundary ...", 0, 100 );
            initProgressBar();
        } catch ( IOException error ) {
            displayError( "Algorithm Snake: Image(s) locked" );
            setCompleted( false );
            return;
        } catch ( OutOfMemoryError e ) {
            displayError( "Algorithm Snake:  Out of Memory" );
            setCompleted( false );
            return;
        }
        progressBar.updateValue( 25, activeImage );

        contours = srcVOI.getCurves();
        nContours = contours[0].size();
        progressBar.updateValue( 30, activeImage );

        for ( int j = 0; j < nContours; j++ ) {
            if ( ( (VOIContour) ( contours[0].elementAt( j ) ) ).isActive() ) {

                ( (VOIContour) ( contours[0].elementAt( j ) ) ).makeClockwise();
                gons = srcVOI.exportPolygons( 0 );
                xPoints = new float[gons[j].npoints + 2];
                yPoints = new float[gons[j].npoints + 2];
                resultGon = new Polygon();
                setPoints( xPoints, yPoints, gons[j] );
                runSnake( xPoints, yPoints, imgBuffer, resultGon );
                resultVOI.importPolygon( resultGon, 0 );
                ( (VOIContour) ( resultVOI.getCurves()[0].lastElement() ) ).trimPoints( Preferences.getTrim(),
                        Preferences.getTrimAdjacient() );
            } else {
                gons = srcVOI.exportPolygons( 0 );
                resultVOI.importPolygon( gons[j], 0 );
            }
            progressBar.updateValue( 30 + ( j / nContours - 1 ) * 70, activeImage );
        }
        progressBar.updateValue( 100, activeImage );
        progressBar.dispose();

        setCompleted( true );

    }

    /**
     *   Takes the polygon and forms two special arrays for use
     *   in runSnake.
     *   @param xPoints storage location of array of x coord. points
     *   @param yPoints storage location array of y coord. points
     *   @param gon     initial polygon
     */
    private void setPoints( float[] xPoints, float[] yPoints, Polygon gon ) {
        int i;

        xPoints[0] = gon.xpoints[gon.npoints - 1];
        yPoints[0] = gon.ypoints[gon.npoints - 1];

        for ( i = 0; i < gon.npoints; i++ ) {
            xPoints[i + 1] = gon.xpoints[i];
            yPoints[i + 1] = gon.ypoints[i];
        }

        xPoints[gon.npoints + 1] = gon.xpoints[0];
        yPoints[gon.npoints + 1] = gon.ypoints[0];
    }

    /**
     *   Actual function that evolves the boundary by moving normal to the boundary.
     *   @param xPoints   x coordinates that describe the contour
     *   @param yPoints   y coordinates that describe the contour
     *   @param image     image data
     *   @param resultGon resultant polygon
     *   @return the sum of the energy along the boundary of the <code>resultGon</code>
     */
    private float runSnake( float[] xPoints, float[] yPoints, float[] image, Polygon resultGon ) {
        int i, j;
        int nPts;
        Point2Df interpPt = new Point2Df();
        Point2Df inNormPt = new Point2Df();
        Point2Df outNormPt = new Point2Df();
        Point2Df tangentDir = new Point2Df();
        Point2Df normDir = new Point2Df();
        Point2Df normStep = new Point2Df();
        float newXPts[] = null, newYPts[] = null;
        float normLength;
        float stepPct = (float) 0.45;
        float ix, iy;
        float gradMag, inGradMag, outGradMag;
        float energy = 0, oldEnergy = 0;

        Vector ptsArray;

        for ( int s = 2; s >= 2.0; s-- ) {

            for ( int z = 0; ( z < boundaryIterations ) && ( !threadStopped ); z++ ) {
                energy = 0;

                ptsArray = cleanLine( xPoints, yPoints );

                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];
                for ( i = 0; i < ptsArray.size(); i++ ) {
                    xPoints[i] = ( (Point2Df) ( ptsArray.elementAt( i ) ) ).x;
                    yPoints[i] = ( (Point2Df) ( ptsArray.elementAt( i ) ) ).y;
                }
                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];

                for ( i = 1; i < nPts - 1; i++ ) {

                    tangentDir.x = ( xPoints[i] - xPoints[i - 1] + xPoints[i + 1] - xPoints[i] ) / 2;
                    tangentDir.y = ( yPoints[i] - yPoints[i - 1] + yPoints[i + 1] - yPoints[i] ) / 2;

                    interpPt.x = xPoints[i];
                    interpPt.y = yPoints[i];

                    normLength = (float) Math.sqrt( tangentDir.x * tangentDir.x + tangentDir.y * tangentDir.y );
                    normDir.x = -tangentDir.y / normLength;
                    normDir.y = tangentDir.x / normLength;

                    normStep.x = stepPct * normDir.x;
                    normStep.y = stepPct * normDir.y;

                    outNormPt.x = -normStep.x + interpPt.x;
                    outNormPt.y = -normStep.y + interpPt.y;

                    inNormPt.x = normStep.x + interpPt.x;
                    inNormPt.y = normStep.y + interpPt.y;

                    ix = AlgorithmConvolver.convolve2DPt( interpPt, srcImage.getExtents(), image, kExtents, GxData );
                    iy = AlgorithmConvolver.convolve2DPt( interpPt, srcImage.getExtents(), image, kExtents, GyData );
                    // gradMag = (float)Math.sqrt(ix*ix + iy*iy);
                    gradMag = ( ix * ix + iy * iy );

                    if ( evolveDirection == OUT_DIR ) {
                        inGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt( inNormPt, srcImage.getExtents(), image, kExtents, GxData );
                        iy = AlgorithmConvolver.convolve2DPt( inNormPt, srcImage.getExtents(), image, kExtents, GyData );
                        // inGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        inGradMag = ( ix * ix + iy * iy );
                    }

                    if ( evolveDirection == IN_DIR ) {
                        outGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt( outNormPt, srcImage.getExtents(), image, kExtents, GxData );
                        iy = AlgorithmConvolver.convolve2DPt( outNormPt, srcImage.getExtents(), image, kExtents, GyData );
                        // outGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        outGradMag = ( ix * ix + iy * iy );
                    }

                    if ( outGradMag > gradMag || inGradMag > gradMag ) {
                        if ( outGradMag > inGradMag ) {
                            newXPts[i] = outNormPt.x;
                            newYPts[i] = outNormPt.y;
                            energy += outGradMag;
                        } else {
                            newXPts[i] = inNormPt.x;
                            newYPts[i] = inNormPt.y;
                            energy += inGradMag;
                        }
                    } else {
                        newXPts[i] = interpPt.x;
                        newYPts[i] = interpPt.y;
                        energy += gradMag;
                    }
                }
                if ( Math.abs( ( energy / oldEnergy ) - 1 ) < 0.0001 ) {
                    break;
                }
                oldEnergy = energy;

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
            }

        }
        // resultGon = new Polygon();
        for ( j = 1; j < yPoints.length - 1; j++ ) {
            resultGon.addPoint( Math.round( xPoints[j] ), Math.round( yPoints[j] ) );
        }
        return energy;
    }

    /**
     *   Removes points (vectors) that form sharp angles (i.e. smoothes boudnary)
     *   Also adds points separated by some distance and removes adjacent points
     *   @param xPts   x coords of points that define a contour
     *   @param yPts   y coords of points that define a contour
     *   @return an ordered list of the points along the cleaned-up line
     */
    private Vector cleanLine( float[] xPts, float[] yPts ) {
        int i;
        double distance;
        float midX, midY;
        Vector pts = new Vector( 50, 50 );

        for ( i = 0; i < xPts.length; i++ ) {
            pts.addElement( new Point2Df( xPts[i], yPts[i] ) );
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for ( i = 1; i < pts.size() - 1; i++ ) {

            distance = distance( ( (Point2Df) ( pts.elementAt( i ) ) ).x, ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x,
                    ( (Point2Df) ( pts.elementAt( i ) ) ).y, ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y );

            if ( distance > 3 ) {
                midX = (float) ( ( ( (Point2Df) ( pts.elementAt( i ) ) ).x + ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x )
                        / 2.0 );
                midY = (float) ( ( ( (Point2Df) ( pts.elementAt( i ) ) ).y + ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y )
                        / 2.0 );

                pts.insertElementAt( new Point2Df( midX, midY ), i + 1 );
                i--;
            } else if ( distance > 1 ) {} else {
                pts.removeElementAt( i + 1 );
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;

        end = pts.size() - 2;

        double magV1, magV2;
        double angle;
        double pt1x, pt1y, pt2x, pt2y, pt3x, pt3y;
        double v1x, v1y, v2x, v2y;

        while ( flag == true ) {
            flag = false;
            for ( i = 0; i < end; i++ ) {

                pt1x = ( (Point2Df) ( pts.elementAt( i ) ) ).x;
                pt1y = ( (Point2Df) ( pts.elementAt( i ) ) ).y;
                pt2x = ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x;
                pt2y = ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y;
                pt3x = ( (Point2Df) ( pts.elementAt( i + 2 ) ) ).x;
                pt3y = ( (Point2Df) ( pts.elementAt( i + 2 ) ) ).y;

                v1x = pt1x - pt2x;
                v1y = pt1y - pt2y;

                v2x = pt3x - pt2x;
                v2y = pt3y - pt2y;

                magV1 = Math.sqrt( v1x * v1x + v1y * v1y );
                v1x = v1x / magV1;
                v1y = v1y / magV1;

                magV2 = Math.sqrt( v2x * v2x + v2y * v2y );
                v2x = v2x / magV2;
                v2y = v2y / magV2;

                angle = Math.acos( v1x * v2x + v1y * v2y );
                // Smooth points
                if ( angle < smoothness ) {
                    pts.removeElementAt( i + 1 );
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }

    /**
     *   Prepares the data and runs the algorithm for a 3D image
     */
    private void calc3D() {

        int length;
        float[] imgBuffer;
        int slice;
        float baseEnergy = 0, energy, tempEnergy;
        int baseNPts = 0, nPts;
        Polygon tempGon;
        Polygon baseGon;
        float xPoints[], yPoints[];

        Polygon resultGon = null;
        Polygon[] gons = null;
        Vector[] contours;
        int nContours;
        int nSlices = srcImage.getExtents()[2];
        boolean failureFlag = false;

        try {
            length = srcImage.getSliceSize();
            imgBuffer = new float[length];
            buildProgressBar( srcImage.getImageName(), "Evolving boundary ...", 0, 100 );
            initProgressBar();
        } catch ( OutOfMemoryError e ) {
            displayError( "Algorithm snake: Out of memory" );
            setCompleted( false );
            return;
        }

        contours = srcVOI.getCurves();
        progressBar.updateValue( 30, activeImage );

        for ( slice = 0; slice < nSlices; slice++ ) {
            progressBar.updateValue( (int) ( 30 + ( (float) slice / ( nSlices - 1 ) ) * 70 ), activeImage );

            try {
                srcImage.exportData( slice * length, length, imgBuffer );
            } catch ( IOException error ) {
                displayError( "Algorithm snake: Image(s) locked" );
                setCompleted( false );
                return;
            }

            nContours = contours[slice].size();
            for ( int j = 0; j < nContours; j++ ) {
                if ( ( (VOIContour) ( contours[slice].elementAt( j ) ) ).isActive() ) {

                    ( (VOIContour) ( contours[slice].elementAt( j ) ) ).makeClockwise();

                    gons = srcVOI.exportPolygons( slice );

                    // @todo + 5 in AlgorithmBSnake (why?)
                    xPoints = new float[gons[j].npoints + 2];
                    yPoints = new float[gons[j].npoints + 2];

                    resultGon = new Polygon();
                    setPoints( xPoints, yPoints, gons[j] );

                    baseEnergy = runSnake( xPoints, yPoints, imgBuffer, resultGon );

                    baseNPts = resultGon.npoints;
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(),
                            Preferences.getTrimAdjacient() );
                    stSlice = slice;
                } else {
                    gons = srcVOI.exportPolygons( slice );
                    resultVOI.importPolygon( gons[j], slice );
                }
            }
        }

        if ( propagationType == PROP_SINGLE ) {
            progressBar.updateValue( 100, activeImage );
            setCompleted( true );
            progressBar.dispose();
            return;
        }

        slice = stSlice + 1;
        baseGon = new Polygon( resultGon.xpoints, resultGon.ypoints, resultGon.npoints );
        tempGon = resultGon;
        resultGon = new Polygon();
        Polygon optGon = null;

        tempEnergy = baseEnergy;

        // @todo + 5 in AlgorithmBSnake (why?)
        xPoints = new float[tempGon.npoints + 2];
        yPoints = new float[tempGon.npoints + 2];
        progressBar.updateValue( 25, activeImage );
        int percent = 25;
        int increment = ( 100 - percent ) / ( nSlices );

        AlgorithmVOISimplexOpt voiSimplex = new AlgorithmVOISimplexOpt( srcImage, sigmas, AlgorithmVOISimplexOpt.MAXSUM );

        if ( propagationType != PROP_PREV ) {
            while ( !threadStopped ) {

                try {
                    srcImage.exportData( slice * length, length, imgBuffer );
                } catch ( IOException error ) {
                    displayError( "Algorithm Snake: Image(s) locked" );
                    setCompleted( false );
                    progressBar.dispose();
                    return;
                }

                optGon = voiSimplex.goOptimize( imgBuffer, tempGon );
                percent += increment;
                progressBar.updateValue( percent, activeImage );
                setPoints( xPoints, yPoints, optGon );

                energy = runSnake( xPoints, yPoints, imgBuffer, resultGon );
                nPts = resultGon.npoints;

                if ( nPts < 8 || Math.abs( energy / tempEnergy - 1 ) > PROP_THRESHOLD
                        || Math.abs( ( energy / nPts ) / ( baseEnergy / baseNPts ) - 1 ) > PROP_THRESHOLD ) {
                    // if the energy sum changed too much, then the single propagation that we wanted to do has failed
                    if ( propagationType == PROP_NEXT ) {
                        setCompleted( false );
                        failureFlag = true;
                    }
                    break;
                } else {
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(), Preferences.getTrimAdjacient() );
                }

                // @todo + 5 in AlgorithmBSnake (why?)
                xPoints = new float[resultGon.npoints + 2];
                yPoints = new float[resultGon.npoints + 2];
                tempGon = resultGon;
                resultGon = new Polygon();
                tempEnergy = energy;
                slice++;

                if ( slice >= srcImage.getExtents()[2] ) {
                    // if we tried to propagate to the next slice, which doesn't exist
                    if ( propagationType == PROP_NEXT ) {
                        setCompleted( false );
                        failureFlag = true;
                    }
                    break;
                }

                // stop after propagating to one slice if PROP_NEXT
                if ( propagationType == PROP_NEXT ) {
                    progressBar.updateValue( 100, activeImage );
                    if ( !failureFlag ) {
                        setCompleted( true );
                    }
                    progressBar.dispose();
                    return;
                }
            }

            if ( threadStopped ) {
                finalize();
                return;
            }
        }

        if ( propagationType != PROP_NEXT ) {
            slice = stSlice - 1;
            tempEnergy = baseEnergy;
            tempGon = baseGon;

            // @todo + 5 in AlgorithmBSnake (why?)
            xPoints = new float[tempGon.npoints + 2];
            yPoints = new float[tempGon.npoints + 2];
            resultGon = new Polygon();
            progressBar.updateValue( percent, activeImage );
            while ( !threadStopped ) {

                try {
                    srcImage.exportData( slice * length, length, imgBuffer );
                } catch ( IOException error ) {
                    displayError( "Algorithm Bsnake: Image(s) locked" );
                    setCompleted( false );
                    progressBar.dispose();
                    return;
                }

                optGon = voiSimplex.goOptimize( imgBuffer, tempGon );
                percent += increment;
                progressBar.updateValue( percent, activeImage );
                setPoints( xPoints, yPoints, optGon );
                energy = runSnake( xPoints, yPoints, imgBuffer, resultGon );
                nPts = resultGon.npoints;

                if ( nPts < 8 || Math.abs( energy / tempEnergy - 1 ) > PROP_THRESHOLD
                        || Math.abs( ( energy / nPts ) / ( baseEnergy / baseNPts ) - 1 ) > PROP_THRESHOLD ) {
                    // if the energy sum changed too much, then the single propagation that we wanted to do has failed
                    if ( propagationType == PROP_PREV ) {
                        setCompleted( false );
                        failureFlag = true;
                    }
                    break;
                } else {
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(),
                            Preferences.getTrimAdjacient() );
                }

                // @todo + 5 in AlgorithmBSnake (why?)
                xPoints = new float[resultGon.npoints + 2];
                yPoints = new float[resultGon.npoints + 2];
                tempGon = resultGon;
                resultGon = new Polygon();
                tempEnergy = energy;
                slice--;

                if ( slice < 0 ) {
                    // if we tried to propagate to the previous slice, which doesn't exsist
                    if ( propagationType == PROP_PREV ) {
                        setCompleted( false );
                        failureFlag = true;
                    }
                    break;
                }

                // stop after propagating to one slice if PROP_PREV
                if ( propagationType == PROP_PREV ) {
                    progressBar.updateValue( 100, activeImage );
                    if ( !failureFlag ) {
                        setCompleted( true );
                    }
                    progressBar.dispose();
                    return;
                }
            }
            if ( threadStopped ) {
                finalize();
                return;
            }
        }

        progressBar.updateValue( 100, activeImage );
        if ( !failureFlag ) {
            setCompleted( true );
        }
        progressBar.dispose();
    }

    /**
     *   Calculates the euclidian distance between two points
     *   @param x1 first x coord.
     *   @param x2 seconde x coord.
     *   @param y1 first y1 coord.
     *   @param y2 seconde y2 coord.
     *   @return the distance between the points <code>(x1,y1)</code> and <code>(x2,y2)</code>
     */
    private final double distance( int x1, int x2, int y1, int y2 ) {
        return Math.sqrt( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) );
    }

    /**
     *   Calculates the euclidian distance between two points
     *   @param x1 first x coord.
     *   @param x2 seconde x coord.
     *   @param y1 first y1 coord.
     *   @param y2 seconde y2 coord.
     *   @return the distance between the points <code>(x1,y1)</code> and <code>(x2,y2)</code>
     */
    private final double distance( float x1, float x2, float y1, float y2 ) {
        return Math.sqrt( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) );
    }

}
