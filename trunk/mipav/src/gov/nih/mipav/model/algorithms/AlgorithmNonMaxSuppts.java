package gov.nih.mipav.model.algorithms;

import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.view.*;

import java.io.*;

import WildMagic.LibFoundation.Mathematics.Vector3f;

public class AlgorithmNonMaxSuppts extends AlgorithmBase {
	/** 
	Non-maximal suppression for features/corners
    Non maxima suppression and thresholding for points generated by a feature
    or corner detector.

	Note: An issue with integer valued images is that if there are multiple pixels
	all with the same value within distance 2*radius of each other then they will
	all be marked as local maxima. 

	Copyright (c) 2003-2013 Peter Kovesi
	Centre for Exploration Targeting
	The University of Western Australia
	peter.kovesi at uwa edu au
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, subject to the following conditions:
	 
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	
	The Software is provided "as is", without warranty of any kind.

	September 2003  Original version
	August    2005  Subpixel localization and Octave compatibility
	January   2010  Fix for completely horizontal and vertical lines (by Thomas Stehle,
                 RWTH Aachen University) 
	January   2011  Warning given if no maxima found
	*/
	
	private VOIVector VOIs;
	private int radius;
	private double threshold;
	private double xsubp[] = null;
	private double ysubp[] = null;
	private boolean subpixel;
	
	/**
	 * 
	 * @param destImg  Optional image.  If this is supplied, the thresholded corners are overlayed on
	 *                 this image.  This can be useful for parameter tuning
	 * @param srcImg   Corner strength image
	 * @param VOIs
	 * @param radius   Radius of the region considered in non-maximal suppression.
	 *                 Typical values to use might be 1-3 pixels.
	 * @param threshold
	 * @param hcd byte buffer containing corner points
	 */
	public AlgorithmNonMaxSuppts(ModelImage destImg, ModelImage srcImg, VOIVector VOIs, int radius, double threshold) {
		super(destImg, srcImg);	
		this.VOIs = VOIs;
		this.radius = radius;
		this.threshold = threshold;
		subpixel = false;
	}
	
	/**
	 * 
	 * @param destImg  Optional image.  If this is supplied, the thresholded corners are overlayed on
	 *                 this image.  This can be useful for parameter tuning
	 * @param srcImg   Corner strength image
	 * @param VOIs
	 * @param radius   Radius of the region considered in non-maximal suppression.
	 *                 Typical values to use might be 1-3 pixels.
	 * @param threshold
	 * @param xsubp  Sub-pixel localization of feature points is attempted and returned as as 
	 *               additional set of floating point coordinates.  Note that you may still want
	 *               to use the integer valued coordinates to specify centers of correlation
	 *               windows for feature matching.
	 * @param ysubp
	 */
	public AlgorithmNonMaxSuppts(ModelImage destImg, ModelImage srcImg, VOIVector VOIs, int radius, double threshold,
			                     double[] xsubp, double[] ysubp) {
		super(destImg, srcImg);
		this.VOIs = VOIs;
		this.radius = radius;
		this.threshold = threshold;
		this.xsubp = xsubp;
		this.ysubp = ysubp;
		subpixel = true;
	}

	 /**
     * finalize -
     */
    public void finalize() {
        super.finalize();
    }

    /**
     * Starts the program.
     */
    public void runAlgorithm() {
    	int xDim = srcImage.getExtents()[0];
    	int yDim = srcImage.getExtents()[1];
    	int sliceSize = xDim * yDim;
    	double cim[] = new double[sliceSize];
    	int y;
    	int x;
    	int ym;
    	int xm;
    	double maxVal;
    	double mx[] = new double[sliceSize];
    	byte hcd[] = new byte[sliceSize];
    	int index;
    	int cornersFound = 0;
    	int w;
    	int indxminus1;
    	int indxplus1;
    	int indyminus1;
    	int indyplus1;
    	double ax;
    	double bx;
    	double cx;
    	double xshift;
    	double ay;
    	double by;
    	double cy;
    	double yshift;
    	int presentCorner;
    	VOI newVOI;
    	Vector3f pt;
    
    	try {
    		srcImage.exportData(0, sliceSize, cim);
    	}
    	catch (IOException e) {
    		MipavUtil.displayError("IOException " + e + " on srcImage.exportData(0, sliceSize, cim)");
    		setCompleted(false);
    		return;
    	}
    	// Extract local maxima by performing a grey scale morphological dilation and then finding 
    	// points in the corner strength image, the srcImage, that match the dilated image and are 
    	// also greater than the threshold.
    	// Gray scale dilate
    	for (y = 0; y < yDim; y++) {
    		for (x = 0; x < xDim; x++) {
    		    maxVal = -Double.MAX_VALUE;
    		    for (ym = Math.max(0, y-radius); ym <= Math.min(yDim-1, y+radius); ym++) {
    		    	for (xm = Math.max(0,  x-radius); xm <= Math.min(xDim-1, x+radius); xm++) {
    		    	    if (cim[xm + ym * xDim] > maxVal) {
    		    	    	maxVal = cim[xm + ym * xDim];
    		    	    } // if (cim[xm + ym * xDim] > maxVal)
    		    	} // for (xm = Math.max(0,  x-radius); xm <= Math.min(xDim-1, x+radius); xm++)
    		    } // for (ym = Math.max(0, y-radius); ym <= Math.min(yDim-1, y+radius); ym++)
    		    mx[x + y * xDim] = maxVal;
    		} // for (x = 0; x < xDim; x++)
    	} // for (y = 0; y < yDim; y++)
    	
    	// Excluding points within a radius of the boundary find points where mx == buffer and value >= threshold
    	for (y = radius; y <= yDim - 1 - radius; y++) {
    		for (x = radius; x <= xDim - 1 - radius; x++) {
    			index = x + y * xDim;
    			if ((cim[index] == mx[index]) && (cim[index] >= threshold)) {
    				hcd[index] = 1;
    				if (VOIs != null) {
	    				newVOI = new VOI((short) cornersFound, "pt" + String.valueOf(cornersFound), VOI.POINT, -1);
	    				pt = new Vector3f(x, y, 0);
	    				newVOI.importPoint(pt);
	    				VOIs.add(newVOI);
    				}
    				cornersFound++;
    			} // if ((cim[index] == mx[index]) && (cim[index] >= threshold))
    		} // for (x = radius; x <= xDim - 1 - radius; x++)
    	} // for (y = radius; y <= yDim - 1 - radius; y++)
    	
    	if (cornersFound == 0) {
    		MipavUtil.displayWarning("No maxima above threshold found in AlgorithmNonMaxSuppts");
            setCompleted(true);
            return;
    	}
    	
    	try {
        	destImage.importData(0, hcd, true);
        }
        catch(IOException e) {
        	MipavUtil.displayError("IOException " + e + " on destImage.importData(0, hcd, true");
        	setCompleted(false);
        	return;
        }
    	
    	if (!subpixel) {
    		setCompleted(true);
    		return;
    	} // if (!subpixel)
    	
    	// Compute local maxima to subpixel accuracy
    	xsubp = new double[cornersFound];
    	ysubp = new double[cornersFound];
    	w = 1; // Width that we look out on each side of the feature point
    	       // to fit a local parabola
    	presentCorner = 0;
    	for (y = radius; y <= yDim - 1 - radius; y++) {
    		for (x = radius; x <= xDim - 1 - radius; x++) {
    			index = x + y * xDim;
    			if (hcd[index] == 1) {
    				// Indices of points left, right, above, and below feature point
    			    indxminus1 = Math.max(index-w, y*xDim);
    			    indxplus1 = Math.min(index+w, y*xDim + xDim-1);
    			    indyminus1 = Math.max(index - w*xDim, x);
    			    indyplus1 = Math.min(index + w*xDim, (yDim-1)*xDim + x);
    			    
    			    // Solve for quadratic across x
    			    cx = cim[index];
    			    ax = (cim[indxminus1] + cim[indxplus1])/2.0 - cx;
    			    bx = ax + cx - cim[indxminus1];
    			    if (ax != 0.0) {
    			    	xshift = -w*bx/(2.0*ax); // Maximum of quadratic
    			    } // if (ax != 0.0)
    			    else {
    			    	xshift = 0.0;
    			    }
    			    
    			    // Solve for quadratic down y
    			    cy = cim[index];
    			    ay = (cim[indyminus1] + cim[indyplus1])/2.0 - cy;
    			    by = ay + cy - cim[indyminus1];
    			    if (ay != 0.0) {
    			    	yshift = -w*by/(2.0*ay);
    			    } // if (ay != 0.0)
    			    else {
    			    	yshift = 0.0;
    			    }
    			    
    			    xsubp[presentCorner] = x + xshift;
    			    ysubp[presentCorner++] = y + yshift;
    			} // if (hcd[index] == 1)
    		} // for (x = radius; x <= xDim - 1 - radius; x++)
    	} // for (y = radius; y <= yDim - 1 - radius; y++)
    	
    	setCompleted(true);
    	return;
    }
}