package gov.nih.mipav.model.algorithms;


import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.view.*;
import gov.nih.mipav.model.file.*;

import java.awt.*;
import java.io.*;
import java.util.*;


/**
 *  Snake-like algorithm deriviative. The algorithm is supplied
 *  a polygon (VOI - contour) and that polygon is allowed to evolve to the edge of
 *  the object generated by calculating the gradient vector field.
 *  The user/programmer supplies the sigmas (scales) at which to
 *  calculate the edge map f = |grad(Gsigma(x,y)*I(x,y))|
 *  <p>
 *  2 iterative processes are used. The first calculates the gradient vector field.
 *  The gradient of the edge map is used to initialize the iterative equation
 *  for the gradient vector field.  In the second iterative process which calculates
 *  the boundary, the point is moved by the gradient vector field.
 *  <p>
 *  *  This original GVF algorithm has:<br>
 *  u[i] += mu*del2(u[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(u[i] - fx[i]);<br>
 *  v[i] += mu*del2(v[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(v[i] - fy[i]);<br>
 *  This program uses the generalized GVF algorithm with:<br>
 *  du/dt = g(|grad f|)del2xy(u) - h(|grad f|)*(u - fx)
 *  dv/dt = g(|grad f|)del2xy(v) - h(|grad f|)*(v - fy)
 *  g[i] = Math.exp(-(fx[i]*fx[i] + fy[i]*fy[i])/(k*k))<br>
 *  h[i] = 1 - g[i]
 *  du/dt = u(i,j,n+1) - u(i,j,n)/(delta t)
 *  del2xy(u) = (1/((delta x)(delta y)))*  (u(i+1,j,n) + u(i,j+1,n) +
 *            u(i-1,j,n) + u(i,j-1,n) - 4u(i,j,n) = del2(u)/((delta x)*(delta y))
 *  u(i,j,n+1) = u(i,j,n) + g(|grad f|)*(delta t)/((delta x)*(delta y)) * del2(u)
 *               - (1 - g(|grad f|)*(u - fx)*delta t
 *  Letting detla x = 1, delta y = 1, and delta t = 0.25:
 *  u[i] += 0.25f*(g[i]*del2(u[i]) - (1 - g[i])*(u[i] - fx[i]));<br>
 *  v[i] += 0.25f*(g[i]*del2(v[i]) - (1 - g[i])*(v[i] - fy[i]));<br>
 *  Stability for the original GVF algorithm requires mu <= 0.25f and stability for
 *  the generalized GVF algorithm requires that
 *   delta t <= (delta x * delta y)/(4 * gmax) = 1/4.
 *   For 3D:
 *   delta t <= (delta x * delta y * delta z)/(6* gmax) = 1/6.
 *  <p>
 *  A large scale slows the snake and causes the snake to conform to large scale structure.
 *  A small sigma value causes the snake to conform to the small scale structure
 *  is therefore more sensitive to noise. The three-dimensional version  is really
 *  a two-and-half dimensional algorithm where the resultant contour in a slice is
 *  projected into the adjacent slice and is used as an initialization to the
 *  evolution in the new slice.
 *  <p>
 *
 *  Useful references on gradient vector field:<br>
 *  1.) "Gradient Vector Flow: A New External Force For Snakes", Chenyang Xu and
 *       Jerry L. Prince, IEEE Proc. Conf. on Comp. Vis. Patt. Recog. (CVPR'97),
 *       pp. 66- 71.<br>
 *  2.) "Snakes, Shapes, and Gradient Vector Flow", Chenyang Xu and Jerry L. Prince,
 *       IEEE Transactions on Image Processing, March, 1998, pp. 359-369.<br>
 *  3.) "Generalized gradient vector flow external forces for active contours",
 *       Chenyang Xu and Jerry Prince, Signal Processing, 71(2), December, 1998, pp. 131-139.<br>
 *  4.) "Gradient Vector Flow Deformable Models", Handbook of Medical Imaging,
 *       ChenYang Xu and Jerry Prince, edited by I. Bankman, Academic Press, 2000, pp. 159-169.<br>
 *  5.) "Image Segmentation Using Deformable Models", Handbook of Medical Imaging -- Volume 2:
 *       Medical Imaging and Analysis, Chenyang Xu, Dzung Pham, and Jerry Prince, edited
 *       by J.M. Fitzpatrick and M. Sonka, SPIE Press, May, 2000, pp. 129-174.<br>
 *  More information on gradient vector field can be found at Chenyang Xu's homepage
 *  at http://iacl.ece.jhu.edu/~chenyang<br>
 *
 *  @see GenerateGaussian
 */
public class AlgorithmAGVF extends AlgorithmBase {

    private int stSlice;

    /**
     * Maximum iterations to generate generalized gradient vector field
     */
    private int gvfIterations = 200;

    /**
     * Maximum iterations to generate new boundary
     */
    private int boundaryIterations = 1000;

    /**
     * In the paper "Generalized gradient vector flow external forces for active contours"
     * by Chenyang Xu and Jerry Prince values of 0.05, 0.15, and 0.2 were used for k
     */
    private float kValue = 0.15f;

    /**
     *   The initial VOI to initialize the evolution process
     */
    private VOI srcVOI;

    /**
     *   The resultant polygon and the evolution has completed
     */
    private VOI resultVOI;

    /**
     *   If true propagate the contour to an adjacent slice
     */
    private boolean propagationFlag = true;

    private float smoothness;

    /**
     *   Dimensionality of the kernel
     */
    private int[] kExtents;

    /**
     *   Standard deviations of the gaussian used to calculate the kernels
     */
    private float[] sigmas;

    /* Only applies to 3D, if true do slice by slice */
    private boolean do25D = true;

    /**
     *   Storage location of the first derivative of the Gaussian in the X direction
     */
    private float[] GxData;

    /**
     *   Storage location of the first derivative of the Gaussian in the Y direction
     */
    private float[] GyData;

    /**
     *   Storage location of the first derivative of the Gaussian in the Z direction
     */
    private float[] GzData;
    private int xDim, yDim, zDim;
    private float[] uVal;
    private float[] vVal;
    private float[] wVal;
    private float[] gvfBuffer;
    private float[] expGvfBuffer;
    private float[] fx;
    private float[] fy;
    private float[] fz;
    private float[] gVal;
    private int length;
    private int[] extents;

    /**
     *
     *   @param resultImage image of GVF field magnitude
     *   @param srcImg     2D or 3D source image
     *   @param sigmas    describe the scale of the gaussian in each dimension
     *   @param gvfIterations iterations in calculating GVF field
     *   @param boundaryIterations iterations in calculating boundary
     *   @param k GVF constant
     *   @param smoothness
     *   @param srcVOI    VOI that is to be evolved
     *   @param do25D     only applies to 3D, if true do slice by slice
     */
    public AlgorithmAGVF( ModelImage resultImage, ModelImage srcImg, float[] sigmas,
            int gvfIterations, int boundaryIterations,
            float k, float smoothness, VOI srcVOI, boolean do25D ) {
        super( resultImage, srcImg );
        this.srcVOI = srcVOI;
        this.sigmas = sigmas;
        this.gvfIterations = gvfIterations;
        this.boundaryIterations = boundaryIterations;
        this.kValue = k;
        this.smoothness = smoothness;
        this.do25D = do25D;

        if ( srcImage.getNDims() == 2 ) {
            makeKernels2D();
            resultVOI = new VOI( (short) srcImage.getVOIs().size(), "AGVF_VOI", 1, VOI.CONTOUR, -1.0f );

        } else if ( srcImage.getNDims() > 2 ) {
            if ( do25D ) {
                makeKernels2D();
                resultVOI = new VOI( (short) srcImage.getVOIs().size(), "AGVF-VOI.voi", srcImage.getExtents()[2],
                        VOI.CONTOUR, -1.0f );
            } else {
                makeKernels3D();
                resultVOI = new VOI( (short) srcImage.getVOIs().size(), "AGVF-VOI.voi", srcImage.getExtents()[2],
                        VOI.CONTOUR, -1.0f );
            }
        } // else if (srcImage.getNDims() > 2)
    }

    /**
     *   Returns the resultant VOI.
     *   @return        resultant VOI that has localized to the boundaries of the object
     */
    public VOI getResultVOI() {
        return resultVOI;
    }

    /**
     *   Sets the propagation flag
     *   @param flag      if true result contour from a slice is propagated to the
     *                    adjacent slice and used to initialize the snake algorithm
     *                    for that slice. If false the snake algorithm stops after
     *                    optimizing the boundary in the present slice.
     */
    public void setPropagation( boolean flag ) {
        propagationFlag = flag;
    }

    /**
     *   Prepares this class for destruction
     */
    public void finalize() {
        uVal = null;
        vVal = null;
        wVal = null;
        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        srcImage = null;
        destImage = null;
        sigmas = null;
        extents = null;
        super.finalize();
    }

    /**
     *   Makes derivative kernels to be used in the calculation
     *   of the gradient magnitude.
     */
    private void makeKernels2D() {
        int xkDim, ykDim;
        int[] derivOrder = new int[2];

        kExtents = new int[2];
        derivOrder[0] = 1;
        derivOrder[1] = 0;

        xkDim = Math.round( 5 * sigmas[0] );
        if ( xkDim % 2 == 0 ) {
            xkDim++;
        }
        kExtents[0] = xkDim;

        ykDim = Math.round( 5 * sigmas[1] );
        if ( ykDim % 2 == 0 ) {
            ykDim++;
        }
        kExtents[1] = ykDim;

        GxData = new float[xkDim * ykDim];
        GenerateGaussian Gx = new GenerateGaussian( GxData, kExtents, sigmas, derivOrder );
        Gx.calc( false );

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        GyData = new float[xkDim * ykDim];
        GenerateGaussian Gy = new GenerateGaussian( GyData, kExtents, sigmas, derivOrder );
        Gy.calc( true );
    }

    /**
     *   Makes 3D derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels3D() {
        int xkDim, ykDim, zkDim;
        int[] derivOrder = new int[3];

        kExtents = new int[3];

        xkDim = Math.round( 5 * sigmas[0] );
        if ( xkDim % 2 == 0 ) {
            xkDim++;
        }
        kExtents[0] = xkDim;

        ykDim = Math.round( 5 * sigmas[1] );
        if ( ykDim % 2 == 0 ) {
            ykDim++;
        }
        kExtents[1] = ykDim;

        zkDim = Math.round( 5 * sigmas[2] );
        if ( zkDim % 2 == 0 ) {
            zkDim++;
        }
        kExtents[2] = zkDim;

        derivOrder[0] = 1;
        derivOrder[1] = 0;
        derivOrder[2] = 0;
        GxData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gx = new GenerateGaussian( GxData, kExtents, sigmas, derivOrder );
        Gx.calc( false );

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        derivOrder[2] = 0;
        GyData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gy = new GenerateGaussian( GyData, kExtents, sigmas, derivOrder );
        Gy.calc( true );

        derivOrder[0] = 0;
        derivOrder[1] = 0;
        derivOrder[2] = 1;
        GzData = new float[xkDim * ykDim * zkDim];
        GenerateGaussian Gz = new GenerateGaussian( GzData, kExtents, sigmas, derivOrder );
        Gz.calc( true );
    }

    /**
     * starts the snake algorithm
     */
    public void runAlgorithm() {

        if ( srcImage == null ) {
            displayError( "Source Image is null" );
            return;
        } else {
            if ( srcImage.getNDims() == 2 ) {
                calc2D();
            } else if ( srcImage.getNDims() > 2 ) {
                if ( do25D ) {
                    calc25D();
                } else {
                    calc3D();
                }
            }
        }
    }

    /**
     *   Prepares the data and runs the algorithm for a 2D image
     */
    private void calc2D() {

        float[] imgBuffer;
        float[] xPoints = null;
        float[] yPoints = null;
        Polygon resultGon = null;
        Polygon[] gons = null;
        Vector[] contours;
        int nVOI, nContours;

        int i;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;
        try {
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[( xDim + 2 ) * ( yDim + 2 )];
            fx = new float[( xDim + 2 ) * ( yDim + 2 )];
            fy = new float[( xDim + 2 ) * ( yDim + 2 )];
            uVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            vVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            gVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            srcImage.exportData( 0, length, imgBuffer ); // locks and releases lock
            this.buildProgressBar( srcImage.getImageName(), "Evolving boundary ...", 0, 100 );
        } catch ( IOException error ) {
            cleanup();
            progressBar.dispose();
            displayError( "Algorithm AGVF: Image(s) locked" );
            setCompleted( false );
            return;
        } catch ( OutOfMemoryError e ) {
            cleanup();
            progressBar.dispose();
            displayError( "Algorithm AGVF:  Out of Memory" );
            setCompleted( false );
            return;
        }

        this.initProgressBar();
        //progressBar.setLocation(xScreen/2, yScreen/2);
        //progressBar.setVisible(true);
        progressBar.updateValue( 25, activeImage );

        calcGVF( imgBuffer );
        expGvfBuffer = null;
        fx = null;
        fy = null;
        gVal = null;
        System.gc();

        if ( destFlag == true ) {
            for ( i = 0; i < length; i++ ) {
                gvfBuffer[i] = (float) Math.sqrt( uVal[i] * uVal[i] + vVal[i] * vVal[i] );
            }
            try {
                destImage.importData( 0, gvfBuffer, true );
            } catch ( IOException error ) {
                cleanup();
                MipavUtil.displayError(
                        "AlgorithmAGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)" + error );
                progressBar.dispose();
                setCompleted( false );
                return;
            }
        }
        gvfBuffer = null;
        System.gc();

        contours = srcVOI.getCurves();
        nContours = contours[0].size();
        progressBar.updateValue( 30, activeImage );

        for ( int j = 0; j < nContours; j++ ) {
            if ( ( (VOIContour) ( contours[0].elementAt( j ) ) ).isActive() ) {
                gons = srcVOI.exportPolygons( 0 );
                xPoints = new float[gons[j].npoints + 2];
                yPoints = new float[gons[j].npoints + 2];
                resultGon = new Polygon();
                setPoints( xPoints, yPoints, gons[j] );
                runSnake( xPoints, yPoints, uVal, vVal, resultGon );
                resultVOI.importPolygon( resultGon, 0 );
                ( (VOIContour) ( resultVOI.getCurves()[0].lastElement() ) ).trimPoints( Preferences.getTrim(),
                        Preferences.getTrimAdjacient() );
            } else {
                gons = srcVOI.exportPolygons( 0 );
                resultVOI.importPolygon( gons[j], 0 );
            }
            progressBar.updateValue( 30 + ( j / nContours - 1 ) * 70, activeImage );
        }

        progressBar.updateValue( 100, activeImage );
        if ( threadStopped ) {
            finalize();
            return;
        }

        cleanup();
        progressBar.dispose();
        setCompleted( true );
    }

    /**
     *   Takes the polygon and forms two special arrarys for use
     *   in runSnake.
     *   @param xPoints storage location of array of x coord. points
     *   @param yPoints storage location array of y coord. points
     *   @param gon     initial polygon
     */
    private void setPoints( float[] xPoints, float[] yPoints, Polygon gon ) {
        int i;

        xPoints[0] = gon.xpoints[gon.npoints - 1];
        yPoints[0] = gon.ypoints[gon.npoints - 1];

        for ( i = 0; i < gon.npoints; i++ ) {
            xPoints[i + 1] = gon.xpoints[i];
            yPoints[i + 1] = gon.ypoints[i];
        }

        xPoints[gon.npoints + 1] = gon.xpoints[0];
        yPoints[gon.npoints + 1] = gon.ypoints[0];
    }

    /**
     * Calculate GVF from image buffer
     * @param imgBuffer
     */
    private void calcGVF( float[] imgBuffer ) {
        float ix, iy;
        float gvfMin, gvfMax;
        int x, y;
        float del2;
        int iteration;
        //float       k = 0.15f;
        int i;

        uVal = new float[( xDim + 2 ) * ( yDim + 2 )];
        vVal = new float[( xDim + 2 ) * ( yDim + 2 )];
        // Edge map = |grad(Gsigma(x,y)*I(x,y))|
        for ( y = 0; y < yDim; y++ ) {
            for ( x = 0; x < xDim; x++ ) {
                i = x + xDim * y;
                if ( sigmas[0] != 0.0f ) {
                    ix = AlgorithmConvolver.convolveWhole2DPt( i, extents, imgBuffer, kExtents, GxData );
                } // if (sigmas[0] != 0.0f)
                else { // (sigmas[0] == 0.0f)
                    if ( x == 0 ) {
                        ix = imgBuffer[1 + y * xDim] - imgBuffer[i];
                    } else if ( x == ( xDim - 1 ) ) {
                        ix = imgBuffer[i] - imgBuffer[( xDim - 2 ) + y * xDim];
                    } else {
                        ix = ( imgBuffer[( x + 1 ) + y * xDim] - imgBuffer[( x - 1 ) + y * xDim] ) / 2.0f;
                    }
                } // else (sigmas[0] == 0.0f)
                if ( sigmas[1] != 0.0f ) {
                    iy = AlgorithmConvolver.convolveWhole2DPt( i, extents, imgBuffer, kExtents, GyData );
                } // if (sigmas[1] != 0.0f)
                else { // sigmas[1] == 0.0f
                    if ( y == 0 ) {
                        iy = imgBuffer[x + xDim] - imgBuffer[i];
                    } else if ( y == ( yDim - 1 ) ) {
                        iy = imgBuffer[i] - imgBuffer[x + ( yDim - 2 ) * xDim];
                    } else {
                        iy = ( imgBuffer[x + ( y + 1 ) * xDim] - imgBuffer[x + ( y - 1 ) * xDim] ) / 2.0f;
                    }
                } // else sigmas[1] == 0.0f
                gvfBuffer[i] = (float) Math.sqrt( ix * ix + iy * iy );
            } // for (x = 0; x < xDim; x++)
        } // for (y = 0; y < yDim; y++)

        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];
        for ( i = 1; i < length; i++ ) {
            if ( gvfBuffer[i] > gvfMax ) {
                gvfMax = gvfBuffer[i];
            }
            if ( gvfBuffer[i] < gvfMin ) {
                gvfMin = gvfBuffer[i];
            }
        }
        for ( i = 0; i < length; i++ ) {
            gvfBuffer[i] = ( gvfBuffer[i] - gvfMin ) / ( gvfMax - gvfMin );
        }

        // Take care of the boundary condition
        for ( y = 0; y < yDim; y++ ) {
            for ( x = 0; x < xDim; x++ ) {
                expGvfBuffer[( x + 1 ) + ( y + 1 ) * ( xDim + 2 )] = gvfBuffer[x + y * xDim];
            }
        }

        // Create a mirror at the corners
        expGvfBuffer[0] = gvfBuffer[1 + xDim];
        expGvfBuffer[xDim + 1] = gvfBuffer[( xDim - 2 ) + xDim];
        expGvfBuffer[( yDim + 1 ) * ( xDim + 2 )] = gvfBuffer[( yDim - 2 ) * xDim + 1];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) - 1] = gvfBuffer[( yDim - 2 ) * xDim + xDim - 2];

        // Mirror left and right boundaries
        for ( y = 0; y < yDim; y++ ) {
            expGvfBuffer[( y + 1 ) * ( xDim + 2 )] = gvfBuffer[y * xDim + 1];
            expGvfBuffer[( y + 1 ) * ( xDim + 2 ) + xDim + 1] = gvfBuffer[y * xDim + xDim - 2];
        }

        // Mirror top and bottom boundaries
        for ( x = 0; x < xDim; x++ ) {
            expGvfBuffer[x + 1] = gvfBuffer[xDim + x];
            expGvfBuffer[( yDim + 1 ) * ( xDim + 2 ) + x + 1] = gvfBuffer[( yDim - 2 ) * xDim + x];
        }

        // Calculate the x and y gradients
        for ( y = 0; y < ( yDim + 2 ); y++ ) {
            for ( x = 0; x < ( xDim + 2 ); x++ ) {
                if ( x == 0 ) {
                    fx[y * ( xDim + 2 )] = expGvfBuffer[1 + y * ( xDim + 2 )] - expGvfBuffer[y * ( xDim + 2 )];
                } else if ( x == ( xDim + 1 ) ) {
                    fx[xDim + 1 + y * ( xDim + 2 )] = expGvfBuffer[xDim + 1 + y * ( xDim + 2 )]
                            - expGvfBuffer[xDim + y * ( xDim + 2 )];
                } else {
                    fx[x + y * ( xDim + 2 )] = ( expGvfBuffer[( x + 1 ) + y * ( xDim + 2 )]
                            - expGvfBuffer[( x - 1 ) + y * ( xDim + 2 )] )
                                    / 2.0f;
                }
                if ( y == 0 ) {
                    fy[x] = expGvfBuffer[x + ( xDim + 2 )] - expGvfBuffer[x];
                } else if ( y == ( yDim + 1 ) ) {
                    fy[x + ( yDim + 1 ) * ( xDim + 2 )] = expGvfBuffer[x + ( yDim + 1 ) * ( xDim + 2 )]
                            - expGvfBuffer[x + yDim * ( xDim + 2 )];
                } else {
                    fy[x + y * ( xDim + 2 )] = ( expGvfBuffer[x + ( y + 1 ) * ( xDim + 2 )]
                            - expGvfBuffer[x + ( y - 1 ) * ( xDim + 2 )] )
                                    / 2.0f;
                }
            } // for (x = 0; x < (xDim+2); x++)
        } // for (y = 0; y < (yDim+2); y++)

        // Initialize GVF to the gradient
        for ( i = 0; i < fx.length; i++ ) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
        }

        for ( i = 0; i < fx.length; i++ ) {
            gVal[i] = (float) Math.exp( -( fx[i] * fx[i] + fy[i] * fy[i] ) / ( kValue * kValue ) );
        }

        for ( iteration = 0; ( iteration < gvfIterations ) && ( !threadStopped ); iteration++ ) {
            // Create a mirror at the u boundaries
            // Create a mirror at the corners
            uVal[0] = uVal[2 + 2 * ( xDim + 2 )];
            uVal[xDim + 1] = uVal[( xDim - 1 ) + 2 * ( xDim + 2 )];
            uVal[( yDim + 1 ) * ( xDim + 2 )] = uVal[( yDim - 1 ) * ( xDim + 2 ) + 2];
            uVal[( xDim + 2 ) * ( yDim + 2 ) - 1] = uVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1];

            // Mirror left and right boundaries
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                uVal[y * ( xDim + 2 )] = uVal[y * ( xDim + 2 ) + 2];
                uVal[y * ( xDim + 2 ) + xDim + 1] = uVal[y * ( xDim + 2 ) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for ( x = 1; x < ( xDim + 1 ); x++ ) {
                uVal[x] = uVal[2 * ( xDim + 2 ) + x];
                uVal[( yDim + 1 ) * ( xDim + 2 ) + x] = uVal[( yDim - 1 ) * ( xDim + 2 ) + x];
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the corners
            vVal[0] = vVal[2 + 2 * ( xDim + 2 )];
            vVal[xDim + 1] = vVal[( xDim - 1 ) + 2 * ( xDim + 2 )];
            vVal[( yDim + 1 ) * ( xDim + 2 )] = vVal[( yDim - 1 ) * ( xDim + 2 ) + 2];
            vVal[( xDim + 2 ) * ( yDim + 2 ) - 1] = vVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1];

            // Mirror left and right boundaries
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                vVal[y * ( xDim + 2 )] = vVal[y * ( xDim + 2 ) + 2];
                vVal[y * ( xDim + 2 ) + xDim + 1] = vVal[y * ( xDim + 2 ) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for ( x = 1; x < ( xDim + 1 ); x++ ) {
                vVal[x] = vVal[2 * ( xDim + 2 ) + x];
                vVal[( yDim + 1 ) * ( xDim + 2 ) + x] = vVal[( yDim - 1 ) * ( xDim + 2 ) + x];
            }

            for ( y = 0; y < ( yDim + 2 ); y++ ) {
                for ( x = 0; x < ( xDim + 2 ); x++ ) {
                    del2 = 0.0f;
                    i = x + y * ( xDim + 2 );
                    if ( x == 0 ) {
                        del2 += 2 * uVal[( x + 1 ) + y * ( xDim + 2 )];
                    } else if ( x == ( xDim + 1 ) ) {
                        del2 += 2 * uVal[( x - 1 ) + y * ( xDim + 2 )];
                    } else {
                        del2 += uVal[( x + 1 ) + y * ( xDim + 2 )] + uVal[( x - 1 ) + y * ( xDim + 2 )];
                    }
                    if ( y == 0 ) {
                        del2 += 2 * uVal[x + ( y + 1 ) * ( xDim + 2 )];
                    } else if ( y == ( yDim + 1 ) ) {
                        del2 += 2 * uVal[x + ( y - 1 ) * ( xDim + 2 )];
                    } else {
                        del2 += uVal[x + ( y + 1 ) * ( xDim + 2 )] + uVal[x + ( y - 1 ) * ( xDim + 2 )];
                    }
                    del2 -= 4 * uVal[i];
                    uVal[i] += 0.25f * ( gVal[i] * del2 - ( 1 - gVal[i] ) * ( uVal[i] - fx[i] ) );

                    del2 = 0.0f;
                    if ( x == 0 ) {
                        del2 += 2 * vVal[( x + 1 ) + y * ( xDim + 2 )];
                    } else if ( x == ( xDim + 1 ) ) {
                        del2 += 2 * vVal[( x - 1 ) + y * ( xDim + 2 )];
                    } else {
                        del2 += vVal[( x + 1 ) + y * ( xDim + 2 )] + vVal[( x - 1 ) + y * ( xDim + 2 )];
                    }
                    if ( y == 0 ) {
                        del2 += 2 * vVal[x + ( y + 1 ) * ( xDim + 2 )];
                    } else if ( y == ( yDim + 1 ) ) {
                        del2 += 2 * vVal[x + ( y - 1 ) * ( xDim + 2 )];
                    } else {
                        del2 += vVal[x + ( y + 1 ) * ( xDim + 2 )] + vVal[x + ( y - 1 ) * ( xDim + 2 )];
                    }
                    del2 -= 4 * vVal[i];
                    vVal[i] += 0.25f * ( gVal[i] * del2 - ( 1 - gVal[i] ) * ( vVal[i] - fy[i] ) );
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for ( y = 1; y < ( yDim + 1 ); y++ ) {
            for ( x = 1; x < ( xDim + 1 ); x++ ) {
                gvfBuffer[( x - 1 ) + ( y - 1 ) * xDim] = uVal[x + y * ( xDim + 2 )];
            }
        }

        uVal = new float[length];
        for ( i = 0; i < length; i++ ) {
            uVal[i] = gvfBuffer[i];
        }

        for ( y = 1; y < ( yDim + 1 ); y++ ) {
            for ( x = 1; x < ( xDim + 1 ); x++ ) {
                gvfBuffer[( x - 1 ) + ( y - 1 ) * xDim] = vVal[x + y * ( xDim + 2 )];
            }
        }

        vVal = new float[length];
        for ( i = 0; i < length; i++ ) {
            vVal[i] = gvfBuffer[i];
        }
        return;
    }

    /**
     *   Actual function that evolves the boundary
     *   @param xPoints   x coordinates that describe the contour
     *   @param yPoints   y coordinates that describe the contour
     *   @param u         x component of the GVF
     *   @param v         y component of the GVF
     *   @param resultGon resultant polygon
     */
    private void runSnake( float[] xPoints, float[] yPoints, float[] u, float[] v, Polygon resultGon ) {
        int i, j;
        int nPts;
        Point2Df interpPt = new Point2Df();
        float newXPts[] = null, newYPts[] = null;
        int position;
        boolean finished = false;

        Vector ptsArray;

        for ( int s = 2; s >= 2.0; s-- ) {
            for ( int z = 0; ( z < boundaryIterations ) && ( !finished ) && ( !threadStopped ); z++ ) {
                finished = true;

                ptsArray = cleanLine( xPoints, yPoints );

                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];
                for ( i = 0; i < ptsArray.size(); i++ ) {
                    xPoints[i] = ( (Point2Df) ( ptsArray.elementAt( i ) ) ).x;
                    yPoints[i] = ( (Point2Df) ( ptsArray.elementAt( i ) ) ).y;
                }
                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];

                for ( i = 1; i < nPts - 1; i++ ) {

                    interpPt.x = xPoints[i];
                    interpPt.y = yPoints[i];

                    position = (int) interpPt.x + xDim * (int) interpPt.y;
                    newXPts[i] = interpPt.x
                            + getBilinear( position, interpPt.x - (int) interpPt.x, interpPt.y - (int) interpPt.y,
                            extents, u );

                    newYPts[i] = interpPt.y
                            + getBilinear( position, interpPt.x - (int) interpPt.x, interpPt.y - (int) interpPt.y,
                            extents, v );
                    if ( ( Math.abs( newXPts[i] - interpPt.x ) >= 0.02f )
                            || ( Math.abs( newYPts[i] - interpPt.y ) >= 0.02f ) ) {
                        finished = false;
                    }
                }

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
            }
        }
        //resultGon = new Polygon();
        for ( j = 1; j < yPoints.length - 1; j++ ) {
            resultGon.addPoint( Math.round( xPoints[j] ), Math.round( yPoints[j] ) );
        }
        return;
    }

    /**
     *   Performs bilinear interpolation of image data.
     *   @param  i        index into image
     *   @param  dx       change in x from integer
     *   @param  dy       change in y from integer
     *   @param  iExtents dimensions of image
     *   @param  image    image data
     */
    private static final float getBilinear( int i, float dx, float dy,
            int[] iExtents, float[] image ) {

        int xDim = iExtents[0];
        float x1, x2;
        int ix, iy;

        // The below code prevents an out of bounds index being used for image
        // when the y coordinate is exactly equal to ydim - 1.
        if ( dx == 0.0f ) {
            ix = i;
        } else {
            ix = i + 1;
        }

        if ( dy == 0.0f ) {
            iy = 0;
        } else {
            iy = xDim;
        }

        x1 = ( 1 - dx ) * image[i] + dx * image[ix];
        x2 = ( 1 - dx ) * image[i + iy] + dx * image[ix + iy];

        return (float) ( ( 1 - dy ) * x1 + dy * x2 );
    }

    /**
     *   Removes points (vectors) that form sharp angles (i.e. smoothes boudnary)
     *   Also adds points separated by some distance and removes adjacent points
     *   @param xPts   x coords of points that define a contour
     *   @param yPts   y coords of points that define a contour
     */
    private Vector cleanLine( float[] xPts, float[] yPts ) {
        int i;
        double distance;
        float midX, midY;
        Vector pts = new Vector( 50, 50 );

        for ( i = 0; i < xPts.length; i++ ) {
            pts.addElement( new Point2Df( xPts[i], yPts[i] ) );
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for ( i = 1; i < pts.size() - 1; i++ ) {

            distance = distance( ( (Point2Df) ( pts.elementAt( i ) ) ).x, ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x,
                    ( (Point2Df) ( pts.elementAt( i ) ) ).y, ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y );

            if ( distance > 3 ) {
                midX = (float) ( ( ( (Point2Df) ( pts.elementAt( i ) ) ).x + ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x )
                        / 2.0 );
                midY = (float) ( ( ( (Point2Df) ( pts.elementAt( i ) ) ).y + ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y )
                        / 2.0 );

                pts.insertElementAt( new Point2Df( midX, midY ), i + 1 );
                i--;
            } else if ( distance > 1 ) {} else {
                pts.removeElementAt( i + 1 );
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;
        end = pts.size() - 2;

        double magV1, magV2;
        double angle;
        double pt1x, pt1y, pt2x, pt2y, pt3x, pt3y;
        double v1x, v1y, v2x, v2y;

        while ( flag == true ) {
            flag = false;
            for ( i = 0; i < end; i++ ) {

                pt1x = ( (Point2Df) ( pts.elementAt( i ) ) ).x;
                pt1y = ( (Point2Df) ( pts.elementAt( i ) ) ).y;
                pt2x = ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).x;
                pt2y = ( (Point2Df) ( pts.elementAt( i + 1 ) ) ).y;
                pt3x = ( (Point2Df) ( pts.elementAt( i + 2 ) ) ).x;
                pt3y = ( (Point2Df) ( pts.elementAt( i + 2 ) ) ).y;

                v1x = pt1x - pt2x;
                v1y = pt1y - pt2y;

                v2x = pt3x - pt2x;
                v2y = pt3y - pt2y;

                magV1 = Math.sqrt( v1x * v1x + v1y * v1y );
                v1x = v1x / magV1;
                v1y = v1y / magV1;

                magV2 = Math.sqrt( v2x * v2x + v2y * v2y );
                v2x = v2x / magV2;
                v2y = v2y / magV2;

                angle = Math.acos( v1x * v2x + v1y * v2y );
                // Smooth points
                if ( angle < smoothness ) {
                    pts.removeElementAt( i + 1 );
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }

    /**
     *   Prepares the data and runs the algorithm for a 3D image
     */
    private void calc25D() {

        float[] imgBuffer;
        int slice;
        float baseEnergy = 0, energy, tempEnergy;
        int baseNPts, nPts;
        Polygon tempGon;
        Polygon baseGon;
        float xPoints[], yPoints[];
        float xB[], yB[], zB[];
        int i;
        int nSlice;
        int slicesDone = 0;

        Polygon resultGon = null;
        Polygon[] gons = null;
        Vector[] contours;
        int nVOI, nContours;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        nSlice = srcImage.getExtents()[2];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;
        try {
            xB = new float[2];
            yB = new float[2];
            zB = new float[2];
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[( xDim + 2 ) * ( yDim + 2 )];
            fx = new float[( xDim + 2 ) * ( yDim + 2 )];
            fy = new float[( xDim + 2 ) * ( yDim + 2 )];
            uVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            vVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            gVal = new float[( xDim + 2 ) * ( yDim + 2 )];
            buildProgressBar( srcImage.getImageName(), "Evolving boundary ...", 0, 100 );
        } catch ( OutOfMemoryError e ) {
            cleanup();
            progressBar.dispose();
            displayError( "Algorithm AGVF: Out of memory" );
            setCompleted( false );
            return;
        }
        this.initProgressBar();

        contours = srcVOI.getCurves();
        progressBar.updateValue( 30, activeImage );

        //System.out.println("DestImage " + destImage.toString());

        srcVOI.getBounds( xB, yB, zB );
        for ( slice = (int) zB[0]; slice <= (float) zB[1]; slice++ ) {
            progressBar.updateValue( (int) ( 30 + ( (float) slice / ( nSlice - 1 ) ) * 70 ), activeImage );

            try {
                srcImage.exportData( slice * length, length, imgBuffer );
            } catch ( IOException error ) {
                cleanup();
                MipavUtil.displayError( "AlgorithmAGVF: IOException on srcImage" );
                progressBar.dispose();
                setCompleted( false );
                return;
            }
            calcGVF( imgBuffer );

            if ( destFlag == true ) {
                for ( i = 0; i < length; i++ ) {
                    gvfBuffer[i] = (float) Math.sqrt( uVal[i] * uVal[i] + vVal[i] * vVal[i] );
                }
                try {
                    destImage.importData( slice * length, gvfBuffer, false );
                } catch ( IOException error ) {
                    cleanup();
                    MipavUtil.displayError(
                            "AlgorithmAGVF: IOException on destImage" + ".importData(slice*length,gvfBuffer,false)"
                            + error );
                    progressBar.dispose();
                    setCompleted( false );
                    return;
                }
            }

            nContours = contours[slice].size();
            for ( int j = 0; j < nContours; j++ ) {
                if ( ( (VOIContour) ( contours[slice].elementAt( j ) ) ).isActive() ) {
                    gons = srcVOI.exportPolygons( slice );
                    xPoints = new float[gons[j].npoints + 2];
                    yPoints = new float[gons[j].npoints + 2];
                    resultGon = new Polygon();
                    setPoints( xPoints, yPoints, gons[j] );
                    runSnake( xPoints, yPoints, uVal, vVal, resultGon );
                    baseNPts = resultGon.npoints;
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(),
                            Preferences.getTrimAdjacient() );
                    stSlice = slice;
                } else {
                    gons = srcVOI.exportPolygons( slice );
                    resultVOI.importPolygon( gons[j], slice );
                }
            }
        }

        if ( threadStopped ) {
            finalize();
            return;
        }

        if ( propagationFlag == false ) {
            if ( destFlag == true ) {
                destImage.calcMinMax();
            }
            cleanup();
            progressBar.updateValue( 100, activeImage );
            progressBar.dispose();
            setCompleted( true );
            return;
        }

        slice = stSlice;
        baseGon = resultGon;
        slice++;
        tempGon = resultGon;
        xPoints = new float[tempGon.npoints + 2];
        yPoints = new float[tempGon.npoints + 2];
        resultGon = new Polygon();
        if ( slice < nSlice ) {
            while ( !threadStopped ) {

                try {
                    srcImage.exportData( slice * length, length, imgBuffer );
                } catch ( IOException error ) {
                    cleanup();
                    displayError( "Algorithm AGVF: Image(s) locked" );
                    setCompleted( false );
                    progressBar.dispose();
                    return;
                }

                calcGVF( imgBuffer );

                if ( destFlag == true ) {
                    for ( i = 0; i < length; i++ ) {
                        gvfBuffer[i] = (float) Math.sqrt( uVal[i] * uVal[i] + vVal[i] * vVal[i] );
                    }
                    try {
                        destImage.importData( slice * length, gvfBuffer, false );
                    } catch ( IOException error ) {
                        cleanup();
                        MipavUtil.displayError(
                                "AlgorithmAGVF: IOException on destImage" + ".importData(slice*length,gvfBuffer,false)" );
                        progressBar.dispose();
                        setCompleted( false );
                        return;
                    }
                }

                // this is where I need to add simplex optimization algo stuff
                setPoints( xPoints, yPoints, tempGon );

                runSnake( xPoints, yPoints, uVal, vVal, resultGon );
                slicesDone++;
                progressBar.updateValue( slicesDone * 100 / nSlice, activeImage );
                nPts = resultGon.npoints;

                if ( nPts < 8 ) {
                    break;
                } else {
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(),
                            Preferences.getTrimAdjacient() );
                }

                xPoints = new float[resultGon.npoints + 2];
                yPoints = new float[resultGon.npoints + 2];
                tempGon = resultGon;
                resultGon = new Polygon();
                slice++;

                if ( slice >= srcImage.getExtents()[2] ) {
                    break;
                }
            } // while (!threadStopped)
        } // if (slice < nSlice)
        if ( threadStopped ) {
            finalize();
            return;
        }

        slice = stSlice - 1;
        tempGon = baseGon;
        xPoints = new float[tempGon.npoints + 2];
        yPoints = new float[tempGon.npoints + 2];
        resultGon = new Polygon();
        slicesDone = nSlice - stSlice;
        progressBar.updateValue( 100 * slicesDone / nSlice, activeImage );
        if ( slice >= 0 ) {
            while ( !threadStopped ) {

                try {
                    srcImage.exportData( slice * length, length, imgBuffer );
                } catch ( IOException error ) {
                    cleanup();
                    displayError( "Algorithm AGVF: Image(s) locked" );
                    setCompleted( false );
                    progressBar.dispose();
                    return;
                }
                calcGVF( imgBuffer );

                if ( destFlag == true ) {
                    for ( i = 0; i < length; i++ ) {
                        gvfBuffer[i] = (float) Math.sqrt( uVal[i] * uVal[i] + vVal[i] * vVal[i] );
                    }
                    try {
                        destImage.importData( slice * length, gvfBuffer, false );
                    } catch ( IOException error ) {
                        cleanup();
                        MipavUtil.displayError(
                                "AlgorithmAGVF: IOException on destImage" + ".importData(slice*length,gvfBuffer,false)" );
                        progressBar.dispose();
                        setCompleted( false );
                        return;
                    }
                }

                // this is where I need to add simplex optimization algo stuff
                setPoints( xPoints, yPoints, tempGon );
                runSnake( xPoints, yPoints, uVal, vVal, resultGon );
                slicesDone++;
                progressBar.updateValue( slicesDone * 100 / nSlice, activeImage );
                nPts = resultGon.npoints;

                if ( nPts < 8 ) {
                    break;
                } else {
                    resultVOI.importPolygon( resultGon, slice );
                    ( (VOIContour) ( resultVOI.getCurves()[slice].lastElement() ) ).trimPoints( Preferences.getTrim(),
                            Preferences.getTrimAdjacient() );
                }

                xPoints = new float[resultGon.npoints + 2];
                yPoints = new float[resultGon.npoints + 2];
                tempGon = resultGon;
                resultGon = new Polygon();
                slice--;

                if ( slice < 0 ) {
                    break;
                }
            } // while (!threadStopped)
        } // if (slice >= 0)
        if ( threadStopped ) {
            finalize();
            return;
        }
        if ( destFlag == true ) {
            destImage.calcMinMax();
        }
        cleanup();
        progressBar.updateValue( 100, activeImage );
        setCompleted( true );
        progressBar.dispose();
    }

    /**
     *   Prepares the data and runs the algorithm for a 3D image
     */
    private void calc3D() {

        float[] imgBuffer;
        int slice;
        int baseNPts, nPts;
        Polygon tempGon;
        Polygon baseGon;
        float xPoints[], yPoints[];
        float xB[], yB[], zB[];
        int i;
        int sliceNum;
        int slicesDone = 0;

        Polygon resultGon = null;
        Polygon[] gons = null;
        Vector[] contours;
        int nVOI, nContours;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        zDim = srcImage.getExtents()[2];
        sliceNum = srcImage.getExtents()[2];
        extents = new int[3];
        extents[0] = xDim;
        extents[1] = yDim;
        extents[2] = zDim;
        try {
            xB = new float[2];
            yB = new float[2];
            zB = new float[2];
            length = xDim * yDim * zDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            fx = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            fy = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            fz = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            uVal = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            vVal = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            wVal = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];
            gVal = new float[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 2 )];

            this.buildProgressBar( srcImage.getImageName(), "Evolving boundary ...", 0, 100 );
        } catch ( OutOfMemoryError e ) {
            cleanup();
            progressBar.dispose();
            displayError( "Algorithm AGVF: Out of memory" );
            setCompleted( false );
            return;
        }

        this.initProgressBar();
        progressBar.updateValue( 0, activeImage );

        try {
            srcImage.exportData( 0, length, imgBuffer );
        } catch ( IOException error ) {
            cleanup();
            MipavUtil.displayError( "AlgorithmAGVF: IOException on srcImage.exportData" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }
        progressBar.setMessage( "Calculating 3D GVF" );
        calcGVF3D( imgBuffer );

        if ( destFlag == true ) {
            for ( i = 0; i < length; i++ ) {
                gvfBuffer[i] = (float) Math.sqrt( uVal[i] * uVal[i] + vVal[i] * vVal[i] + wVal[i] * wVal[i] );
            }
            try {
                destImage.importData( 0, gvfBuffer, true );
            } catch ( IOException error ) {
                cleanup();
                MipavUtil.displayError( "AlgorithmAGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)" );
                progressBar.dispose();
                setCompleted( false );
                return;
            }
        } // if (destFlag == true)

        /*contours  = srcVOI.getCurves();
         progressBar.updateValue(30);

         srcVOI.getBounds(xB, yB, zB);
         for (slice = (int)zB[0]; slice <= (float)zB[1]; slice++) {
         progressBar.updateValue((int)(30 + ((float)slice/(sliceNum-1))*70) );


         }

         nContours = contours[slice].size();
         for(int j = 0; j < nContours; j++){
         if ( ((VOIContour)(contours[slice].elementAt(j))).isActive() ) {
         gons    = srcVOI.exportPolygons(slice);
         xPoints = new float[gons[j].npoints+5];
         yPoints = new float[gons[j].npoints+5];
         resultGon = new Polygon();
         setPoints(xPoints, yPoints, gons[j]);
         runSnake(xPoints, yPoints, uVal, vVal, resultGon);
         baseNPts   = resultGon.npoints;
         resultVOI.importPolygon(resultGon, slice);
         ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints(
         Preferences.getTrim(), Preferences.getTrimAdjacient());
         stSlice = slice;
         }
         else {
         gons = srcVOI.exportPolygons(slice);
         resultVOI.importPolygon(gons[j], slice);
         }
         }
         }

         if (threadStopped) {
         finalize();
         return;
         }

         if (propagationFlag == false)  {
         cleanup();
         progressBar.updateValue(100);
         progressBar.dispose();
         setCompleted(true);
         return;
         }

         slice   = stSlice;
         baseGon = resultGon;
         slice++;
         tempGon    = resultGon;
         xPoints = new float[tempGon.npoints+5];
         yPoints = new float[tempGon.npoints+5];
         resultGon = new Polygon();
         if (slice < sliceNum) {
         while(!threadStopped) {

         try {
         srcImage.exportData(slice*length,length, imgBuffer);
         }
         catch (IOException error) {
         cleanup();
         displayError("Algorithm GVF: Image(s) locked");
         setCompleted(false);
         progressBar.dispose();
         return;
         }

         uVal = new float[(xDim+2)*(yDim+2)];
         vVal = new float[(xDim+2)*(yDim+2)];
         calcGVF(imgBuffer);

         if (destFlag == true) {
         for (i = 0; i < length; i++) {
         gvfBuffer[i] = (float)Math.sqrt(uVal[i]*uVal[i] + vVal[i]*vVal[i]);
         }
         try {
         destImage.importData(slice*length,gvfBuffer,false);
         }
         catch (IOException error) {
         cleanup();
         MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
         ".importData(slice*length,gvfBuffer,false)");
         progressBar.dispose();
         setCompleted(false);
         return;
         }
         }

         // this is where I need to add simplex optimization algo stuff
         setPoints(xPoints, yPoints, tempGon);
         runSnake(xPoints, yPoints, uVal, vVal, resultGon);
         slicesDone++;
         progressBar.updateValue(slicesDone * 100/sliceNum);
         nPts   = resultGon.npoints;
         Preferences.debug(" Points = " + nPts);

         if (nPts < 8) {
         break;
         }
         else{
         resultVOI.importPolygon(resultGon, slice);
         ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints(
         Preferences.getTrim(), Preferences.getTrimAdjacient());
         }

         xPoints = new float[resultGon.npoints+5];
         yPoints = new float[resultGon.npoints+5];
         tempGon = resultGon;
         resultGon = new Polygon();
         slice++;

         if (slice >= srcImage.getExtents()[2]) break;
         } // while(!threadStopped)
         } // if (slice < sliceNum)
         if (threadStopped) {
         finalize();
         return;
         }

         slice = stSlice-1;
         tempGon    = baseGon;
         xPoints = new float[tempGon.npoints+5];
         yPoints = new float[tempGon.npoints+5];
         resultGon = new Polygon();
         slicesDone = sliceNum - stSlice;
         progressBar.updateValue(slicesDone * 100/sliceNum);
         Preferences.debug("Going down");
         if (slice >= 0) {
         while(!threadStopped) {

         try {
         srcImage.exportData(slice*length,length, imgBuffer);
         }
         catch (IOException error) {
         cleanup();
         displayError("Algorithm GVF: Image(s) locked");
         setCompleted(false);
         progressBar.dispose();
         return;
         }

         uVal = new float[(xDim+2)*(yDim+2)];
         vVal = new float[(xDim+2)*(yDim+2)];
         calcGVF(imgBuffer);

         if (destFlag == true) {
         for (i = 0; i < length; i++) {
         gvfBuffer[i] = (float)Math.sqrt(uVal[i]*uVal[i] + vVal[i]*vVal[i]);
         }
         try {
         destImage.importData(slice*length,gvfBuffer,false);
         }
         catch (IOException error) {
         cleanup();
         MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
         ".importData(slice*length,gvfBuffer,false)");
         progressBar.dispose();
         setCompleted(false);

         return;
         }
         }

         // this is where I need to add simplex optimization algo stuff
         setPoints(xPoints, yPoints, tempGon);
         runSnake(xPoints, yPoints, uVal, vVal, resultGon);
         slicesDone++;
         progressBar.updateValue(slicesDone * 100/sliceNum);
         nPts   = resultGon.npoints;

         if (nPts < 8){
         break;
         }
         else{
         resultVOI.importPolygon(resultGon, slice);
         ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints(
         Preferences.getTrim(), Preferences.getTrimAdjacient());
         }

         xPoints = new float[resultGon.npoints+5];
         yPoints = new float[resultGon.npoints+5];
         tempGon = resultGon;
         resultGon = new Polygon();
         slice--;

         if (slice < 0) break;
         } // while (!threadStopped)
         } // if (slice >= 0)*/
        if ( threadStopped ) {
            finalize();
            return;
        }
        if ( destFlag == true ) {
            destImage.calcMinMax();
        }
        cleanup();
        progressBar.updateValue( 100, activeImage );
        progressBar.dispose();
        setCompleted( true );

    }

    /**
     * Calculate GVF from 3D image buffer
     * @param imgBuffer
     */
    private void calcGVF3D( float[] imgBuffer ) {
        float ix, iy, iz;
        float gvfMin, gvfMax;
        int x, y, z;
        float del2;
        int iteration;
        //float       k = 0.15f;
        int i, i1, i2;
        int sliceSize = xDim * yDim;
        int expSliceSize = ( xDim + 2 ) * ( yDim + 2 );

        // Edge map = |grad(Gsigma(x,y,z)*I(x,y,z))|
        for ( z = 0; z < zDim; z++ ) {
            i1 = z * sliceSize;
            for ( y = 0; y < yDim; y++ ) {
                i2 = i1 + xDim * y;
                for ( x = 0; x < xDim; x++ ) {
                    i = i2 + x;
                    ;
                    if ( sigmas[0] != 0.0f ) {
                        ix = AlgorithmConvolver.convolveWhole3DPt( i, extents, imgBuffer, kExtents, GxData );
                    } // if (sigmas[0] != 0.0f)
                    else { // (sigmas[0] == 0.0f)
                        if ( x == 0 ) {
                            ix = imgBuffer[1 + y * xDim + z * sliceSize] - imgBuffer[i];
                        } else if ( x == ( xDim - 1 ) ) {
                            ix = imgBuffer[i] - imgBuffer[( xDim - 2 ) + y * xDim + z * sliceSize];
                        } else {
                            ix = ( imgBuffer[( x + 1 ) + y * xDim + z * sliceSize]
                                    - imgBuffer[( x - 1 ) + y * xDim + z * sliceSize] )
                                            / 2.0f;
                        }
                    } // else (sigmas[0] == 0.0f)
                    if ( sigmas[1] != 0.0f ) {
                        iy = AlgorithmConvolver.convolveWhole3DPt( i, extents, imgBuffer, kExtents, GyData );
                    } // if (sigmas[1] != 0.0f)
                    else { // sigmas[1] == 0.0f
                        if ( y == 0 ) {
                            iy = imgBuffer[x + xDim + z * sliceSize] - imgBuffer[i];
                        } else if ( y == ( yDim - 1 ) ) {
                            iy = imgBuffer[i] - imgBuffer[x + ( yDim - 2 ) * xDim + z * sliceSize];
                        } else {
                            iy = ( imgBuffer[x + ( y + 1 ) * xDim + z * sliceSize]
                                    - imgBuffer[x + ( y - 1 ) * xDim + z * sliceSize] )
                                            / 2.0f;
                        }
                    } // else sigmas[1] == 0.0f
                    if ( sigmas[2] != 0.0 ) {
                        iz = AlgorithmConvolver.convolveWhole3DPt( i, extents, imgBuffer, kExtents, GzData );
                    } // if (sigmas[2] != 0.0f)
                    else { // sigmas[2] == 0.0f
                        if ( z == 0 ) {
                            iz = imgBuffer[x + y * xDim + sliceSize] - imgBuffer[x + y * xDim];
                        } else if ( z == ( zDim - 1 ) ) {
                            iz = imgBuffer[x + y * xDim + ( zDim - 1 ) * sliceSize]
                                    - imgBuffer[x + y * xDim + ( zDim - 2 ) * sliceSize];
                        } else {
                            iz = ( imgBuffer[x + y * xDim + ( z + 1 ) * sliceSize]
                                    - imgBuffer[x + y * xDim + ( z - 1 ) * sliceSize] )
                                            / 2.0f;
                        }
                    } // else sigmas[2] == 0.0f

                    gvfBuffer[i] = (float) Math.sqrt( ix * ix + iy * iy + iz * iz );
                } // for (x = 0; x < xDim; x++)
            } // for (y = 0; y < yDim; y++)
        } // for (z = 0; z < zDim; z++)

        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];
        for ( i = 1; i < length; i++ ) {
            if ( gvfBuffer[i] > gvfMax ) {
                gvfMax = gvfBuffer[i];
            }
            if ( gvfBuffer[i] < gvfMin ) {
                gvfMin = gvfBuffer[i];
            }
        }
        for ( i = 0; i < length; i++ ) {
            gvfBuffer[i] = ( gvfBuffer[i] - gvfMin ) / ( gvfMax - gvfMin );
        }

        // Take care of the boundary condition
        for ( z = 0; z < zDim; z++ ) {
            for ( y = 0; y < yDim; y++ ) {
                for ( x = 0; x < xDim; x++ ) {
                    expGvfBuffer[( x + 1 ) + ( y + 1 ) * ( xDim + 2 ) + ( z + 1 ) * expSliceSize] = gvfBuffer[x + y * xDim + z * sliceSize];
                }
            }
        }

        // Create a mirror at the 8 corner points
        expGvfBuffer[0] = gvfBuffer[1 + xDim + sliceSize];
        expGvfBuffer[xDim + 1] = gvfBuffer[( xDim - 2 ) + xDim + sliceSize];
        expGvfBuffer[( yDim + 1 ) * ( xDim + 2 )] = gvfBuffer[( yDim - 2 ) * xDim + 1 + sliceSize];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) - 1] = gvfBuffer[( yDim - 2 ) * xDim + xDim - 2 + sliceSize];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 1 )] = gvfBuffer[1 + xDim + sliceSize * ( zDim - 2 )];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 1 ) + xDim + 1] = gvfBuffer[( xDim - 2 ) + xDim + sliceSize * ( zDim - 2 )];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 1 ) + ( yDim + 1 ) * ( xDim + 2 )] = gvfBuffer[( yDim - 2 ) * xDim + 1 + sliceSize * ( zDim - 2 )];
        expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) * ( zDim + 1 ) + ( xDim + 2 ) * ( yDim + 2 ) - 1] = gvfBuffer[( yDim - 2 ) * xDim + xDim - 2 + sliceSize * ( zDim - 2 )];

        // Create a mirror at the corner line segments from x = 1 to x = xDim slices
        for ( x = 0; x < xDim; x++ ) {
            expGvfBuffer[x + 1] = gvfBuffer[x + xDim + sliceSize];
            expGvfBuffer[x + 1 + ( yDim + 1 ) * ( xDim + 2 )] = gvfBuffer[x + ( yDim - 2 ) * xDim + sliceSize];
            expGvfBuffer[x + 1 + ( zDim + 1 ) * expSliceSize] = gvfBuffer[x + xDim + ( zDim - 2 ) * sliceSize];
            expGvfBuffer[x + 1 + ( yDim + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = gvfBuffer[x + ( yDim - 2 ) * xDim + ( zDim - 2 ) * sliceSize];
        }

        // Create a mirror at the corner line segments from y = 1 to y = yDim slices
        for ( y = 0; y < yDim; y++ ) {
            expGvfBuffer[( y + 1 ) * ( xDim + 2 )] = gvfBuffer[1 + y * xDim + sliceSize];
            expGvfBuffer[xDim + 1 + ( y + 1 ) * ( xDim + 2 )] = gvfBuffer[xDim - 2 + y * xDim + sliceSize];
            expGvfBuffer[( y + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = gvfBuffer[1 + y * xDim + ( zDim - 2 ) * sliceSize];
            expGvfBuffer[xDim + 1 + ( y + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = gvfBuffer[xDim - 2 + y * xDim + ( zDim - 2 ) * sliceSize];
        }

        // Create a mirror at the corner line segments from z = 1 to z = zDim slices
        for ( z = 0; z < zDim; z++ ) {
            expGvfBuffer[( z + 1 ) * expSliceSize] = gvfBuffer[1 + xDim + z * sliceSize];
            expGvfBuffer[xDim + 1 + ( z + 1 ) * expSliceSize] = gvfBuffer[( xDim - 2 ) + xDim + z * sliceSize];
            expGvfBuffer[( yDim + 1 ) * ( xDim + 2 ) + ( z + 1 ) * expSliceSize] = gvfBuffer[( yDim - 2 ) * xDim + 1 + z * sliceSize];
            expGvfBuffer[( xDim + 2 ) * ( yDim + 2 ) - 1 + ( z + 1 ) * expSliceSize] = gvfBuffer[( yDim - 2 ) * xDim + xDim - 2 + z * sliceSize];
        }

        // Mirror left and right x boundaries
        for ( z = 0; z < zDim; z++ ) {
            for ( y = 0; y < yDim; y++ ) {
                expGvfBuffer[( y + 1 ) * ( xDim + 2 ) + ( z + 1 ) * expSliceSize] = gvfBuffer[z * sliceSize + y * xDim + 1];
                expGvfBuffer[( y + 1 ) * ( xDim + 2 ) + xDim + 1 + ( z + 1 ) * expSliceSize] = gvfBuffer[z * sliceSize + y * xDim + xDim - 2];
            }
        }

        // Mirror top and bottom y boundaries
        for ( z = 0; z < zDim; z++ ) {
            for ( x = 0; x < xDim; x++ ) {
                expGvfBuffer[x + 1 + ( z + 1 ) * expSliceSize] = gvfBuffer[z * sliceSize + xDim + x];
                expGvfBuffer[( yDim + 1 ) * ( xDim + 2 ) + x + 1 + ( z + 1 ) * expSliceSize] = gvfBuffer[z * sliceSize + ( yDim - 2 ) * xDim + x];
            }
        }

        // Mirror front and back z boundaries
        for ( y = 0; y < yDim; y++ ) {
            for ( x = 0; x < xDim; x++ ) {
                expGvfBuffer[x + 1 + ( y + 1 ) * ( xDim + 2 )] = gvfBuffer[sliceSize + y * xDim + x];
                expGvfBuffer[x + 1 + ( y + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = gvfBuffer[( zDim - 2 ) * sliceSize + y * xDim + x];
            }
        }

        // Calculate the x and y and z gradients
        for ( z = 0; z < ( zDim + 2 ); z++ ) {
            for ( y = 0; y < ( yDim + 2 ); y++ ) {
                for ( x = 0; x < ( xDim + 2 ); x++ ) {
                    if ( x == 0 ) {
                        fx[y * ( xDim + 2 ) + z * expSliceSize] = expGvfBuffer[1 + y * ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[y * ( xDim + 2 ) + z * expSliceSize];
                    } else if ( x == ( xDim + 1 ) ) {
                        fx[xDim + 1 + y * ( xDim + 2 ) + z * expSliceSize] = expGvfBuffer[xDim + 1 + y * ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[xDim + y * ( xDim + 2 ) + z * expSliceSize];
                    } else {
                        fx[x + y * ( xDim + 2 ) + z * expSliceSize] = ( expGvfBuffer[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize] )
                                        / 2.0f;
                    }
                    if ( y == 0 ) {
                        fy[x + z * expSliceSize] = expGvfBuffer[x + ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[x + z * expSliceSize];
                    } else if ( y == ( yDim + 1 ) ) {
                        fy[x + ( yDim + 1 ) * ( xDim + 2 ) + z * expSliceSize] = expGvfBuffer[x + ( yDim + 1 ) * ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[x + yDim * ( xDim + 2 ) + z * expSliceSize];
                    } else {
                        fy[x + y * ( xDim + 2 ) + z * expSliceSize] = ( expGvfBuffer[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize]
                                - expGvfBuffer[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize] )
                                        / 2.0f;
                    }
                    if ( z == 0 ) {
                        fz[x + y * ( xDim + 2 )] = expGvfBuffer[x + y * ( xDim + 2 ) + expSliceSize]
                                - expGvfBuffer[x + y * ( xDim + 2 )];
                    } else if ( z == ( zDim + 1 ) ) {
                        fz[x + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = expGvfBuffer[x + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize]
                                - expGvfBuffer[x + y * ( xDim + 2 ) + zDim * expSliceSize];
                    } else {
                        fz[x + y * ( xDim + 2 ) + z * expSliceSize] = ( expGvfBuffer[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize]
                                - expGvfBuffer[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize] )
                                        / 2.0f;
                    }
                } // for (x = 0; x < (xDim+2); x++)
            } // for (y = 0; y < (yDim+2); y++)
        } // for (z = 0; z < (zDim+2); z++)

        // Initialize GVF to the gradient
        for ( i = 0; i < fx.length; i++ ) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
            wVal[i] = fz[i];
        }

        for ( i = 0; i < fx.length; i++ ) {
            gVal[i] = (float) Math.exp( -( fx[i] * fx[i] + fy[i] * fy[i] + fz[i] * fz[i] ) / ( kValue * kValue ) );
        }

        //gvfIterations = 200;
        for ( iteration = 0; ( iteration < gvfIterations ) && ( !threadStopped ); iteration++ ) {
            // Create a mirror at the u boundaries
            // Create a mirror at the 8 corner points of the cube
            uVal[0] = uVal[2 + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            uVal[xDim + 1] = uVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            uVal[( yDim + 1 ) * ( xDim + 2 )] = uVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + 2 * expSliceSize];
            uVal[( xDim + 2 ) * ( yDim + 2 ) - 1] = uVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + 2 * expSliceSize];
            uVal[( zDim + 1 ) * expSliceSize] = uVal[2 + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            uVal[( zDim + 1 ) * expSliceSize + xDim + 1] = uVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            uVal[( zDim + 1 ) * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = uVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + ( zDim - 1 ) * expSliceSize];
            uVal[( zDim + 1 ) * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = uVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + ( zDim - 1 ) * expSliceSize];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for ( x = 1; x <= xDim; x++ ) {
                uVal[x] = uVal[x + 2 * ( xDim + 2 ) + 2 * expSliceSize];
                uVal[x + ( yDim + 1 ) * ( xDim + 2 )] = uVal[x + ( yDim - 1 ) * ( xDim + 2 ) + 2 * expSliceSize];
                uVal[x + ( zDim + 1 ) * expSliceSize] = uVal[x + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                uVal[x + ( yDim + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = uVal[x + ( yDim - 1 ) * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for ( y = 1; y <= yDim; y++ ) {
                uVal[y * ( xDim + 2 )] = uVal[2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                uVal[xDim + 1 + y * ( xDim + 2 )] = uVal[xDim - 2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                uVal[y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = uVal[2 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                uVal[xDim + 1 + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = uVal[xDim - 1 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for ( z = 1; z <= zDim; z++ ) {
                uVal[z * expSliceSize] = uVal[2 + 2 * ( xDim + 2 ) + z * expSliceSize];
                uVal[z * expSliceSize + xDim + 1] = uVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + z * expSliceSize];
                uVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = uVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + z * expSliceSize];
                uVal[z * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = uVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + z * expSliceSize];
            }

            // Mirror left and right x boundaries for z = 1 to z = zDim
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( y = 1; y < ( yDim + 1 ); y++ ) {
                    uVal[z * expSliceSize + y * ( xDim + 2 )] = uVal[z * expSliceSize + y * ( xDim + 2 ) + 2];
                    uVal[z * expSliceSize + y * ( xDim + 2 ) + xDim + 1] = uVal[z * expSliceSize + y * ( xDim + 2 ) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    uVal[z * expSliceSize + x] = uVal[z * expSliceSize + 2 * ( xDim + 2 ) + x];
                    uVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 ) + x] = uVal[z * expSliceSize + ( yDim - 1 ) * ( xDim + 2 ) + x];
                }
            }

            // Mirror front and back z boundaries
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    uVal[x + y * ( xDim + 2 )] = uVal[x + y * ( xDim + 2 ) + 2 * expSliceSize];
                    uVal[x + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = uVal[x + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                }
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the 8 corners
            vVal[0] = vVal[2 + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            vVal[xDim + 1] = vVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            vVal[( yDim + 1 ) * ( xDim + 2 )] = vVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + 2 * expSliceSize];
            vVal[( xDim + 2 ) * ( yDim + 2 ) - 1] = vVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + 2 * expSliceSize];
            vVal[( zDim + 1 ) * expSliceSize] = vVal[2 + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            vVal[( zDim + 1 ) * expSliceSize + xDim + 1] = vVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            vVal[( zDim + 1 ) * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = vVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + ( zDim - 1 ) * expSliceSize];
            vVal[( zDim + 1 ) * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = vVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + ( zDim - 1 ) * expSliceSize];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for ( x = 1; x <= xDim; x++ ) {
                vVal[x] = vVal[x + 2 * ( xDim + 2 ) + 2 * expSliceSize];
                vVal[x + ( yDim + 1 ) * ( xDim + 2 )] = vVal[x + ( yDim - 1 ) * ( xDim + 2 ) + 2 * expSliceSize];
                vVal[x + ( zDim + 1 ) * expSliceSize] = vVal[x + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                vVal[x + ( yDim + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = vVal[x + ( yDim - 1 ) * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for ( y = 1; y <= yDim; y++ ) {
                vVal[y * ( xDim + 2 )] = vVal[2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                vVal[xDim + 1 + y * ( xDim + 2 )] = vVal[xDim - 2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                vVal[y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = vVal[2 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                vVal[xDim + 1 + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = vVal[xDim - 1 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for ( z = 1; z <= zDim; z++ ) {
                vVal[z * expSliceSize] = vVal[2 + 2 * ( xDim + 2 ) + z * expSliceSize];
                vVal[z * expSliceSize + xDim + 1] = vVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + z * expSliceSize];
                vVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = vVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + z * expSliceSize];
                vVal[z * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = vVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + z * expSliceSize];
            }

            // Mirror left and right x boundaries
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( y = 1; y < ( yDim + 1 ); y++ ) {
                    vVal[z * expSliceSize + y * ( xDim + 2 )] = vVal[z * expSliceSize + y * ( xDim + 2 ) + 2];
                    vVal[z * expSliceSize + y * ( xDim + 2 ) + xDim + 1] = vVal[z * expSliceSize + y * ( xDim + 2 ) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    vVal[z * expSliceSize + x] = vVal[z * expSliceSize + 2 * ( xDim + 2 ) + x];
                    vVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 ) + x] = vVal[z * expSliceSize + ( yDim - 1 ) * ( xDim + 2 ) + x];
                }
            }

            // Mirror front and back z boundaries
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    vVal[x + y * ( xDim + 2 )] = vVal[x + y * ( xDim + 2 ) + 2 * expSliceSize];
                    vVal[x + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = vVal[x + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                }
            }

            // Create a mirror at the w boundaries
            // Create a mirror at the 8 corner points
            wVal[0] = wVal[2 + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            wVal[xDim + 1] = wVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + 2 * expSliceSize];
            wVal[( yDim + 1 ) * ( xDim + 2 )] = wVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + 2 * expSliceSize];
            wVal[( xDim + 2 ) * ( yDim + 2 ) - 1] = wVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + 2 * expSliceSize];
            wVal[( zDim + 1 ) * expSliceSize] = wVal[2 + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            wVal[( zDim + 1 ) * expSliceSize + xDim + 1] = wVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            wVal[( zDim + 1 ) * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = wVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + ( zDim - 1 ) * expSliceSize];
            wVal[( zDim + 1 ) * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = wVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + ( zDim - 1 ) * expSliceSize];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for ( x = 1; x <= xDim; x++ ) {
                wVal[x] = wVal[x + 2 * ( xDim + 2 ) + 2 * expSliceSize];
                wVal[x + ( yDim + 1 ) * ( xDim + 2 )] = wVal[x + ( yDim - 1 ) * ( xDim + 2 ) + 2 * expSliceSize];
                wVal[x + ( zDim + 1 ) * expSliceSize] = wVal[x + 2 * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                wVal[x + ( yDim + 1 ) * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = wVal[x + ( yDim - 1 ) * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for ( y = 1; y <= yDim; y++ ) {
                wVal[y * ( xDim + 2 )] = wVal[2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                wVal[xDim + 1 + y * ( xDim + 2 )] = wVal[xDim - 2 + y * ( xDim + 2 ) + 2 * expSliceSize];
                wVal[y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = wVal[2 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                wVal[xDim + 1 + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = wVal[xDim - 1 + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
            }

            // Create a mirror at the corner line segments for z = 1 to z = zDim
            for ( z = 1; z <= zDim; z++ ) {
                wVal[z * expSliceSize] = wVal[2 + 2 * ( xDim + 2 ) + z * expSliceSize];
                wVal[z * expSliceSize + xDim + 1] = wVal[( xDim - 1 ) + 2 * ( xDim + 2 ) + z * expSliceSize];
                wVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 )] = wVal[( yDim - 1 ) * ( xDim + 2 ) + 2 + z * expSliceSize];
                wVal[z * expSliceSize + ( xDim + 2 ) * ( yDim + 2 ) - 1] = wVal[( yDim - 1 ) * ( xDim + 2 ) + xDim - 1 + z * expSliceSize];
            }

            // Mirror left and right x boundaries
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( y = 1; y < ( yDim + 1 ); y++ ) {
                    wVal[z * expSliceSize + y * ( xDim + 2 )] = wVal[z * expSliceSize + y * ( xDim + 2 ) + 2];
                    wVal[z * expSliceSize + y * ( xDim + 2 ) + xDim + 1] = wVal[z * expSliceSize + y * ( xDim + 2 ) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for ( z = 1; z < ( zDim + 1 ); z++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    wVal[z * expSliceSize + x] = wVal[z * expSliceSize + 2 * ( xDim + 2 ) + x];
                    wVal[z * expSliceSize + ( yDim + 1 ) * ( xDim + 2 ) + x] = wVal[z * expSliceSize + ( yDim - 1 ) * ( xDim + 2 ) + x];
                }
            }

            // Mirror front and back z boundaries
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    wVal[x + y * ( xDim + 2 )] = wVal[x + y * ( xDim + 2 ) + 2 * expSliceSize];
                    wVal[x + y * ( xDim + 2 ) + ( zDim + 1 ) * expSliceSize] = wVal[x + y * ( xDim + 2 ) + ( zDim - 1 ) * expSliceSize];
                }
            }

            for ( z = 0; z < ( zDim + 2 ); z++ ) {
                i1 = z * expSliceSize;
                for ( y = 0; y < ( yDim + 2 ); y++ ) {
                    i2 = i1 + y * ( xDim + 2 );
                    for ( x = 0; x < ( xDim + 2 ); x++ ) {
                        del2 = 0.0f;
                        i = x + i2;
                        if ( x == 0 ) {
                            del2 += 2 * uVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( x == ( xDim + 1 ) ) {
                            del2 += 2 * uVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += uVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize]
                                    + uVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        }
                        if ( y == 0 ) {
                            del2 += 2 * uVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( y == ( yDim + 1 ) ) {
                            del2 += 2 * uVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += uVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize]
                                    + uVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];

                        }
                        if ( z == 0 ) {
                            del2 += 2 * uVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize];
                        } else if ( z == ( zDim + 1 ) ) {
                            del2 += 2 * uVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        } else {
                            del2 += uVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize]
                                    + +uVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        }
                        del2 -= 6 * uVal[i];
                        uVal[i] += 0.1666f * ( gVal[i] * del2 - ( 1 - gVal[i] ) * ( uVal[i] - fx[i] ) );

                        del2 = 0.0f;
                        if ( x == 0 ) {
                            del2 += 2 * vVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( x == ( xDim + 1 ) ) {
                            del2 += 2 * vVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += vVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize]
                                    + vVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        }
                        if ( y == 0 ) {
                            del2 += 2 * vVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( y == ( yDim + 1 ) ) {
                            del2 += 2 * vVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += vVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize]
                                    + vVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        }
                        if ( z == 0 ) {
                            del2 += 2 * vVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize];
                        } else if ( z == ( zDim + 1 ) ) {
                            del2 += 2 * vVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        } else {
                            del2 += vVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize]
                                    + +vVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        }
                        del2 -= 6 * vVal[i];
                        vVal[i] += 0.1666f * ( gVal[i] * del2 - ( 1 - gVal[i] ) * ( vVal[i] - fy[i] ) );

                        del2 = 0.0f;
                        if ( x == 0 ) {
                            del2 += 2 * wVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( x == ( xDim + 1 ) ) {
                            del2 += 2 * wVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += wVal[( x + 1 ) + y * ( xDim + 2 ) + z * expSliceSize]
                                    + wVal[( x - 1 ) + y * ( xDim + 2 ) + z * expSliceSize];
                        }
                        if ( y == 0 ) {
                            del2 += 2 * wVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else if ( y == ( yDim + 1 ) ) {
                            del2 += 2 * wVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        } else {
                            del2 += wVal[x + ( y + 1 ) * ( xDim + 2 ) + z * expSliceSize]
                                    + wVal[x + ( y - 1 ) * ( xDim + 2 ) + z * expSliceSize];
                        }
                        if ( z == 0 ) {
                            del2 += 2 * wVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize];
                        } else if ( z == ( zDim + 1 ) ) {
                            del2 += 2 * wVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        } else {
                            del2 += wVal[x + y * ( xDim + 2 ) + ( z + 1 ) * expSliceSize]
                                    + +wVal[x + y * ( xDim + 2 ) + ( z - 1 ) * expSliceSize];
                        }
                        del2 -= 6 * wVal[i];
                        wVal[i] += 0.1666f * ( gVal[i] * del2 - ( 1 - gVal[i] ) * ( wVal[i] - fz[i] ) );
                    }
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for ( z = 1; z < ( zDim + 1 ); z++ ) {
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    gvfBuffer[( x - 1 ) + ( y - 1 ) * xDim + ( z - 1 ) * sliceSize] = uVal[x + y * ( xDim + 2 ) + z * expSliceSize];
                }
            }
        }

        uVal = new float[length];
        for ( i = 0; i < length; i++ ) {
            uVal[i] = gvfBuffer[i];
        }

        for ( z = 1; z < ( zDim + 1 ); z++ ) {
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    gvfBuffer[( x - 1 ) + ( y - 1 ) * xDim + ( z - 1 ) * sliceSize] = vVal[x + y * ( xDim + 2 ) + z * expSliceSize];
                }
            }
        }

        vVal = new float[length];
        for ( i = 0; i < length; i++ ) {
            vVal[i] = gvfBuffer[i];
        }

        for ( z = 1; z < ( zDim + 1 ); z++ ) {
            for ( y = 1; y < ( yDim + 1 ); y++ ) {
                for ( x = 1; x < ( xDim + 1 ); x++ ) {
                    gvfBuffer[( x - 1 ) + ( y - 1 ) * xDim + ( z - 1 ) * sliceSize] = wVal[x + y * ( xDim + 2 ) + z * expSliceSize];
                }
            }
        }

        wVal = new float[length];
        for ( i = 0; i < length; i++ ) {
            wVal[i] = gvfBuffer[i];
        }

        ModelImage gvfImage = new ModelImage( ModelImage.FLOAT, srcImage.getExtents(), srcImage.getImageName() + "_uvf",
                srcImage.getUserInterface() );
        try {
            gvfImage.importData( 0, uVal, true );
        } catch ( IOException error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.importData" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }
        try {
            gvfImage.saveImage( srcImage.getFileInfo( 0 ).getFileDirectory(), srcImage.getImageName() + "_uvf",
                    FileBase.XML, true );
        } catch ( OutOfMemoryError error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.saveImage" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }
        try {
            gvfImage.importData( 0, vVal, true );
        } catch ( IOException error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.importData" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }

        try {
            gvfImage.saveImage( srcImage.getFileInfo( 0 ).getFileDirectory(), srcImage.getImageName() + "_vvf",
                    FileBase.XML, true );
        } catch ( OutOfMemoryError error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.saveImage" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }

        try {
            gvfImage.importData( 0, wVal, true );
        } catch ( IOException error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.importData" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }
        try {
            gvfImage.saveImage( srcImage.getFileInfo( 0 ).getFileDirectory(), srcImage.getImageName() + "_wvf",
                    FileBase.XML, true );
        } catch ( OutOfMemoryError error ) {
            if ( gvfImage != null ) {
                gvfImage.disposeLocal();
            }
            gvfImage = null;
            MipavUtil.displayError( "Error on gvfImage.saveImage" );
            progressBar.dispose();
            setCompleted( false );
            return;
        }

        gvfImage.disposeLocal();
        gvfImage = null;

        return;
    }

    /**
     *   Calculates the euclidian distance between two points
     *   @param x1 first x coord.
     *   @param x2 seconde x coord.
     *   @param y1 first y1 coord.
     *   @param y2 seconde y2 coord.
     */
    private final double distance( int x1, int x2, int y1, int y2 ) {
        return Math.sqrt( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) );
    }

    /**
     *   Calculates the euclidian distance between two points
     *   @param x1 first x coord.
     *   @param x2 seconde x coord.
     *   @param y1 first y1 coord.
     *   @param y2 seconde y2 coord.
     */
    private final double distance( float x1, float x2, float y1, float y2 ) {
        return Math.sqrt( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) );
    }

    /**
     *   Simple structure to use in the AlgorithmBSnake for special purpose
     */
    private class PointGM {
        public int index;
        public float gradMag;

        public PointGM( int i, float _gradMag ) {
            index = i;
            gradMag = _gradMag;

        }
    }

    /**
     * Sets structures to null
     */
    private void cleanup() {
        uVal = null;
        vVal = null;
        wVal = null;
        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        System.gc();
    }

}
