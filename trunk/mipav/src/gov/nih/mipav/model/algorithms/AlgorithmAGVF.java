package gov.nih.mipav.model.algorithms;


import WildMagic.LibFoundation.Mathematics.Vector2f;
import WildMagic.LibFoundation.Mathematics.Vector3f;
import gov.nih.mipav.util.MipavMath;
import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.*;

import java.awt.*;

import java.io.*;

import java.util.*;


/**
 * Snake-like algorithm deriviative. The algorithm is supplied a polygon (VOI - contour) and that polygon is allowed to
 * evolve to the edge of the object generated by calculating the gradient vector field. The user/programmer supplies the
 * sigmas (scales) at which to calculate the edge map f = |grad(Gsigma(x,y)*I(x,y))|
 *
 * <p>2 iterative processes are used. The first calculates the gradient vector field. The gradient of the edge map is
 * used to initialize the iterative equation for the gradient vector field. In the second iterative process which
 * calculates the boundary, the point is moved by the gradient vector field.</p>
 *
 * <p>* This original GVF algorithm has:<br>
 * u[i] += mu*del2(u[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(u[i] - fx[i]);<br>
 * v[i] += mu*del2(v[i]) - Math.sqrt(fx[i]*fx[i] + fy[i]*fy[i])*(v[i] - fy[i]);<br>
 * This program uses the generalized GVF algorithm with:<br>
 * du/dt = g(|grad f|)del2xy(u) - h(|grad f|)*(u - fx) dv/dt = g(|grad f|)del2xy(v) - h(|grad f|)*(v - fy) g[i] =
 * Math.exp(-(fx[i]*fx[i] + fy[i]*fy[i])/(k*k))<br>
 * h[i] = 1 - g[i] du/dt = u(i,j,n+1) - u(i,j,n)/(delta t) del2xy(u) = (1/((delta x)(delta y)))* (u(i+1,j,n) +
 * u(i,j+1,n) + u(i-1,j,n) + u(i,j-1,n) - 4u(i,j,n) = del2(u)/((delta x)*(delta y)) u(i,j,n+1) = u(i,j,n) + g(|grad
 * f|)*(delta t)/((delta x)*(delta y)) * del2(u) - (1 - g(|grad f|)*(u - fx)*delta t Letting detla x = 1, delta y = 1,
 * and delta t = 0.25: u[i] += 0.25f*(g[i]*del2(u[i]) - (1 - g[i])*(u[i] - fx[i]));<br>
 * v[i] += 0.25f*(g[i]*del2(v[i]) - (1 - g[i])*(v[i] - fy[i]));<br>
 * Stability for the original GVF algorithm requires mu <= 0.25f and stability for the generalized GVF algorithm
 * requires that delta t <= (delta x * delta y)/(4 * gmax) = 1/4. For 3D: delta t <= (delta x * delta y * delta z)/(6*
 * gmax) = 1/6.</p>
 *
 * <p>A large scale slows the snake and causes the snake to conform to large scale structure. A small sigma value causes
 * the snake to conform to the small scale structure is therefore more sensitive to noise. The three-dimensional version
 * is really a two-and-half dimensional algorithm where the resultant contour in a slice is projected into the adjacent
 * slice and is used as an initialization to the evolution in the new slice.</p>
 *
 * <p>Useful references on gradient vector field:<br>
 * 1.) "Gradient Vector Flow: A New External Force For Snakes", Chenyang Xu and Jerry L. Prince, IEEE Proc. Conf. on
 * Comp. Vis. Patt. Recog. (CVPR'97), pp. 66- 71.<br>
 * 2.) "Snakes, Shapes, and Gradient Vector Flow", Chenyang Xu and Jerry L. Prince, IEEE Transactions on Image
 * Processing, March, 1998, pp. 359-369.<br>
 * 3.) "Generalized gradient vector flow external forces for active contours", Chenyang Xu and Jerry Prince, Signal
 * Processing, 71(2), December, 1998, pp. 131-139.<br>
 * 4.) "Gradient Vector Flow Deformable Models", Handbook of Medical Imaging, ChenYang Xu and Jerry Prince, edited by I.
 * Bankman, Academic Press, 2000, pp. 159-169.<br>
 * 5.) "Image Segmentation Using Deformable Models", Handbook of Medical Imaging -- Volume 2: Medical Imaging and
 * Analysis, Chenyang Xu, Dzung Pham, and Jerry Prince, edited by J.M. Fitzpatrick and M. Sonka, SPIE Press, May, 2000,
 * pp. 129-174.<br>
 * More information on gradient vector field can be found at Chenyang Xu's homepage at http://iacl.ece.jhu.edu/~chenyang
 * <br>
 * </p>
 *
 * @see  GenerateGaussian
 */
public class AlgorithmAGVF extends AlgorithmBase implements AlgorithmInterface {

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** Maximum iterations to generate new boundary. */
    protected int boundaryIterations = 1000;

    /** DOCUMENT ME! */
    protected int[] extents;

    /** DOCUMENT ME! */
    protected int xDim, yDim, zDim;

    /** Only applies to 3D, if true do slice by slice. */
    private boolean do25D = true;

    /** DOCUMENT ME! */
    private float[] expGvfBuffer;

    /** DOCUMENT ME! */
    private float[] fx;

    /** DOCUMENT ME! */
    private float[] fy;

    /** DOCUMENT ME! */
    private float[] fz;

    /** DOCUMENT ME! */
    private float[] gVal;

    /** DOCUMENT ME! */
    private float[] gvfBuffer;

    /** Maximum iterations to generate generalized gradient vector field. */
    private int gvfIterations = 200;

    /** Storage location of the first derivative of the Gaussian in the X direction. */
    private float[] GxData;

    /** Storage location of the first derivative of the Gaussian in the Y direction. */
    private float[] GyData;

    /** Storage location of the first derivative of the Gaussian in the Z direction. */
    private float[] GzData;

    /** Dimensionality of the kernel. */
    private int[] kExtents;

    /**
     * In the paper "Generalized gradient vector flow external forces for active contours" by Chenyang Xu and Jerry
     * Prince values of 0.05, 0.15, and 0.2 were used for k.
     */
    private float kValue = 0.15f;

    /** DOCUMENT ME! */
    private int length;

    /** If true propagate the contour to an adjacent slice. */
    private boolean propagationFlag = true;

    /** The resultant polygon and the evolution has completed. */
    private VOI resultVOI;

    /** Standard deviations of the gaussian used to calculate the kernels. */
    private float[] sigmas;

    /** DOCUMENT ME! */
    private float smoothness;

    /** The initial VOI to initialize the evolution process. */
    private VOI srcVOI;

    /** DOCUMENT ME! */
    private int stSlice;

    /** DOCUMENT ME! */
    private float[] uVal;

    /** DOCUMENT ME! */
    private float[] vVal;

    /** DOCUMENT ME! */
    private float[] wVal;
    
    // Storage for result of AlgorithmConvolver
    private float[] outputBuffer = null;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Creates a new AlgorithmAGVF object.
     *
     * @param  resultImage         image of GVF field magnitude
     * @param  srcImg              2D or 3D source image
     * @param  sigmas              describe the scale of the gaussian in each dimension
     * @param  gvfIterations       iterations in calculating GVF field
     * @param  boundaryIterations  iterations in calculating boundary
     * @param  k                   GVF constant
     * @param  smoothness          DOCUMENT ME!
     * @param  srcVOI              VOI that is to be evolved
     * @param  do25D               only applies to 3D, if true do slice by slice
     */
    public AlgorithmAGVF(ModelImage resultImage, ModelImage srcImg, float[] sigmas, int gvfIterations,
                         int boundaryIterations, float k, float smoothness, VOI srcVOI, boolean do25D) {
        super(resultImage, srcImg);
        this.srcVOI = srcVOI;
        this.sigmas = sigmas;
        this.gvfIterations = gvfIterations;
        this.boundaryIterations = boundaryIterations;
        this.kValue = k;
        this.smoothness = smoothness;
        this.do25D = do25D;

        if (srcImage.getNDims() == 2) {
            makeKernels2D();
            resultVOI = new VOI((short) srcImage.getVOIs().size(), "AGVF_VOI", VOI.CONTOUR, -1.0f);

        } else if (srcImage.getNDims() > 2) {

            if (do25D) {
                makeKernels2D();
                resultVOI = new VOI((short) srcImage.getVOIs().size(), "AGVF-VOI.voi",
                                    VOI.CONTOUR, -1.0f);
            } else {
                makeKernels3D();
                resultVOI = new VOI((short) srcImage.getVOIs().size(), "AGVF-VOI.voi",
                                    VOI.CONTOUR, -1.0f);
            }
        } // else if (srcImage.getNDims() > 2)
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Prepares this class for destruction.
     */
    public void finalize() {
        uVal = null;
        vVal = null;
        wVal = null;
        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        srcImage = null;
        destImage = null;
        sigmas = null;
        extents = null;
        super.finalize();
    }

    /**
     * Returns the resultant VOI.
     *
     * @return  resultant VOI that has localized to the boundaries of the object
     */
    public VOI getResultVOI() {
        return resultVOI;
    }

    /**
     * starts the snake algorithm.
     */
    public void runAlgorithm() {
        AlgorithmConvolver convolver;

        if (srcImage == null) {
            displayError("Source Image is null");

            return;
        } else {
            fireProgressStateChanged(srcImage.getImageName(), "Evolving boundary ...");
            if (((srcImage.getNDims() == 2) || do25D) && ((sigmas[0] != 0.0) || (sigmas[1] != 0.0))) {
                if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0)) {
                    boolean entireImage = true;
                    boolean sqrtXY = true;
                    convolver = new AlgorithmConvolver(srcImage, GxData, GyData, kExtents, entireImage, sqrtXY);
                }
                else if (sigmas[0] != 0.0) {
                    convolver = new AlgorithmConvolver(srcImage, GxData, kExtents, true, true);
                }
                else { // sigmas[1] != 0.0
                    convolver = new AlgorithmConvolver(srcImage, GyData, kExtents, true, true);
                }
                convolver.setMinProgressValue(0);
                convolver.setMaxProgressValue(10);
                linkProgressToAlgorithm(convolver);
                convolver.addListener(this);
                convolver.run();
                convolver.finalize();    
            } // if (((srcImage.getNDims() == 2) || do25D) && ((sigmas[0] != 0.0) || (sigmas[1] != 0.0)))
            else if ((srcImage.getNDims() == 3) && (sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0)) {
                convolver = new AlgorithmConvolver(srcImage, GxData, GyData, GzData, kExtents, true); 
                convolver.setMinProgressValue(0);
                convolver.setMaxProgressValue(10);
                linkProgressToAlgorithm(convolver);
                convolver.addListener(this);
                convolver.run();
                convolver.finalize();    
            } // else if ((srcImage.getNDims() == 3) && (sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0))

            if (srcImage.getNDims() == 2) {
                calc2D();
            } else if (srcImage.getNDims() > 2) {

                if (do25D) {
                    calc25D();
                } else {
                    calc3D();
                }
            }
        }
    }

    /**
     * Sets the propagation flag.
     *
     * @param  flag  if true result contour from a slice is propagated to the adjacent slice and used to initialize the
     *               snake algorithm for that slice. If false the snake algorithm stops after optimizing the boundary in
     *               the present slice.
     */
    public void setPropagation(boolean flag) {
        propagationFlag = flag;
    }

    /**
     * Performs bilinear interpolation of image data.
     *
     * @param   i         index into image
     * @param   dx        change in x from integer
     * @param   dy        change in y from integer
     * @param   iExtents  dimensions of image
     * @param   image     image data
     *
     * @return  DOCUMENT ME!
     */
    protected static float getBilinear(int i, float dx, float dy, int[] iExtents, float[] image) {

        int xDim = iExtents[0];
        float x1, x2;
        int ix, iy;

        // The below code prevents an out of bounds index being used for image
        // when the y coordinate is exactly equal to ydim - 1.
        if (dx == 0.0f) {
            ix = i;
        } else {
            ix = i + 1;
        }

        if (dy == 0.0f) {
            iy = 0;
        } else {
            iy = xDim;
        }

        x1 = ((1 - dx) * image[i]) + (dx * image[ix]);
        x2 = ((1 - dx) * image[i + iy]) + (dx * image[ix + iy]);

        return (float) (((1 - dy) * x1) + (dy * x2));
    }

    /**
     * Removes points (vectors) that form sharp angles (i.e. smoothes boudnary) Also adds points separated by some
     * distance and removes adjacent points
     *
     * @param   xPts  x coords of points that define a contour
     * @param   yPts  y coords of points that define a contour
     *
     * @return  DOCUMENT ME!
     */
    protected Vector<Vector2f> cleanLine(float[] xPts, float[] yPts) {
        int i;
        double distance;
        float midX, midY;
        Vector<Vector2f> pts = new Vector<Vector2f>(50, 50);

        for (i = 0; i < xPts.length; i++) {
            pts.addElement(new Vector2f(xPts[i], yPts[i]));
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for (i = 1; i < (pts.size() - 1); i++) {

            distance = distance(((Vector2f) (pts.elementAt(i))).X, ((Vector2f) (pts.elementAt(i + 1))).X,
                                ((Vector2f) (pts.elementAt(i))).Y, ((Vector2f) (pts.elementAt(i + 1))).Y);

            if (distance > 3) {
                midX = (float) ((((Vector2f) (pts.elementAt(i))).X + ((Vector2f) (pts.elementAt(i + 1))).X) / 2.0);
                midY = (float) ((((Vector2f) (pts.elementAt(i))).Y + ((Vector2f) (pts.elementAt(i + 1))).Y) / 2.0);

                pts.insertElementAt(new Vector2f(midX, midY), i + 1);
                i--;
            } else if (distance > 1) { }
            else {
                pts.removeElementAt(i + 1);
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;
        end = pts.size() - 2;

        double magV1, magV2;
        double angle;
        double pt1x, pt1y, pt2x, pt2y, pt3x, pt3y;
        double v1x, v1y, v2x, v2y;

        while (flag == true) {
            flag = false;

            for (i = 0; i < end; i++) {

                pt1x = ((Vector2f) (pts.elementAt(i))).X;
                pt1y = ((Vector2f) (pts.elementAt(i))).Y;
                pt2x = ((Vector2f) (pts.elementAt(i + 1))).X;
                pt2y = ((Vector2f) (pts.elementAt(i + 1))).Y;
                pt3x = ((Vector2f) (pts.elementAt(i + 2))).X;
                pt3y = ((Vector2f) (pts.elementAt(i + 2))).Y;

                v1x = pt1x - pt2x;
                v1y = pt1y - pt2y;

                v2x = pt3x - pt2x;
                v2y = pt3y - pt2y;

                magV1 = Math.sqrt((v1x * v1x) + (v1y * v1y));
                v1x = v1x / magV1;
                v1y = v1y / magV1;

                magV2 = Math.sqrt((v2x * v2x) + (v2y * v2y));
                v2x = v2x / magV2;
                v2y = v2y / magV2;

                angle = Math.acos((v1x * v2x) + (v1y * v2y));

                // Smooth points
                if (angle < smoothness) {
                    pts.removeElementAt(i + 1);
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }



    private Vector<Vector3f> cleanLine(float[] xPts, float[] yPts, float[] zPts) {
        int i;
        double distance;
        float midX, midY, midZ;
        Vector<Vector3f> pts = new Vector<Vector3f>();

        for (i = 0; i < xPts.length; i++) {
            pts.addElement(new Vector3f(xPts[i], yPts[i], zPts[i]));
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for (i = 1; i < (pts.size() - 1); i++) {

            distance = MipavMath.distance( pts.elementAt(i), pts.elementAt(i+1) );

            if (distance > 3) {
                midX = (float) ((((pts.elementAt(i))).X + ((pts.elementAt(i + 1))).X) / 2.0);
                midY = (float) ((((pts.elementAt(i))).Y + ((pts.elementAt(i + 1))).Y) / 2.0);
                midZ = (float) ((((pts.elementAt(i))).Z + ((pts.elementAt(i + 1))).Z) / 2.0);

                pts.insertElementAt(new Vector3f(midX, midY, midZ), i + 1);
                i--;
            } else if (distance > 1) { }
            else {
                pts.removeElementAt(i + 1);
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;

        end = pts.size() - 2;

        double angle;
        Vector3f v1 = new Vector3f();
        Vector3f v2 = new Vector3f();
        while (flag == true) {
            flag = false;

            for (i = 0; i < end; i++) {

                v1.copy( pts.elementAt(i) ).sub( pts.elementAt(i+1) );
                v2.copy( pts.elementAt(i+2) ).sub( pts.elementAt(i+1) );

                v1.normalize();
                v2.normalize();
                angle = Vector3f.angle(v1,v2);

                // Smooth points
                if (angle < smoothness) {
                    pts.removeElementAt(i + 1);
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }

    
    
    
    /**
     * Sets structures to null.
     */
    protected void cleanup() {
        uVal = null;
        vVal = null;
        wVal = null;
        gvfBuffer = null;
        expGvfBuffer = null;
        gVal = null;
        fx = null;
        fy = null;
        fz = null;
        GxData = null;
        GyData = null;
        GzData = null;
        kExtents = null;
        System.gc();
    }

    /**
     * Actual function that evolves the boundary.
     *
     * @param  xPoints    x coordinates that describe the contour
     * @param  yPoints    y coordinates that describe the contour
     * @param  u          x component of the GVF
     * @param  v          y component of the GVF
     * @param  resultGon  resultant polygon
     */
    protected void runSnake(float[] xPoints, float[] yPoints, float[] u, float[] v, Polygon resultGon) {
        int i, j;
        int nPts;
        Vector2f interpPt = new Vector2f();
        float[] newXPts = null, newYPts = null;
        int position;
        boolean finished = false;

        Vector<Vector2f> ptsArray;

        for (int s = 2; s >= 2.0; s--) {

            for (int z = 0; (z < boundaryIterations) && (!finished) && (!threadStopped); z++) {
                finished = true;

                ptsArray = cleanLine(xPoints, yPoints);

                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];

                for (i = 0; i < ptsArray.size(); i++) {
                    xPoints[i] = ((Vector2f) (ptsArray.elementAt(i))).X;
                    yPoints[i] = ((Vector2f) (ptsArray.elementAt(i))).Y;
                }

                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];

                for (i = 1; i < (nPts - 1); i++) {

                    interpPt.X = xPoints[i];
                    interpPt.Y = yPoints[i];

                    position = (int) interpPt.X + (xDim * (int) interpPt.Y);
                    newXPts[i] = interpPt.X +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, u);

                    newYPts[i] = interpPt.Y +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, v);

                    if ((Math.abs(newXPts[i] - interpPt.X) >= 0.02f) || (Math.abs(newYPts[i] - interpPt.Y) >= 0.02f)) {
                        finished = false;
                    }
                }

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
            }
        }

        // resultGon = new Polygon();
        for (j = 1; j < (yPoints.length - 1); j++) {
            resultGon.addPoint(Math.round(xPoints[j]), Math.round(yPoints[j]));
        }

        return;
    }
    
    
    /**
     * Actual function that evolves the boundary.
     *
     * @param  xPoints    x coordinates that describe the contour
     * @param  yPoints    y coordinates that describe the contour
     * @param  u          x component of the GVF
     * @param  v          y component of the GVF
     * @param  resultGon  resultant polygon
     */
    protected void runSnake(float[] xPoints, float[] yPoints, float[] zPoints, float[] u, float[] v, VOIBase resultContour) {
        int i, j;
        int nPts;
        Vector2f interpPt = new Vector2f();
        float[] newXPts = null, newYPts = null, newZPts;
        int position;
        boolean finished = false;

        Vector<Vector3f> ptsArray;

        for (int s = 2; s >= 2.0; s--) {

            for (int z = 0; (z < boundaryIterations) && (!finished) && (!threadStopped); z++) {
                finished = true;
                ptsArray = cleanLine(xPoints, yPoints, zPoints);
                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];
                zPoints = new float[ptsArray.size()];

                for (i = 0; i < ptsArray.size(); i++) {
                    xPoints[i] = ptsArray.elementAt(i).X;
                    yPoints[i] = ptsArray.elementAt(i).Y;
                    zPoints[i] = ptsArray.elementAt(i).Z;
                }

                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];
                newZPts = new float[xPoints.length];

                for (i = 1; i < (nPts - 1); i++) {

                    interpPt.X = xPoints[i];
                    interpPt.Y = yPoints[i];

                    position = (int) interpPt.X + (xDim * (int) interpPt.Y);
                    newXPts[i] = interpPt.X +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, u);

                    newYPts[i] = interpPt.Y +
                                 getBilinear(position, interpPt.X - (int) interpPt.X, interpPt.Y - (int) interpPt.Y,
                                             extents, v);

                    if ((Math.abs(newXPts[i] - interpPt.X) >= 0.02f) || (Math.abs(newYPts[i] - interpPt.Y) >= 0.02f)) {
                        finished = false;
                    }
                    newZPts[i] = zPoints[i];
                }

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newZPts[0] = newZPts[i - 1];
                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];
                newZPts[i] = newZPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
                zPoints = newZPts;
            }
        }
        for (j = 1; j < (yPoints.length - 1); j++) {
            resultContour.add( new Vector3f( Math.round(xPoints[j]), Math.round(yPoints[j]), Math.round(zPoints[j])) );
        }

        return;
    }

    /**
     * Prepares the data and runs the algorithm for a 3D image.
     */
    private void calc25D() {

        float[] imgBuffer;
        int slice;
        int nPts;
        float[] xPoints, yPoints, zPoints;
        float[] xB, yB, zB;
        int i;
        int nSlice;
        int slicesDone = 0;
        Vector<VOIBase> contours;
        int nContours;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        nSlice = srcImage.getExtents()[2];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;

        try {
            xB = new float[2];
            yB = new float[2];
            zB = new float[2];
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2)];
        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm AGVF: Out of memory");
            setCompleted(false);

            return;
        }

        contours = srcVOI.getCurves();
        fireProgressStateChanged(30);

        // System.out.println("DestImage " + destImage.toString());

        srcVOI.getBounds(xB, yB, zB);
        
        VOIContour resultContour = null;
        for (slice = (int) zB[0]; slice <= zB[1]; slice++) {
            fireProgressStateChanged((int) (30 + (((float) slice / (nSlice - 1)) * 70)));

            try {
                srcImage.exportData(slice * length, length, imgBuffer);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmAGVF: IOException on srcImage");

                setCompleted(false);

                return;
            }

            calcGVF(slice, imgBuffer);

            if (destFlag == true) {

                for (i = 0; i < length; i++) {
                    gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                }

                try {
                    destImage.importData(slice * length, gvfBuffer, false);
                } catch (IOException error) {
                    cleanup();
                    MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
                                           ".importData(slice*length,gvfBuffer,false)" + error);

                    setCompleted(false);

                    return;
                }
            }

            nContours = contours.size();

            for (int j = 0; j < nContours; j++) {

                if (((VOIContour) (contours.elementAt(j))).isActive()) {
                    int nPoints = contours.elementAt(j).size();
                    xPoints = new float[nPoints + 2];
                    yPoints = new float[nPoints + 2];
                    zPoints = new float[nPoints + 2];
                    setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));
                    resultContour = new VOIContour(false, true);
                    runSnake(xPoints, yPoints, zPoints, uVal, vVal, resultContour);
                    resultContour.trimPoints(Preferences.getTrimVoi(),
                            Preferences.getTrimAdjacient());
                    if ( resultContour.size() > 0 )
                    {
                        resultContour.update();
                        resultVOI.importCurve(resultContour);
                    }
                    stSlice = slice;
                } else {
                    resultVOI.importCurve( contours.elementAt(j) );
                }
            }
        }

        if (threadStopped) {
            finalize();

            return;
        }

        if (propagationFlag == false || resultContour == null ) {

            if (destFlag == true) {
                destImage.calcMinMax();
            }

            cleanup();
            fireProgressStateChanged(100);

            setCompleted(true);

            return;
        }

        slice = stSlice;
        slice++;
        VOIContour tempContour = new VOIContour( resultContour, 1 );

        if (slice < nSlice) {

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, imgBuffer);
                } catch (IOException error) {
                    cleanup();
                    displayError("Algorithm AGVF: Image(s) locked");
                    setCompleted(false);


                    return;
                }
                calcGVF(slice, imgBuffer);
                if (destFlag == true) {

                    for (i = 0; i < length; i++) {
                        gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                    }

                    try {
                        destImage.importData(slice * length, gvfBuffer, false);
                    } catch (IOException error) {
                        cleanup();
                        MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
                                               ".importData(slice*length,gvfBuffer,false)");

                        setCompleted(false);

                        return;
                    }
                }

                xPoints = new float[tempContour.size() + 2];
                yPoints = new float[tempContour.size() + 2];
                zPoints = new float[tempContour.size() + 2];
                // this is where I need to add simplex optimization algo stuff
                setPoints(xPoints, yPoints, zPoints, tempContour);
                tempContour.clear();
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, tempContour);
                slicesDone++;
                fireProgressStateChanged(slicesDone * 100 / nSlice);
                nPts = tempContour.size();

                if (nPts < 8) {
                    break;
                } else {
                    tempContour.trimPoints(Preferences.getTrimVoi(), Preferences.getTrimAdjacient());
                    resultVOI.importCurve(tempContour);
                }
                tempContour = new VOIContour(tempContour, 1);
                slice++;

                if (slice >= srcImage.getExtents()[2]) {
                    break;
                }
            } // while (!threadStopped)
        } // if (slice < nSlice)

        if (threadStopped) {
            finalize();

            return;
        }

        slice = stSlice - 1;
        tempContour = new VOIContour( resultContour, -1 );
        xPoints = new float[tempContour.size() + 2];
        yPoints = new float[tempContour.size() + 2];
        zPoints = new float[tempContour.size() + 2];
        slicesDone = nSlice - stSlice;
        fireProgressStateChanged(100 * slicesDone / nSlice);

        if (slice >= 0) {

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, imgBuffer);
                } catch (IOException error) {
                    cleanup();
                    displayError("Algorithm AGVF: Image(s) locked");
                    setCompleted(false);


                    return;
                }

                calcGVF(slice, imgBuffer);

                if (destFlag == true) {

                    for (i = 0; i < length; i++) {
                        gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
                    }

                    try {
                        destImage.importData(slice * length, gvfBuffer, false);
                    } catch (IOException error) {
                        cleanup();
                        MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
                                               ".importData(slice*length,gvfBuffer,false)");

                        setCompleted(false);

                        return;
                    }
                }

                // this is where I need to add simplex optimization algo stuff
                setPoints(xPoints, yPoints, zPoints, tempContour);
                tempContour.clear();
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, tempContour);
                slicesDone++;
                fireProgressStateChanged(slicesDone * 100 / nSlice);
                nPts = tempContour.size();

                if (nPts < 8) {
                    break;
                } else {
                    tempContour.trimPoints(Preferences.getTrimVoi(), Preferences.getTrimAdjacient());
                    resultVOI.importCurve(tempContour);
                }

                xPoints = new float[tempContour.size() + 2];
                yPoints = new float[tempContour.size() + 2];
                zPoints = new float[tempContour.size() + 2];
                tempContour = new VOIContour( tempContour, -1 );
                slice--;

                if (slice < 0) {
                    break;
                }
            } // while (!threadStopped)
        } // if (slice >= 0)

        if (threadStopped) {
            finalize();

            return;
        }

        if (destFlag == true) {
            destImage.calcMinMax();
        }

        cleanup();
        fireProgressStateChanged(100);
        setCompleted(true);

    }

    /**
     * Prepares the data and runs the algorithm for a 2D image.
     */
    private void calc2D() {

        float[] imgBuffer;
        float[] xPoints = null;
        float[] yPoints = null;
        float[] zPoints = null;
        Vector<VOIBase> contours;
        int nContours;

        int i;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        extents = new int[2];
        extents[0] = xDim;
        extents[1] = yDim;

        try {
            length = xDim * yDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2)];
            srcImage.exportData(0, length, imgBuffer); // locks and releases lock
        } catch (IOException error) {
            cleanup();

            displayError("Algorithm AGVF: Image(s) locked");
            setCompleted(false);

            return;
        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm AGVF:  Out of Memory");
            setCompleted(false);

            return;
        }

        //
        //
        fireProgressStateChanged(25);

        calcGVF(0, imgBuffer);
        expGvfBuffer = null;
        fx = null;
        fy = null;
        gVal = null;
        System.gc();

        if (destFlag == true) {

            for (i = 0; i < length; i++) {
                gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]));
            }

            try {
                destImage.importData(0, gvfBuffer, true);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)" +
                                       error);

                setCompleted(false);

                return;
            }
        }

        gvfBuffer = null;
        System.gc();

        contours = srcVOI.getCurves();
        nContours = contours.size();
        fireProgressStateChanged(30);

        for (int j = 0; j < nContours; j++) {

            if (((VOIContour) (contours.elementAt(j))).isActive()) {
                int nPoints = contours.elementAt(j).size();
                xPoints = new float[nPoints + 2];
                yPoints = new float[nPoints + 2];
                zPoints = new float[nPoints + 2];
                setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));
                VOIContour resultContour = new VOIContour(false, true);
                runSnake(xPoints, yPoints, zPoints, uVal, vVal, resultContour);
                resultContour.trimPoints(Preferences.getTrimVoi(),
                        Preferences.getTrimAdjacient());
                if ( resultContour.size() > 0 )
                {
                    resultContour.update();
                    resultVOI.importCurve(resultContour);
                }
            } else {
                resultVOI.importCurve( contours.elementAt(j) );
            }

            fireProgressStateChanged(30 + (((j / nContours) - 1) * 70));
        }

        fireProgressStateChanged(100);

        if (threadStopped) {
            finalize();

            return;
        }

        cleanup();

        setCompleted(true);
    }

    /**
     * Prepares the data and runs the algorithm for a 3D image.
     */
    private void calc3D() {

        float[] imgBuffer;
        int i;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];
        zDim = srcImage.getExtents()[2];
        extents = new int[3];
        extents[0] = xDim;
        extents[1] = yDim;
        extents[2] = zDim;

        try {
            length = xDim * yDim * zDim;
            imgBuffer = new float[length];
            gvfBuffer = new float[length];
            expGvfBuffer = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fx = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fy = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            fz = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            uVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            vVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            wVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];
            gVal = new float[(xDim + 2) * (yDim + 2) * (zDim + 2)];

        } catch (OutOfMemoryError e) {
            cleanup();

            displayError("Algorithm AGVF: Out of memory");
            setCompleted(false);

            return;
        }

        fireProgressStateChanged(0);

        try {
            srcImage.exportData(0, length, imgBuffer);
        } catch (IOException error) {
            cleanup();
            MipavUtil.displayError("AlgorithmAGVF: IOException on srcImage.exportData");

            setCompleted(false);

            return;
        }

        fireProgressStateChanged("Calculating 3D GVF");
        calcGVF3D(imgBuffer);

        if (destFlag == true) {

            for (i = 0; i < length; i++) {
                gvfBuffer[i] = (float) Math.sqrt((uVal[i] * uVal[i]) + (vVal[i] * vVal[i]) + (wVal[i] * wVal[i]));
            }

            try {
                destImage.importData(0, gvfBuffer, true);
            } catch (IOException error) {
                cleanup();
                MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" + ".importData(0,gvfBuffer,true)");

                setCompleted(false);

                return;
            }
        } // if (destFlag == true)

        /*contours  = srcVOI.getCurves();
         * fireProgressStateChanged(30);
         *
         * srcVOI.getBounds(xB, yB, zB); for (slice = (int)zB[0]; slice <= (float)zB[1]; slice++) {
         * fireProgressStateChanged((int)(30 + ((float)slice/(sliceNum-1))*70) );
         *
         *
         * }
         *
         * nContours = contours[slice].size(); for(int j = 0; j < nContours; j++){ if (
         * ((VOIContour)(contours[slice].elementAt(j))).isActive() ) { gons    = srcVOI.exportPolygons(slice); xPoints =
         * new float[gons[j].npoints+5]; yPoints = new float[gons[j].npoints+5]; resultGon = new Polygon();
         * setPoints(xPoints, yPoints, gons[j]); runSnake(xPoints, yPoints, uVal, vVal, resultGon); baseNPts   =
         * resultGon.npoints; resultVOI.importPolygon(resultGon, slice);
         * ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints( Preferences.getTrim(),
         * Preferences.getTrimAdjacient()); stSlice = slice; } else { gons = srcVOI.exportPolygons(slice);
         * resultVOI.importPolygon(gons[j], slice); } } }
         *
         * if (threadStopped) { finalize(); return; }
         *
         * if (propagationFlag == false)  { cleanup(); fireProgressStateChanged(100); setCompleted(true); return; }
         *
         * slice   = stSlice; baseGon = resultGon; slice++; tempGon    = resultGon; xPoints = new
         * float[tempGon.npoints+5]; yPoints = new float[tempGon.npoints+5]; resultGon = new Polygon(); if (slice <
         * sliceNum) { while(!threadStopped) {
         *
         * try { srcImage.exportData(slice*length,length, imgBuffer); } catch (IOException error) { cleanup();
         * displayError("Algorithm GVF: Image(s) locked"); setCompleted(false);  return; }
         *
         * uVal = new float[(xDim+2)*(yDim+2)]; vVal = new float[(xDim+2)*(yDim+2)]; calcGVF(imgBuffer);
         *
         * if (destFlag == true) { for (i = 0; i < length; i++) { gvfBuffer[i] = (float)Math.sqrt(uVal[i]*uVal[i] +
         * vVal[i]*vVal[i]); } try { destImage.importData(slice*length,gvfBuffer,false); } catch (IOException error) {
         * cleanup(); MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
         * ".importData(slice*length,gvfBuffer,false)");  setCompleted(false); return; } }
         *
         * // this is where I need to add simplex optimization algo stuff setPoints(xPoints, yPoints, tempGon);
         * runSnake(xPoints, yPoints, uVal, vVal, resultGon); slicesDone++; fireProgressStateChanged(slicesDone *
         * 100/sliceNum); nPts   = resultGon.npoints; Preferences.debug(" Points = " + nPts, Preferences.DEBUG_ALGORITHM);
         *
         * if (nPts < 8) { break; } else{ resultVOI.importPolygon(resultGon, slice);
         * ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints( Preferences.getTrim(),
         * Preferences.getTrimAdjacient()); }
         *
         * xPoints = new float[resultGon.npoints+5]; yPoints = new float[resultGon.npoints+5]; tempGon = resultGon;
         * resultGon = new Polygon(); slice++;
         *
         * if (slice >= srcImage.getExtents()[2]) break; } // while(!threadStopped) } // if (slice < sliceNum) if
         * (threadStopped) { finalize(); return; }
         *
         * slice = stSlice-1; tempGon    = baseGon; xPoints = new float[tempGon.npoints+5]; yPoints = new
         * float[tempGon.npoints+5]; resultGon = new Polygon(); slicesDone = sliceNum - stSlice;
         * fireProgressStateChanged(slicesDone * 100/sliceNum); Preferences.debug("Going down", Preferences.DEBUG_ALGORITHM); if (slice >= 0) {
         * while(!threadStopped) {
         *
         * try { srcImage.exportData(slice*length,length, imgBuffer); } catch (IOException error) { cleanup();
         * displayError("Algorithm GVF: Image(s) locked"); setCompleted(false);  return; }
         *
         * uVal = new float[(xDim+2)*(yDim+2)]; vVal = new float[(xDim+2)*(yDim+2)]; calcGVF(imgBuffer);
         *
         * if (destFlag == true) { for (i = 0; i < length; i++) { gvfBuffer[i] = (float)Math.sqrt(uVal[i]*uVal[i] +
         * vVal[i]*vVal[i]); } try { destImage.importData(slice*length,gvfBuffer,false); } catch (IOException error) {
         * cleanup(); MipavUtil.displayError("AlgorithmAGVF: IOException on destImage" +
         * ".importData(slice*length,gvfBuffer,false)");  setCompleted(false);
         *
         * return; } }
         *
         * // this is where I need to add simplex optimization algo stuff setPoints(xPoints, yPoints, tempGon);
         * runSnake(xPoints, yPoints, uVal, vVal, resultGon); slicesDone++; fireProgressStateChanged(slicesDone *
         * 100/sliceNum); nPts   = resultGon.npoints;
         *
         * if (nPts < 8){ break; } else{ resultVOI.importPolygon(resultGon, slice);
         * ((VOIContour)(resultVOI.getCurves()[slice].lastElement())).trimPoints( Preferences.getTrim(),
         * Preferences.getTrimAdjacient()); }
         *
         * xPoints = new float[resultGon.npoints+5]; yPoints = new float[resultGon.npoints+5]; tempGon = resultGon;
         * resultGon = new Polygon(); slice--;
         *
         * if (slice < 0) break; } // while (!threadStopped) } // if (slice >= 0)*/
        if (threadStopped) {
            finalize();

            return;
        }

        if (destFlag == true) {
            destImage.calcMinMax();
        }

        cleanup();
        fireProgressStateChanged(100);

        setCompleted(true);

    }

    /**
     * Calculate GVF from image buffer.
     *
     * @param sliceNum
     * @param  imgBuffer  DOCUMENT ME!
     */
    private void calcGVF(int sliceNum, float[] imgBuffer) {
        float ix, iy;
        float gvfMin, gvfMax;
        int x, y;
        float del2;
        int iteration;
        int sliceSize = xDim * yDim;
        int offset = sliceSize *sliceNum;

        // float       k = 0.15f;
        int i;

        uVal = new float[(xDim + 2) * (yDim + 2)];
        vVal = new float[(xDim + 2) * (yDim + 2)];

        // Edge map = |grad(Gsigma(x,y)*I(x,y))|
        if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0)) {
            for (i = 0; i < sliceSize; i++) {
                gvfBuffer[i] = outputBuffer[offset + i];
            }
        } // if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0))
        else if (sigmas[0] != 0.0) {
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y);
                    ix = outputBuffer[offset + i];
                    if (y == 0) {
                        iy = imgBuffer[x + xDim] - imgBuffer[i];
                    } else if (y == (yDim - 1)) {
                        iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim)];
                    } else {
                        iy = (imgBuffer[x + ((y + 1) * xDim)] - imgBuffer[x + ((y - 1) * xDim)]) / 2.0f;
                    }
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        } // else if (sigmas[0] != 0.0)
        else if (sigmas[1] != 0.0) {
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y); 
                    if (x == 0) {
                        ix = imgBuffer[1 + (y * xDim)] - imgBuffer[i];
                    } else if (x == (xDim - 1)) {
                        ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim)];
                    } else {
                        ix = (imgBuffer[(x + 1) + (y * xDim)] - imgBuffer[(x - 1) + (y * xDim)]) / 2.0f;
                    }
                    iy = outputBuffer[offset + i];
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        } // else if (sigmas[1] != 0.0)
        else { // ((sigmas[0] == 0.0) && (sigmas[1] == 0.0))
            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    i = x + (xDim * y); 
                    if (x == 0) {
                        ix = imgBuffer[1 + (y * xDim)] - imgBuffer[i];
                    } else if (x == (xDim - 1)) {
                        ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim)];
                    } else {
                        ix = (imgBuffer[(x + 1) + (y * xDim)] - imgBuffer[(x - 1) + (y * xDim)]) / 2.0f;
                    }
                    if (y == 0) {
                        iy = imgBuffer[x + xDim] - imgBuffer[i];
                    } else if (y == (yDim - 1)) {
                        iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim)];
                    } else {
                        iy = (imgBuffer[x + ((y + 1) * xDim)] - imgBuffer[x + ((y - 1) * xDim)]) / 2.0f;
                    }
                    gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy));
                }
            }
        }

        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];

        for (i = 1; i < length; i++) {

            if (gvfBuffer[i] > gvfMax) {
                gvfMax = gvfBuffer[i];
            }

            if (gvfBuffer[i] < gvfMin) {
                gvfMin = gvfBuffer[i];
            }
        }

        for (i = 0; i < length; i++) {
            gvfBuffer[i] = (gvfBuffer[i] - gvfMin) / (gvfMax - gvfMin);
        }

        // Take care of the boundary condition
        for (y = 0; y < yDim; y++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[(x + 1) + ((y + 1) * (xDim + 2))] = gvfBuffer[x + (y * xDim)];
            }
        }

        // Create a mirror at the corners
        expGvfBuffer[0] = gvfBuffer[1 + xDim];
        expGvfBuffer[xDim + 1] = gvfBuffer[(xDim - 2) + xDim];
        expGvfBuffer[(yDim + 1) * (xDim + 2)] = gvfBuffer[((yDim - 2) * xDim) + 1];
        expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) * xDim) + xDim - 2];

        // Mirror left and right boundaries
        for (y = 0; y < yDim; y++) {
            expGvfBuffer[(y + 1) * (xDim + 2)] = gvfBuffer[(y * xDim) + 1];
            expGvfBuffer[((y + 1) * (xDim + 2)) + xDim + 1] = gvfBuffer[(y * xDim) + xDim - 2];
        }

        // Mirror top and bottom boundaries
        for (x = 0; x < xDim; x++) {
            expGvfBuffer[x + 1] = gvfBuffer[xDim + x];
            expGvfBuffer[((yDim + 1) * (xDim + 2)) + x + 1] = gvfBuffer[((yDim - 2) * xDim) + x];
        }

        // Calculate the x and y gradients
        for (y = 0; y < (yDim + 2); y++) {

            for (x = 0; x < (xDim + 2); x++) {

                if (x == 0) {
                    fx[y * (xDim + 2)] = expGvfBuffer[1 + (y * (xDim + 2))] - expGvfBuffer[y * (xDim + 2)];
                } else if (x == (xDim + 1)) {
                    fx[xDim + 1 + (y * (xDim + 2))] = expGvfBuffer[xDim + 1 + (y * (xDim + 2))] -
                                                      expGvfBuffer[xDim + (y * (xDim + 2))];
                } else {
                    fx[x + (y * (xDim + 2))] = (expGvfBuffer[(x + 1) + (y * (xDim + 2))] -
                                                expGvfBuffer[(x - 1) + (y * (xDim + 2))]) / 2.0f;
                }

                if (y == 0) {
                    fy[x] = expGvfBuffer[x + (xDim + 2)] - expGvfBuffer[x];
                } else if (y == (yDim + 1)) {
                    fy[x + ((yDim + 1) * (xDim + 2))] = expGvfBuffer[x + ((yDim + 1) * (xDim + 2))] -
                                                        expGvfBuffer[x + (yDim * (xDim + 2))];
                } else {
                    fy[x + (y * (xDim + 2))] = (expGvfBuffer[x + ((y + 1) * (xDim + 2))] -
                                                expGvfBuffer[x + ((y - 1) * (xDim + 2))]) / 2.0f;
                }
            } // for (x = 0; x < (xDim+2); x++)
        } // for (y = 0; y < (yDim+2); y++)

        // Initialize GVF to the gradient
        for (i = 0; i < fx.length; i++) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
        }

        for (i = 0; i < fx.length; i++) {
            gVal[i] = (float) Math.exp(-((fx[i] * fx[i]) + (fy[i] * fy[i])) / (kValue * kValue));
        }

        for (iteration = 0; (iteration < gvfIterations) && (!threadStopped); iteration++) {

            // Create a mirror at the u boundaries
            // Create a mirror at the corners
            uVal[0] = uVal[2 + (2 * (xDim + 2))];
            uVal[xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2))];
            uVal[(yDim + 1) * (xDim + 2)] = uVal[((yDim - 1) * (xDim + 2)) + 2];
            uVal[((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1];

            // Mirror left and right boundaries
            for (y = 1; y < (yDim + 1); y++) {
                uVal[y * (xDim + 2)] = uVal[(y * (xDim + 2)) + 2];
                uVal[(y * (xDim + 2)) + xDim + 1] = uVal[(y * (xDim + 2)) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for (x = 1; x < (xDim + 1); x++) {
                uVal[x] = uVal[(2 * (xDim + 2)) + x];
                uVal[((yDim + 1) * (xDim + 2)) + x] = uVal[((yDim - 1) * (xDim + 2)) + x];
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the corners
            vVal[0] = vVal[2 + (2 * (xDim + 2))];
            vVal[xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2))];
            vVal[(yDim + 1) * (xDim + 2)] = vVal[((yDim - 1) * (xDim + 2)) + 2];
            vVal[((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1];

            // Mirror left and right boundaries
            for (y = 1; y < (yDim + 1); y++) {
                vVal[y * (xDim + 2)] = vVal[(y * (xDim + 2)) + 2];
                vVal[(y * (xDim + 2)) + xDim + 1] = vVal[(y * (xDim + 2)) + xDim - 1];
            }

            // Mirror top and bottom boundaries
            for (x = 1; x < (xDim + 1); x++) {
                vVal[x] = vVal[(2 * (xDim + 2)) + x];
                vVal[((yDim + 1) * (xDim + 2)) + x] = vVal[((yDim - 1) * (xDim + 2)) + x];
            }

            for (y = 0; y < (yDim + 2); y++) {

                for (x = 0; x < (xDim + 2); x++) {
                    del2 = 0.0f;
                    i = x + (y * (xDim + 2));

                    if (x == 0) {
                        del2 += 2 * uVal[(x + 1) + (y * (xDim + 2))];
                    } else if (x == (xDim + 1)) {
                        del2 += 2 * uVal[(x - 1) + (y * (xDim + 2))];
                    } else {
                        del2 += uVal[(x + 1) + (y * (xDim + 2))] + uVal[(x - 1) + (y * (xDim + 2))];
                    }

                    if (y == 0) {
                        del2 += 2 * uVal[x + ((y + 1) * (xDim + 2))];
                    } else if (y == (yDim + 1)) {
                        del2 += 2 * uVal[x + ((y - 1) * (xDim + 2))];
                    } else {
                        del2 += uVal[x + ((y + 1) * (xDim + 2))] + uVal[x + ((y - 1) * (xDim + 2))];
                    }

                    del2 -= 4 * uVal[i];
                    uVal[i] += 0.25f * ((gVal[i] * del2) - ((1 - gVal[i]) * (uVal[i] - fx[i])));

                    del2 = 0.0f;

                    if (x == 0) {
                        del2 += 2 * vVal[(x + 1) + (y * (xDim + 2))];
                    } else if (x == (xDim + 1)) {
                        del2 += 2 * vVal[(x - 1) + (y * (xDim + 2))];
                    } else {
                        del2 += vVal[(x + 1) + (y * (xDim + 2))] + vVal[(x - 1) + (y * (xDim + 2))];
                    }

                    if (y == 0) {
                        del2 += 2 * vVal[x + ((y + 1) * (xDim + 2))];
                    } else if (y == (yDim + 1)) {
                        del2 += 2 * vVal[x + ((y - 1) * (xDim + 2))];
                    } else {
                        del2 += vVal[x + ((y + 1) * (xDim + 2))] + vVal[x + ((y - 1) * (xDim + 2))];
                    }

                    del2 -= 4 * vVal[i];
                    vVal[i] += 0.25f * ((gVal[i] * del2) - ((1 - gVal[i]) * (vVal[i] - fy[i])));
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for (y = 1; y < (yDim + 1); y++) {

            for (x = 1; x < (xDim + 1); x++) {
                gvfBuffer[(x - 1) + ((y - 1) * xDim)] = uVal[x + (y * (xDim + 2))];
            }
        }

        uVal = new float[length];

        for (i = 0; i < length; i++) {
            uVal[i] = gvfBuffer[i];
        }

        for (y = 1; y < (yDim + 1); y++) {

            for (x = 1; x < (xDim + 1); x++) {
                gvfBuffer[(x - 1) + ((y - 1) * xDim)] = vVal[x + (y * (xDim + 2))];
            }
        }

        vVal = new float[length];

        for (i = 0; i < length; i++) {
            vVal[i] = gvfBuffer[i];
        }

        return;
    }

    /**
     * Calculate GVF from 3D image buffer.
     *
     * @param  imgBuffer  DOCUMENT ME!
     */
    private void calcGVF3D(float[] imgBuffer) {
        float ix, iy, iz;
        float gvfMin, gvfMax;
        int x, y, z;
        float del2;
        int iteration;
        int totalLength = xDim * yDim * zDim;

        // float       k = 0.15f;
        int i, i1, i2;
        int sliceSize = xDim * yDim;
        int expSliceSize = (xDim + 2) * (yDim + 2);

        // Edge map = |grad(Gsigma(x,y,z)*I(x,y,z))|
        if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0)) {
            for (i = 0; i < totalLength; i++) {
                gvfBuffer[i] = outputBuffer[i];
            }
        } // if ((sigmas[0] != 0.0) && (sigmas[1] != 0.0) && (sigmas[2] != 0.0))
        else {
            for (z = 0; z < zDim; z++) {
                i1 = z * sliceSize;
    
                for (y = 0; y < yDim; y++) {
                    i2 = i1 + (xDim * y);
    
                    for (x = 0; x < xDim; x++) {
                        i = i2 + x;
                        ;
    
                        if (sigmas[0] != 0.0f) {
                            ix = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GxData);
                        } // if (sigmas[0] != 0.0f)
                        else { // (sigmas[0] == 0.0f)
    
                            if (x == 0) {
                                ix = imgBuffer[1 + (y * xDim) + (z * sliceSize)] - imgBuffer[i];
                            } else if (x == (xDim - 1)) {
                                ix = imgBuffer[i] - imgBuffer[(xDim - 2) + (y * xDim) + (z * sliceSize)];
                            } else {
                                ix = (imgBuffer[(x + 1) + (y * xDim) + (z * sliceSize)] -
                                      imgBuffer[(x - 1) + (y * xDim) + (z * sliceSize)]) / 2.0f;
                            }
                        } // else (sigmas[0] == 0.0f)
    
                        if (sigmas[1] != 0.0f) {
                            iy = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GyData);
                        } // if (sigmas[1] != 0.0f)
                        else { // sigmas[1] == 0.0f
    
                            if (y == 0) {
                                iy = imgBuffer[x + xDim + (z * sliceSize)] - imgBuffer[i];
                            } else if (y == (yDim - 1)) {
                                iy = imgBuffer[i] - imgBuffer[x + ((yDim - 2) * xDim) + (z * sliceSize)];
                            } else {
                                iy = (imgBuffer[x + ((y + 1) * xDim) + (z * sliceSize)] -
                                      imgBuffer[x + ((y - 1) * xDim) + (z * sliceSize)]) / 2.0f;
                            }
                        } // else sigmas[1] == 0.0f
    
                        if (sigmas[2] != 0.0) {
                            iz = AlgorithmConvolver.convolveWhole3DPt(i, extents, imgBuffer, kExtents, GzData);
                        } // if (sigmas[2] != 0.0f)
                        else { // sigmas[2] == 0.0f
    
                            if (z == 0) {
                                iz = imgBuffer[x + (y * xDim) + sliceSize] - imgBuffer[x + (y * xDim)];
                            } else if (z == (zDim - 1)) {
                                iz = imgBuffer[x + (y * xDim) + ((zDim - 1) * sliceSize)] -
                                     imgBuffer[x + (y * xDim) + ((zDim - 2) * sliceSize)];
                            } else {
                                iz = (imgBuffer[x + (y * xDim) + ((z + 1) * sliceSize)] -
                                      imgBuffer[x + (y * xDim) + ((z - 1) * sliceSize)]) / 2.0f;
                            }
                        } // else sigmas[2] == 0.0f
    
                        gvfBuffer[i] = (float) Math.sqrt((ix * ix) + (iy * iy) + (iz * iz));
                    } // for (x = 0; x < xDim; x++)
                } // for (y = 0; y < yDim; y++)
            } // for (z = 0; z < zDim; z++)
        } // else

        // Compute the gradient vector flow of the edge map
        // Normalize to the range [0,1]
        gvfMin = gvfBuffer[0];
        gvfMax = gvfBuffer[0];

        for (i = 1; i < length; i++) {

            if (gvfBuffer[i] > gvfMax) {
                gvfMax = gvfBuffer[i];
            }

            if (gvfBuffer[i] < gvfMin) {
                gvfMin = gvfBuffer[i];
            }
        }

        for (i = 0; i < length; i++) {
            gvfBuffer[i] = (gvfBuffer[i] - gvfMin) / (gvfMax - gvfMin);
        }

        // Take care of the boundary condition
        for (z = 0; z < zDim; z++) {

            for (y = 0; y < yDim; y++) {

                for (x = 0; x < xDim; x++) {
                    expGvfBuffer[(x + 1) + ((y + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[x +
                                                                                                          (y * xDim) +
                                                                                                          (z *
                                                                                                               sliceSize)];
                }
            }
        }

        // Create a mirror at the 8 corner points
        expGvfBuffer[0] = gvfBuffer[1 + xDim + sliceSize];
        expGvfBuffer[xDim + 1] = gvfBuffer[(xDim - 2) + xDim + sliceSize];
        expGvfBuffer[(yDim + 1) * (xDim + 2)] = gvfBuffer[((yDim - 2) * xDim) + 1 + sliceSize];
        expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) * xDim) + xDim - 2 + sliceSize];
        expGvfBuffer[(xDim + 2) * (yDim + 2) * (zDim + 1)] = gvfBuffer[1 + xDim + (sliceSize * (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + xDim + 1] = gvfBuffer[(xDim - 2) + xDim +
                                                                                    (sliceSize * (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + ((yDim + 1) * (xDim + 2))] = gvfBuffer[((yDim - 2) *
                                                                                                          xDim) + 1 +
                                                                                                     (sliceSize *
                                                                                                          (zDim - 2))];
        expGvfBuffer[((xDim + 2) * (yDim + 2) * (zDim + 1)) + ((xDim + 2) * (yDim + 2)) - 1] = gvfBuffer[((yDim - 2) *
                                                                                                              xDim) +
                                                                                                         xDim - 2 +
                                                                                                         (sliceSize *
                                                                                                              (zDim -
                                                                                                                   2))];

        // Create a mirror at the corner line segments from x = 1 to x = xDim slices
        for (x = 0; x < xDim; x++) {
            expGvfBuffer[x + 1] = gvfBuffer[x + xDim + sliceSize];
            expGvfBuffer[x + 1 + ((yDim + 1) * (xDim + 2))] = gvfBuffer[x + ((yDim - 2) * xDim) + sliceSize];
            expGvfBuffer[x + 1 + ((zDim + 1) * expSliceSize)] = gvfBuffer[x + xDim + ((zDim - 2) * sliceSize)];
            expGvfBuffer[x + 1 + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[x +
                                                                                                      ((yDim - 2) *
                                                                                                           xDim) +
                                                                                                      ((zDim - 2) *
                                                                                                           sliceSize)];
        }

        // Create a mirror at the corner line segments from y = 1 to y = yDim slices
        for (y = 0; y < yDim; y++) {
            expGvfBuffer[(y + 1) * (xDim + 2)] = gvfBuffer[1 + (y * xDim) + sliceSize];
            expGvfBuffer[xDim + 1 + ((y + 1) * (xDim + 2))] = gvfBuffer[xDim - 2 + (y * xDim) + sliceSize];
            expGvfBuffer[((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[1 + (y * xDim) +
                                                                                           ((zDim - 2) * sliceSize)];
            expGvfBuffer[xDim + 1 + ((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[xDim - 2 +
                                                                                                      (y * xDim) +
                                                                                                      ((zDim - 2) *
                                                                                                           sliceSize)];
        }

        // Create a mirror at the corner line segments from z = 1 to z = zDim slices
        for (z = 0; z < zDim; z++) {
            expGvfBuffer[(z + 1) * expSliceSize] = gvfBuffer[1 + xDim + (z * sliceSize)];
            expGvfBuffer[xDim + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(xDim - 2) + xDim + (z * sliceSize)];
            expGvfBuffer[((yDim + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[((yDim - 2) * xDim) + 1 +
                                                                                           (z * sliceSize)];
            expGvfBuffer[((xDim + 2) * (yDim + 2)) - 1 + ((z + 1) * expSliceSize)] = gvfBuffer[((yDim - 2) * xDim) +
                                                                                               xDim - 2 +
                                                                                               (z * sliceSize)];
        }

        // Mirror left and right x boundaries
        for (z = 0; z < zDim; z++) {

            for (y = 0; y < yDim; y++) {
                expGvfBuffer[((y + 1) * (xDim + 2)) + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                            (y * xDim) + 1];
                expGvfBuffer[((y + 1) * (xDim + 2)) + xDim + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                                       (y * xDim) +
                                                                                                       xDim - 2];
            }
        }

        // Mirror top and bottom y boundaries
        for (z = 0; z < zDim; z++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[x + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) + xDim + x];
                expGvfBuffer[((yDim + 1) * (xDim + 2)) + x + 1 + ((z + 1) * expSliceSize)] = gvfBuffer[(z * sliceSize) +
                                                                                                       ((yDim - 2) *
                                                                                                            xDim) + x];
            }
        }

        // Mirror front and back z boundaries
        for (y = 0; y < yDim; y++) {

            for (x = 0; x < xDim; x++) {
                expGvfBuffer[x + 1 + ((y + 1) * (xDim + 2))] = gvfBuffer[sliceSize + (y * xDim) + x];
                expGvfBuffer[x + 1 + ((y + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = gvfBuffer[((zDim - 2) *
                                                                                                            sliceSize) +
                                                                                                       (y * xDim) + x];
            }
        }

        // Calculate the x and y and z gradients
        for (z = 0; z < (zDim + 2); z++) {

            for (y = 0; y < (yDim + 2); y++) {

                for (x = 0; x < (xDim + 2); x++) {

                    if (x == 0) {
                        fx[(y * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[1 + (y * (xDim + 2)) +
                                                                                 (z * expSliceSize)] -
                                                                    expGvfBuffer[(y * (xDim + 2)) + (z * expSliceSize)];
                    } else if (x == (xDim + 1)) {
                        fx[xDim + 1 + (y * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[xDim + 1 +
                                                                                            (y * (xDim + 2)) +
                                                                                            (z * expSliceSize)] -
                                                                               expGvfBuffer[xDim + (y * (xDim + 2)) +
                                                                                            (z * expSliceSize)];
                    } else {
                        fx[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[(x + 1) + (y * (xDim + 2)) +
                                                                                      (z * expSliceSize)] -
                                                                         expGvfBuffer[(x - 1) + (y * (xDim + 2)) +
                                                                                      (z * expSliceSize)]) / 2.0f;
                    }

                    if (y == 0) {
                        fy[x + (z * expSliceSize)] = expGvfBuffer[x + (xDim + 2) + (z * expSliceSize)] -
                                                     expGvfBuffer[x + (z * expSliceSize)];
                    } else if (y == (yDim + 1)) {
                        fy[x + ((yDim + 1) * (xDim + 2)) + (z * expSliceSize)] = expGvfBuffer[x +
                                                                                              ((yDim + 1) *
                                                                                                   (xDim + 2)) +
                                                                                              (z * expSliceSize)] -
                                                                                 expGvfBuffer[x + (yDim * (xDim + 2)) +
                                                                                              (z * expSliceSize)];
                    } else {
                        fy[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[x + ((y + 1) * (xDim + 2)) +
                                                                                      (z * expSliceSize)] -
                                                                         expGvfBuffer[x + ((y - 1) * (xDim + 2)) +
                                                                                      (z * expSliceSize)]) / 2.0f;
                    }

                    if (z == 0) {
                        fz[x + (y * (xDim + 2))] = expGvfBuffer[x + (y * (xDim + 2)) + expSliceSize] -
                                                   expGvfBuffer[x + (y * (xDim + 2))];
                    } else if (z == (zDim + 1)) {
                        fz[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                              ((zDim + 1) *
                                                                                                   expSliceSize)] -
                                                                                 expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                              (zDim * expSliceSize)];
                    } else {
                        fz[x + (y * (xDim + 2)) + (z * expSliceSize)] = (expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                      ((z + 1) * expSliceSize)] -
                                                                         expGvfBuffer[x + (y * (xDim + 2)) +
                                                                                      ((z - 1) * expSliceSize)]) / 2.0f;
                    }
                } // for (x = 0; x < (xDim+2); x++)
            } // for (y = 0; y < (yDim+2); y++)
        } // for (z = 0; z < (zDim+2); z++)

        // Initialize GVF to the gradient
        for (i = 0; i < fx.length; i++) {
            uVal[i] = fx[i];
            vVal[i] = fy[i];
            wVal[i] = fz[i];
        }

        for (i = 0; i < fx.length; i++) {
            gVal[i] = (float) Math.exp(-((fx[i] * fx[i]) + (fy[i] * fy[i]) + (fz[i] * fz[i])) / (kValue * kValue));
        }

        // gvfIterations = 200;
        for (iteration = 0; (iteration < gvfIterations) && (!threadStopped); iteration++) {

            // Create a mirror at the u boundaries
            // Create a mirror at the 8 corner points of the cube
            uVal[0] = uVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            uVal[xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            uVal[(yDim + 1) * (xDim + 2)] = uVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            uVal[((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            uVal[(zDim + 1) * expSliceSize] = uVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = uVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            uVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                uVal[x] = uVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                uVal[x + ((yDim + 1) * (xDim + 2))] = uVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                uVal[x + ((zDim + 1) * expSliceSize)] = uVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                uVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                uVal[y * (xDim + 2)] = uVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                uVal[xDim + 1 + (y * (xDim + 2))] = uVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                uVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                uVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                uVal[z * expSliceSize] = uVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                uVal[(z * expSliceSize) + xDim + 1] = uVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                uVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = uVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                uVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = uVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries for z = 1 to z = zDim
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    uVal[(z * expSliceSize) + (y * (xDim + 2))] = uVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    uVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = uVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    uVal[(z * expSliceSize) + x] = uVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    uVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = uVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    uVal[x + (y * (xDim + 2))] = uVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    uVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = uVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            // Create a mirror at the v boundaries
            // Create a mirror at the 8 corners
            vVal[0] = vVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            vVal[xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            vVal[(yDim + 1) * (xDim + 2)] = vVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            vVal[((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            vVal[(zDim + 1) * expSliceSize] = vVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = vVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            vVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                vVal[x] = vVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                vVal[x + ((yDim + 1) * (xDim + 2))] = vVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                vVal[x + ((zDim + 1) * expSliceSize)] = vVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                vVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                vVal[y * (xDim + 2)] = vVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                vVal[xDim + 1 + (y * (xDim + 2))] = vVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                vVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                vVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                vVal[z * expSliceSize] = vVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                vVal[(z * expSliceSize) + xDim + 1] = vVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                vVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = vVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                vVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = vVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    vVal[(z * expSliceSize) + (y * (xDim + 2))] = vVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    vVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = vVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    vVal[(z * expSliceSize) + x] = vVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    vVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = vVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    vVal[x + (y * (xDim + 2))] = vVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    vVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = vVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            // Create a mirror at the w boundaries
            // Create a mirror at the 8 corner points
            wVal[0] = wVal[2 + (2 * (xDim + 2)) + (2 * expSliceSize)];
            wVal[xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) + (2 * expSliceSize)];
            wVal[(yDim + 1) * (xDim + 2)] = wVal[((yDim - 1) * (xDim + 2)) + 2 + (2 * expSliceSize)];
            wVal[((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim - 1 + (2 * expSliceSize)];
            wVal[(zDim + 1) * expSliceSize] = wVal[2 + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) +
                                                                ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + ((yDim + 1) * (xDim + 2))] = wVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                                 ((zDim - 1) * expSliceSize)];
            wVal[((zDim + 1) * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim -
                                                                                     1 + ((zDim - 1) * expSliceSize)];

            // Create a mirror at the corner line segments from x = 1 to x = xDim
            for (x = 1; x <= xDim; x++) {
                wVal[x] = wVal[x + (2 * (xDim + 2)) + (2 * expSliceSize)];
                wVal[x + ((yDim + 1) * (xDim + 2))] = wVal[x + ((yDim - 1) * (xDim + 2)) + (2 * expSliceSize)];
                wVal[x + ((zDim + 1) * expSliceSize)] = wVal[x + (2 * (xDim + 2)) + ((zDim - 1) * expSliceSize)];
                wVal[x + ((yDim + 1) * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[x + ((yDim - 1) * (xDim + 2)) +
                                                                                         ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments from y = 1 to y = yDim
            for (y = 1; y <= yDim; y++) {
                wVal[y * (xDim + 2)] = wVal[2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                wVal[xDim + 1 + (y * (xDim + 2))] = wVal[xDim - 2 + (y * (xDim + 2)) + (2 * expSliceSize)];
                wVal[(y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[2 + (y * (xDim + 2)) +
                                                                            ((zDim - 1) * expSliceSize)];
                wVal[xDim + 1 + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[xDim - 1 + (y * (xDim + 2)) +
                                                                                       ((zDim - 1) * expSliceSize)];
            }

            // Create a mirror at the corner line segments for z = 1 to z = zDim
            for (z = 1; z <= zDim; z++) {
                wVal[z * expSliceSize] = wVal[2 + (2 * (xDim + 2)) + (z * expSliceSize)];
                wVal[(z * expSliceSize) + xDim + 1] = wVal[(xDim - 1) + (2 * (xDim + 2)) + (z * expSliceSize)];
                wVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2))] = wVal[((yDim - 1) * (xDim + 2)) + 2 +
                                                                            (z * expSliceSize)];
                wVal[(z * expSliceSize) + ((xDim + 2) * (yDim + 2)) - 1] = wVal[((yDim - 1) * (xDim + 2)) + xDim - 1 +
                                                                                (z * expSliceSize)];
            }

            // Mirror left and right x boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (y = 1; y < (yDim + 1); y++) {
                    wVal[(z * expSliceSize) + (y * (xDim + 2))] = wVal[(z * expSliceSize) + (y * (xDim + 2)) + 2];
                    wVal[(z * expSliceSize) + (y * (xDim + 2)) + xDim + 1] = wVal[(z * expSliceSize) +
                                                                                  (y * (xDim + 2)) + xDim - 1];
                }
            }

            // Mirror top and bottom y boundaries
            for (z = 1; z < (zDim + 1); z++) {

                for (x = 1; x < (xDim + 1); x++) {
                    wVal[(z * expSliceSize) + x] = wVal[(z * expSliceSize) + (2 * (xDim + 2)) + x];
                    wVal[(z * expSliceSize) + ((yDim + 1) * (xDim + 2)) + x] = wVal[(z * expSliceSize) +
                                                                                    ((yDim - 1) * (xDim + 2)) + x];
                }
            }

            // Mirror front and back z boundaries
            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    wVal[x + (y * (xDim + 2))] = wVal[x + (y * (xDim + 2)) + (2 * expSliceSize)];
                    wVal[x + (y * (xDim + 2)) + ((zDim + 1) * expSliceSize)] = wVal[x + (y * (xDim + 2)) +
                                                                                    ((zDim - 1) * expSliceSize)];
                }
            }

            for (z = 0; z < (zDim + 2); z++) {
                i1 = z * expSliceSize;

                for (y = 0; y < (yDim + 2); y++) {
                    i2 = i1 + (y * (xDim + 2));

                    for (x = 0; x < (xDim + 2); x++) {
                        del2 = 0.0f;
                        i = x + i2;

                        if (x == 0) {
                            del2 += 2 * uVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * uVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += uVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    uVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * uVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * uVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += uVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    uVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];

                        }

                        if (z == 0) {
                            del2 += 2 * uVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * uVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += uVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +uVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * uVal[i];
                        uVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (uVal[i] - fx[i])));

                        del2 = 0.0f;

                        if (x == 0) {
                            del2 += 2 * vVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * vVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += vVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    vVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * vVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * vVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += vVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    vVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (z == 0) {
                            del2 += 2 * vVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * vVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += vVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +vVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * vVal[i];
                        vVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (vVal[i] - fy[i])));

                        del2 = 0.0f;

                        if (x == 0) {
                            del2 += 2 * wVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else if (x == (xDim + 1)) {
                            del2 += 2 * wVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += wVal[(x + 1) + (y * (xDim + 2)) + (z * expSliceSize)] +
                                    wVal[(x - 1) + (y * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (y == 0) {
                            del2 += 2 * wVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else if (y == (yDim + 1)) {
                            del2 += 2 * wVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        } else {
                            del2 += wVal[x + ((y + 1) * (xDim + 2)) + (z * expSliceSize)] +
                                    wVal[x + ((y - 1) * (xDim + 2)) + (z * expSliceSize)];
                        }

                        if (z == 0) {
                            del2 += 2 * wVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)];
                        } else if (z == (zDim + 1)) {
                            del2 += 2 * wVal[x + (y * (xDim + 2)) + ((z - 1) * expSliceSize)];
                        } else {
                            del2 += wVal[x + (y * (xDim + 2)) + ((z + 1) * expSliceSize)] + +wVal[x + (y * (xDim + 2)) +
                                                                                                  ((z - 1) *
                                                                                                       expSliceSize)];
                        }

                        del2 -= 6 * wVal[i];
                        wVal[i] += 0.1666f * ((gVal[i] * del2) - ((1 - gVal[i]) * (wVal[i] - fz[i])));
                    }
                }
            }
        } // for (iteration = 0; iteration < gvfIterations; iteration++)

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = uVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        uVal = new float[length];

        for (i = 0; i < length; i++) {
            uVal[i] = gvfBuffer[i];
        }

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = vVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        vVal = new float[length];

        for (i = 0; i < length; i++) {
            vVal[i] = gvfBuffer[i];
        }

        for (z = 1; z < (zDim + 1); z++) {

            for (y = 1; y < (yDim + 1); y++) {

                for (x = 1; x < (xDim + 1); x++) {
                    gvfBuffer[(x - 1) + ((y - 1) * xDim) + ((z - 1) * sliceSize)] = wVal[x + (y * (xDim + 2)) +
                                                                                         (z * expSliceSize)];
                }
            }
        }

        wVal = new float[length];

        for (i = 0; i < length; i++) {
            wVal[i] = gvfBuffer[i];
        }

        ModelImage gvfImage = new ModelImage(ModelImage.FLOAT, srcImage.getExtents(), srcImage.getImageName() + "_uvf");

        try {
            gvfImage.importData(0, uVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_uvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.importData(0, vVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_vvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.importData(0, wVal, true);
        } catch (IOException error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.importData");

            setCompleted(false);

            return;
        }

        try {
            gvfImage.saveImage(srcImage.getFileInfo(0).getFileDirectory(), srcImage.getImageName() + "_wvf",
                               FileUtility.XML, true);
        } catch (OutOfMemoryError error) {

            if (gvfImage != null) {
                gvfImage.disposeLocal();
            }

            gvfImage = null;
            MipavUtil.displayError("Error on gvfImage.saveImage");

            setCompleted(false);

            return;
        }

        gvfImage.disposeLocal();
        gvfImage = null;

        return;
    }

    /**
     * Calculates the euclidian distance between two points.
     *
     * @param   x1  first x coord.
     * @param   x2  seconde x coord.
     * @param   y1  first y1 coord.
     * @param   y2  seconde y2 coord.
     *
     * @return  DOCUMENT ME!
     */
    private double distance(float x1, float x2, float y1, float y2) {
        return Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
    }

    /**
     * Makes derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels2D() {
        int xkDim, ykDim;
        int[] derivOrder = new int[2];

        kExtents = new int[2];
        derivOrder[0] = 1;
        derivOrder[1] = 0;

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        GxData = new float[xkDim * ykDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);
        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        GyData = new float[xkDim * ykDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);
        Gy.calc(true);
    }

    /**
     * Makes 3D derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels3D() {
        int xkDim, ykDim, zkDim;
        int[] derivOrder = new int[3];

        kExtents = new int[3];

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        zkDim = Math.round(5 * sigmas[2]);

        if ((zkDim % 2) == 0) {
            zkDim++;
        }

        kExtents[2] = zkDim;

        derivOrder[0] = 1;
        derivOrder[1] = 0;
        derivOrder[2] = 0;
        GxData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);
        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        derivOrder[2] = 0;
        GyData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);
        Gy.calc(true);

        derivOrder[0] = 0;
        derivOrder[1] = 0;
        derivOrder[2] = 1;
        GzData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gz = new GenerateGaussian(GzData, kExtents, sigmas, derivOrder);
        Gz.calc(true);
    }

    /**
     * Takes the polygon and forms two special arrarys for use in runSnake.
     *
     * @param  xPoints  storage location of array of x coord. points
     * @param  yPoints  storage location array of y coord. points
     * @param  gon      initial polygon
     */
    @SuppressWarnings("unused")
    private void setPoints(float[] xPoints, float[] yPoints, Polygon gon) {
        int i;

        xPoints[0] = gon.xpoints[gon.npoints - 1];
        yPoints[0] = gon.ypoints[gon.npoints - 1];

        for (i = 0; i < gon.npoints; i++) {
            xPoints[i + 1] = gon.xpoints[i];
            yPoints[i + 1] = gon.ypoints[i];
        }

        xPoints[gon.npoints + 1] = gon.xpoints[0];
        yPoints[gon.npoints + 1] = gon.ypoints[0];
    }
    /**
     * Takes the polygon and forms two special arrarys for use in runSnake.
     *
     * @param  xPoints  storage location of array of x coord. points
     * @param  yPoints  storage location array of y coord. points
     * @param  gon      initial polygon
     */
    private void setPoints(float[] xPoints, float[] yPoints, float[] zPoints, VOIBase contour) {
        xPoints[0] = contour.get(contour.size() - 1).X;
        yPoints[0] = contour.get(contour.size() - 1).Y;
        zPoints[0] = contour.get(contour.size() - 1).Z;

        for (int i = 0; i < contour.size(); i++) {
            xPoints[i + 1] = contour.get(i).X;
            yPoints[i + 1] = contour.get(i).Y;
            zPoints[i + 1] = contour.get(i).Z;
        }

        xPoints[contour.size() + 1] = contour.get(0).X;
        yPoints[contour.size() + 1] = contour.get(0).Y;
        zPoints[contour.size() + 1] = contour.get(0).Z;
    }

    public void algorithmPerformed(AlgorithmBase algorithm){
        if(!algorithm.isCompleted()){
            finalize();
            return;
        }
        if (algorithm instanceof AlgorithmConvolver) {
            AlgorithmConvolver convolver = (AlgorithmConvolver) algorithm;
            outputBuffer = convolver.getOutputBuffer();
        }
    }
}
