package gov.nih.mipav.model.structures.jama;


import gov.nih.mipav.view.*;


/**
 * This file contains 1 user callable eigenvalue function and 2 user callable generalized eigenvalue functions.
 *
 * <p>The eigenvalue problem solves the equation: A*x = lambda*x, where A is an n-by-n matrix, x is an n-length column
 * vector, and lambda is a scalar. The eigenvalues are the n values of lambda that solve the equation, and the
 * corresponding values of x are the right eigenvectors. The function dsyev solves the eigenvalue problem for the case
 * of real symmetric matrix A.</p>
 *
 * <p>The generalized eigenvalue problem solves the equation: A*x = lambda*B*x where both A and B are n-by-n matrices
 * and lambda is a scalar. The generalized eigenvalues are the n values of lambda that solve the equation, and the
 * corresponding values of x are the generalized right eigenvectors. The function dsygv solves the generalized
 * eigenvalue problem for the case of real symmetric A, symmetric positive definite B. The funciton dggev solves the
 * generalized eigenvalue problem for the case of real nonsymmetric A, real general B.</p>
 *
 * <p>The symmetric generalized eigenvalue driver dsygv was tested with dsygv_test. The statement All 882 tests for
 * dsygv passed the threshold was repeated 3 times. dchkst_test was implemented to test the dsytrd, dorgtr, dsteqr, and
 * dsterf routines belonging to the dsygv drver. The statement All 1134 tests for dchkst passed the threshold was
 * repeated 5 times. ddrvst_test was implemented to test dsyev. The statement All 648 tests for ddrvst passed the
 * threshold was repeated 5 times.</p>
 *
 * <p>The nonsymmetric generalized eigenvalue driver dggev was tested with dggev_test. The resulting statement was 12
 * out of 1092 dggev tests failed to pass the threshold. dchkgl was implemented to test the dggbal balancing routine of
 * dggev. All 8 tests showed no signficant error. dchkgk was implemented to test the dggbak backward balancing routine
 * of dggev. All 8 tests showed no significant error. dchkgg_test was implemented to test the dgghrd, dhgeqz, and dtgevc
 * routines of the dggev driver. The following output statements resulted: 15 out of 2156 dchkgg tests failed to pass
 * the threshold. 20 out of 2149 dchkgg tests failed to pass the threshold. 17 out of 2163 dchkgg tests failed to pass
 * the threshold. 20 out of 2142 dchkgg tests failed to pass the threshold. The errors in the nonsymmetric case would
 * not occur for matrix sizes of 5 or less. Following one case in parallel in the FORTRAN on the WATCOM compiler and on
 * Java revealed input variables that were identical up to about 9 signficant places yielding an output variable of
 * 7.77E-16 on the FORTRAN and -2.61E-15 on the Java. So apparently the Java failures are due to the Java 64 bit
 * arithmetic having a greater error than the FORTRAN 64 bit arithmetic.</p>
 * 
 * Running 7 self-tests:
 * if (runTest) {
            GeneralizedEigenvalue ge = new GeneralizedEigenvalue();
            //ge.dchkgg_test();
            ge.dchkst_test();
            //ge.ddrvst_test();
            //ge.dggev_test();
            //ge.dsygv_test();
            //ge.dchkgl();
            //ge.dchkgk();
            return;
        }
 *
 * <p>There are basically 2 problems with Java precision. 1.) The Intel Pentium uses 80 bit numbers in floating point
 * registers. However, Java must round each number back to 64 bits whenever a Java variable is assigned. There used to
 * be a proposal to introduce a special keyword extendedfp to fully use whatever math the platform had, but it didn't
 * get thru. Apparently the Java designers felt for Java being consistent is more important than being successful. 2.)
 * Java also forbids the use of fused multiply-add (FMA) operations. This operation computes the quantity ax + y as a
 * single floating-point operation. Operations of this type are found in many compute-intensive applications,
 * particularly matrix operations. With this instruction, only a single rounding occurs for the two arithmetic
 * operations, yielding a more accurate result in less time than would be required for two separate operations. Java's
 * strict language definition does not permit use of FMAs and thus sacrifices up to 50% of performance on some
 * platforms.</p>
 *
 * <p>The only obvious cure for this problem would be to use the Java BigDecimal class. However, the use of BigDecimal
 * would involve much more work than just changing doubles to BigDecimals. For example, with doubles I would write: f =
 * f/g; With BigDecimal I would write: f = f.divide(g, mc); where mc is the mathematical context settings. Likewise,
 * instead of the ordinary arithmetic operators I would have to use add, compareTo, equals, negate, plus, remainder, and
 * subtract. Using BigDecimal would undoubtedly slow the program down considerably.</p>
 *
 * <p>On significant change was made in the port of the nonsymmetric driver. In routine dhgeqz the number of maximum
 * iterations maxit was increased from 30 * (ihi-ilo+1) to 300 * (ihi-ilo+1)</p>
 *
 * <p>Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.</p>
 *
 * <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:</p>
 *
 * <p>- Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.</p>
 *
 * <p>- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer listed in this license in the documentation and/or other materials provided with the
 * distribution.</p>
 *
 * <p>- Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.</p>
 *
 * <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
 */
public class GeneralizedEigenvalue implements java.io.Serializable {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** Use serialVersionUID for interoperability. */
    private static final long serialVersionUID = 3809017135250813360L;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** DOCUMENT ME! */
    private double base;

    /** DOCUMENT ME! */
    //private boolean doOnce = true;
    // To set up for testing the software integrity:
    // GeneralizedEigenvalue ge = new GeneralizedEigenvalue();
    // ge.dsygv_test();

    /** DOCUMENT ME! */
    private double emax;

    /** DOCUMENT ME! */
    private double emin;

    /** DOCUMENT ME! */
    private double eps;

    /**
     * ------------------------ Class variables ------------------------ Double precision machine parameters found in
     * routine dlamch.
     */
    private boolean first = true;

    /** Double precison machine variables found in routine dlartg. */
    private boolean first_dlartg = true;

    /** DOCUMENT ME! */
    private int[] iparms;

    /** DOCUMENT ME! */
    private double prec;

    /** DOCUMENT ME! */
    private double rmax;

    /** DOCUMENT ME! */
    private double rmin;

    /** DOCUMENT ME! */
    private double rnd;

    /** DOCUMENT ME! */
    private double safmin;

    /** DOCUMENT ME! */
    private double safmn2;

    /** DOCUMENT ME! */
    private double safmx2;

    /** DOCUMENT ME! */
    private double sfmin;

    /** DOCUMENT ME! */
    private double t;

    /** Common variables in testing routines. */
    private ViewUserInterface UI = ViewUserInterface.getReference();

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Creates a new GeneralizedEigenvalue object.
     */
    public GeneralizedEigenvalue() { }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive dchkgg in
     * order to run dchkgg to test the nonsymmetric generalized eigenvalue problem. Tests dgghrd, dhgeqz, and dtgevc.
     * Numerical values were obtained from the dgg.in datafile. Original DCHKEE created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., January, 2007
     */
    public void dchkgg_test() {

        // Number of values of n
        int nn = 7;

        // Values of matrix dimension n
        int[] nval = new int[] { 0, 1, 2, 3, 5, 10, 16 };

        // Number of values of NB, NBMIN, NSVAL, MXBVAL, and NBCOL
        int nparms = 4;

        // Values of blocksize NB
        int[] nbval = new int[] { 1, 1, 2, 2 };

        // Values of minimum row dimension for blocks NBMIN
        int[] nbmin = new int[] { 40, 40, 2, 2 };

        // Number of shifts NSVAL
        int[] nsval = new int[] { 2, 4, 2, 4 };

        // The values for MAXB, used in determining minimum blocksize
        int[] mxbval = new int[] { 40, 40, 2, 2 };

        // The values for NBCOL, the minimum column dimension for blocks
        int[] nbcol = new int[] { 40, 40, 2, 2 };

        // Threshold value for the test ratios.  Information will be printed
        // about each test for which the test ratio is greater than or equal
        // to threshold.
        double thresh = 20.0;

        // Test the LAPACK routines
        boolean tstchk = true;

        // Test the driver routines
        boolean tstdrv = true;

        // Test the error exits for the LAPACK routines and driver routines.
        boolean tsterr = true;

        // Code describing how to set the random number seed.
        // = 0: Set the seed to a default number before each run.
        // = 1: Initialize the seed to a default value only before the first
        // run.
        // = 2: Like 1, but use the seed values in the 4 integer array
        // ioldsd
        int newsd = 1;
        int maxt = 30;
        boolean[] dotype = new boolean[maxt];
        int[] ioldsd = new int[] { 0, 0, 0, 1 };
        int[] iseed = new int[] { 0, 0, 0, 1 };
        int nmax = 132;
        int lwork = (nmax * ((5 * nmax) + 5)) + 1;
        boolean[] logwrk = new boolean[nmax];
        double[] work = new double[lwork];
        double[] result = new double[500];
        int[] info = new int[1];
        int need = 14;
        boolean tstdif = false;
        double thrshn = 10.0;
        double[][] A;
        double[][] B;
        double[][] H;
        double[][] T;
        double[][] S1;
        double[][] S2;
        double[][] P1;
        double[][] P2;
        double[][] U;
        double[][] V;
        double[][] Q;
        double[][] Z;
        double[] alphr1;
        double[] alphi1;
        double[] beta1;
        double[] alphr3;
        double[] alphi3;
        double[] beta3;
        double[][] evectl;
        double[][] evectr;

        // Number of test matrix types
        int ntypes = 26;
        int maxtyp = 26;
        int i;
        int k;
        int maxnval;
        UI.setDataText("Tests of the Generalized Nonsymmetric Eigenvalue Problem routines\n");

        for (i = 0; i < maxtyp; i++) {
            dotype[i] = true;
        }

        maxnval = 0;

        for (i = 0; i < nn; i++) {

            if (nval[i] > maxnval) {
                maxnval = nval[i];
            }
        }

        iparms = new int[100];
        A = new double[nmax][maxnval];
        B = new double[nmax][maxnval];
        H = new double[nmax][maxnval];
        T = new double[nmax][maxnval];
        S1 = new double[nmax][maxnval];
        S2 = new double[nmax][maxnval];
        P1 = new double[nmax][maxnval];
        P2 = new double[nmax][maxnval];
        U = new double[nmax][maxnval];
        V = new double[nmax][maxnval];
        Q = new double[nmax][maxnval];
        Z = new double[nmax][maxnval];
        alphr1 = new double[maxnval];
        alphi1 = new double[maxnval];
        beta1 = new double[maxnval];
        alphr3 = new double[maxnval];
        alphi3 = new double[maxnval];
        beta3 = new double[maxnval];
        evectl = new double[nmax][maxnval];
        evectr = new double[nmax][maxnval];

        for (i = 1; i <= nparms; i++) {

            // 1 = The optimal blocksize; if this value is 1, an unblocked
            // algorithm will give the best performance
            iparms[1 - 1] = nbval[i - 1];

            // 2 = The minimum blocksize for which the block routine should be
            // used; if the usable block size is less than this value, an
            // unblocked routine should be used.
            iparms[2 - 1] = nbmin[i - 1];

            // 3 = The number of shifts, used in nonsymmetric eigenvalue routines.
            iparms[4 - 1] = nsval[i - 1];

            // 5 = The minimum column dimension for blocking to be used;
            // rectangular blocks must have dimension at least k by m,
            // where k is given by ilaenv(2,...) and m by ilaenv(5,...)
            iparms[5 - 1] = nbcol[i - 1];

            // 8 = Another crossover point, for the multishift QR and QZ methods
            // for nonsymmetric eigenvalue problems
            iparms[8 - 1] = mxbval[i - 1];

            if (newsd == 0) {

                for (k = 0; k < 4; k++) {
                    iseed[k] = ioldsd[k];
                }
            } // if (newsd == 0)

            UI.setDataText("Optimal blocksize = " + nbval[i - 1] + "\n");
            UI.setDataText("Minimum blocksize = " + nbmin[i - 1] + "\n");
            UI.setDataText("Number of shifrs = " + nsval[i - 1] + "\n");
            UI.setDataText("Minimum column dimnsion for blocks = " + nbcol[i - 1] + "\n");
            UI.setDataText("Minimum submatrix size = " + mxbval[i - 1] + "\n");

            if (tstchk) {
                dchkgg(nn, nval, maxtyp, dotype, iseed, thresh, tstdif, thrshn, A, nmax, B, H, T, S1, S2, P1, P2, U,
                       nmax, V, Q, Z, alphr1, alphi1, beta1, alphr3, alphi3, beta3, evectl, evectr, work, lwork, logwrk,
                       result, info);

                if (info[0] != 0) {
                    MipavUtil.displayError("dchkgg had info = " + info[0]);
                }
            } // if (tstchk)
        } // for (i = 1; i <= nparms; i++)
    } // dchkgg_test

    /**
     * This is a port of version 3.1 LAPACK test routine DCHKGK Original DCHKGK created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * Sample data values obtained from the file dgbak.in dchkgk tests dggbak, a routine for backward balancing of a
     * matrix pair (A, B).
     */
    public void dchkgk() {
        int lda = 50;
        int ldb = 50;
        int ldvl = 50;
        int ldvr = 50;
        int lde = 50;
        int ldf = 50;
        int ldwork = 50;
        int i;
        int[] ihi = new int[1];
        int[] ilo = new int[1];
        int[] info = new int[1];
        int j;
        int m;
        int n;
        double anorm;
        double bnorm;
        double eps;
        double vmax;
        double[][] A = new double[lda][lda];
        double[][] Asrc;
        double[][] AF = new double[lda][lda];
        double[][] B = new double[ldb][ldb];
        double[][] Bsrc;
        double[][] BF = new double[ldb][ldb];
        double[][] E = new double[lde][lde];
        double[][] F = new double[ldf][ldf];
        double[] lscale = new double[lda];
        double[] rscale = new double[lda];
        double[][] VL = new double[ldvl][ldvl];
        double[][] VLsrc;
        double[][] VLF = new double[ldvl][ldvl];
        double[][] VR = new double[ldvr][ldvr];
        double[][] VRsrc;
        double[][] VRF = new double[ldvr][ldvr];
        double[][] work = new double[ldwork][ldwork];
        int itest;
        double[] work1d;
        int ierr = 0;
        int jerr = 0;

        eps = dlamch('P');
        UI.setDataText("Test output of DGGBAK\n");

        for (itest = 1; itest <= 8; itest++) {

            if (itest == 1) {
                n = 6;
                m = 3;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01, 0.6000E+01 }
                        };

                VRsrc = new double[][] {
                            { -0.1000E+01, -0.1000E+01, -0.1000E+01 },
                            { -0.2000E+01, -0.2000E+01, -0.2000E+01 },
                            { -0.3000E+01, -0.3000E+01, -0.3000E+01 },
                            { -0.4000E+01, -0.4000E+01, -0.4000E+01 },
                            { -0.5000E+01, -0.5000E+01, -0.5000E+01 },
                            { -0.6000E+01, -0.6000E+01, -0.6000E+01 }
                        };

            } else if (itest == 2) {
                n = 6;
                m = 3;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.2000E+01, 0.2100E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.3000E+01, 0.3100E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.4100E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.5100E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01, 0.6100E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01, 0.6000E+01 }
                        };

                VRsrc = new double[][] {
                            { -0.1000E+01, -0.1000E+01, -0.1000E+01 },
                            { -0.2000E+01, -0.2000E+01, -0.2000E+01 },
                            { -0.3000E+01, -0.3000E+01, -0.3000E+01 },
                            { -0.4000E+01, -0.4000E+01, -0.4000E+01 },
                            { -0.5000E+01, -0.5000E+01, -0.5000E+01 },
                            { -0.6000E+01, -0.6000E+01, -0.6000E+01 }
                        };

            } else if (itest == 3) {
                n = 5;
                m = 5;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01 }
                        };

                VRsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01 }
                        };

            } else if (itest == 4) {
                n = 6;
                m = 5;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.2000E+01, -0.3000E+01, 0.4000E+01, 0.5000E+01 },
                            { 0.8000E+01, 0.9000E+01, 0.0000E+00, 0.9000E+01, 0.2000E+01 },
                            { 0.0000E+00, -0.9000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.8000E+01, 0.2000E+01, 0.1000E+01, 0.0000E+00, 0.2000E+01 },
                            { 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.1000E+01, 0.9000E+01, 0.0000E+00, 0.1000E+01 }
                        };

                VRsrc = new double[][] {
                            { 0.1000E+01, -0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01 },
                            { -0.8000E+01, 0.9000E+01, 0.0000E+00, 0.9000E+01, 0.2000E+01 },
                            { 0.0000E+00, 0.9000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.8000E+01, 0.2000E+01, 0.1000E+01, 0.0000E+00, 0.2000E+01 },
                            { 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.8000E+01, 0.9000E+01, 0.0000E+00, 0.1000E+01 }
                        };

            } else if (itest == 5) {
                n = 6;
                m = 2;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01 }
                        };

                VRsrc = new double[][] {
                            { 0.1100E+01, 0.1100E+01 },
                            { 0.2200E+01, 0.2200E+01 },
                            { 0.3300E+01, 0.3300E+01 },
                            { 0.4400E+01, 0.4400E+01 },
                            { 0.5500E+01, 0.5500E+01 },
                            { 0.6600E+01, 0.6600E+01 }
                        };

            } else if (itest == 6) {
                n = 7;
                m = 3;
                Asrc = new double[][] {
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01, 0.6000E+01 },
                            { 0.7000E+01, 0.7000E+01, 0.7000E+01 }
                        };

                VRsrc = new double[][] {
                            { -0.1000E+01, -0.1000E+01, -0.1000E+01 },
                            { -0.2000E+01, -0.2000E+01, -0.2000E+01 },
                            { -0.3000E+01, -0.3000E+01, -0.3000E+01 },
                            { -0.4000E+01, -0.4000E+01, -0.4000E+01 },
                            { -0.5000E+01, -0.5000E+01, -0.5000E+01 },
                            { -0.6000E+01, -0.6000E+01, -0.6000E+01 },
                            { -0.7000E+01, -0.7000E+01, -0.7000E+01 }
                        };

            } else if (itest == 7) {
                n = 7;
                m = 3;
                Asrc = new double[][] {
                           { 0.0000E+00, 0.1000E+04, 0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E-04 },
                           { 0.0000E+00, 0.1000E-04, 0.1000E+04, 0.1000E-04, 0.1000E-04, 0.1000E+04, 0.1000E+04 },
                           { 0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04 },
                           { 0.0000E+00, 0.1000E-04, 0.0000E+00, 0.1000E+00, 0.1000E+04, 0.1000E-04, 0.1000E+04 },
                           { 0.0000E+00, 0.1000E+04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.4000E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-04 },
                           { 0.0000E+00, 0.1000E+04, 0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04 }
                       };

                Bsrc = new double[][] {
                           { 0.0000E+00, 0.1000E-01, 0.0000E+00, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04 },
                           { 0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+00, 0.1000E+04 },
                           { 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04 },
                           { 0.0000E+00, 0.4000E-01, 0.0000E+00, 0.1000E+04, 0.1000E+01, 0.1000E+04, 0.1000E+04 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E-04, 0.0000E+00, 0.1000E+04, 0.1000E+01, 0.1000E+01, 0.1000E-04 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01, 0.6000E+01 },
                            { 0.7000E+01, 0.7000E+01, 0.7000E+01 }
                        };

                VRsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01, 0.6000E+01 },
                            { 0.7000E+01, 0.7000E+01, 0.7000E+01 }
                        };

            } else {
                n = 6;
                m = 2;
                Asrc = new double[][] {
                           { -0.2000E+02, -0.1000E+05, -0.2000E+01, -0.1000E+07, -0.1000E+02, -0.2000E+06 },
                           { 0.6000E-02, 0.4000E+01, 0.6000E-03, 0.2000E+03, 0.3000E-02, 0.3000E+02 },
                           { -0.2000E+00, -0.3000E+03, -0.4000E-01, -0.1000E+05, 0.0000E+00, 0.3000E+04 },
                           { 0.6000E-04, 0.4000E-01, 0.9000E-05, 0.9000E+01, 0.3000E-04, 0.5000E+00 },
                           { 0.6000E-01, 0.5000E+02, 0.8000E-02, -0.4000E+04, 0.8000E-01, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+04, 0.7000E+00, -0.2000E+06, 0.1300E+02, -0.6000E+05 }
                       };

                Bsrc = new double[][] {
                           { -0.2000E+02, -0.1000E+05, 0.2000E+01, -0.2000E+07, 0.1000E+02, -0.1000E+06 },
                           { 0.5000E-02, 0.3000E+01, -0.2000E-03, 0.4000E+03, -0.1000E-02, 0.3000E+02 },
                           { 0.0000E+00, -0.1000E+03, -0.8000E-01, 0.2000E+05, -0.4000E+00, 0.0000E+00 },
                           { 0.5000E-04, 0.3000E-01, 0.2000E-05, 0.4000E+01, 0.2000E-04, 0.1000E+00 },
                           { 0.4000E-01, 0.3000E+02, -0.1000E-02, 0.3000E+04, -0.1000E-01, 0.6000E+03 },
                           { -0.1000E+01, 0.0000E+00, 0.4000E+00, -0.1000E+06, 0.4000E+01, 0.2000E+05 }
                       };

                VLsrc = new double[][] {
                            { 0.1000E+01, 0.1000E+01 },
                            { 0.2000E+01, 0.2000E+01 },
                            { 0.3000E+01, 0.3000E+01 },
                            { 0.4000E+01, 0.4000E+01 },
                            { 0.5000E+01, 0.5000E+01 },
                            { 0.6000E+01, 0.6000E+01 }
                        };

                VRsrc = new double[][] {
                            { 0.1000E+02, 0.1000E+02 },
                            { 0.2000E+02, 0.2000E+02 },
                            { 0.3000E+02, 0.3000E+02 },
                            { 0.4000E+02, 0.4000E+02 },
                            { 0.5000E+02, 0.5000E+02 },
                            { 0.6000E+02, 0.6000E+02 }
                        };

            } // else itest == 8

            for (i = 0; i < lda; i++) {

                for (j = 0; j < lda; j++) {
                    A[i][j] = 0.0;
                }
            }

            for (i = 0; i < ldb; i++) {

                for (j = 0; j < ldb; j++) {
                    B[i][j] = 0.0;
                }
            }

            for (i = 0; i < ldvl; i++) {

                for (j = 0; j < ldvl; j++) {
                    VL[i][j] = 0.0;
                }
            }

            for (i = 0; i < ldvr; i++) {

                for (j = 0; j < ldvr; j++) {
                    VR[i][j] = 0.0;
                }
            }

            for (i = 0; i < n; i++) {

                for (j = 0; j < n; j++) {
                    A[i][j] = Asrc[i][j];
                    B[i][j] = Bsrc[i][j];
                }

                for (j = 0; j < m; j++) {
                    VL[i][j] = VLsrc[i][j];
                    VR[i][j] = VRsrc[i][j];
                }
            }

            work1d = new double[6 * n];
            anorm = dlange('M', n, n, A, lda, work1d);
            bnorm = dlange('M', n, n, B, ldb, work1d);

            dlacpy('F', n, n, A, lda, AF, lda);
            dlacpy('F', n, n, B, ldb, BF, ldb);

            UI.setDataText("Test number = " + itest + "\n");
            dggbal('B', n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work1d, info);

            if (info[0] != 0) {
                UI.setDataText("dggbal had info[0] = " + info[0] + "\n");
            }

            dlacpy('F', n, m, VL, ldvl, VLF, ldvl);
            dlacpy('F', n, m, VR, ldvr, VRF, ldvr);

            dggbak('B', 'L', n, ilo[0], ihi[0], lscale, rscale, m, VL, ldvl, info);

            if (info[0] != 0) {
                UI.setDataText("dggbak with side = L had info[0] = " + info[0] + "\n");
            }

            dggbak('B', 'R', n, ilo[0], ihi[0], lscale, rscale, m, VR, ldvr, info);

            if (info[0] != 0) {
                UI.setDataText("dggbak with side = R had info[0] = " + info[0] + "\n");
            }

            // Test of dggbak
            // Check tilde(V)'*A*tilde(VR) - VL'*tilde(A)*VR
            // where tilde(A) denotes the transformed matrix
            dgemm('N', 'N', n, m, n, 1.0, AF, lda, VR, ldvr, 0.0, work, ldwork);
            dgemm('T', 'N', m, m, n, 1.0, VL, ldvl, work, ldwork, 0.0, E, lde);

            dgemm('N', 'N', n, m, n, 1.0, A, lda, VRF, ldvr, 0.0, work, ldwork);
            dgemm('T', 'N', m, m, n, 1.0, VLF, ldvl, work, ldwork, 0.0, F, ldf);

            vmax = 0.0;

            for (j = 0; j < m; j++) {

                for (i = 0; i < m; i++) {

                    if (Math.abs(E[i][j] - F[i][j]) > vmax) {
                        vmax = Math.abs(E[i][j] - F[i][j]);
                        ierr = i;
                        jerr = j;
                    }
                }
            }

            vmax = vmax / (eps * Math.max(anorm, bnorm));
            UI.setDataText("For A check vmax = " + vmax + "\n");

            if (vmax > 0.0) {
                UI.setDataText("E[" + ierr + "][" + jerr + "] = " + E[ierr][jerr] + "\n");
                UI.setDataText("F[" + ierr + "][" + jerr + "] = " + F[ierr][jerr] + "\n");
            }

            // Check tilde(V)'*B*tilde(VR) - VL'*tilde(B)*VR
            dgemm('N', 'N', n, m, n, 1.0, BF, ldb, VR, ldvr, 0.0, work, ldwork);
            dgemm('T', 'N', m, m, n, 1.0, VL, ldvl, work, ldwork, 0.0, E, lde);

            dgemm('N', 'N', n, m, n, 1.0, B, ldb, VRF, ldvr, 0.0, work, ldwork);
            dgemm('T', 'N', m, m, n, 1.0, VLF, ldvl, work, ldwork, 0.0, F, ldf);

            vmax = 0.0;

            for (j = 0; j < m; j++) {

                for (i = 0; i < m; i++) {

                    if (Math.abs(E[i][j] - F[i][j]) > vmax) {
                        vmax = Math.abs(E[i][j] - F[i][j]);
                        ierr = i;
                        jerr = j;
                    }
                }
            }

            vmax = vmax / (eps * Math.max(anorm, bnorm));
            UI.setDataText("For B check vmax = " + vmax + "\n");

            if (vmax > 0.0) {
                UI.setDataText("E[" + ierr + "][" + jerr + "] = " + E[ierr][jerr] + "\n");
                UI.setDataText("F[" + ierr + "][" + jerr + "] = " + F[ierr][jerr] + "\n");
            }

        } // for (itest = 1; itest <= 8; itest++)

        return;
    } // dchkgk

    /**
     * This is a port of version 3.1 LAPACK test routine DCHKGL Original DCHKGL created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * Sample data values obtained from the file dgbal.in
     *
     * <p>dchkgl tests dggbal, a routine for balancing a matrix pair (A, B)</p>
     */
    public void dchkgl() {
        int lda = 20;
        int ldb = 20;
        int lwork = 6 * lda;
        double eps;
        double anorm;
        double bnorm;
        double[] work = new double[lwork];
        int[] info = new int[1];
        double vmax;
        int i;
        int j;
        int itest;
        int n;
        double[][] A = new double[lda][lda];
        double[][] Asrc;
        double[][] B = new double[ldb][ldb];
        double[][] Bsrc;
        int iloin;
        int ihiin;
        int[] ilo = new int[1];
        int[] ihi = new int[1];
        double[][] ain = new double[lda][lda];
        double[][] ainsrc;
        double[][] bin = new double[ldb][ldb];
        double[][] binsrc;
        double[] lsclin = new double[lda];
        double[] lsclinsrc;
        double[] rsclin = new double[lda];
        double[] rsclinsrc;
        double[] lscale = new double[lda];
        double[] rscale = new double[lda];
        int itype;
        int ierr = 0;
        int jerr = 0;

        eps = dlamch('P');
        UI.setDataText("Test output of DGGBAL\n");

        for (itest = 1; itest <= 8; itest++) {

            if (itest == 1) {
                n = 6;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01 }
                       };
                Bsrc = new double[][] {
                           { 0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                       };
                iloin = 1;
                ihiin = 1;
                ainsrc = new double[][] {
                             { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01 }
                         };
                binsrc = new double[][] {
                             { 0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };
                lsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01 };
                rsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01 };
            } // if (itest = 1);
            else if (itest == 2) {
                n = 6;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                       };

                iloin = 1;
                ihiin = 1;
                ainsrc = new double[][] {
                             { 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                binsrc = new double[][] {
                             { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                lsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

                rsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

            } else if (itest == 3) {
                n = 6;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01 }
                       };

                iloin = 1;
                ihiin = 1;
                ainsrc = new double[][] {
                             { 0.6000E+01, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                binsrc = new double[][] {
                             { 0.6000E+01, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                lsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

                rsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

            } else if (itest == 4) {
                n = 5;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00 },
                           { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00 },
                           { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                       };

                iloin = 1;
                ihiin = 1;
                ainsrc = new double[][] {
                             { 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                binsrc = new double[][] {
                             { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                lsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

                rsclinsrc = new double[] { 0.1000E+01, 0.2000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01 };

            } else if (itest == 5) {
                n = 6;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                iloin = 1;
                ihiin = 6;
                ainsrc = new double[][] {
                             { 0.1000E-03, 0.1000E+05, 0.1000E+04, 0.1000E+02, 0.1000E+00, 0.1000E-01 },
                             { 0.1000E-02, 0.1000E-04, 0.1000E+05, 0.1000E+03, 0.1000E+01, 0.1000E+00 },
                             { 0.1000E+00, 0.1000E-02, 0.1000E-03, 0.1000E+05, 0.1000E+03, 0.1000E+02 },
                             { 0.1000E+02, 0.1000E+00, 0.1000E-01, 0.1000E-03, 0.1000E+05, 0.1000E+04 },
                             { 0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E+05 },
                             { 0.1000E+05, 0.1000E+03, 0.1000E+02, 0.1000E+00, 0.1000E-02, 0.1000E-03 }
                         };

                binsrc = new double[][] {
                             { 0.1000E-03, 0.1000E+05, 0.1000E+04, 0.1000E+02, 0.1000E+00, 0.1000E-01 },
                             { 0.1000E-02, 0.1000E-04, 0.1000E+05, 0.1000E+03, 0.1000E+01, 0.1000E+00 },
                             { 0.1000E+00, 0.1000E-02, 0.1000E-03, 0.1000E+05, 0.1000E+03, 0.1000E+02 },
                             { 0.1000E+02, 0.1000E+00, 0.1000E-01, 0.1000E-03, 0.1000E+05, 0.1000E+04 },
                             { 0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E+05 },
                             { 0.1000E+05, 0.1000E+03, 0.1000E+02, 0.1000E+00, 0.1000E-02, 0.1000E-03 }
                         };

                lsclinsrc = new double[] { 0.1000E-05, 0.1000E-04, 0.1000E-02, 0.1000E+00, 0.1000E+01, 0.1000E+03 };

                rsclinsrc = new double[] { 0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E-05 };

            } else if (itest == 6) {
                n = 6;
                Asrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07 }
                       };

                Bsrc = new double[][] {
                           { 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05 },
                           { 0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07 }
                       };

                iloin = 4;
                ihiin = 6;
                ainsrc = new double[][] {
                             { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-03, 0.1000E+05 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+05, 0.1000E+01, 0.1000E-03 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-03, 0.1000E+05, 0.1000E+01 }
                         };

                binsrc = new double[][] {
                             { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-03, 0.1000E+05 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+05, 0.1000E+01, 0.1000E-03 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-03, 0.1000E+05, 0.1000E+01 }
                         };

                lsclinsrc = new double[] { 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.1000E+00, 0.1000E+04, 0.1000E-04 };

                rsclinsrc = new double[] { 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00 };

            } else if (itest == 7) {
                n = 7;
                Asrc = new double[][] {
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                Bsrc = new double[][] {
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 },
                           { 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 }
                       };

                iloin = 3;
                ihiin = 5;
                ainsrc = new double[][] {
                             { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                binsrc = new double[][] {
                             { 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01 },
                             { 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01 }
                         };

                lsclinsrc = new double[] {
                                0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.6000E+01, 0.5000E+01
                            };

                rsclinsrc = new double[] {
                                0.1000E+01, 0.3000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.2000E+01, 0.2000E+01
                            };

            } else {
                n = 6;
                Asrc = new double[][] {
                           { -0.2000E+02, -0.1000E+05, -0.2000E+01, -0.1000E+07, -0.1000E+02, -0.2000E+06 },
                           { 0.6000E-02, 0.4000E+01, 0.6000E-03, 0.2000E+03, 0.3000E-02, 0.3000E+02 },
                           { -0.2000E+00, -0.3000E+03, -0.4000E-01, -0.1000E+05, 0.0000E+00, 0.3000E+04 },
                           { 0.6000E-04, 0.4000E-01, 0.9000E-05, 0.9000E+01, 0.3000E-04, 0.5000E+00 },
                           { 0.6000E-01, 0.5000E+02, 0.8000E-02, -0.4000E+04, 0.8000E-01, 0.0000E+00 },
                           { 0.0000E+00, 0.1000E+04, 0.7000E+00, -0.2000E+06, 0.1300E+02, -0.6000E+05 }
                       };

                Bsrc = new double[][] {
                           { -0.2000E+02, -0.1000E+05, 0.2000E+01, -0.2000E+07, 0.1000E+02, -0.1000E+06 },
                           { 0.5000E-02, 0.3000E+01, -0.2000E-03, 0.4000E+03, -0.1000E-02, 0.3000E+02 },
                           { 0.0000E+00, -0.1000E+03, -0.8000E-01, 0.2000E+05, -0.4000E+00, 0.0000E+00 },
                           { 0.5000E-04, 0.3000E-01, 0.2000E-05, 0.4000E+01, 0.2000E-04, 0.1000E+00 },
                           { 0.4000E-01, 0.3000E+02, -0.1000E-02, 0.3000E+04, -0.1000E-01, 0.6000E+03 },
                           { -0.1000E+01, 0.0000E+00, 0.4000E+00, -0.1000E+06, 0.4000E+01, 0.2000E+05 }
                       };

                iloin = 1;
                ihiin = 6;
                ainsrc = new double[][] {
                             { -0.2000E+00, -0.1000E+01, -0.2000E+00, -0.1000E+01, -0.1000E+01, -0.2000E+01 },
                             { 0.6000E+00, 0.4000E+01, 0.6000E+00, 0.2000E+01, 0.3000E+01, 0.3000E+01 },
                             { -0.2000E+00, -0.3000E+01, -0.4000E+00, -0.1000E+01, 0.0000E+00, 0.3000E+01 },
                             { 0.6000E+00, 0.4000E+01, 0.9000E+00, 0.9000E+01, 0.3000E+01, 0.5000E+01 },
                             { 0.6000E+00, 0.5000E+01, 0.8000E+00, -0.4000E+01, 0.8000E+01, 0.0000E+00 },
                             { 0.0000E+00, 0.1000E+01, 0.7000E+00, -0.2000E+01, 0.1300E+02, -0.6000E+01 }
                         };

                binsrc = new double[][] {
                             { -0.2000E+00, -0.1000E+01, 0.2000E+00, -0.2000E+01, 0.1000E+01, -0.1000E+01 },
                             { 0.5000E+00, 0.3000E+01, -0.2000E+00, 0.4000E+01, -0.1000E+01, 0.3000E+01 },
                             { 0.0000E+00, -0.1000E+01, -0.8000E+00, 0.2000E+01, -0.4000E+01, 0.0000E+00 },
                             { 0.5000E+00, 0.3000E+01, 0.2000E+00, 0.4000E+01, 0.2000E+01, 0.1000E+01 },
                             { 0.4000E+00, 0.3000E+01, -0.1000E+00, 0.3000E+01, -0.1000E+01, 0.6000E+01 },
                             { -0.1000E+00, 0.0000E+00, 0.4000E+00, -0.1000E+01, 0.4000E+01, 0.2000E+01 }
                         };

                lsclinsrc = new double[] { 0.1000E-02, 0.1000E+02, 0.1000E+00, 0.1000E+04, 0.1000E+01, 0.1000E-01 };

                rsclinsrc = new double[] { 0.1000E+02, 0.1000E+00, 0.1000E+03, 0.1000E-02, 0.1000E+03, 0.1000E-01 };

            } // else itest == 8

            for (i = 0; i < lda; i++) {
                lscale[i] = 0.0;
                lsclin[i] = 0.0;
                rscale[i] = 0.0;
                rsclin[i] = 0.0;

                for (j = 0; j < lda; j++) {
                    A[i][j] = 0.0;
                    ain[i][j] = 0.0;
                }
            }

            for (i = 0; i < ldb; i++) {

                for (j = 0; j < ldb; j++) {
                    B[i][j] = 0.0;
                    bin[i][j] = 0.0;
                }
            }

            for (i = 0; i < n; i++) {
                lsclin[i] = lsclinsrc[i];
                rsclin[i] = rsclinsrc[i];

                for (j = 0; j < n; j++) {
                    A[i][j] = Asrc[i][j];
                    ain[i][j] = ainsrc[i][j];
                    B[i][j] = Bsrc[i][j];
                    bin[i][j] = binsrc[i][j];
                }
            }

            anorm = dlange('M', n, n, A, lda, work);
            bnorm = dlange('M', n, n, B, ldb, work);

            dggbal('B', n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info);
            UI.setDataText("Test number = " + itest + "\n");

            if (info[0] != 0) {
                UI.setDataText("info[0] = " + info[0] + "\n");
            }

            if ((ilo[0] != iloin) || (ihi[0] != ihiin)) {
                UI.setDataText("ilo or ihi wrong\n");
            }

            vmax = 0.0;
            itype = 0;

            for (i = 0; i < n; i++) {

                for (j = 0; j < n; j++) {

                    if (Math.abs(A[i][j] - ain[i][j]) > vmax) {
                        vmax = Math.abs(A[i][j] - ain[i][j]);
                        itype = 1;
                        ierr = i;
                        jerr = j;
                    }

                    if (Math.abs(B[i][j] - bin[i][j]) > vmax) {
                        itype = 2;
                        ierr = i;
                        jerr = j;
                    }
                }
            }

            for (i = 0; i < n; i++) {

                if (Math.abs(lscale[i] - lsclin[i]) > vmax) {
                    vmax = Math.abs(lscale[i] - lsclin[i]);
                    itype = 3;
                    ierr = i;
                }

                if (Math.abs(rscale[i] - rsclin[i]) > vmax) {
                    vmax = Math.abs(rscale[i] - rsclin[i]);
                    itype = 4;
                    ierr = i;
                }
            }

            vmax = vmax / (eps * Math.max(anorm, bnorm));

            UI.setDataText("Error vmax = " + vmax + "\n");

            if (vmax > 0.0) {

                if (itype == 1) {
                    UI.setDataText("A[" + ierr + "][" + jerr + "] = " + A[ierr][jerr] + "\n");
                    UI.setDataText("ain[" + ierr + "][" + jerr + "] = " + ain[ierr][jerr] + "\n");
                } else if (itype == 2) {
                    UI.setDataText("B[" + ierr + "][" + jerr + "] = " + B[ierr][jerr] + "\n");
                    UI.setDataText("bin[" + ierr + "][" + jerr + "] = " + bin[ierr][jerr] + "\n");
                } else if (itype == 3) {
                    UI.setDataText("lscale[" + ierr + "] = " + lscale[ierr] + "\n");
                    UI.setDataText("lsclin[" + ierr + "] = " + lsclin[ierr] + "\n");
                } else if (itype == 4) {
                    UI.setDataText("rscale[" + ierr + "] = " + rscale[ierr] + "\n");
                    UI.setDataText("rsclin[" + ierr + "] = " + rsclin[ierr] + "\n");

                }
            } // if (vmax > 0.0)
        } // for (itest = 1; itest <= 8; itest++)

        return;
    } // dchkgl

    /**
     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive dchkst, that tests
     * routines used in symmetric generalized eigenvalue problem. The routines tested are dsytrd, dorgtr, dsteqr, and
     * dsterf. Numerical values were obtained from the sep.in datafile. Original DCHKEE created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., January, 2007
     */
    public void dchkst_test() {

        // Number of values of n
        int nn = 6;

        // Values of matrix dimension n
        int[] nval = new int[] { 0, 1, 2, 3, 5, 20 };

        // Number of values of NB, NBMIN, and NX
        int nparms = 5;

        // Values of blocksize NB
        int[] nbval = new int[] { 1, 3, 3, 3, 10 };

        // Values of minimum blocksize NBMIN
        int[] nbmin = new int[] { 2, 2, 2, 2, 2 };

        // Values of crossover point NX
        int[] nxval = new int[] { 1, 0, 5, 9, 1 };

        // Threshold value for the test ratios.  Information will be printed
        // about each test for which the test ratio is greater than or equal
        // to threshold.
        double thresh = 50.0;

        // Test the LAPACK routines
        boolean tstchk = true;

        // Test the driver routines
        boolean tstdrv = true;

        // Test the error exits for the LAPACK routines and driver routines.
        boolean tsterr = true;

        // Code describing how to set the random number seed.
        // = 0: Set the seed to a default number before each run.
        // = 1: Initialize the seed to a default value only before the first
        // run.
        // = 2: Like 1, but use the seed values in the 4 integer array
        // ioldsd
        int newsd = 1;
        int maxt = 30;
        boolean[] dotype = new boolean[maxt];
        int[] ioldsd = new int[] { 0, 0, 0, 1 };
        int[] iseed = new int[] { 0, 0, 0, 1 };
        int nmax = 132;
        int lwork = (nmax * ((5 * nmax) + 5)) + 1;
        int liwork = nmax * ((5 * nmax) + 20);
        int[] iwork = new int[liwork];
        double[] work = new double[lwork];
        double[] result = new double[500];
        int[] info = new int[1];
        int need = 14;
        double[][] A;
        double[] AP;
        double[] SD;
        double[] SE;
        double[] D1;
        double[] D2;
        double[] D3;
        double[] D4;
        double[] D5;
        double[] WA1;
        double[] WA2;
        double[] WA3;
        double[] WR;
        double[][] U;
        double[][] V;
        double[] VP;
        double[] TAU;
        double[][] Z;

        // Number of test matrix types
        int ntypes = 21;
        int maxtyp = 21;
        int i;
        int k;
        int maxnval;
        UI.setDataText("Tests of the Symmetric Eigenvalue Problem routines\n");

        for (i = 0; i < maxtyp; i++) {
            dotype[i] = true;
        }

        maxnval = 0;

        for (i = 0; i < nn; i++) {

            if (nval[i] > maxnval) {
                maxnval = nval[i];
            }
        }

        iparms = new int[100];

        // 9 = maximum size of the subproblems at the bottom of the computation
        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
        iparms[9 - 1] = 25;
        A = new double[nmax][maxnval];
        AP = new double[maxnval * (maxnval + 1) / 2];
        SD = new double[maxnval];
        SE = new double[maxnval];
        D1 = new double[maxnval];
        D2 = new double[maxnval];
        D3 = new double[maxnval];
        D4 = new double[maxnval];
        D5 = new double[maxnval];
        WA1 = new double[maxnval];
        WA2 = new double[maxnval];
        WA3 = new double[maxnval];
        WR = new double[maxnval];
        U = new double[nmax][maxnval];
        V = new double[nmax][maxnval];
        VP = new double[maxnval * (maxnval + 1) / 2];
        TAU = new double[maxnval];
        Z = new double[nmax][maxnval];

        for (i = 1; i <= nparms; i++) {

            // 1 = The optimal blocksize; if this value is 1, an unblocked
            // algorithm will give the best performance
            iparms[1 - 1] = nbval[i - 1];

            // 2 = The minimum blocksize for which the block routine should be
            // used; if the usable block size is less than this value, an
            // unblocked routine should be used.
            iparms[2 - 1] = nbmin[i - 1];

            // 3 = The crossover point (in a block routine, for n less than this
            // value, an unblocked routine should be used).
            iparms[3 - 1] = nxval[i - 1];

            if (newsd == 0) {

                for (k = 0; k < 4; k++) {
                    iseed[k] = ioldsd[k];
                }
            } // if (newsd == 0)

            UI.setDataText("Optimal blocksize = " + nbval[i - 1] + "\n");
            UI.setDataText("Minimum blocksize = " + nbmin[i - 1] + "\n");
            UI.setDataText("Crossover point = " + nxval[i - 1] + "\n");

            if (tstchk) {
                dchkst(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, AP, SD, SE, D1, D2, D3, D4, D5, WA1, WA2, WA3,
                       WR, U, nmax, V, VP, TAU, Z, work, lwork, iwork, liwork, result, info);

                if (info[0] != 0) {
                    MipavUtil.displayError("dckkst had info = " + info[0]);
                }
            } // if (tstchk)
        } // for (i = 1; i <= nparms; i++)
    } // dckkst_test

    /**
     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrvst, that tests
     * symmetric generalized eigenvalue drivers. The driver tested is dsyev. Numerical values were obtained from the
     * sep.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., January, 2007
     */
    public void ddrvst_test() {

        // Number of values of n
        int nn = 6;

        // Values of matrix dimension n
        int[] nval = new int[] { 0, 1, 2, 3, 5, 20 };

        // Number of values of NB, NBMIN, and NX
        int nparms = 5;

        // Values of blocksize NB
        int[] nbval = new int[] { 1, 3, 3, 3, 10 };

        // Values of minimum blocksize NBMIN
        int[] nbmin = new int[] { 2, 2, 2, 2, 2 };

        // Values of crossover point NX
        int[] nxval = new int[] { 1, 0, 5, 9, 1 };

        // Threshold value for the test ratios.  Information will be printed
        // about each test for which the test ratio is greater than or equal
        // to threshold.
        double thresh = 50.0;

        // Test the LAPACK routines
        boolean tstchk = true;

        // Test the driver routines
        boolean tstdrv = true;

        // Test the error exits for the LAPACK routines and driver routines.
        boolean tsterr = true;

        // Code describing how to set the random number seed.
        // = 0: Set the seed to a default number before each run.
        // = 1: Initialize the seed to a default value only before the first
        // run.
        // = 2: Like 1, but use the seed values in the 4 integer array
        // ioldsd
        int newsd = 1;
        int maxt = 30;
        boolean[] dotype = new boolean[maxt];
        int[] ioldsd = new int[] { 0, 0, 0, 1 };
        int[] iseed = new int[] { 0, 0, 0, 1 };
        int nmax = 132;
        int lwork = (nmax * ((5 * nmax) + 5)) + 1;
        int liwork = nmax * ((5 * nmax) + 20);
        int[] iwork = new int[liwork];
        double[] work = new double[lwork];
        double[] result = new double[500];
        int[] info = new int[1];
        double[][] A;
        double[] D1;
        double[] D2;
        double[] D3;
        double[] D4;
        double[] eveigs;
        double[] WA1;
        double[] WA2;
        double[] WA3;
        double[][] U;
        double[][] V;
        double[] tau;
        double[][] Z;

        // Number of test matrix types
        int ntypes = 21;
        int maxtyp = 21;
        int i;
        int k;
        int maxnval;
        UI.setDataText("Tests of the Symmetric Eigenvalue Problem routines\n");

        for (i = 0; i < maxtyp; i++) {
            dotype[i] = true;
        }

        maxnval = 0;

        for (i = 0; i < nn; i++) {

            if (nval[i] > maxnval) {
                maxnval = nval[i];
            }
        }

        iparms = new int[100];

        // 9 = maximum size of the subproblems at the bottom of the computation
        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
        iparms[9 - 1] = 25;
        A = new double[nmax][maxnval];
        D1 = new double[maxnval];
        D2 = new double[maxnval];
        D3 = new double[maxnval];
        D4 = new double[maxnval];
        eveigs = new double[maxnval];
        WA1 = new double[maxnval];
        WA2 = new double[maxnval];
        WA3 = new double[maxnval];
        U = new double[nmax][maxnval];
        V = new double[nmax][maxnval];
        tau = new double[maxnval];
        Z = new double[nmax][maxnval];

        for (i = 1; i <= nparms; i++) {

            // 1 = The optimal blocksize; if this value is 1, an unblocked
            // algorithm will give the best performance
            iparms[1 - 1] = nbval[i - 1];

            // 2 = The minimum blocksize for which the block routine should be
            // used; if the usable block size is less than this value, an
            // unblocked routine should be used.
            iparms[2 - 1] = nbmin[i - 1];

            // 3 = The crossover point (in a block routine, for n less than this
            // value, an unblocked routine should be used).
            iparms[3 - 1] = nxval[i - 1];

            if (newsd == 0) {

                for (k = 0; k < 4; k++) {
                    iseed[k] = ioldsd[k];
                }
            } // if (newsd == 0)

            UI.setDataText("Optimal blocksize = " + nbval[i - 1] + "\n");
            UI.setDataText("Minimum blocksize = " + nbmin[i - 1] + "\n");
            UI.setDataText("Crossover point = " + nxval[i - 1] + "\n");

            if (tstdrv) {
                ddrvst(nn, nval, 18, dotype, iseed, thresh, A, nmax, D1, D2, D3, D4, eveigs, WA1, WA2, WA3, U, nmax, V,
                       tau, Z, work, lwork, iwork, liwork, result, info);

                if (info[0] != 0) {
                    MipavUtil.displayError("ddrvst had info = " + info[0]);
                }
            } // if (tstchk)
        } // for (i = 1; i <= nparms; i++)
    } // ddrvst_test

    /**
     * This is a port of the version 3.1 LAPACK driver routine DGGEV Original DGGEV created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006 dggev computes for a pair of n by n real nonsymmetric
     * matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors.
     *
     * <p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such
     * that A - lambda*B is singular. It is usually represented as the pair (alpha, beta), as there is a reasonable
     * interpretation for beta = 0, and even for both being zero.</p>
     *
     * <p>The right eigenvector v[j] corresponding to the eigenvalue lambda[j] of (A,B) satisfies A * v[j] = lambda[j] *
     * B * v[j] The left eigenvector u[j] corresponding to the eigenvalue lambda[j] of (A,B) satisfies u[j]**H * A =
     * lambda[j] * u[j]**H * B where u[j]**H is the conjugate-transpose of u[j].</p>
     *
     * @param  jobvl   input char = 'N': do not compute the left generalized eigenvectors = 'V': compute the left
     *                 generalized eigenvectors
     * @param  jobvr   input char = 'N': do not compute the right generalized eigenvectors = 'V': compute the right
     *                 generalized eigenvectors
     * @param  n       input int The order of the matrices A, B, vl, and vr. n >= 0.
     * @param  A       input/output double[][] of dimension (lda,n) On entry, the matrix A in the pair (A,B). On exit, A
     *                 has been overwritten.
     * @param  lda     input int The leading dimension of A. lda >= max(1,n).
     * @param  B       input/output double[][] of dimension (ldb,n). On entry, the matrix B in the pair (A,B). On exit,
     *                 B has been overwritten.
     * @param  ldb     input int The leading dimension of B. ldb >= max(1,n).
     * @param  alphar  output double[] of dimension n
     * @param  alphai  output double[] of dimension n
     * @param  beta    output double[] of dimension n On exit, (alphar[j] + alphai[j]*i)/beta[j], j = 0,...,n-1 will be
     *                 the generalized eigenvalues. If alphai[j] is zero, then the j-th eigenvalue is real; if positive,
     *                 then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with alphai[j+1] negative.
     *
     *                 <p>Note: the quotients alphar[j]/beta[j] and alphai[j]/beta[j] may easily over- or underflow, and
     *                 beta[j] may even be zero. Thus, the user should avoid naively computing the ratio alpha/beta.
     *                 However, alphar and alphai will be always less than and usually comparable with norm(A) in
     *                 magnitude, and beta always less than and usually comparable with norm(B).</p>
     * @param  vl      output double[][] of dimension (ldvl,n) If jobvl = 'V', the left eigenvectors u[j] are stored one
     *                 after another in the columns of vl, in the same order as their eigenvalues. If the j-th
     *                 eigenvalue is real, then u[j] = vl(:,j), the j-th column of vl. If the j-th and (j+1)-th
     *                 eigenvalues form a complex conjugate pair, then u[j] = vl(:,j) + i*vl(:,j+1) and u[j+1] = vl(:,j)
     *                 - i*vl(:,j+1). Each eigenvector will be scaled so the largest component have abs(real part) +
     *                 abs(imag part) = 1. Not referenced if jobvl = 'N'.
     * @param  ldvl    input int The leading dimension of matrix vl. ldvl >= 1, and if jobvl = 'V', ldvl >= n.
     * @param  vr      output double[][] of dimension (ldvr,n) If jobvr = 'V', the right eigenvectors v[j] are stored
     *                 one after another in the columns of vr, in the same order as their eigenvalues. If the j-th
     *                 eigenvalue is real, then v[j] = vr(:,j), the j-th column of vr. If the j-th and (j+1)-th
     *                 eigenvalues form a complex pair, then v[j] = vr(:,j) + i*vr(:,j+1) and v[j+1] = vr(:,j) -
     *                 i*vr(:,j+1). Each eigenvector will be scaled so the largest component have abs(real part) +
     *                 abs(imag part) = 1. Not referenced if jobvr = 'N'.
     * @param  ldvr    input int The leading dimension of matrix vr. ldvr >= 1, and if jobvr = 'V', ldvr >= n.
     * @param  work    (workspace/output) double[] of dimension max(1,lwork) On exit, if info[0] = 0, work[0] returns
     *                 the optimal lwork.
     * @param  lwork   input int The dimension of the array work. lwork >= max(1,8*n). For good performance, lwork must
     *                 generally be larger. If lwork = -1, then a workspace query is assumed; the routine only
     *                 calculates the optimal size of the work array, returns this value as the first entry of the work
     *                 array, and no error message related to lwork is issued.
     * @param  info    output int[] = 0: successful exit < 0: if info[0] = -i, the i-th argument had an illegal value =
     *                 1,...,n: The QZ iteration failed. No eigenvectors have been calculated, but alphar[j] ,
     *                 alphai[j], and beta[j] should be correct for j = info[0],...,n-1. > n: = n+1: other than QZ
     *                 iteration failed in DHGEQZ. = n+2: error return from dtgevc.
     */
    public void dggev(char jobvl, char jobvr, int n, double[][] A, int lda, double[][] B, int ldb, double[] alphar,
                      double[] alphai, double[] beta, double[][] vl, int ldvl, double[][] vr, int ldvr, double[] work,
                      int lwork, int[] info) {
        boolean ilascl;
        boolean ilbscl;
        boolean ilv;
        boolean ilvl;
        boolean ilvr;
        boolean lquery;
        char chtemp;
        int icols;
        int[] ierr = new int[1];
        int[] ihi = new int[1];
        int ijobvl;
        int ijobvr;
        int ileft;
        int[] ilo = new int[1];
        int[] in = new int[1];
        int iright;
        int irows;
        int itau;
        int iwrk;
        int jc;
        int jr;
        int maxwrk = 1;
        int minwrk;
        double anrm;
        double anrmto = 0.0;
        double[] bignum = new double[1];
        double bnrm;
        double bnrmto = 0.0;
        double eps;
        double[] smlnum = new double[1];
        double temp;
        boolean[] ldumma = new boolean[1];
        String name;
        String opts;
        double[] work2 = new double[n];
        double[] work3 = new double[6 * n];
        double[][] array1;
        double[][] array2;
        double[] work4;
        double[] work5;
        int i;
        int j;
        int row1;

        // Decode the input arguments
        if ((jobvl == 'N') || (jobvl == 'n')) {
            ijobvl = 1;
            ilvl = false;
        } else if ((jobvl == 'V') || (jobvl == 'v')) {
            ijobvl = 2;
            ilvl = true;
        } else {
            ijobvl = -1;
            ilvl = false;
        }

        if ((jobvr == 'N') || (jobvr == 'n')) {
            ijobvr = 1;
            ilvr = false;
        } else if ((jobvr == 'V') || (jobvr == 'v')) {
            ijobvr = 2;
            ilvr = true;
        } else {
            ijobvr = -1;
            ilvr = false;
        }

        ilv = ilvl || ilvr;

        // Test the input arguments
        info[0] = 0;

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        if (ijobvl <= 0) {
            info[0] = -1;
        } else if (ijobvr <= 0) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (lda < Math.max(1, n)) {
            info[0] = -5;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -7;
        } else if ((ldvl < 1) || (ilvl && (ldvl < n))) {
            info[0] = -12;
        } else if ((ldvr < 1) || (ilvr && (ldvr < n))) {
            info[0] = -14;
        }

        // Compute workspace
        // (Note: Comments in the code beginning "Workspace:" describe the
        // minimal amount of workspace needed at that point in the code, as well
        // as the preferred amount for good performance.  NB refers to the
        // optimal block size for the immediately follwing subroutine, as
        // returned by ilaenv.  The workspace is computed assuming ilo = 1 and
        // ihi = n, the worst case.)

        minwrk = 1;

        if (info[0] == 0) {
            minwrk = Math.max(1, 8 * n);
            name = new String("DGEQRF");
            opts = new String(" ");
            maxwrk = Math.max(1, n * (7 + ilaenv(1, name, opts, n, 1, n, 0)));
            name = new String("DORMQR");
            maxwrk = Math.max(maxwrk, n * (7 + ilaenv(1, name, opts, n, 1, n, 0)));

            if (ilvl) {
                name = new String("DORGQR");
                maxwrk = Math.max(maxwrk, n * (7 + ilaenv(1, name, opts, n, 1, n, -1)));
            }

            work[0] = maxwrk;

            if ((lwork < minwrk) && (!lquery)) {
                info[0] = -16;
            }
        } // if (info[0] == 0)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dggev had info[0] = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        // Get machine constants
        eps = dlamch('P');
        smlnum[0] = dlamch('S');
        bignum[0] = 1.0 / smlnum[0];
        dlabad(smlnum, bignum);
        smlnum[0] = Math.sqrt(smlnum[0]) / eps;
        bignum[0] = 1.0 / smlnum[0];

        // Scale A if max element outside range (smlnum[0], bignum[0])
        anrm = dlange('M', n, n, A, lda, work);
        ilascl = false;

        if ((anrm > 0.0) && (anrm < smlnum[0])) {
            anrmto = smlnum[0];
            ilascl = true;
        } else if (anrm > bignum[0]) {
            anrmto = bignum[0];
            ilascl = true;
        }

        if (ilascl) {
            dlascl('G', 0, 0, anrm, anrmto, n, n, A, lda, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dlascl 1 had ierr[0] = " + ierr[0] + "\n");
            }
        }

        // Scale B if max element outside range (smalnum[0], bignum[0])
        bnrm = dlange('M', n, n, B, ldb, work);
        ilbscl = false;

        if ((bnrm > 0.0) && (bnrm < smlnum[0])) {
            bnrmto = smlnum[0];
            ilbscl = true;
        } else if (bnrm > bignum[0]) {
            bnrmto = bignum[0];
            ilbscl = true;
        }

        if (ilbscl) {
            dlascl('G', 0, 0, bnrm, bnrmto, n, n, B, ldb, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dlascl 2 had ierr[0] = " + ierr[0] + "\n");
            }
        }

        // Permute the matrices A, B to isolate eigenvalues if possible
        // (Workspace: need 6*n)
        ileft = 1;
        iright = n + 1;
        iwrk = iright + n;
        dggbal('P', n, A, lda, B, ldb, ilo, ihi, work, work2, work3, ierr);

        if (ierr[0] != 0) {
            UI.setDataText("dggev call to dggbal had ierr[0] = " + ierr[0] + "\n");
        }

        // Reduce B to triangular form (QR decomposition of B)
        // (Workspace: need n, prefer n*nb)
        irows = ihi[0] + 1 - ilo[0];

        if (ilv) {
            icols = n + 1 - ilo[0];
        } else {
            icols = irows;
        }

        itau = iwrk;
        iwrk = itau + irows;
        row1 = Math.max(1, irows);
        array1 = new double[row1][icols];

        for (i = 0; i < row1; i++) {

            for (j = 0; j < icols; j++) {
                array1[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
            }
        }

        work4 = new double[Math.min(irows, icols)];
        work5 = new double[lwork + 1 - iwrk];
        dgeqrf(irows, icols, array1, row1, work4, work5, lwork + 1 - iwrk, ierr);

        if (ierr[0] != 0) {
            UI.setDataText("dggev call to dgeqrf had ierr[0] = " + ierr[0] + "\n");
        }

        for (i = 0; i < row1; i++) {

            for (j = 0; j < icols; j++) {
                B[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
            }
        }

        // Apply the orthogonal transformation to matrix A
        // (Workspace: need n, prefer n*nb)
        array1 = new double[row1][irows];

        for (i = 0; i < row1; i++) {

            for (j = 0; j < irows; j++) {
                array1[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
            }
        }

        array2 = new double[row1][icols];

        for (i = 0; i < row1; i++) {

            for (j = 0; j < icols; j++) {
                array2[i][j] = A[ilo[0] - 1 + i][ilo[0] - 1 + j];
            }
        }

        dormqr('L', 'T', irows, icols, irows, array1, row1, work4, array2, row1, work5, lwork + 1 - iwrk, ierr);

        if (ierr[0] != 0) {
            UI.setDataText("dggev call to dormqr had ierr[0] = " + ierr[0] + "\n");
        }

        for (i = 0; i < row1; i++) {

            for (j = 0; j < icols; j++) {
                A[ilo[0] - 1 + i][ilo[0] - 1 + j] = array2[i][j];
            }
        }

        // Initialize vl
        // (Workspace:  need n, prefer n*nb)
        if (ilvl) {
            dlaset('F', n, n, 0.0, 1.0, vl, ldvl);

            if (irows > 1) {
                row1 = Math.max(1, irows - 1);
                array1 = new double[row1][irows - 1];

                for (i = 0; i < row1; i++) {

                    for (j = 0; j < (irows - 1); j++) {
                        array1[i][j] = B[ilo[0] + i][ilo[0] - 1 + j];
                    }
                }

                array2 = new double[row1][irows - 1];
                dlacpy('L', irows - 1, irows - 1, array1, row1, array2, row1);

                for (i = 0; i < row1; i++) {

                    for (j = 0; j < (irows - 1); j++) {
                        vl[ilo[0] + i][ilo[0] - 1 + j] = array2[i][j];
                    }
                }
            } // if (irows > 1)

            row1 = Math.max(1, irows);
            array1 = new double[row1][irows];

            for (i = 0; i < row1; i++) {

                for (j = 0; j < irows; j++) {
                    array1[i][j] = vl[ilo[0] - 1 + i][ilo[0] - 1 + j];
                }
            }

            dorgqr(irows, irows, irows, array1, row1, work4, work5, lwork + 1 - iwrk, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dorgqr had ierr[0] = " + ierr[0] + "\n");
            }

            for (i = 0; i < row1; i++) {

                for (j = 0; j < irows; j++) {
                    vl[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
                }
            }
        } // if (ilvl)

        // Initialize vr
        if (ilvr) {
            dlaset('F', n, n, 0.0, 1.0, vr, ldvr);
        }

        // Reduce to generalized Hessenberg form
        // (Workspace: none needed)
        if (ilv) {

            // Eigenvectors requested -- work on whole matrix
            dgghrd(jobvl, jobvr, n, ilo[0], ihi[0], A, lda, B, ldb, vl, ldvl, vr, ldvr, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dgghrd 1 had ierr[0] = " + ierr[0] + "\n");
            }

        } else {
            row1 = Math.max(1, irows);
            array1 = new double[row1][irows];
            array2 = new double[row1][irows];

            for (i = 0; i < row1; i++) {

                for (j = 0; j < irows; j++) {
                    array1[i][j] = A[ilo[0] - 1 + i][ilo[0] - 1 + j];
                    array2[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
                }
            }

            dgghrd('N', 'N', irows, 1, irows, array1, row1, array2, row1, vl, ldvl, vr, ldvr, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dgghrd 2 had ierr[0] = " + ierr[0] + "\n");
            }

            for (i = 0; i < row1; i++) {

                for (j = 0; j < irows; j++) {
                    A[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
                    B[ilo[0] - 1 + i][ilo[0] - 1 + j] = array2[i][j];
                }
            }
        } // else

        // Perform QZ algorithm (Compute eigenvalues, and optionally, the
        // Schur forms and Schur vectors)
        // (Workspace: need n)

        iwrk = itau;

        if (ilv) {
            chtemp = 'S';
        } else {
            chtemp = 'E';
        }
        /* double Ainput[][] = new double[lda][n];
         * for (i = 0; i < lda; i++) {  for (j = 0; j < n; j++) {      Ainput[i][j] = A[i][j];  } } double Binput[][] =
         * new double[ldb][n]; for (i = 0; i < ldb; i++) {  for (j = 0; j < n; j++) {      Binput[i][j] = B[i][j];  }
         * }*/

        dhgeqz(chtemp, jobvl, jobvr, n, ilo[0], ihi[0], A, lda, B, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work5,
               lwork + 1 - iwrk, ierr);

        if (ierr[0] != 0) {
            UI.setDataText("dggev call to dgheqz had ierr[0] = " + ierr[0] + "\n");
            /*for (i = 0; i < n; i++) {
             *  for (j = 0; j < n; j++) {     UI.setDataText("Ainput[" + i +"][" + j + "] = " + Ainput[i][j] + "\n"); }
             * } for (i = 0; i < n; i++) { for (j = 0; j < n; j++) {     UI.setDataText("Binput[" + i +"][" + j + "] = "
             * + Binput[i][j] + "\n"); } } for (i = 0; i < n; i++) { for (j = 0; j < n; j++) {     UI.setDataText("A[" +
             * i +"][" + j + "] = " + A[i][j] + "\n"); } } for (i = 0; i < n; i++) { for (j = 0; j < n; j++) {
             * UI.setDataText("B[" + i +"][" + j + "] = " + B[i][j] + "\n"); }}*/

        }

        if (ierr[0] != 0) {

            if ((ierr[0] > 0) && (ierr[0] <= n)) {
                info[0] = ierr[0];
            } else if ((ierr[0] > n) && (ierr[0] <= (2 * n))) {
                info[0] = ierr[0] - n;
            } else {
                info[0] = n + 1;
            }

            work[0] = maxwrk;

            return;
        } // if (ierr[0] != 0)

        // Compute eigenvectors
        // (Workspace: need 6*n)
        if (ilv) {

            if (ilvl) {

                if (ilvr) {
                    chtemp = 'B';
                } // if (ilvr)
                else {
                    chtemp = 'L';
                } // else
            } // if (ilvl)
            else {
                chtemp = 'R';
            } // else

            work5 = new double[6 * n];
            dtgevc(chtemp, 'B', ldumma, n, A, lda, B, ldb, vl, ldvl, vr, ldvr, n, in, work5, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dtgevc had ierr[0] = " + ierr[0] + "\n");
                info[0] = n + 2;
                work[0] = maxwrk;

                return;
            }

            // Undo balancing on vl and vr and normalization
            // (Workspace: none needed)
            if (ilvl) {
                dggbak('P', 'L', n, ilo[0], ihi[0], work, work2, n, vl, ldvl, ierr);

                if (ierr[0] != 0) {
                    UI.setDataText("dggev call to dggbak 1 had ierr[0] = " + ierr[0] + "\n");
                }

                for (jc = 0; jc < n; jc++) {

                    if (alphai[jc] < 0.0) {
                        continue;
                    } // if (alphai[jc] < 0.0)

                    temp = 0.0;

                    if (alphai[jc] == 0.0) {

                        for (jr = 0; jr < n; jr++) {
                            temp = Math.max(temp, Math.abs(vl[jr][jc]));
                        }
                    } // if (alphai[jc] == 0.0)
                    else { // alphai[jc] != 0.0

                        for (jr = 0; jr < n; jr++) {
                            temp = Math.max(temp, Math.abs(vl[jr][jc]) + Math.abs(vl[jr][jc + 1]));
                        }
                    } // else alphai[jc] != 0.0

                    if (temp < smlnum[0]) {
                        continue;
                    } // if (temp < smlnum[0])

                    temp = 1.0 / temp;

                    if (alphai[jc] == 0.0) {

                        for (jr = 0; jr < n; jr++) {
                            vl[jr][jc] = vl[jr][jc] * temp;
                        }
                    } // if (alphai[jc] == 0.0)
                    else { // alphai[jc] != 0.0

                        for (jr = 0; jr < n; jr++) {
                            vl[jr][jc] = vl[jr][jc] * temp;
                            vl[jr][jc + 1] = vl[jr][jc + 1] * temp;
                        } // for (jr = 0; jr < n; jr++)
                    } // else alphai[jc] != 0.0
                } // for (jc = 0; jc < n; jc++)
            } // if (ilvl)

            if (ilvr) {
                dggbak('P', 'R', n, ilo[0], ihi[0], work, work2, n, vr, ldvr, ierr);

                if (ierr[0] != 0) {
                    UI.setDataText("dggev call to dggbak 2 had ierr[0] = " + ierr[0] + "\n");
                }

                for (jc = 0; jc < n; jc++) {

                    if (alphai[jc] < 0.0) {
                        continue;
                    } // if (alphai[jc] < 0.0)

                    temp = 0.0;

                    if (alphai[jc] == 0.0) {

                        for (jr = 0; jr < n; jr++) {
                            temp = Math.max(temp, Math.abs(vr[jr][jc]));
                        }
                    } // if (alphai[jc] == 0.0)
                    else { // alphai[jc] != 0.0

                        for (jr = 0; jr < n; jr++) {
                            temp = Math.max(temp, Math.abs(vr[jr][jc]) + Math.abs(vr[jr][jc + 1]));
                        }
                    } // else alphai[jc] != 0.0

                    if (temp < smlnum[0]) {
                        continue;
                    } // if (temp < smlnum[0])

                    temp = 1.0 / temp;

                    if (alphai[jc] == 0.0) {

                        for (jr = 0; jr < n; jr++) {
                            vr[jr][jc] = vr[jr][jc] * temp;
                        }
                    } // if (alphai[jc] == 0.0)
                    else { // alphai[jc] != 0.0

                        for (jr = 0; jr < n; jr++) {
                            vr[jr][jc] = vr[jr][jc] * temp;
                            vr[jr][jc + 1] = vr[jr][jc + 1] * temp;
                        } // for (jr = 0; jr < n; jr++)
                    } // else alphai[jc] != 0.0
                } // for (jc = 0; jc < n; jc++)
            } // if (ilvr)
            // End of eigenvector calculation
        } // if (ilv)

        // Undo scaling if necessary
        if (ilascl) {
            array1 = new double[n][1];

            for (i = 0; i < n; i++) {
                array1[i][0] = alphar[i];
            }

            dlascl('G', 0, 0, anrmto, anrm, n, 1, array1, n, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dlascl 3 had ierr[0] = " + ierr[0] + "\n");
            }

            for (i = 0; i < n; i++) {
                alphar[i] = array1[i][0];
                array1[i][0] = alphai[i];
            }

            dlascl('G', 0, 0, anrmto, anrm, n, 1, array1, n, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dlascl 4 had ierr[0] = " + ierr[0] + "\n");
            }

            for (i = 0; i < n; i++) {
                alphai[i] = array1[i][0];
            }
        } // if (ilascl)

        if (ilbscl) {
            array1 = new double[n][1];

            for (i = 0; i < n; i++) {
                array1[i][0] = beta[i];
            }

            dlascl('G', 0, 0, bnrmto, bnrm, n, 1, array1, n, ierr);

            if (ierr[0] != 0) {
                UI.setDataText("dggev call to dlascl 5 had ierr[0] = " + ierr[0] + "\n");
            }

            for (i = 0; i < n; i++) {
                beta[i] = array1[i][0];
            }
        } // if (ilbscl)

        work[0] = maxwrk;

        return;
    } // dggev

    /**
     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrgev in order to test
     * DGGEV, that handles the nonsymmetric generalized eigenvalue problem. Numerical values were obtained from the dgv
     * section in the dgd.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California Berkeley, and NAG
     * Ltd., January, 2007
     */
    public void dggev_test() {

        // Number of values of n
        int nn = 6;

        // Values of matrix dimension n
        int[] nval = new int[] { 2, 6, 8, 10, 15, 20 };

        // Value of blocksize NB
        int[] nbval = new int[] { 1 };

        // minimum blocksize NBMIN
        int[] nbmin = new int[] { 1 };

        // Minimum dimension for blocking
        int[] nxval = new int[] { 1 };

        // Number of shifts in xHGEQR
        int[] nsval = new int[] { 2 };

        // Minimum column size for blocking
        int[] mxbval = new int[] { 1 };

        // The test threshold against which computed residuals are compared.
        // Should generally be in the range from 10.0 to 20.0.  If it is 0.0,
        // all test data will be printed.
        double thresh = 10.0;

        // Test the error exits.
        boolean tsterr = true;

        // Code describing how to set the random number seed.
        // = 0: Set the seed to a default value before each run.
        // = 1: Initialize the seed to a default value only before the first
        // run.
        // = 2: Like 1, but use the seed values on the next line
        int newsd = 0;
        int maxt = 30;
        boolean[] dotype = new boolean[maxt];
        int[] ioldsd = new int[] { 0, 0, 0, 1 };
        int[] iseed = new int[] { 0, 0, 0, 1 };
        int nmax = 132;
        int lwork = (nmax * ((5 * nmax) + 5)) + 1;
        int liwork = nmax * ((5 * nmax) + 20);
        int[] iwork = new int[liwork];
        double[] work = new double[lwork];
        double[] result = new double[7];
        int[] info = new int[1];
        int need = 14;
        double[][] A;
        double[][] B;
        double[][] S;
        double[][] T;
        double[][] Q;
        double[][] Z;
        double[][] QE;
        double[] alphar;
        double[] alphai;
        double[] beta;
        double[] alphr1;
        double[] alphi1;
        double[] beta1;

        // Number of test matrix types
        int ntypes = 26;
        int maxtyp = 26;
        int i;
        int k;
        int maxnval;
        UI.setDataText("Tests of the Generalized Nonsymmetric Eigenvalue Problem Driver dggev\n");

        for (i = 0; i < maxtyp; i++) {
            dotype[i] = true;
        }

        maxnval = 0;

        for (i = 0; i < nn; i++) {

            if (nval[i] > maxnval) {
                maxnval = nval[i];
            }
        }

        iparms = new int[100];
        A = new double[nmax][maxnval];
        B = new double[nmax][maxnval];
        S = new double[nmax][maxnval];
        T = new double[nmax][maxnval];
        Q = new double[nmax][maxnval];
        Z = new double[nmax][maxnval];
        QE = new double[nmax][maxnval];
        alphar = new double[maxnval];
        alphai = new double[maxnval];
        beta = new double[maxnval];
        alphr1 = new double[maxnval];
        alphi1 = new double[maxnval];
        beta1 = new double[maxnval];

        // 1 = The optimal blocksize; if this value is 1, an unblocked
        // algorithm will give the best performance
        iparms[1 - 1] = nbval[0];

        // 2 = The minimum blocksize for which the block routine should be
        // used; if the usable block size is less than this value, an
        // unblocked routine should be used.
        iparms[2 - 1] = nbmin[0];

        // 3 = The crossover point (in a block routine, for n less than this
        // value, an unblocked routine should be used).
        iparms[3 - 1] = nxval[0];

        // 4 = the number of shifts, used in the nonsymmetric eigenvalue
        // routines
        iparms[4 - 1] = nsval[0];

        // 8 = another crossover point, for the multishift QR and QZ methods
        // for nonsymmetric eigenvalue problems
        iparms[8 - 1] = mxbval[0];


        UI.setDataText("Optimal blocksize = " + nbval[0] + "\n");
        UI.setDataText("Minimum blocksize = " + nbmin[0] + "\n");
        UI.setDataText("Crossover point = " + nxval[0] + "\n");
        UI.setDataText("Number of shifts = " + nsval[0] + "\n");
        UI.setDataText("Another crossover point = " + mxbval[0] + "\n");

        ddrgev(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, B, S, T, Q, nmax, Z, QE, nmax, alphar, alphai, beta,
               alphr1, alphi1, beta1, work, lwork, result, info);

        if (info[0] != 0) {
            MipavUtil.displayError("ddrgev had info = " + info[0]);
        }
    } // dggev_test

    /**
     * This is a port of the version 3.1 LAPACK DSYEV routine Original DSYEV created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsyev computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.
     *
     * @param  jobz   input char 
     *                = 'N': Compute eigenvalues only 
     *                = 'V': Compute eigenvalues and eigenvectors.
     * @param  uplo   input char 
     *                = 'U': Upper triangle of A is stored 
     *                = 'L': Lower triangle of A is stored
     * @param  n      input int The order of the matrix A. n >= 0.
     * @param  A      input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *                leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A. If
     *                uplo = 'L', the leading n-by-n lower triangular part of A contains the lower triangular part of
     *                matrix A. On exit, if jobz = 'V', then if info = 0, A contains the orthonormal eigenvectors of the
     *                matrix A. If jobz = 'N', then on exit the lower triangle (if uplo = 'L') or the upper triangle (if
     *                uplo = 'U') of A, including the diagonal, is destroyed.
     * @param  lda    input int The leading dimension of array A. lda >= max(1,n).
     * @param  w      output double[] of dimension n. If info = 0, the eigenvalues are in ascending order.
     * @param  work   (workspace/output) double[] of dimension max(1,lwork). On exit, if info = 0, then work[0] returns the
     *                optimal lwork.
     * @param  lwork  input int The length of the array work. lwork >= max(1,3*n-1). For optimal efficiency , lwork >=
     *                (nb+2)*n, where nb is the blocksize for dsytrd returned by ilaenv.
     *
     *                <p>If lwork = -1, then a workspace query is assumed; the routine only calculates the optimal size
     *                of the work array, returns this value as the first entry of the work array, and no error message
     *                related to lwork is issued.</p>
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument had an illegal value.
     *                > 0: If info[0] = i, the algorithm failed to converge; i off-diagonal elements of an intermediate
     *                tridiagonal form did not converge to zero.
     */
    public void dsyev(char jobz, char uplo, int n, double[][] A, int lda, double[] w, double[] work, int lwork,
                      int[] info) {
        boolean lower;
        boolean lquery;
        boolean wantz;
        int[] iinfo = new int[1];
        int imax;
        int inde;
        int indtau;
        int indwrk;
        int iscale;
        int llwork;
        int lwkopt = 1;
        int nb;
        double anrm;
        double bignum;
        double eps;
        double rmax;
        double rmin;
        double safmin;
        double sigma = 1.0;
        double smlnum;
        char[] ch = new char[1];
        String opts;
        double[] vector1;
        double[] vector2;
        double[] vector3;

        // Test the input parameters.
        if ((jobz == 'V') || (jobz == 'v')) {
            wantz = true;
        } else {
            wantz = false;
        }

        if ((uplo == 'L') || (uplo == 'l')) {
            lower = true;
        } else {
            lower = false;
        }

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        info[0] = 0;

        if ((!wantz) && (jobz != 'N') && (jobz != 'n')) {
            info[0] = -1;
        } else if ((!lower) && (uplo != 'U') && (uplo != 'u')) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (lda < Math.max(1, n)) {
            info[0] = -5;
        } 

        if (info[0] == 0) {
            ch[0] = uplo;
            opts = new String(ch);
            nb = ilaenv(1, "DSYTRD", opts, n, -1, -1, -1);
            lwkopt = Math.max(1, (nb + 2) * n);
            work[0] = lwkopt;
            
            if ((lwork < Math.max(1, (3 * n) - 1)) && (!lquery)) {
                info[0] = -8;
            }
        } // if (info[0] == 0)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsyev had info = " + info[0]);

            return;
        } // if (info[0] != 0)
        else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (n == 1) {
            w[0] = A[0][0];
            work[0] = 2;

            if (wantz) {
                A[0][0] = 1.0;
            }

            return;
        } // if (n == 1)

        // Get machine constants

        safmin = dlamch('S');
        eps = dlamch('P');
        smlnum = safmin / eps;
        bignum = 1.0 / smlnum;
        rmin = Math.sqrt(smlnum);
        rmax = Math.sqrt(bignum);

        // Scale matrix to allowable range, if necessary

        anrm = dlansy('M', uplo, n, A, lda, work);
        iscale = 0;

        if ((anrm > 0.0) && (anrm < rmin)) {
            iscale = 1;
            sigma = rmin / anrm;
        } // if ((anrm > 0.0) && (anrm < rmin))
        else if (anrm > rmax) {
            iscale = 1;
            sigma = rmax / anrm;
        } // else if (anrm > rmax)

        if (iscale == 1) {
            dlascl(uplo, 0, 0, 1.0, sigma, n, n, A, lda, info);

            if (info[0] != 0) {
                UI.setDataText("dsyev call to dlascl had info[0] = " + info[0] + "\n");
            }
        }

        // Call dsytrd to reduce symmetric matrix to tridiagonal form
        inde = 1;
        indtau = inde + n;
        indwrk = indtau + n;
        llwork = lwork - indwrk + 1;
        vector1 = new double[n - 1];
        vector2 = new double[n - 1];
        vector3 = new double[llwork];

        dsytrd(uplo, n, A, lda, w, vector1, vector2, vector3, llwork, iinfo);

        if (iinfo[0] != 0) {
            UI.setDataText("dsyev call to dsytrd had iinfo[0] = " + iinfo[0] + "\n");
        }

        // For eigenvalues only, call dsterf.  For eigenvectors, first call dorgtr
        // to generate the orthogonal matrix, then call dsteqr.

        if (!wantz) {
            dsterf(n, w, vector1, info);

            if (info[0] != 0) {
                UI.setDataText("dsyev call to dsterf had info[0] = " + info[0] + "\n");
            }
        } else {
            dorgtr(uplo, n, A, lda, vector2, vector3, llwork, iinfo);

            if (iinfo[0] != 0) {
                UI.setDataText("dsyev call to dorgtr had iinfo[0] = " + iinfo[0] + "\n");
            }

            vector2 = new double[Math.max(1, (2 * n) - 2)];
            dsteqr(jobz, n, w, vector1, A, lda, vector2, info);

            if (info[0] != 0) {
                UI.setDataText("dsyev call to dsteqr had info[0] = " + info[0] + "\n");
            }
        }

        // If matrix was scaled, then rescale eigenvalues appropriately.
        if (iscale == 1) {

            if (info[0] == 0) {
                imax = n;
            } else {
                imax = info[0] - 1;
            }

            dscal(imax, 1.0 / sigma, w, 1);
        } // if (iscale == 1)

        // Set work[0] to optimal workspace size.
        work[0] = lwkopt;

        return;
    } // dsyev

    /**
     * DYSGV is ported from the version 3.1 LAPACK driver routine Original DSYGV created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * DSYGV computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite
     * eigenproblem, of the form A*x = (lambda)*B*x, A*Bx = (lambda)*x, or B*A*x = (lambda)*x. Here A and B are assumed
     * to be symmetric and B is also positive definite
     *
     * @param  itype  input integer specifies the problem type to be solved: 
     *         = 1: A*x = (lambda)*B*x 
     *         = 2: A*B*x = (lambda)*x '
     *         = 3: B*A*x = (lambda)*x
     * @param  jobz   input char 
     *         = 'N': Compute eigenvalues only 
     *         = 'V': Compute eigenvalues and eigenvectors
     * @param  uplo   input char 
     *         = 'U': Upper triangles of A and B are stored 
     *         = 'L': Lower triangles of A and B are stored
     * @param  n      input integer The order of matrices A and B. n >= 0.
     * @param  A      (input/output) double[][], dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *                leading n by n upper triangular part of A contains the upper triangular part of the matrix A. If
     *                uplo = 'L', the leading n by n lower triangular part of A contains the lower triangular part of
     *                the matrix A.
     *
     *                <p>On exit, if jobz = 'V', then if info[0] = 0, A contains the matrix Z of eigenvectors. The
     *                eigenvectors are normalized as follows:
     *                If itype = 1 or 2, Z**T*B*Z = I;
     *                If itype = 3, Z**T*inv(B)*Z = I.
     *                If jobz = 'N', then on exit the upper triangle (if uplo = 'U') or the lower triangle (if uplo =
     *                'L') of A, including the diagonal, is destroyed.</p>
     * @param  lda    input integer The leading dimension of array A. lda >= max(1,n).
     * @param  B      (input/output) double[][], dimension ldb by n On entry, the symmetric positive definite matrix B.
     *                If uplo = 'U', the leading n by n upper triangular part of B contains the upper triangular part of
     *                the matrix B. If uplo = 'L', the leading n by n lower triangular part of B contains the lower
     *                triangular part of the matrix B.
     *
     *                <p>On exit, if info <= n, the part of B containing the matrix is overwritten by the triangular
     *                factor U or L from the Cholesky factorization B = U**T*U or B = L*L**T.</p>
     * @param  ldb    input integer The leading dimension of the array B. ldb >= max(1,n).
     * @param  w      output double[] of dimension n If info = 0, the eigenvalues in ascending order.
     * @param  work   (workspace/output) double[] of dimension max(1,lwork)
     *                On exit, if info = 0, work[0] returns the optimal lwork.
     * @param  lwork  input integer The length of the array work. lwork >= max(1,3*n-1). For optimal efficiency, lwork
     *                >= (nb+2)*n, where nb is the blocksize for dsytrd returned by ilaenv.
     *
     *                <p>If lwork = -1, then a workspace query is assumed; the routine only calculates the optimal size
     *                of the work array, returns this value as the first entry of the work array, and no error message
     *                related to lwork is issued.</p>
     * @param  info   output integer[] 
     *                = 0: successful exit 
     *                < 0: if info = -i, the i-th argument had an illegal value
     *                > 0: dpotrf or dsyev returned an error code: 
     *                   <= n: If info = i, dsyev failed to converge; i off-diagonal elements of an intermediate
     *                         tridiagonal form did not converge to zero; 
     *                   > n: If info = n + i, for 1 <= i <= n, then the leading minor of order i of B is not positive definite. The
     *                        factorization of B could not be completed and no eigenvalues or eigenvectors were computed.
     */
    public void dsygv(int itype, char jobz, char uplo, int n, double[][] A, int lda, double[][] B, int ldb, double[] w,
                      double[] work, int lwork, int[] info) {
        boolean wantz;
        boolean upper;
        boolean lquery;
        int nb;
        String name;
        char[] optsChar = new char[1];
        String opts;
        int lwkopt = 0;
        int neig;
        char trans;
        int lwkmin;

        // Test the input statements
        if ((jobz == 'V') || (jobz == 'v')) {
            wantz = true;
        } else {
            wantz = false;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        info[0] = 0;

        if ((itype < 1) || (itype > 3)) {
            info[0] = -1;
        } else if (!((wantz) || (jobz == 'N') || (jobz == 'n'))) {
            info[0] = -2;
        } else if (!((upper) || (uplo == 'L') || (uplo == 'l'))) {
            info[0] = -3;
        } else if (n < 0) {
            info[0] = -4;
        } else if (lda < Math.max(1, n)) {
            info[0] = -6;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -8;
        } 

        if (info[0] == 0) {
            lwkmin = Math.max(1, 3*n-1);
            name = new String("DSYTRD");
            optsChar[0] = uplo;
            opts = new String(optsChar);
            nb = ilaenv(1, name, opts, n, -1, -1, -1);
            lwkopt = Math.max(lwkmin,(nb + 2) * n);
            work[0] = lwkopt;
            if ((lwork < lwkmin) && (!lquery)) {
                info[0] = -11;
            }
        }

        if (info[0] != 0) {
            MipavUtil.displayError("dsygv had info = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        // Form a Cholesky factorization of B
        dpotrf(uplo, n, B, ldb, info);

        if (info[0] != 0) {
            UI.setDataText("Call to dpotrf in dsygv returned info[0] = " + info[0] + "\n");
            info[0] = n + info[0];

            return;
        }

        // Transform problem to standard eigenvalue problem and solve
        dsygst(itype, uplo, n, A, lda, B, ldb, info);

        if (info[0] != 0) {
            UI.setDataText("call to dsygst in dsygv returned info[0] = " + info[0] + "\n");
        }

        dsyev(jobz, uplo, n, A, lda, w, work, lwork, info);

        if (info[0] != 0) {
            UI.setDataText("Call to dsyev in dsygv returned info[0] = " + info[0] + "\n");
        }

        if (wantz) {

            // Backtransform eigenvectors to the original problem.

            neig = n;

            if (info[0] > 0) {
                neig = info[0] - 1;
            } // if (info[0] > 0)

            if ((itype == 1) || (itype == 2)) {

                // For A*x = (lambda)*B*x and A*B*x = (lambda)*x
                // backtransform eigenvectors: x = (inv(L))'*y or inv(U)*y

                if (upper) {
                    trans = 'N';
                } // if (upper)
                else {
                    trans = 'T';
                }

                dtrsm('L', uplo, trans, 'N', n, neig, 1.0, B, ldb, A, lda);
            } // if ((itype == 1) || (itype == 2))
            else if (itype == 3) {

                // For B*A*x = (lambda)*x
                // backtransform eigenvectors: x = L*y or U'*y

                if (upper) {
                    trans = 'T';
                } // if (upper)
                else {
                    trans = 'N';
                }

                dtrmm('L', uplo, trans, 'N', n, neig, 1.0, B, ldb, A, lda);
            } // else if (itype == 3)
        } // if (wantz)

        work[0] = lwkopt;

        return;
    } // dsygv


    /**
     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrvsg in order to test
     * DSYGV, that handles the symmetric generalized eigenvalue problem. Numerical values were obtained from the dsg.in
     * datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd.,
     * January, 2007
     */
    public void dsygv_test() {

        // Number of values of n
        int nn = 7;

        // Values of matrix dimension n
        int[] nval = new int[] { 0, 1, 2, 3, 5, 10, 16 };

        // Number of values of NB, NBMIN, and NX
        int nparms = 3;

        // Values of blocksize NB
        int[] nbval = new int[] { 1, 3, 20 };

        // Values of minimum blocksize NBMIN
        int[] nbmin = new int[] { 2, 2, 2 };

        // Values of crossover point NX
        int[] nxval = new int[] { 1, 1, 1 };

        // Threshold value for the test ratios.  Information will be printed
        // about each test for which the test ratio is greater than or equal
        // to threshold.
        double thresh = 20.0;

        // Test the LAPACK routines
        boolean tstchk = true;

        // Test the driver routines
        boolean tstdrv = true;

        // Test the error exits for the LAPACK routines and driver routines.
        boolean tsterr = true;

        // Code describing how to set the random number seed.
        // = 0: Set the seed to a default number before each run.
        // = 1: Initialize the seed to a default value only before the first
        // run.
        // = 2: Like 1, but use the seed values in the 4 integer array
        // ioldsd
        int newsd = 1;
        int maxt = 30;
        boolean[] dotype = new boolean[maxt];
        int[] ioldsd = new int[] { 0, 0, 0, 1 };
        int[] iseed = new int[] { 0, 0, 0, 1 };
        int nmax = 132;
        int lwork = (nmax * ((5 * nmax) + 5)) + 1;
        int liwork = nmax * ((5 * nmax) + 20);
        int[] iwork = new int[liwork];
        double[] work = new double[lwork];
        double[] result = new double[500];
        int[] info = new int[1];
        int need = 14;
        double[][] A;
        double[][] B;
        double[] D;
        double[][] Z;
        double[][] AB;
        double[][] BB;
        double[] AP;
        double[] BP;

        // Number of test matrix types
        int ntypes = 21;
        int maxtyp = 21;
        int i;
        int k;
        int maxnval;
        UI.setDataText("Tests of the Symmetric Eigenvalue Problem routines\n");

        for (i = 0; i < maxtyp; i++) {
            dotype[i] = true;
        }

        maxnval = 0;

        for (i = 0; i < nn; i++) {

            if (nval[i] > maxnval) {
                maxnval = nval[i];
            }
        }

        iparms = new int[100];

        // 9 = maximum size of the subproblems at the bottom of the computation
        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
        iparms[9 - 1] = 25;
        A = new double[nmax][maxnval];
        B = new double[nmax][maxnval];
        D = new double[maxnval];
        Z = new double[nmax][maxnval];
        AB = new double[nmax][maxnval];
        BB = new double[nmax][maxnval];
        AP = new double[maxnval * maxnval];
        BP = new double[maxnval * maxnval];

        for (i = 1; i <= nparms; i++) {

            // 1 = The optimal blocksize; if this value is 1, an unblocked
            // algorithm will give the best performance
            iparms[1 - 1] = nbval[i - 1];

            // 2 = The minimum blocksize for which the block routine should be
            // used; if the usable block size is less than this value, an
            // unblocked routine should be used.
            iparms[2 - 1] = nbmin[i - 1];

            // 3 = The crossover point (in a block routine, for n less than this
            // value, an unblocked routine should be used).
            iparms[3 - 1] = nxval[i - 1];

            if (newsd == 0) {

                for (k = 0; k < 4; k++) {
                    iseed[k] = ioldsd[k];
                }
            } // if (newsd == 0)

            UI.setDataText("Optimal blocksize = " + nbval[i - 1] + "\n");
            UI.setDataText("Minimum blocksize = " + nbmin[i - 1] + "\n");
            UI.setDataText("Crossover point = " + nxval[i - 1] + "\n");

            if (tstchk) {
                ddrvsg(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, B, nmax, D, Z, nmax, AB, BB, AP, BP, work,
                       lwork, iwork, liwork, result, info);

                if (info[0] != 0) {
                    MipavUtil.displayError("ddrvsg had info = " + info[0]);
                }
            } // if (tstchk)
        } // for (i = 1; i <= nparms; i++)
    } // dsygv_test

    /**
     * DOCUMENT ME!
     */
    public void dsygv_test2() {
        this.UI = ViewUserInterface.getReference();

        int itype = 1;
        char jobz = 'V';
        char uplo = 'U';
        int n = 4;
        double[][] A = new double[4][4];
        A[0][0] = 0.24;
        A[0][1] = 0.39;
        A[0][2] = 0.42;
        A[0][3] = -0.16;
        A[1][0] = 0.39;
        A[1][1] = -0.11;
        A[1][2] = 0.79;
        A[1][3] = 0.63;
        A[2][0] = 0.42;
        A[2][1] = 0.79;
        A[2][2] = -0.25;
        A[2][3] = 0.48;
        A[3][0] = -0.16;
        A[3][1] = 0.63;
        A[3][2] = 0.48;
        A[3][3] = -0.03;

        int lda = 4;
        double[][] B = new double[4][4];
        B[0][0] = 4.16;
        B[0][1] = -3.12;
        B[0][2] = 0.56;
        B[0][3] = -0.10;
        B[1][0] = -3.12;
        B[1][1] = 5.03;
        B[1][2] = -0.83;
        B[1][3] = 1.09;
        B[2][0] = 0.56;
        B[2][1] = -0.83;
        B[2][2] = 0.76;
        B[2][3] = 0.34;
        B[3][0] = -0.10;
        B[3][1] = 1.09;
        B[3][2] = 0.34;
        B[3][3] = 1.18;

        int ldb = 4;
        double[] w = new double[4];
        double[] work = new double[100];
        int lwork = 100;
        int[] info = new int[1];
        dsygv(itype, jobz, uplo, n, A, lda, B, ldb, w, work, lwork, info);

        if (info[0] != 0) {
            UI.setDataText("dsygv had info[0] = " + info[0] + "\n");

            return;
        }

        UI.setDataText("Eigenvalues in ascending order are:\n");
        UI.setDataText(w[0] + "  " + w[1] + "  " + w[2] + "  " + w[3] + "\n");
        UI.setDataText("Eigenvector 0:\n");
        UI.setDataText(A[0][0] + "\n");
        UI.setDataText(A[1][0] + "\n");
        UI.setDataText(A[2][0] + "\n");
        UI.setDataText(A[3][0] + "\n");
        UI.setDataText("Eigenvector 1:\n");
        UI.setDataText(A[0][1] + "\n");
        UI.setDataText(A[1][1] + "\n");
        UI.setDataText(A[2][1] + "\n");
        UI.setDataText(A[3][1] + "\n");
        UI.setDataText("Eigenvector 2:\n");
        UI.setDataText(A[0][2] + "\n");
        UI.setDataText(A[1][2] + "\n");
        UI.setDataText(A[2][2] + "\n");
        UI.setDataText(A[3][2] + "\n");
        UI.setDataText("Eigenvector 3:\n");
        UI.setDataText(A[0][3] + "\n");
        UI.setDataText(A[1][3] + "\n");
        UI.setDataText(A[2][3] + "\n");
        UI.setDataText(A[3][3] + "\n");

        return;
    }

    /**
     * DOCUMENT ME!
     *
     * @param  UI  DOCUMENT ME!
     */
    public void dsygv_test3(ViewUserInterface UI) {
        this.UI = UI;

        int itype = 1;
        char jobz = 'V';
        char uplo = 'L';
        int n = 2;
        double[][] A = new double[2][2];
        A[0][0] = 0.24;
        A[0][1] = 0.39;
        A[1][0] = 0.39;
        A[1][1] = -0.11;

        int lda = 2;
        double[][] B = new double[2][2];
        B[0][0] = 4.16;
        B[0][1] = -3.12;
        B[1][0] = -3.12;
        B[1][1] = 5.03;

        int ldb = 2;
        double[] w = new double[2];
        double[] work = new double[100];
        int lwork = 100;
        int[] info = new int[1];
        dsygv(itype, jobz, uplo, n, A, lda, B, ldb, w, work, lwork, info);

        if (info[0] != 0) {
            UI.setDataText("dsygv had info[0] = " + info[0] + "\n");

            return;
        }

        UI.setDataText("Eigenvalues in ascending order are:\n");
        UI.setDataText(w[0] + "  " + w[1] + "\n");
        UI.setDataText("Eigenvector 0:\n");
        UI.setDataText(A[0][0] + "\n");
        UI.setDataText(A[1][0] + "\n");
        UI.setDataText("Eigenvector 1:\n");
        UI.setDataText(A[0][1] + "\n");
        UI.setDataText(A[1][1] + "\n");

        return;
    }

    /**
     * Port of 12/3/93 linpack routine daxpy Original version written by Jack Dongarra vector dy = vector dy + da *
     * vector dx.
     *
     * @param  n     input int
     * @param  da    inut double
     * @param  dx    input double[]
     * @param  incx  input int
     * @param  dy    input/output double[]
     * @param  incy  input int
     */
    private void daxpy(int n, double da, double[] dx, int incx, double[] dy, int incy) {
        int i;
        int ix;
        int iy;
        int m;
        int mp1;

        if (n <= 0) {
            return;
        }

        if (da == 0.0) {
            return;
        }

        if ((incx != 1) || (incy != 1)) {

            // Code for unequal increments or equal increments not equal to 1
            ix = 1;
            iy = 1;

            if (incx < 0) {
                ix = ((-n + 1) * incx) + 1;
            }

            if (incy < 0) {
                iy = ((-n + 1) * incy) + 1;
            }

            for (i = 1; i <= n; i++) {
                dy[iy - 1] = dy[iy - 1] + (da * dx[ix - 1]);
                ix = ix + incx;
                iy = iy + incy;
            }

            return;
        } // if ((incx != 1) || (incy != 1))

        // Code for both increments equal to 1
        m = n % 4;

        if (m != 0) {

            for (i = 0; i < m; i++) {
                dy[i] = dy[i] + (da * dx[i]);
            }

            if (n < 4) {
                return;
            }
        } // if (m != 0)

        mp1 = m + 1;

        for (i = mp1; i <= n; i += 4) {
            dy[i - 1] = dy[i - 1] + (da * dx[i - 1]);
            dy[i] = dy[i] + (da * dx[i]);
            dy[i + 1] = dy[i + 1] + (da * dx[i + 1]);
            dy[i + 2] = dy[i + 2] + (da * dx[i + 2]);
        }

        return;
    } // daxpy

    /**
     * /** This is a port of version 3.1 LAPACK test routine DCHKGG Original DCHKGG created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dchkgg checks the nonsymmetric generalized eigenvalue problem routines.
     *
     * <p>dgghrd factors A and B as U H Vtranspose and U T Vtranspose, where H is hessenberg, T is triangular, and U and
     * V are orthogonal.</p>
     *
     * <p>dhgeqz factors H and T as Q S Ztranspose and Q P Ztranspose, where P is upper triangular, S is in generalized
     * Schur form (block upper triangular, with 1x1 and 2x2 blocks on the diagonal, the 2x2 blocks corresponding to
     * complex conjugate pairs of generalized eigenvalues), and Q and Z are orthogonal. It also computes the generalized
     * eigenvalues (alpha[0], beta[0]),...,(alpha[n-1], beta[n-1]), where alpha[j] = S[j][j] and beta[j] = P[j][j] --
     * thus, w[j] = alpha[j]/beta[j] is a root of the generalized eigenvalue problem det(A - w[j] B ) = 0 and m[j] =
     * beta[j]/alpha[j] is a root of the essentially equivalent problem det(m[j] A - B ) = 0</p>
     *
     * <p>dtgevc computes the matrix L of left eigenvectors and the matrix R of right eigenvectors for the matrix pair
     * (S, P). In the description below, L and R are left and right eigenvectors corresponding to the generalized
     * eigenvalues (alpha, beta).</p>
     *
     * <p>When dchkgg is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For
     * each size ("n") and each type of matrix, one matrix will be generated and used to test the nonsymmetric
     * eigenroutines. For each matrix, 15 tests will be performed. The first twelve "test ratios" should be small --
     * O(1). They will be compared with the threshold thresh: 
     * (1) | A - U H Vtrans| / ( |A| n ulp)
     * (2) | B - U T Vtrans| / ( |B| n ulp)
     * (3) | I - UUtrans| / (n ulp)
     * (4) | I - VVtrans| / (n ulp)
     * (5) | H - Q S Ztrans| / ( |H| n ulp)
     * (6) | T - Q P Ztrans| / ( |T| n ulp)
     * (7) | I - QQtrans| / (n ulp)
     * (8) | I - ZZtrans| / (n ulp)
     * (9) max over all left eigenvalue/-vector pairs (beta/alpha, L) of
     *     | L**H * (beta S - alpha P) | / (ulp max( |beta S|, |alpha P| ))
     * (10) max over all left eigenvalue/-vector pairs (beta/alpha, L') of
     *    | L'**H * (beta H - alphatranspose T) | / (ulp max( |beta H|, |alpha T| ))
     *    where the eigenvectors L' are the result of passing Q to dtgevc and back transforming (howmny = 'B').
     * (11) max over all right eigenvalue/-vector pairs (beta/alpha, R) of
     *    | (beta S - alpha T) R | / (ulp max( |beta S|, |alpha T| ))
     * (12) max over all right eigenvalue/-vector pairs (beta/alpha, R') of
     *    | (beta H - alpha T) R' | / ( ulp max( |beta H|, |alpha T| )) where the eigenvectors R' are the result of
     *    passing Z to dtgevc and back transforming (howmny = 'B').
     * The last three test ratios will usually be small, but there is no mathematical requirement that they be so.
     * They are therefore compared with thresh only if tstdif is true.
     * (13) | S(Q,Z computed) - S(Q,Z not computed) | / ( |S| ulp )
     * (14) | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp )
     * (15) max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S|,
     *           |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) / ulp
     * In addition, the normalization of L and R are checked, and compared with the threshold thrshn.</p>
     *
     * <p>Test Matrices The sizes of the test matrices are specified by an array nn[0:sizes-1]; the value of each
     * element nn[j] specifies one size. The "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j]
     * is true, then a matrix type "j" will be generated. Currently, the list of possible types is:
     * (1) (0, 0) (a pair of zero matrices)
     * (2) (I, 0) (an identity and a zero matrix)
     * (3) (0, I) (a zero and an identity matrix)
     * (4) (I, I) (a pair of identity matrices)
     * (5) (Jtranspose, Jtranspose) (a pair of transposed Jordan blocks)
     * (6) (X, Y)
     * where X = (Jtranspose 0) and Y = (I      0    ) 
     *           (0          I)         (0 Jtranspose)
     * and I is a k by k identity and J a (k+1) by (k+1) Jordan block; k = (N-1)/2
     * (7) (D, I) where D is diag(0, 1,..., N-1) (a diagonal matrix with those diagonal entries.)
     * (8) (I, D)
     * (9) (big*D, small*I) where "big" is near overflow and small = 1/big
     * (10) (small*D, big*I)
     * (11) (big*I, small*D) 
     * (12) (small*I, big*D)
     * (13) (big*D, big*I)
     * (14) (small*D, small*I) 
     * (15) (D1, D2) where D1 is diag(0, 0, 1, ..., N-3, 0) and D2 is diag(0, N-3, N-4,..., 1, 0, 0)
     * (16) U (Jtranspose, Jtranspose) V where U and V are random orthogonal matrices.
     * (17) U (T1, T2) V where T1 and T2 are upper triangular matrices with random
     *      O(1) entries above the diagonal and diagonal entries diag(T1) = (0, 0, 1, ..., N-3, 0)
     *     and diag(T2) = (0, N-3, N-4, ..., 1, 0, 0)
     * (18) U (T1, T2) V diag(T1) = (0, 0, 1, 1, s, ..., s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0)
     *      s = machine precision
     * (19) U (T1, T2) V diag(T1) = (0,0,1,1, 1-d, ..., 1 - (N-5)*d=s, 0)
     *                   diag(T2) = (0, 1, 0, 1, ..., 1, 0)
     * (20) U (T1, T2) V diag(T1) = (0,0,1,1,a, ..., a**(N-5)=s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0)
     * (21) U (T1, T2) V diag(T1) = (0, 0, 1, r1, r2, ..., r(N-4), 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0)
     *                 where r1, ..., r(N-4) are random.
     * (22) U (big*T1, small*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
     * (23) U (small*T1, big*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
     * (24) U (small*T1, small*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
     * (25) U (big*T1, big*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
     * (26) U(T1, T2) V where T1 and T2 are random upper-triangular matrices.</p>
     *
     * @param  nsizes  input int The number of sizes of matrices to use. If it is zero, dchkgg does nothing. It must be
     *                 at least zero.
     * @param  nn      input int[] of dimension (nsizes) An array containing the sizes to be used for matrices. Zero
     *                 values will be skipped. The values must be at least zero.
     * @param  ntypes  input int The number of elements in dotype. If it is zero, dchkgg does nothing. It must be at
     *                 least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined,
     *                 which is to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and
     *                 dotype[maxtyp] is true.
     * @param  dotype  input boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
     *                 that size and of type j will be generated. If ntypes is smaller than the maximum number of types
     *                 defined(parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is
     *                 larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
     * @param  iseed   (input/ouptut) int[] of dimension (4) On entry iseed specifies the seed of the random number
     *                 generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
     *                 Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence
     *                 limited to small integers, and so should produce machine independent random numbers. The values
     *                 of iseed are changed on exit, and can be used in the next call to dchkgg to continue the same
     *                 random number sequence.
     * @param  thresh  input double A test will count as "failed" if the "error", computed as described above, exceeds
     *                 thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple
     *                 of 1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double)
     *                 or the size of the matrix. It must be at least zero.
     * @param  tstdif  input boolean Specifies whether the ratios 13-15 will be computed and compared with thresh.
     *                 = false: Only test ratios 1-12 will be computed and tested. Ratios 13-15 will be set to zero.
     *                 = true: All the test ratios 1-15 will be computed and tested.
     * @param  thrshn  input double Threshold for reporting eigenvector normalization error. If the normalization of any
     *                 eigenvector differs from one by nore than thrshn*ulp, then a special error message will be
     *                 printed. (This is handled separately from the other tests, since only a compiler or programming
     *                 error should cause an error message, at least if thrshn is at least 5--10.)
     * @param  A       (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original A matrix. Used
     *                 as input only if ntypes = maxtyp+1, dotype[0:maxtyp-1] = false, and dotype[maxtyp] = true.
     * @param  lda     input int The leaeding dimension of A, B, H, T, S1, P1, S2, and P2. It must be at least 1 and at
     *                 least max(nn).
     * @param  B       (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original B matrix.
     *                 Used as input only if ntypes= maxtyp+1, dotype[0:maxtyp-1] = false, and dotype[maxtyp] = true.
     * @param  H       (workspace) double[][] of dimension (lda, max(nn)) The upper Hessenberg matrix computed from A by
     *                 dgghrd.
     * @param  T       (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from B by
     *                 dgghrd.
     * @param  S1      (workspace) double[][] of dimension (lda, max(nn)) The Schur (block upper triangular) matrix
     *                 computed from H by dhgeqz when Q and Z are also computed.
     * @param  S2      (workspace) double[][] of dimension (lda, max(nn)) The Schur (block upper triangular) matrix
     *                 computed from H by dhgeqz when Q and Z are not computed.
     * @param  P1      (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from T by
     *                 dhgeqz when Q and Z are also computed.
     * @param  P2      (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from T by
     *                 dhgeqz when Q and Z are not computed.
     * @param  U       (workspace) double[][] of dimension (ldu, max(nn)) The (left) orthogonal matrix computed by
     *                 dgghrd.
     * @param  ldu     input int The leading dimension of U, V, Q, Z, evectl, and evectr. It must be at least 1 and at
     *                 least max(nn).
     * @param  V       (workspace) double[][] of dimension (ldu, max(nn)) The (right) orthogonal matrix computed by
     *                 dgghrd.
     * @param  Q       (workspace) double[][] of dimesnion (ldu, max(nn)) The (left) orthogonal matrix computed by
     *                 dhgeqz.
     * @param  Z       (workspace) double[][] of dimension (ldu, max(nn)) The (left) orthogonal matrix computed by
     *                 dhgeqz.
     * @param  alphr1  (workspace) double[] of dimension (max(nn))
     * @param  alphi1  (workspace) double[] of dimension (max(nn))
     * @param  beta1   (workspace) double[] of dimension (max(nn)) The generalized eigenvalues of (A,B) computed by
     *                 dhgeqz when Q, Z, and the full Schur matrices are computed. On exit, (alphr1[k] + alphi1[k]*i)
     *                 /beta1[k] is the (k+1)-st generalized eigenvalue of the matrices in A and B.
     * @param  alphr3  (workspace) double[] of dimension (max(nn))
     * @param  alphi3  (workspace) double[] of dimension (max(nn))
     * @param  beta3   (workspace) double[] of dimension (max(nn))
     * @param  evectl  (workspace) double[][] of dimension (ldu, max(nn)) The (block lower triangular) left eigenvector
     *                 matrix for the matrices in S1 and P1. (See dtgevc for the format.)
     * @param  evectr  (workspace) double[][] of dimesnion (ldu, max(nn)) The (block upper triangular) right eigenvector
     *                 matrix for the matrices in S1 and P1. (See dtgevc for the format.)
     * @param  work    (workspace) double[] of dimension (lwork)
     * @param  lwork   input int The number of entries in work. This must be at least max(2*n**2, 6*n, 1), for all n =
     *                 nn[j].
     * @param  llwork  (workspace) boolean[] of dimension max(nn))
     * @param  result  (output) double[] of dimension (15) The values computed by the tests described above. The values
     *                 are currently limited to 1/ulp, to avoid overflow.
     * @param  info    (output) int[] 
     *                          = 0: successful exit 
     *                          < 0: If info[0] == -i, then i-th argument had an illegal value.
     *                          > 0: A routine returned an error code. info is the absolute value of the info value
     *                               returned.
     */
    private void dchkgg(int nsizes, int[] nn, int ntypes, boolean[] dotype, int[] iseed, double thresh, boolean tstdif,
                        double thrshn, double[][] A, int lda, double[][] B, double[][] H, double[][] T, double[][] S1,
                        double[][] S2, double[][] P1, double[][] P2, double[][] U, int ldu, double[][] V, double[][] Q,
                        double[][] Z, double[] alphr1, double[] alphi1, double[] beta1, double[] alphr3,
                        double[] alphi3, double[] beta3, double[][] evectl, double[][] evectr, double[] work, int lwork,
                        boolean[] llwork, double[] result, int[] info) {
        int maxtyp = 26;
        boolean badnn;
        int i1;
        int iadd;
        int[] iinfo = new int[1];
        int[] in = new int[] { 1 };
        int j;
        int jc;
        int jr;
        int jsize;
        int jtype;
        int lwkopt;
        int mtypes;
        int n;
        int n1;
        int nerrs;
        int nmats;
        int nmax;
        int ntest;
        int ntestt;
        double anorm = 0.0;
        double bnorm = 0.0;
        double[] safmax = new double[1];
        double[] safmin = new double[1];
        double temp1;
        double temp2;
        double ulp;
        double ulpinv;
        int[] iasign = new int[] { 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0 };
        int[] ibsign = new int[] { 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        int[] ioldsd = new int[4];
        int[] kadd = new int[] { 0, 0, 0, 0, 3, 2 };
        int[] kamagn = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 2, 1 };
        int[] katype = new int[] { 0, 1, 0, 1, 2, 3, 4, 1, 4, 4, 1, 1, 4, 4, 4, 2, 4, 5, 8, 7, 9, 4, 4, 4, 4, 0 };
        int[] kazero = new int[] { 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 3, 5, 5, 5, 5, 3, 3, 3, 3, 1 };
        int[] kbmagn = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 1 };
        int[] kbtype = new int[] { 0, 0, 1, 1, 2, -3, 1, 4, 1, 1, 4, 4, 1, 1, -4, 2, -4, 8, 8, 8, 8, 8, 8, 8, 8, 0 };
        int[] kbzero = new int[] { 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 4, 1, 4, 6, 6, 6, 6, 4, 4, 4, 4, 1 };
        int[] kclass = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 };
        int[] ktrian = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
        int[] kz1 = new int[] { 0, 1, 2, 1, 3, 3 };
        int[] kz2 = new int[] { 0, 0, 1, 2, 1, 1 };
        double[] dumma = new double[4];
        double[] rmagn = new double[4];
        double[] alpha = new double[1];
        double[] x;
        double[] tau = new double[1];
        int i;
        double[] work2;
        double[] res = new double[1];
        double[][] dummy = new double[1][1];
        int row1;
        double[][] array1;

        // Check for errors
        info[0] = 0;
        badnn = false;
        nmax = 1;

        for (j = 0; j < nsizes; j++) {
            nmax = Math.max(nmax, nn[j]);

            if (nn[j] < 0) {
                badnn = true;
            }
        } // for (j = 0; j < nsizes; j++)

        // Maximum blocksize and shift -- we assume that blocksize and number
        // of shifts are monotone and increasing functions of n.
        lwkopt = Math.max(6 * nmax, 2 * nmax * nmax);
        lwkopt = Math.max(lwkopt, 1);

        // Check for errors
        if (nsizes < 0) {
            info[0] = -1;
        } else if (badnn) {
            info[0] = -2;
        } else if (ntypes < 0) {
            info[0] = -3;
        } else if (thresh < 0.0) {
            info[0] = -6;
        } else if ((lda <= 1) || (lda < nmax)) {
            info[0] = -10;
        } else if ((ldu <= 1) || (ldu < nmax)) {
            info[0] = -19;
        } else if (lwkopt > lwork) {
            info[0] = -30;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dchkgg had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((nsizes == 0) || (ntypes == 0)) {
            return;
        }

        safmin[0] = dlamch('S');
        ulp = dlamch('E') * dlamch('B');
        safmin[0] = safmin[0] / ulp;
        safmax[0] = 1.0 / safmin[0];
        dlabad(safmin, safmax);
        ulpinv = 1.0 / ulp;

        // The values rmagn(2:3) depend on n, see below.
        rmagn[0] = 0.0;
        rmagn[1] = 1.0;

        // Loop over sizes, types
        ntestt = 0;
        nerrs = 0;
        nmats = 0;

        for (jsize = 1; jsize <= nsizes; jsize++) {
            n = nn[jsize - 1];
            n1 = Math.max(1, n);
            rmagn[2] = safmax[0] * ulp / n1;
            rmagn[3] = safmin[0] * ulpinv * n1;

            if (nsizes != 1) {
                mtypes = Math.min(maxtyp, ntypes);
            } else {
                mtypes = Math.min(maxtyp + 1, ntypes);
            }

            for (jtype = 1; jtype <= mtypes; jtype++) {

                if (!dotype[jtype - 1]) {
                    continue;
                }

                nmats = nmats + 1;
                ntest = 0;

                // Save iseed in case of error
                for (j = 0; j < 4; j++) {
                    ioldsd[j] = iseed[j];
                }

                // Initialize result
                for (j = 0; j < 15; j++) {
                    result[j] = 0.0;
                }

                // Compute A and B
                // Description of control parameters:
                // kclass = 1 means without rotation, = 2 means with rotation,
                // = 3 means random.
                // katype: the "type" to be passed to dlatm4 for computing A.
                // kazero: the pattern of zeros on the diagonal for A:
                // = 1: ( xxx ), = 2: (0, xxx ) = 3: (0, 0, xxx, 0 ),
                // = 4: (0, xxx, 0, 0 ), = 5: ( 0, 0, 1, xxx, 0 ),
                // = 6: ( 0, 1, 0, xxx, 0). (xxx means a string of
                // non-zero entries.)
                // kamagn: the magnitude of the matrix = 0: zero, = 1: O(1),
                // = 2: large, = 3: small.
                // iasign: 1 if the diagonal elements of A are to be multiplied
                // by a random magnitude 1 number, = 2 if randomly chosen
                // diagonal blocks are to be rotated to form 2x2 blocks.
                // kbtype, kbzero, kbmagn, ibsign: the same, but for B.
                // ktrian = 0: don't fill in the upper triangle, = 1: do.
                // kz1, kz2, kadd: used to implement kazero and kbzero.
                // rmagn: used to implement kamagn and kbmagn.

                if (mtypes <= maxtyp) {
                    iinfo[0] = 0;

                    if (kclass[jtype - 1] < 3) {

                        // Generate A without rotation
                        if (Math.abs(katype[jtype - 1]) == 3) {
                            in[0] = (2 * ((n - 1) / 2)) + 1;

                            if (in[0] != n) {
                                dlaset('F', n, n, 0.0, 0.0, A, lda);
                            }
                        } // if (Math.abs(katype[jtype-1] == 3)
                        else {
                            in[0] = n;
                        }

                        dlatm4(katype[jtype - 1], in[0], kz1[kazero[jtype - 1] - 1], kz2[kazero[jtype - 1] - 1],
                               iasign[jtype - 1], rmagn[kamagn[jtype - 1]], ulp,
                               rmagn[ktrian[jtype - 1] * kamagn[jtype - 1]], 2, iseed, A, lda);
                        iadd = kadd[kazero[jtype - 1] - 1];

                        if ((iadd > 0) && (iadd <= n)) {
                            A[iadd - 1][iadd - 1] = rmagn[kamagn[jtype - 1]];
                        }

                        // Generate B without rotation
                        if (Math.abs(kbtype[jtype - 1]) == 3) {
                            in[0] = (2 * ((n - 1) / 2)) + 1;

                            if (in[0] != n) {
                                dlaset('F', n, n, 0.0, 0.0, B, lda);
                            }
                        } // if (Math.abs(kbtype[jtype-1]) == 3)
                        else {
                            in[0] = n;
                        }

                        dlatm4(kbtype[jtype - 1], in[0], kz1[kbzero[jtype - 1] - 1], kz2[kbzero[jtype - 1] - 1],
                               ibsign[jtype - 1], rmagn[kbmagn[jtype - 1]], 1.0,
                               rmagn[ktrian[jtype - 1] * kbmagn[jtype - 1]], 2, iseed, B, lda);
                        iadd = kadd[kbzero[jtype - 1] - 1];

                        if ((iadd != 0) && (iadd <= n)) {
                            B[iadd - 1][iadd - 1] = rmagn[kbmagn[jtype - 1]];
                        }

                        if ((kclass[jtype - 1] == 2) && (n > 0)) {

                            // Include rotations
                            // Generate U, V as Householder transformations times
                            // a diagonal matrix.
                            for (jc = 1; jc <= (n - 1); jc++) {

                                for (jr = jc; jr <= n; jr++) {
                                    U[jr - 1][jc - 1] = dlarnd(3, iseed);
                                    V[jr - 1][jc - 1] = dlarnd(3, iseed);
                                } // for (jr = jc; jr <= n; jr++)

                                x = new double[n - jc];

                                for (i = 0; i < (n - jc); i++) {
                                    x[i] = U[jc + i][jc - 1];
                                }

                                alpha[0] = U[jc - 1][jc - 1];
                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
                                U[jc - 1][jc - 1] = alpha[0];

                                for (i = 0; i < (n - jc); i++) {
                                    U[jc + i][jc - 1] = x[i];
                                }

                                work[jc - 1] = tau[0];

                                if (U[jc - 1][jc - 1] >= 0.0) {
                                    work[(2 * n) + jc - 1] = 1.0;
                                } else {
                                    work[(2 * n) + jc - 1] = -1.0;
                                }

                                U[jc - 1][jc - 1] = 1.0;
                                alpha[0] = V[jc - 1][jc - 1];

                                for (i = 0; i < (n - jc); i++) {
                                    x[i] = V[jc + i][jc - 1];
                                }

                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
                                V[jc - 1][jc - 1] = alpha[0];

                                for (i = 0; i < (n - jc); i++) {
                                    V[jc + i][jc - 1] = x[i];
                                }

                                work[n + jc - 1] = tau[0];

                                if (V[jc - 1][jc - 1] >= 0.0) {
                                    work[(3 * n) + jc - 1] = 1.0;
                                } else {
                                    work[(3 * n) + jc - 1] = -1.0;
                                }

                                V[jc - 1][jc - 1] = 1.0;
                            } // for (jc = 1; jc <= n-1; jc++)

                            U[n - 1][n - 1] = 1.0;
                            work[n - 1] = 0.0;

                            if (dlarnd(2, iseed) >= 0.0) {
                                work[(3 * n) - 1] = 1.0;
                            } else {
                                work[(3 * n) - 1] = -1.0;
                            }

                            V[n - 1][n - 1] = 1.0;
                            work[(2 * n) - 1] = 0.0;

                            if (dlarnd(2, iseed) >= 0.0) {
                                work[(4 * n) - 1] = 1.0;
                            } else {
                                work[(4 * n) - 1] = -1.0;
                            }

                            // Apply the diagonal matrices
                            for (jc = 0; jc < n; jc++) {

                                for (jr = 0; jr < n; jr++) {
                                    A[jr][jc] = work[(2 * n) + jr] * work[(3 * n) + jc] * A[jr][jc];
                                    B[jr][jc] = work[(2 * n) + jr] * work[(3 * n) + jc] * B[jr][jc];
                                }
                            }

                            work2 = new double[n];
                            dorm2r('L', 'N', n, n, n - 1, U, ldu, work, A, lda, work2, iinfo);

                            if (iinfo[0] != 0) {
                                UI.setDataText("First dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(iinfo[0]);

                                return;
                            } // if (iinfo[0] != 0)

                            x = new double[n - 1];

                            for (i = 0; i < (n - 1); i++) {
                                x[i] = work[n + i];
                            }

                            dorm2r('R', 'T', n, n, n - 1, V, ldu, x, A, lda, work2, iinfo);

                            if (iinfo[0] != 0) {
                                UI.setDataText("Second dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(iinfo[0]);

                                return;
                            } // if (iinfo[0] != 0)

                            dorm2r('L', 'N', n, n, n - 1, U, ldu, work, B, lda, work2, iinfo);

                            if (iinfo[0] != 0) {
                                UI.setDataText("Third dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(iinfo[0]);

                                return;
                            } // if (iinfo[0] != 0)

                            dorm2r('R', 'T', n, n, n - 1, V, ldu, x, B, lda, work2, iinfo);

                            if (iinfo[0] != 0) {
                                UI.setDataText("Fourth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(iinfo[0]);

                                return;
                            } // if (iinfo[0] != 0)
                        } // if ((kclass[jtype-1] == 2) && (n > 0))
                    } // if (kclass[jtype-1] < 3)
                    else { // kclass[jtype-1] >= 3

                        // Random matrices
                        for (jc = 0; jc < n; jc++) {

                            for (jr = 0; jr < n; jr++) {
                                A[jr][jc] = rmagn[kamagn[jtype - 1]] * dlarnd(2, iseed);
                                B[jr][jc] = rmagn[kbmagn[jtype - 1]] * dlarnd(2, iseed);
                            }
                        }

                        anorm = dlange('1', n, n, A, lda, work);
                        bnorm = dlange('1', n, n, B, lda, work);
                    } // else kclass[jtype-1] >= 3
                } // if (mtypes <= maxtyp)

                // Call dgeqr2, dorm2r, and dgghrd to compute H, T, U, and V
                dlacpy(' ', n, n, A, lda, H, lda);
                dlacpy(' ', n, n, B, lda, T, lda);
                ntest = 1;
                result[0] = ulpinv;
                work2 = new double[n];

loop1:           {
                    dgeqr2(n, n, T, lda, work, work2, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dgeqr2 returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dorm2r('L', 'T', n, n, n, T, lda, work, H, lda, work2, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("Fifth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dlaset('F', n, n, 0.0, 1.0, U, ldu);
                    dorm2r('R', 'N', n, n, n, T, lda, work, U, ldu, work2, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("Sixth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dgghrd('V', 'I', n, 1, n, H, lda, T, lda, U, ldu, V, ldu, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dgghrd returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    ntest = 4;

                    // Do tests 1--4
                    dget51(1, n, A, lda, H, lda, U, ldu, V, ldu, work, result);
                    dget51(1, n, B, lda, T, lda, U, ldu, V, ldu, work, res);
                    result[1] = res[0];
                    dget51(3, n, B, lda, T, lda, U, ldu, U, ldu, work, res);
                    result[2] = res[0];
                    dget51(3, n, B, lda, T, lda, V, ldu, V, ldu, work, res);
                    result[3] = res[0];

                    // Call dhgeqz to compute S1, P1, S2, P2, Q, and Z, do tests.
                    // Compute T1 and UZ
                    // Eigenvalues only
                    dlacpy(' ', n, n, H, lda, S2, lda);
                    dlacpy(' ', n, n, T, lda, P2, lda);
                    ntest = 5;
                    result[4] = ulpinv;

                    dhgeqz('E', 'N', 'N', n, 1, n, S2, lda, P2, lda, alphr3, alphi3, beta3, Q, ldu, Z, ldu, work, lwork,
                           iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("First dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    // Eigenvalues and full Schur form
                    dlacpy(' ', n, n, H, lda, S2, lda);
                    dlacpy(' ', n, n, T, lda, P2, lda);

                    dhgeqz('S', 'N', 'N', n, 1, n, S2, lda, P2, lda, alphr1, alphi1, beta1, Q, ldu, Z, ldu, work, lwork,
                           iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("Second dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    // Eigenvalues, Schur Form, and Schur Vectors
                    dlacpy(' ', n, n, H, lda, S1, lda);
                    dlacpy(' ', n, n, T, lda, P1, lda);
                    dhgeqz('S', 'I', 'I', n, 1, n, S1, lda, P1, lda, alphr1, alphi1, beta1, Q, ldu, Z, ldu, work, lwork,
                           iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("Third dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    ntest = 8;

                    // Do tests 5--8
                    dget51(1, n, H, lda, S1, lda, Q, ldu, Z, ldu, work, res);
                    result[4] = res[0];
                    dget51(1, n, T, lda, P1, lda, Q, ldu, Z, ldu, work, res);
                    result[5] = res[0];
                    dget51(3, n, T, lda, P1, lda, Q, ldu, Q, ldu, work, res);
                    result[6] = res[0];
                    dget51(3, n, T, lda, P1, lda, Z, ldu, Z, ldu, work, res);
                    result[7] = res[0];

                    // Compute the Left and Right Eigenvectors of (S1,P1)
                    // 9: Compute the left eigenvector matrix without
                    // back transforming:
                    ntest = 9;
                    result[8] = ulpinv;

                    // To test "select" option, compute half of the eigenvectors
                    // in one call, and half in another
                    i1 = n / 2;

                    for (j = 0; j < i1; j++) {
                        llwork[j] = true;
                    }

                    for (j = i1; j < n; j++) {
                        llwork[j] = false;
                    }

                    dtgevc('L', 'S', llwork, n, S1, lda, P1, lda, evectl, ldu, dummy, ldu, n, in, work, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(L,S1) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    i1 = in[0];

                    for (j = 0; j < i1; j++) {
                        llwork[j] = false;
                    }

                    for (j = i1; j < n; j++) {
                        llwork[j] = true;
                    }

                    row1 = Math.max(1, n);
                    array1 = new double[row1][n];

                    for (i = 0; i < row1; i++) {

                        for (j = 0; j < (n - i1); j++) {
                            array1[i][j] = evectl[i][j + i1];
                        }
                    }

                    dtgevc('L', 'S', llwork, n, S1, lda, P1, lda, array1, row1, dummy, ldu, n, in, work, iinfo);

                    for (i = 0; i < row1; i++) {

                        for (j = 0; j < (n - i1); j++) {
                            evectl[i][j + i1] = array1[i][j];
                        }
                    }

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(L,S2) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dget52(true, n, S1, lda, P1, lda, evectl, ldu, alphr1, alphi1, beta1, work, dumma);
                    result[8] = dumma[0];

                    if (dumma[1] > thrshn) {
                        UI.setDataText("Left eigenvectors from dtgevc(howmny=S)" + " incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + dumma[1] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (dumma[1] > thrshn)

                    // 10: Compute the left eigenvector matrix with
                    // back transforming
                    ntest = 10;
                    result[9] = ulpinv;
                    dlacpy('F', n, n, Q, ldu, evectl, ldu);
                    dtgevc('L', 'B', llwork, n, S1, lda, P1, lda, evectl, ldu, dummy, ldu, n, in, work, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(L,B) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dget52(true, n, H, lda, T, lda, evectl, ldu, alphr1, alphi1, beta1, work, dumma);
                    result[9] = dumma[0];

                    if (dumma[1] > thrshn) {
                        UI.setDataText("Left eigenvectors from dtgevc(howmny=B)" + " incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + dumma[1] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (dumma[1] > thrshn)

                    // 11: Compute the right eigenvector matrix without
                    // back transforming
                    ntest = 11;
                    result[10] = ulpinv;

                    // To test "select" option, compute half of the eigenvectors
                    // in one call, and half in another
                    i1 = n / 2;

                    for (j = 0; j < i1; j++) {
                        llwork[j] = true;
                    }

                    for (j = i1; j < n; j++) {
                        llwork[j] = false;
                    }

                    dtgevc('R', 'S', llwork, n, S1, lda, P1, lda, dummy, ldu, evectr, ldu, n, in, work, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(R,S1) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    i1 = in[0];

                    for (j = 0; j < i1; j++) {
                        llwork[j] = false;
                    }

                    for (j = i1; j < n; j++) {
                        llwork[j] = true;
                    }

                    row1 = Math.max(1, n);
                    array1 = new double[row1][n];

                    for (i = 0; i < row1; i++) {

                        for (j = 0; j < (n - i1); j++) {
                            array1[i][j] = evectr[i][j + i1];
                        }
                    }

                    dtgevc('R', 'S', llwork, n, S1, lda, P1, lda, dummy, ldu, array1, row1, n, in, work, iinfo);

                    for (i = 0; i < row1; i++) {

                        for (j = 0; j < (n - i1); j++) {
                            evectr[i][j + i1] = array1[i][j];
                        }
                    }

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(R,S2) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dget52(false, n, S1, lda, P1, lda, evectr, ldu, alphr1, alphi1, beta1, work, dumma);
                    result[10] = dumma[0];

                    if (dumma[1] > thresh) {
                        UI.setDataText("Right eigenvectors from dtgevc(howmny=S)" + " incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + dumma[1] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (dumma[1] > thresh)

                    // 12: Compute the right eigenvector matrix with
                    // back transforming.
                    ntest = 12;
                    result[11] = ulpinv;
                    dlacpy('F', n, n, Z, ldu, evectr, ldu);
                    dtgevc('R', 'B', llwork, n, S1, lda, P1, lda, dummy, ldu, evectr, ldu, n, in, work, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dchkgg dtgevc(R,B) returned iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        break loop1;
                    } // if (iinfo[0] != 0)

                    dget52(false, n, H, lda, T, lda, evectr, ldu, alphr1, alphi1, beta1, work, dumma);
                    result[11] = dumma[0];

                    if (dumma[1] > thresh) {
                        UI.setDataText("Right eigenvectors from dtgevc(howmny=B)" + " incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + dumma[1] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (dumma[1] > thresh)

                    // Tests 13--15 are done only on request
                    if (tstdif) {

                        // Do tests 13--14
                        dget51(2, n, S1, lda, S2, lda, Q, ldu, Z, ldu, work, res);
                        result[12] = res[0];
                        dget51(2, n, P1, lda, P2, lda, Q, ldu, Z, ldu, work, res);
                        result[13] = res[0];

                        // Do test 15
                        temp1 = 0.0;
                        temp2 = 0.0;

                        for (j = 0; j < n; j++) {
                            temp1 = Math.max(temp1, Math.abs(alphr1[j] - alphr3[j]) + Math.abs(alphi1[j] - alphi3[j]));
                            temp2 = Math.max(temp2, Math.abs(beta1[j] - beta3[j]));
                        } // for (j = 0; j < n; j++)

                        temp1 = temp1 / Math.max(safmin[0], ulp * Math.max(temp1, anorm));
                        temp2 = temp2 / Math.max(safmin[0], ulp * Math.max(temp2, bnorm));
                        result[14] = Math.max(temp1, temp2);
                        ntest = 15;
                    } // if (tstdif)
                    else { // !tstdif
                        result[12] = 0.0;
                        result[13] = 0.0;
                        result[14] = 0.0;
                        ntest = 12;
                    } // else !tstdif
                } // loop1

                // End of Loop -- Check for result[j] > thresh
                ntestt = ntestt + ntest;

                // Print out tests which fail.
                for (jr = 0; jr < ntest; jr++) {

                    if (result[jr] >= thresh) {

                        // If this is the first test to fail,
                        // print a header to the data file.
                        if (nerrs == 0) {
                            UI.setDataText("DGG -- Real Generalized eigenvalue problem\n");

                            // Matrix types
                            UI.setDataText("Matrix types (see dchkgg for details):\n");
                            UI.setDataText("Special Matrices:\n");
                            UI.setDataText("J' = transposed Jordan block\n");
                            UI.setDataText("1 = (0,0)\n");
                            UI.setDataText("2 = (I,0)\n");
                            UI.setDataText("3 = (0,I)\n");
                            UI.setDataText("4 = (I,I)\n");
                            UI.setDataText("5 = (J',J')\n");
                            UI.setDataText("6 = (diag(J',I), diag(I,J'))\n");
                            UI.setDataText("Diagonal Matrices: D = diag(0,1,2,...)\n");
                            UI.setDataText("7 = (D,I)\n");
                            UI.setDataText("8 = (I,D)\n");
                            UI.setDataText("9 = (large*D, small*I)\n");
                            UI.setDataText("10 = (small*D, large*I)\n");
                            UI.setDataText("11 = ((large*I, small*D)\n");
                            UI.setDataText("12 = (small*I , large*D)\n");
                            UI.setDataText("13 = (large*D, large*I)\n");
                            UI.setDataText("14 = (small*D, small*I)\n");
                            UI.setDataText("15 = (D, reversed D)\n");
                            UI.setDataText("Matrices Rotated by Random Orthogonal Matrices U,V:\n");
                            UI.setDataText("16 = transposed Jordan Blocks\n");
                            UI.setDataText("17 = arithm. alpha & beta\n");
                            UI.setDataText("18 = clustered alpha, beta = 0,1\n");
                            UI.setDataText("19 = geometric alpha, beta = 0, 1\n");
                            UI.setDataText("20 = arithmetic alpha, beta = 0, 1\n");
                            UI.setDataText("21 = random alpha, beta = 0, 1\n");
                            UI.setDataText("Large & Small Matrices:\n");
                            UI.setDataText("22 = (large, small)\n");
                            UI.setDataText("23 = (small, large)\n");
                            UI.setDataText("24 = (small, small)\n");
                            UI.setDataText("25 = (large, large)\n");
                            UI.setDataText("26 = random O(1) matrices\n");

                            // Tests performed
                            UI.setDataText("Tests performed:\n");
                            UI.setDataText("H is Hessenberg, S is Schur\n");
                            UI.setDataText("B, P, T are triangular\n");
                            UI.setDataText("U, V, Q, and Z are orthogonal\n");
                            UI.setDataText("L is the left eigevector\n");
                            UI.setDataText("R is the right eigenvector\n");
                            UI.setDataText("a is alpha, b is beta\n");
                            UI.setDataText(" ' means transpose\n");
                            UI.setDataText(" 1 = | A - U H V' | / ( |A| n ulp )\n");
                            UI.setDataText(" 2 = | B - U T V' | / ( |B| n ulp )\n");
                            UI.setDataText(" 3 = | I - UU' | / ( n ulp )\n");
                            UI.setDataText(" 4 = | I - VV' | / ( n ulp )\n");
                            UI.setDataText(" 5 = | H - Q S Z' | / ( |H| n ulp )\n");
                            UI.setDataText(" 6 = | T - Q P Z' | / ( |T| n ulp )\n");
                            UI.setDataText(" 7 = | I - QQ' | / ( n ulp )\n");
                            UI.setDataText(" 8 = | I - ZZ' | / ( n ulp )\n");
                            UI.setDataText(" 9 = max | (b S - a P)' | / const\n");
                            UI.setDataText("10 = max | (b H - a T)' | / const\n");
                            UI.setDataText("11 = max | (b S - a P) R | / const\n");
                            UI.setDataText("12 = max | (b H' - a T) R' | / const\n");
                        } // if (nerrs == 0)

                        nerrs = nerrs + 1;
                        UI.setDataText("Matrix order = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        UI.setDataText("result[" + jr + "] = " + result[jr] + "\n");
                    } // if (result[jr] >= thresh)
                } // for (jr = 0; jr < ntest; jr++)
            } // for (jtype = 1; jtype <= mtypes; jtype++)
        } // for (jsize = 1; jsize <= nsizes; jsize++)

        // Summary
        if (nerrs > 0) {
            UI.setDataText(nerrs + " out of " + ntestt + " dchkgg tests failed to pass the threshold\n");
        } else {
            UI.setDataText("All " + ntestt + " dchkgg tests passed the threshold\n");
        }

        return;

    } // dchkgg

    /**
     * This is a port of the porions of LAPACK version 3.1 test routine DCHKST used to test the symmetric eigenvalue
     * routines dsytrd, dorgtr, dsteqr, dsterf, and dsteqr. Original DCHKST created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     *
     * <p>dsytrd factors A as U S U', where ' means transpose, S is symmetric diagonal, and U is orthogonal. dsytrd can
     * use either just the lower or just the upper triangle of A; dchkst checks both cases. U is represented as a
     * product of the Householder transformations, whose vectors are stored in the first n-1 columns of V, and whose
     * scale factors are in TAU.</p>
     *
     * <p>dorgtr constructs the matrix U from the contents of V and TAU.</p>
     *
     * <p>dsteqr factors S as Z D1 Z', where Z is the orthogonal matrix of eigenvectors and D1 is a diagonal matrix with
     * the eigenvalues on the diagonal. D2 is the matrix of eigenvalues computed when Z is not computed.</p>
     *
     * <p>dsterf computes D3, the matrix of eigenvalues, by the PWK method, which does not yield eigenvectors</p>
     *
     * <p>When dchkst is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For
     * each size ("n") and each type of matrix, one matrix will be generated and used to test the symmetric
     * eigenroutines. For each matrix, a number of tests will be performed:
     * (1) | A - V S V' | / ( |A| n ulp ) dsytrd(uplo = 'U', ... )
     * (2) | I - UV' | / ( n ulp ) dorgtr( uplo = 'U', ... )
     * (3) | A - V S V' | / ( |A| n ulp ) dsytrd( uplo = 'L', ... )
     * (4) | I - UV' | / ( n ulp ) dorgtr( uplo = 'L', ... ) 
     * (5) | S - Z D Z' | / ( |S| n ulp) dsteqr('V', ...)
     * (6) | I - ZZ' | / ( n ulp ) dsteqr('V', ...)
     * (7) | D1 - D2 | / ( |D1| ulp ) dsteqr('N', ...)
     * (8) | D1 - D3 | / ( |D1| ulp ) dsterf
     * (9) 0 if the true eigenvalues (computed by sturm count) of S are within
     * thresh of those in D1. 2*thresh if they are not. (Tested using dstech)
     * The "sizes" are specified by an array nn(0:nsizes-1); the value of each element nn[j] specifies one size. 
     * The "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j] is true, then the matrix type
     * "j" will be generated. Currently, the list of possible types is:
     * (1) The zero matrix.
     * (2) The identity matrix.
     * (3) A diagonal matrix with evenly spaced entries 1, ..., ulp and random signs.
     *    (ulp = (first number larger than 1) - 1 )
     * (4) A diagonal matrix with geomtrically spaced entries 1, ..., ulp and random signs. 
     * (5) A diagonal matrix with "clustered" entries 1, ulp, ..., ulp and random signs.
     * (6) Same as (4), but multiplied by sqrt( overflow threshold )
     * (7) Same as (4), but multiplied by sqrt( underflow threshold )
     * (8) A matrix of the form U' D U, where U is orthogonal and D has evenly spaced
     *     entries 1, ..., ulp with random signs on the diagonal.
     * (9) A matrix of the form U' D U, where U is orthogonal and D has geometrically spaced entries 1, ..., ulp
     *     with random signs on the diagonal. 
     * (10) A matrix of the form U' D U, where U is orthogonal and D has "clustered" entries 1, ulp, ..., ulp
     *      with random signs on the diagonal.
     * (11) Same as (8), but multiplied by sqrt( overflow threshold)
     * (12) Same as (8), but multiplied by sqrt( underflow threshold)
     * (13) Symmetric matrix with random entries chosen from (-1,1).
     * (14) Same as (13), but multiplied by sqrt( overflow threshold)
     * (15) Same as (13), but multiplied by sqrt( underflow threshold)
     * (16) Same as (8), but diagonal elements are all positive.
     * (17) Same as (9), but diagonal elements are all positive.
     * (18) Same as (10), but diagonal elements are all positive. 
     * (19) Same as (16), but multiplied by sqrt( overflow threshold)
     * (20) Same as (16), but multiplied by sqrt( underflow threshold)
     * (21) A diagonally dominant tridiagonal matrix with geometrically spaced diagonal entries 1, ..., ulp.</p>
     *
     * @param  nsizes  (input) int The number of sizes of matrices to use. If it is zero, dchkst does nothing. It must
     *                 be at least zero.
     * @param  nn      (input) int[] of dimension (nsizes) An array containing the sizes to be used for the matrices.
     *                 Zero values will be skipped. The values must be at least zero.
     * @param  ntypes  (input) int The number of elements in dotype. If it is zero, dchkst does nothing. It must be at
     *                 least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined,
     *                 which is to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and
     *                 dotype[maxtyp] is true.
     * @param  dotype  (input) boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix
     *                 of that size and of type j will be generated. If ntypes is smaller than the maximum number of
     *                 types defined (parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If
     *                 ntypes is larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
     * @param  iseed   (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
     *                 generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
     *                 Also, iseed[3] must be odd. The random number generator uses an linear congruential sequence
     *                 limited to small integers, and so should produce machine independent random numbers. The values
     *                 of iseed are changed on exit, and can be used in the next call to dchkst to continue the same
     *                 random number sequence.
     * @param  thresh  (input) double A test will count as "failed" if the "error", computed as described above, exceeds
     *                 thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple
     *                 of 1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double)
     *                 or the size of the matrix. It must be at least zero.
     * @param  A       (input/workspace/output) double[][] of dimension (lda, max(nn)) Used to hold the matrix whose
     *                 eigenvalues are to be computed. On exit, A contains the last matrix actually used.
     * @param  lda     (input) int The leading dimension of A. It must be at least 1 and at least max(nn).
     * @param  AP      (workspace) double[] of dimension (max(nn)*max(nn+1)/2) The matrix A stored in packed format.
     * @param  SD      (workspace/output) double[] of dimension (max(nn)) The diagonal of the tridiagonal matrix
     *                 computed by dsytrd. On exit, SD and SE contain the tridiagonal form of the matrix in A.
     * @param  SE      (workspace/output) double[] of dimension (max(nn)) The off-diagonal of the tridiagonal matrix
     *                 computed by dsytrd. On exit, SD and SE contain the tridiagonal form of the matrix in A.
     * @param  D1      (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr
     *                 simultaneously with Z. On exit, the eigenvalues in D1 correspond with the matrix in A.
     * @param  D2      (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr if
     *                 Z is not computed. On exit, the eigenvalues in D2 correspond with the matrix in A.
     * @param  D3      (workspace/output) double[] of dimension max(nn)) The eigenvalues of A, as computed by dsterf. On
     *                 exit, the eigenvalues in D3 correspond with the matrix in A.
     * @param  D4      double[]
     * @param  D5      double[]
     * @param  WA1     double[]
     * @param  WA2     double[]
     * @param  WA3     double[]
     * @param  WR      double[]
     * @param  U       (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix computed by
     *                 dsytrd + dorgtr.
     * @param  ldu     (input) int The leading dimension of U, Z and V. It must be at least 1 and at least max(nn).
     * @param  V       (workspace/output) double[][] of dimension (ldu, max(nn)) The Householder vectors computed by
     *                 dsytrd in reducing A to tridiagonal form. The vectors computed with uplo = 'U' are in the upper
     *                 triangle, and the vectors computed with uplo = 'L' are in the lower triangle. (As described in
     *                 dsytrd, the sub- and superdiagonal are not set to 1, although the true Householder vector has a 1
     *                 in that position. The routines that use V, such as dorgtr, set those entries to 1 before using
     *                 them, and then restore them later.)
     * @param  VP      (workspace) double[] of dimension(max(nn)*max(nn+1)/2) The matrix V stored in packed format.
     * @param  tau     (workspace/output) double[] of dimension max(nn) The Householder factors computed by dsytrd in
     *                 reducing A to tridiagonal form.
     * @param  Z       (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix of eigenvectors
     *                 computed by dsteqr.
     * @param  work    (workspace/output) double[] of dimension (lwork)
     * @param  lwork   (input) int The number of entries in work. This must be at least 1 + 4*nmax + 2 * nmax * lg nmax
     *                 + 3 * nmax**2 where nmax = max(nn[j], 2) and lg = log base 2.
     * @param  iwork   (workspace/output) int[] dimension (6+ 6*nmax + 5 * nmax * lg nmax) where nmax = max(nn[j], 2)
     *                 and lg = log base 2
     * @param  liwork  (input) int length of iwork
     * @param  result  (output) double[] of dimension (26) The values computed by the tests described above. The values
     *                 are currently limited to 1/ulp, to avoid overflow.
     * @param  info    (output) int[] If 0, then everything ran OK.
     *                                -1: nsizes < 0 
     *                                -2: Some nn[j] < 0
     *                                -3: ntypes < 0 
     *                                -5: thresh < 0
     *                                -9: lda < 1 or lda < nmax, where nmax is max(nn[j])
     *                                -23: ldu < 1 or ldu < nmax
     *                                -29: lwork too small.
     * If dlatmr, dlatms, dsytrd, dorgtr, dsteqr, ssterf, or dormc2 returns an error code,
     * the absolute value of it is returned.
     */
    private void dchkst(int nsizes, int[] nn, int ntypes, boolean[] dotype, int[] iseed, double thresh, double[][] A,
                        int lda, double[] AP, double[] SD, double[] SE, double[] D1, double[] D2, double[] D3,
                        double[] D4, double[] D5, double[] WA1, double[] WA2, double[] WA3, double[] WR, double[][] U,
                        int ldu, double[][] V, double[] VP, double[] tau, double[][] Z, double[] work, int lwork,
                        int[] iwork, int liwork, double[] result, int[] info) {
        int maxtyp = 21; // The number of types defined.
        boolean srange = false;
        boolean srel = false;
        boolean badnn;
        int i;
        int[] iinfo = new int[1];
        int iL;
        int imode; // Values to be passed to the matrix generators
        int itemp;
        int itype;
        int iu;
        int j;
        int jc;
        int jr;
        int jsize;
        int jtype;
        int lgn;
        int liwedc;
        int log2ui;
        int lwedc;
        int m;
        int m2;
        int m3;
        int mtypes;
        int n;
        int nap;
        int nblock; // Blocksize as returned by envir.
        int nerrs; // The number of tests which have exceeded thresh so far
        int nmats; // The number of matrices generated so far.
        int nmax; // Largest value in nn.
        int split;
        int ntest; // The number of tests performed, or which can be performed
                   // so far, for the current matrix.
        int ntestt; // The total number of tests performed so far.
        double abstol;
        double aninv;
        double anorm; // Norm of A; passed to matrix generators.
        double cond; // Values to be passed to the matrix generators.
        double[] ovfl = new double[1]; // Overflow threshold.
        double rtovfl; // Square root of ovfl;
        double rtunfl; // Square root of unfl
        double temp1;
        double temp2;
        double temp3;
        double temp4;
        double ulp; // Finest relative precision
        double ulpinv; // Inverse of finest relative precision
        double[] unfl = new double[1]; // Underflow threshold
        double vL;
        double vu;
        int[] idumma = new int[1];
        int[] ioldsd = new int[4];
        int[] iseed2 = new int[4];

        // The general type (1-10) for type "j".
        int[] ktype = new int[] { 1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9, 9, 9, 10 };

        // The order of magnitude ( O(1), O(overflow^(1/2), O(underflow^(1/2) )
        int[] kmagn = new int[] { 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 1, 1, 2, 3, 1 };

        // The mode value to be passed to the matrix generator for type "j".
        int[] kmode = new int[] { 0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 3, 1, 4, 4, 3 };
        double[] dumma = new double[1];
        String name;
        String opts;
        double[] work2;
        double[] work3;
        double[] res = new double[2];
        double[][] dummy2 = new double[1][1];

        idumma[0] = 1;
        ntestt = 0;
        info[0] = 0;

        badnn = false;
        nmax = 1;

        for (j = 0; j < nsizes; j++) {
            nmax = Math.max(nmax, nn[j]);

            if (nn[j] < 0) {
                badnn = true;
            }
        } // for (j = 0; j < nsizes; j++)

        work2 = new double[3 * nmax];
        work3 = new double[nmax];

        name = new String("DSYTRD");
        opts = new String("L");
        nblock = ilaenv(1, name, opts, nmax, -1, -1, -1);
        nblock = Math.min(nmax, Math.max(1, nblock));

        // Check for errors
        if (nsizes < 0) {
            info[0] = -1;
        } else if (badnn) {
            info[0] = -2;
        } else if (ntypes < 0) {
            info[0] = -3;
        } else if (lda < nmax) {
            info[0] = -9;
        } else if (ldu < nmax) {
            info[0] = -23;
        } else if ((2 * Math.max(2, nmax) * Math.max(2, nmax)) > lwork) {
            info[0] = -29;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dchkst had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((nsizes == 0) || (ntypes == 0)) {
            return;
        }

        unfl[0] = dlamch('S');
        ovfl[0] = 1.0 / unfl[0];
        dlabad(unfl, ovfl);
        ulp = dlamch('E') * dlamch('B');
        ulpinv = 1.0 / ulp;
        log2ui = (int) (Math.log(ulpinv) / Math.log(2.0));
        rtunfl = Math.sqrt(unfl[0]);
        rtovfl = Math.sqrt(ovfl[0]);

        // Loop over sizes, types

        for (i = 0; i < 4; i++) {
            iseed2[i] = iseed[i];
        }

        nerrs = 0;
        nmats = 0;

        for (jsize = 1; jsize <= nsizes; jsize++) {
            n = nn[jsize - 1];

            if (n > 0) {
                lgn = (int) (Math.log((double) n) / Math.log(2.0));

                if (Math.pow(2.0, lgn) < n) {
                    lgn = lgn + 1;
                }

                if (Math.pow(2.0, lgn) < n) {
                    lgn = lgn + 1;
                }

                lwedc = 1 + (4 * n) + (2 * n * lgn) + (3 * n * n);
                liwedc = 6 + (6 * n) + (5 * n * lgn);
            } // if (n > 0)
            else { // n <= 0
                lwedc = 8;
                liwedc = 12;
            } // else n <= 0

            nap = (n * (n + 1)) / 2;
            aninv = 1.0 / (double) (Math.max(1, n));

            if (nsizes != 1) {
                mtypes = Math.min(maxtyp, ntypes);
            } else {
                mtypes = Math.min(maxtyp + 1, ntypes);
            }

            for (jtype = 1; jtype <= mtypes; jtype++) {

                if (!dotype[jtype - 1]) {
                    continue;
                }

                nmats = nmats + 1;
                ntest = 0;

                for (j = 0; j < 4; j++) {
                    ioldsd[j] = iseed[j];
                }

                // Compute "A"
                // Control parameters:
                /*         kmagn  kmode        ktype
                 *    = 1  O(1)   clustered 1  zero
                 *    = 2  large  clustered 2  identity
                 *    = 3  small  exponential (none)
                 *    = 4         arithmetic   diagonal, (w/ eigenvalues)
                 *    = 5         random log   symmetric, w/ eigenvalues  
                 *    = 6         random       (none)  
                 *    = 7                      random diagonal   
                 *    = 8                      random symmetric   
                 *    = 9                      positive definite
                 *    = 10                     diagonally dominant tridiagonal
                 */

                if (mtypes <= maxtyp) {
                    itype = ktype[jtype - 1];
                    imode = kmode[jtype - 1];
                    
                    // Compute norm

                    if (kmagn[jtype - 1] == 1) {
                        anorm = 1.0;
                    } else if (kmagn[jtype - 1] == 2) {
                        anorm = (rtovfl * ulp) * aninv;
                    } else {
                        anorm = rtunfl * n * ulpinv;
                    }

                    dlaset('F', lda, n, 0.0, 0.0, A, lda);
                    iinfo[0] = 0;

                    if (jtype <= 15) {
                        cond = ulpinv;
                    } else {
                        cond = ulpinv * aninv / 10.0;
                    }

                    // Special Matrices -- Identity & Jordan block

                    // Zero
                    if (itype == 1) {
                        iinfo[0] = 0;
                    } // if (itype == 1)
                    else if (itype == 2) {

                        // Identity
                        for (jc = 0; jc < n; jc++) {
                            A[jc][jc] = anorm;
                        }
                    } // else if (itype == 2)
                    else if (itype == 4) {

                        // Diagonal Matrix, [Eigen]values, Specified
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);
                    } // else if (itype == 4)
                    else if (itype == 5) {

                        // Symmetric, eigenvalues specified
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
                    } // else if (itype == 5)
                    else if (itype == 7) {

                        // Diagonal, random eigenvalues
                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);
                    } // else if (itype == 7)
                    else if (itype == 8) {

                        // Symmetric, random eigenvalues
                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);
                    } // else if (itype == 8)
                    else if (itype == 9) {

                        // Positive definite, eigenvalues specified
                        dlatms(n, n, 'S', iseed, 'P', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
                    } // else if (itype == 9)
                    else if (itype == 10) {

                        // Positive definite tridiagonal, eigenvalues specified
                        dlatms(n, n, 'S', iseed, 'P', work, imode, cond, anorm, 1, 1, 'N', A, lda, work2, iinfo);

                        for (i = 1; i < n; i++) {
                            temp1 = Math.abs(A[i - 1][i]) / Math.sqrt(Math.abs(A[i - 1][i - 1] * A[i][i]));

                            if (temp1 > 0.5) {
                                A[i - 1][i] = 0.5 * Math.sqrt(Math.abs(A[i - 1][i - 1] * A[i][i]));
                                A[i][i - 1] = A[i - 1][i];
                            } // if (temp1 > 0.5)
                        } // for (i = 1; i < n; i++)
                    } // else if (itype == 10)
                    else {
                        iinfo[0] = 1;
                    } // else

                    if (iinfo[0] != 0) {
                        UI.setDataText("Generator iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        return;
                    } // if (iinfo[0] != 0)
                } // if (mtypes <= maxtyp)

// Call dsytrd and dorgtr to compute S and U from upper triangle.
loop1:           {
                    dlacpy('U', n, n, A, lda, V, ldu);
                    ntest = 1;
                    dsytrd('U', n, V, ldu, SD, SE, tau, work, lwork, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dsytrd(U) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[0] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    dlacpy('U', n, n, V, ldu, U, ldu);
                    ntest = 2;
                    dorgtr('U', n, U, ldu, tau, work, lwork, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dorgtr(U) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[1] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    // Do tests 1 and 2
                    dsyt21(2, 'U', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, result);
                    dsyt21(3, 'U', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
                    result[1] = res[0];

                    // Call dsytrd and dorgtr to compute S and U from
                    // lower triangle, do tests.
                    dlacpy('L', n, n, A, lda, V, ldu);

                    ntest = 3;
                    dsytrd('L', n, V, ldu, SD, SE, tau, work, lwork, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dsytrd(L) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[2] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    dlacpy('L', n, n, V, ldu, U, ldu);

                    ntest = 4;
                    dorgtr('L', n, U, ldu, tau, work, lwork, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dorgtr(L) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[3] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    dsyt21(2, 'L', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
                    result[2] = res[0];
                    dsyt21(3, 'L', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
                    result[3] = res[0];

                    // Call dsteqr to compute D1, D2, and Z, do tests.
                    // Compute D1 and Z
                    for (i = 0; i < n; i++) {
                        D1[i] = SD[i];
                    }

                    if (n > 0) {

                        for (i = 0; i < (n - 1); i++) {
                            work[i] = SE[i];
                        }
                    } // if (n > 0)

                    dlaset('F', n, n, 0.0, 1.0, Z, ldu);

                    ntest = 5;
                    dsteqr('V', n, D1, work, Z, ldu, work2, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dsteqr(V) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[4] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    // Compute D2
                    for (i = 0; i < n; i++) {
                        D2[i] = SD[i];
                    }

                    if (n > 0) {

                        for (i = 0; i < (n - 1); i++) {
                            work[i] = SE[i];
                        }
                    } // if (n > 0)

                    ntest = 7;
                    dsteqr('N', n, D2, work, dummy2, ldu, work2, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dsteqr(N) iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[6] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    // Compute D3 (using PWK method)
                    for (i = 0; i < n; i++) {
                        D3[i] = SD[i];
                    }

                    if (n > 0) {

                        for (i = 0; i < (n - 1); i++) {
                            work[i] = SE[i];
                        }
                    } // if (n > 0)

                    ntest = 8;
                    dsterf(n, D3, work, iinfo);

                    if (iinfo[0] != 0) {
                        UI.setDataText("dsterf iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        if (iinfo[0] < 0) {
                            return;
                        } else {
                            result[7] = ulpinv;

                            break loop1;
                        }
                    } // if (iinfo[0] != 0)

                    // Do tests 5 and 6
                    dstt21(n, 0, SD, SE, D1, dumma, Z, ldu, work, res);
                    result[4] = res[0];
                    result[5] = res[1];

                    // Do tests 7 and 8
                    temp1 = 0.0;
                    temp2 = 0.0;
                    temp3 = 0.0;
                    temp4 = 0.0;

                    for (j = 0; j < n; j++) {
                        temp1 = Math.max(temp1, Math.abs(D1[j]));
                        temp1 = Math.max(temp1, Math.abs(D2[j]));
                        temp2 = Math.max(temp2, Math.abs(D1[j] - D2[j]));
                        temp3 = Math.max(temp3, Math.abs(D1[j]));
                        temp3 = Math.max(temp3, Math.abs(D3[j]));
                        temp4 = Math.max(temp4, Math.abs(D1[j] - D3[j]));
                    } // for (j = 0; j < n; j++)

                    result[6] = temp2 / Math.max(unfl[0], ulp * Math.max(temp1, temp2));
                    result[7] = temp4 / Math.max(unfl[0], ulp * Math.max(temp3, temp4));

                    // Do Test 9 -- Sturm Sequence of Eigenvalues
                    // Go up by factors of two until it succeeds
                    ntest = 9;
                    temp1 = thresh * (0.5 - ulp);

                    for (j = 0; j <= log2ui; j++) {
                        dstech(n, SD, SE, D1, temp1, work, iinfo);

                        if (iinfo[0] == 0) {
                            break;
                        }

                        temp1 = 2.0 * temp1;
                    } // for (j = 0; j <= log2ui; j++)

                    result[8] = temp1;
                } // loop1

                ntestt = ntestt + ntest;

                // End of loop -- Check for result[j] > thresh

                for (jr = 0; jr < ntest; jr++) {

                    if (result[jr] >= thresh) {

                        // If this is the first data to fail,
                        // print a header to the data file.
                        if (nerrs == 0) {
                            UI.setDataText("DST -- Real Symmetric eigenvalue problem\n");
                            UI.setDataText("Matrix types (see dchkst for details):\n");
                            UI.setDataText("Special matrices:\n");
                            UI.setDataText("1 = Zero matrix\n");
                            UI.setDataText("2 = Identity matrix\n");
                            UI.setDataText("3 = Diagonal: evenly spaced entries\n");
                            UI.setDataText("4 = Diagonal: geometrically spaced entries\n");
                            UI.setDataText("5 = Diagonal: clustered entries\n");
                            UI.setDataText("6 = Diagonal: large, evenly spaced\n");
                            UI.setDataText("7 = Diagonal: small, evenly spaced\n");
                            UI.setDataText("Dense Symmetric Matrices\n");
                            UI.setDataText("8 = Evenly spaced eigenvalues\n");
                            UI.setDataText("9 = Geometrically spaced eigenvalues\n");
                            UI.setDataText("10 = Clustered eigenvalues\n");
                            UI.setDataText("11 = Large, evenly spaced eigenvalues\n");
                            UI.setDataText("12 = Small, evenly spaced eigenvalues\n");
                            UI.setDataText("13 = Matrix with random O(1) entries\n");
                            UI.setDataText("14 = Matrix with large random entries\n");
                            UI.setDataText("15 = Matrix with small random entries\n");
                            UI.setDataText("16 = Positive definite, evenly spaced eigenvalues\n");
                            UI.setDataText("17 = Positive definite, geometrically spaced eigenvalues\n");
                            UI.setDataText("18 = Positive definite, clustered eigenvalues\n");
                            UI.setDataText("19 = Positive definite, small evenly spaced eigenvalues\n");
                            UI.setDataText("20 = Positive definite, large evenly spaced eigenvalues\n");
                            UI.setDataText("21 = Diagonally dominant tridiagonal,\n");
                            UI.setDataText("     geometrically, spaced eigenvalues\n");

                            // Tests performed
                            UI.setDataText("Tests performed: see dchkst for details\n");
                        } // if (nerrs == 0)

                        nerrs = nerrs + 1;
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("result[" + jr + "] = " + result[jr] + "\n");
                    } // if (result[jr] >= thresh)
                } // for (jr = 0; jr < ntest; jr++)
            } // for (jtype = 1; jtype <= mtypes; jtype++)
        } // for (jsize = 1; jsize <= nsizes; jsize++)

        // Summary
        if (nerrs > 0) {
            UI.setDataText("dchkst " + nerrs + " out of " + ntestt + " tests failed to pass the threshold\n");
        } else {
            UI.setDataText("All " + ntestt + " tests for dchkst passed the threshold\n");
        }

        return;
    } // dchkst

    /**
     * Port of 12/3/93 linpack ddot routine Original version created by Jack Dongarra Forms the dot product of two
     * vectors.
     *
     * @param   n     int
     * @param   dx    double[]
     * @param   incx  int
     * @param   dy    double[]
     * @param   incy  int
     *
     * @return  double answer
     */
    private double ddot(int n, double[] dx, int incx, double[] dy, int incy) {
        double answer;
        int ix;
        int iy;
        int i;
        int m;
        int mp1;

        answer = 0.0;

        if (n <= 0) {
            return 0.0;
        }

        if ((incx != 1) || (incy != 1)) {

            // Code for unequal increments or equal increments not equal to 1
            ix = 0;
            iy = 0;

            if (incx < 0) {
                ix = (-n + 1) * incx;
            }

            if (incy < 0) {
                iy = (-n + 1) * incy;
            }

            for (i = 0; i < n; i++) {
                answer = answer + (dx[ix] * dy[iy]);
                ix = ix + incx;
                iy = iy + incy;
            } // for (i = 0; i < n; i++)

            return answer;
        } // if ((incx != 1) || (incy != 1))

        // Code for both increments equal to 1
        m = n % 5;

        if (m != 0) {

            for (i = 0; i < m; i++) {
                answer = answer + (dx[i] * dy[i]);
            }

            if (n < 5) {
                return answer;
            }
        } // if (m != 0)

        mp1 = m + 1;

        for (i = mp1; i <= n; i += 5) {
            answer = answer + (dx[i - 1] * dy[i - 1]) + (dx[i] * dy[i]) + (dx[i + 1] * dy[i + 1]) +
                     (dx[i + 2] * dy[i + 2]) + (dx[i + 3] * dy[i + 3]);
        } // for (i = mp1; i <= n; i += 5)

        return answer;
    } // ddot

    /**
     * This is a port of version 3.1 LAPACK test routine DDRGEV Original DDRGEV created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2007 
     * ddrgev checks the nonsymmetric generalized eigenvalue problem driver routine dggev.
     *
     * <p>dggev computes for a pair of n-by-n nonsymmetric matrices (A,B) the generalized eigenvalues and, optionally,
     * the left and right eigenvectors.</p>
     *
     * <p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A -
     * w*B is singular. It is usually represented as the pair (alpha, beta), as there is reasonable interpretation for
     * beta = 0, and even for both being zero.</p>
     *
     * <p>A right generalized eigenvector corresponding to a generalized eigenvalue w for a pair of matrices (A, B) is a
     * vector r such that (A - wB) * r = 0. A left generalized eigenvector is a vector L such that L**H * (A - wB) = 0,
     * where L**H is the conjugate-transpose of L.</p>
     *
     * <p>When ddrgev is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For
     * each size ("n") and each type of matrix, a pair of matrices (A, B) will be generated and used for testing. For
     * each matrix pair, the following tests will be performed and compared with the threshold thresh.</p>
     *
     * <p>Results from dggev: 
     * (1) max over all left eigenvalue/-vector pairs (alpha/beta, L) of
     *   | VL**H * (beta A - alpha B) |/ (ulp max(|beta A|, |alpha B|))
     *   where VL**H is the conjugate-transpose of VL.
     * (2) | |VL(i)| - 1 | / ulp and whether largest component real VL(i) denotes the i-th column of VL.
     * (3) max over all right eigenvalue/-vector pairs (alpha/beta, r) of
     *     | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) )
     * (4) | |VR(i) - 1 | / ulp and whether largest component real VR(i) denotes the i-th column of VR.
     * (5) W(full) = W(partial)
     *     W(full) denotes the eigenvalues computed when both L and r are also computed, and W(partial) denotes
     *     the eigenvalues computed when only W, only W and r, or only W and L are computed.
     * (6) VL(full) = VL(partial)
     *     VL(full) denotes the left eigenvectors computed when both L and r are computed, and VL(partial) denotes the
     *     result when only L is computed.
     * (7) VR(full) = VR(partial)
     *     VR(full) denotes the right eigenvectors computed when both L and r are also computed, and VR(partial)
     *     denotes the result when only r is computed.</p>
     *
     * <p>Test Matrices:
     * The sizes of the test matrices are specified by an array nn(0:nsizes-1); the value of each
     * element nn[j] specifies one size. The "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j]
     * is true, then a matrix type "j" will be generated. Currently, the list of possible types is:
     * (1) (0, 0) (a pair of zero matrices)
     * (2) (I, 0) (an identity and a zero matrix)
     * (3) (0, I) (a zero and an identity matrix)
     * (4) (I, I) (a pair of identity matrices)
     * (5) (Jtranspose, Jtranspose) (a pair of transposed Jordan blocks)
     * (6) (X, Y) where X = (Jtranspose 0) and Y = (I       0   ) 
     *                      (0          I)         (0 Jtranspose)
     *     and I is a k by k identity and J a (k+1) by (k+1) Jordan block; k = (N-1)/2
     * (7) (D, I) where D is diag(0, 1,..., N-1) (a diagonal matrix with those diagonal entries.)
     * (8) (I, D)
     * (9) (big*D, small*I) where "big" is near overflow and small = 1/big 
     * (10) (small*D, big*I)
     * (11) (big*I, small*D)
     * (12) (small*I, big*D)
     * (13) (big*D, big*I)
     * (14) (small*D, small*I)
     * (15) (D1, D2) where D1 is diag(0, 0, 1, ..., N-3, 0) and D2 is diag(0, N-3, N-4,..., 1, 0, 0)
     * (16) Q (Jtranspose, Jtranspose) Z where Q and Z are random orthogonal matrices.
     * (17) Q (T1, T2) Z where T1 and T2 are upper triangular matrices with random
     *      O(1) entries above the diagonal and diagonal entries diag(T1) = (0, 0, 1, ..., N-3, 0) and
     *      diag(T2) = (0, N-3, N-4, ..., 1, 0, 0)
     * (18) Q (T1, T2) Z   diag(T1) = (0, 0, 1, 1, s, ..., s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0)
     *      s = machine precision 
     * (19) Q (T1, T2) Z   diag(T1) = (0,0,1,1, 1-d, ..., 1 - (N-5)*d=s, 0)
     *                     diag(T2) = (0, 1, 0, 1, ..., 1, 0)
     * (20) Q (T1, T2) Z   diag(T1) = (0,0,1,1,a, ..., a**(N-5)=s, 0)
     *                     diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0)
     * (21) Q (T1, T2) Z   diag(T1) = (0, 0, 1, r1, r2, ..., r(N-4), 0) 
     *                     diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0)
     *                     where r1, ..., r(N-4) are random.
     * (22) Q (big*T1, small*T2) Z   diag(T1) = (0, 0, 1, ..., N-3, 0)
     *                               diag(T2) = (0, 1, ..., 1, 0, 0)
     * (23) Q (small*T1, big*T2) Z   diag(T1) = (0, 0, 1, ..., N-3, 0)
     *                               diag(T2) = (0, 1, ..., 1, 0, 0)
     * (24) Q (small*T1, small*T2) Z     diag(T1) = (0, 0, 1, ..., N-3, 0) 
     *                                   diag(T2) = (0, 1, ..., 1, 0, 0)
     * (25) Q (big*T1, big*T2) Z         diag(T1) = (0, 0, 1, ..., N-3, 0)
     *                                   diag(T2) = (0, 1, ..., 1, 0, 0)
     * (26) Q(T1, T2) Z where T1 and T2 are random upper-triangular matrices.</p>
     *
     * @param  nsizes  input int The number of sizes of matrices to use. If it is zero, ddrgev does nothing. nsizes >=
     *                 0.
     * @param  nn      input int[] of dimension (nsizes) An array containing the sizes to be used for the matrices. Zero
     *                 values will be skipped. nn >= 0.
     * @param  ntypes  input int The number of elements in dotype. If it is zero, ddrgev does nothing. It must be at
     *                 least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined,
     *                 which is to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and
     *                 dotype(maxtyp) is true.
     * @param  dotype  input boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
     *                 that size and of type j will be generated. If ntypes is smaller than the maximum number of types
     *                 defined(maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is larger
     *                 than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
     * @param  iseed   (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
     *                 generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
     *                 Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence
     *                 limited to small integers, and so should produce machine independent random numbers. The values
     *                 of iseed are changed on exit, and can be used in the next call to ddrgev to continue the same
     *                 random number sequence.
     * @param  thresh  input double A test will count as "failed" if the "error", computed as described above, exceeds
     *                 thresh. Note that the error is scaled to O(1), so thresh should be a reasonably small multiple of
     *                 1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or
     *                 the size of the matrix. It must be at least zero.
     * @param  A       (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original A matrix. Used
     *                 as input only if ntypes = maxtyp+1, dotype(0:maxtyp-1) = false, and dotype[maxtyp] = true.
     * @param  lda     input int The leading dimension of A, B, S, and T. It must be at least 1 and at least max(nn).
     * @param  B       (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original B matrix. Used
     *                 as input only if ntypes = maxtyp+1, dotype(0:maxtyp-1) = false, and dotype[maxtyp] = true.
     * @param  S       workspace double[][] of dimension (lda, max(nn)) The Schur form matrix computed from A by dggev.
     *                 On exit, S contains the Schur form matrix corresponding to the matrix in A.
     * @param  T       workspace double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from B by
     *                 dggev.
     * @param  Q       workspace double[][] of dimension (ldq, max(nn)) The (left) eigenvectors matrix computed by
     *                 dggev.
     * @param  ldq     input int The leading dimension of Q and Z. It must be at least 1 and at least max(nn).
     * @param  Z       Z (workspace) double[][] of dimension (ldq, max(nn)) The (right) orthogonal matrix computed by dggev.
     * @param  QE      QE (workspace) double[][] of dimension (ldqe, max(nn)) QE holds the computed right or left eigenvectors.
     * @param  ldqe    input int The leading dimension of QE. ldqe >= max(1,max(nn))
     * @param  alphar  workspace double[] of dimension (max(nn))
     * @param  alphai  workspace double[] of dimension (max(nn))
     * @param  beta    workspace double[] of dimension (max(nn)) The generalized eigenvalues of (A,B) computed by dggev.
     *                 (alphar[k-1] + alphai[k-1]*i)/ beta[k-1] is the k-th generalized eigenvalue of A and B.
     * @param  alphr1  workspace double[] of dimension (max(nn))
     * @param  alphi1  workspace double[] of dimension (max(nn))
     * @param  beta1   workspace double[] of dimension (max(nn)) Like alphar, alphai, and beta, these arrays contain the
     *                 eigenvalues of A and B, but those computed when dggev only computes a partial eigendecomposition,
     *                 i.e. not the eigenvalues and left and right eigenvectors.
     * @param  work    workspace double[] of dimension (lwork)
     * @param  lwork   input int The nuber of entries in work. lwork >= max(8*N, N*(N+1)).
     * @param  result  output double[] of dimension (2) The values are computed by the tests described above. The values
     *                 are currently limited to 1/ulp, to avoid overflow.
     * @param  info    output int[] 
     *                 = 0: successful exit
     *                 < 0: If info[0] = -i, the i-th argument had an illegal value.
     *                 > 0: A routine returned an error code.
     */
    private void ddrgev(int nsizes, int[] nn, int ntypes, boolean[] dotype, int[] iseed, double thresh, double[][] A,
                        int lda, double[][] B, double[][] S, double[][] T, double[][] Q, int ldq, double[][] Z,
                        double[][] QE, int ldqe, double[] alphar, double[] alphai, double[] beta, double[] alphr1,
                        double[] alphi1, double[] beta1, double[] work, int lwork, double[] result, int[] info) {
        int maxtyp = 26;
        boolean badnn;
        int i;
        int iadd;
        int[] ierr = new int[1];
        int in;
        int j;
        int jc;
        int jr;
        int jsize;
        int jtype;
        int maxwrk = 1;
        int minwrk;
        int mtypes;
        int n;
        int n1;
        int nerrs;
        int nmats;
        int nmax;
        int ntestt;
        double[] safmax = new double[1];
        double[] safmin = new double[1];
        double ulp;
        double ulpinv;
        int[] iasign = new int[] { 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0 };
        int[] ibsign = new int[] { 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        int[] ioldsd = new int[4];
        int[] kadd = new int[] { 0, 0, 0, 0, 3, 2 };
        int[] kamagn = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 2, 1 };
        int[] katype = new int[] { 0, 1, 0, 1, 2, 3, 4, 1, 4, 4, 1, 1, 4, 4, 4, 2, 4, 5, 8, 7, 9, 4, 4, 4, 4, 0 };
        int[] kazero = new int[] { 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 3, 5, 5, 5, 5, 3, 3, 3, 3, 1 };
        int[] kbmagn = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 1 };
        int[] kbtype = new int[] { 0, 0, 1, 1, 2, -3, 1, 4, 1, 1, 4, 4, 1, 1, -4, 2, -4, 8, 8, 8, 8, 8, 8, 8, 8, 0 };
        int[] kbzero = new int[] { 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 4, 1, 4, 6, 6, 6, 6, 4, 4, 4, 4, 1 };
        int[] kclass = new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 };
        int[] ktrian = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
        int[] kz1 = new int[] { 0, 1, 2, 1, 3, 3 };
        int[] kz2 = new int[] { 0, 0, 1, 2, 1, 1 };
        double[] rmagn = new double[4];
        String name;
        String opts;
        double[] alpha = new double[1];
        double[] x;
        double[] tau = new double[1];
        double[] work2;

        // Check for errors
        info[0] = 0;
        badnn = false;
        nmax = 1;

        for (j = 0; j < nsizes; j++) {
            nmax = Math.max(nmax, nn[j]);

            if (nn[j] < 0) {
                badnn = true;
            } // if (nn[j] < 0)
        } // for (j = 0; j < nsizes; j++)

        if (nsizes < 0) {
            info[0] = -1;
        } else if (badnn) {
            info[0] = -2;
        } else if (ntypes < 0) {
            info[0] = -3;
        } else if (thresh < 0.0) {
            info[0] = -6;
        } else if ((lda <= 1) || (lda < nmax)) {
            info[0] = -9;
        } else if ((ldq <= 1) || (ldq < nmax)) {
            info[0] = -14;
        } else if ((ldqe <= 1) || (ldqe < nmax)) {
            info[0] = -17;
        }

        // Compute workspace:
        // (Note: Comments in the code beginning "Workspace:" describe the
        // minimal amount of workspace needed at that point in the code, as well
        // as the preferred amount for good performance.  NB refers to the
        // optimal block size for the immediately following subroutine, as
        // returned by ilaenv.

        minwrk = 1;

        if ((info[0] == 0) && (lwork >= 1)) {
            minwrk = Math.max(1, 8 * nmax);
            minwrk = Math.max(minwrk, nmax * (nmax + 1));
            name = new String("DGEQRF");
            opts = new String(" ");
            maxwrk = (7 * nmax) + (nmax * ilaenv(1, name, opts, nmax, 1, nmax, 0));
            maxwrk = Math.max(maxwrk, nmax * (nmax + 1));
            work[0] = maxwrk;
        } // if ((info[0] == 0) && (lwork >= 1))

        if (lwork < minwrk) {
            info[0] = -25;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error ddrgev had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((nsizes == 0) || (ntypes == 0)) {
            return;
        }

        safmin[0] = dlamch('S');
        ulp = dlamch('E') * dlamch('B');
        safmin[0] = safmin[0] / ulp;
        safmax[0] = 1.0 / safmin[0];
        dlabad(safmin, safmax);
        ulpinv = 1.0 / ulp;

        // The values rmagn[2] and rmagn[3] depend on n, see below.
        rmagn[0] = 0.0;
        rmagn[1] = 1.0;

        // Loop over sizes, types
        ntestt = 0;
        nerrs = 0;
        nmats = 0;

        for (jsize = 1; jsize <= nsizes; jsize++) {
            n = nn[jsize - 1];
            n1 = Math.max(1, n);
            rmagn[2] = safmax[0] * ulp / n1;
            rmagn[3] = safmin[0] * ulpinv * n1;

            if (nsizes != 1) {
                mtypes = Math.min(maxtyp, ntypes);
            } else {
                mtypes = Math.min(maxtyp + 1, ntypes);
            }

            for (jtype = 1; jtype <= mtypes; jtype++) {

                if (!dotype[jtype - 1]) {
                    continue;
                } // if (!dotype[jtype-1])

                nmats = nmats + 1;

                // Save iseed in case of an error.
                for (j = 0; j < 4; j++) {
                    ioldsd[j] = iseed[j];
                }

                // Generate test matrices A and B
                // Description of control parameters
                // kclass = 1 means without rotation, = 2 means with rotation
                // = 3 means random
                // katype: the "type" to be passed to dlatm4 for computing A.
                // kazero: the pattern of zeros on the diagonal for A:
                // = 1: ( xxx ), = 2: (0, xxx ), = 3: (0, 0, xxx, 0 ),
                // = 4: ( 0, xxx, 0, 0 ), = 5: ( 0, 0, 1, xxx, 0 ),
                // = 6: ( 0, 1, 0, xxx, 0 ).  (xxx means a string of
                // non-zero entries.)
                // kamagn: the magnitude of the matrix: = 0: zero, = 1: O(1),
                // = 2: large, = 3: small.
                // iasign: 1 if the diagonal elements of A are to be multiplied
                // by a random magnitude 1 number, = 2 if randomly
                // chosen diagonal blocks are to be rotated to form
                // 2 by 2 blocks.
                // kbtype, kbzero, kbmagn, ibsign: the same, but for B.
                // ktrian: = 0: don't fill in the upper triangle, = 1: do.
                // kz1, kz2, kadd: used to implement kazero and kbzero.
                // rmagn: used to implement kamagn and kbmagn.

                if (mtypes <= maxtyp) {
                    ierr[0] = 0;

                    if (kclass[jtype - 1] < 3) {

                        // Generate A (without rotation)
                        if (Math.abs(katype[jtype - 1]) == 3) {
                            in = (2 * ((n - 1) / 2)) + 1;

                            if (in != n) {
                                dlaset('F', n, n, 0.0, 0.0, A, lda);
                            }
                        } // if (Math.abs(katype[jtype-1] == 3)
                        else { // Math.abs(katype[jtype-1] != 3
                            in = n;
                        } // else Math.abs(katype[jtype-1] != 3

                        dlatm4(katype[jtype - 1], in, kz1[kazero[jtype - 1] - 1], kz2[kazero[jtype - 1] - 1],
                               iasign[jtype - 1], rmagn[kamagn[jtype - 1]], ulp,
                               rmagn[ktrian[jtype - 1] * kamagn[jtype - 1]], 2, iseed, A, lda);
                        iadd = kadd[kazero[jtype - 1] - 1];

                        if ((iadd > 0) && (iadd <= n)) {
                            A[iadd - 1][iadd - 1] = 1.0;
                        } // if ((iadd > 0) && (iadd <= n))

                        // Generate B (without rotation)
                        if (Math.abs(kbtype[jtype - 1]) == 3) {
                            in = (2 * ((n - 1) / 2)) + 1;

                            if (in != n) {
                                dlaset('F', n, n, 0.0, 0.0, B, lda);
                            }
                        } // if (Math.abs(kbtype[jtype-1] == 3)
                        else { // Math.abs(kbtype[jtype-1] != 3
                            in = n;
                        } // else Math.abs(kbtype[jtype-1] != 3

                        dlatm4(kbtype[jtype - 1], in, kz1[kbzero[jtype - 1] - 1], kz2[kbzero[jtype - 1] - 1],
                               ibsign[jtype - 1], rmagn[kbmagn[jtype - 1]], 1.0,
                               rmagn[ktrian[jtype - 1] * kbmagn[jtype - 1]], 2, iseed, B, lda);
                        iadd = kadd[kbzero[jtype - 1] - 1];

                        if ((iadd != 0) && (iadd <= n)) {
                            B[iadd - 1][iadd - 1] = 1.0;
                        } // if ((iadd != 0) && (iadd <= n))

                        if ((kclass[jtype - 1] == 2) && (n > 0)) {

                            // Include rotations
                            // Generate Q, Z as Householder transformations
                            // times a diagonal matrix
                            for (jc = 1; jc <= (n - 1); jc++) {

                                for (jr = jc; jr <= n; jr++) {
                                    Q[jr - 1][jc - 1] = dlarnd(3, iseed);
                                    Z[jr - 1][jc - 1] = dlarnd(3, iseed);
                                } // for (jr = jc; jr <= n; jr++)

                                alpha[0] = Q[jc - 1][jc - 1];
                                x = new double[n - jc];

                                for (i = 0; i < (n - jc); i++) {
                                    x[i] = Q[jc + i][jc - 1];
                                }

                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
                                Q[jc - 1][jc - 1] = alpha[0];

                                for (i = 0; i < (n - jc); i++) {
                                    Q[jc + i][jc - 1] = x[i];
                                }

                                work[jc - 1] = tau[0];

                                if (Q[jc - 1][jc - 1] >= 0.0) {
                                    work[(2 * n) + jc - 1] = 1.0;
                                } else {
                                    work[(2 * n) + jc - 1] = -1.0;
                                }

                                Q[jc - 1][jc - 1] = 1.0;
                                alpha[0] = Z[jc - 1][jc - 1];

                                for (i = 0; i < (n - jc); i++) {
                                    x[i] = Z[jc + i][jc - 1];
                                }

                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
                                Z[jc - 1][jc - 1] = alpha[0];

                                for (i = 0; i < (n - jc); i++) {
                                    Z[jc + i][jc - 1] = x[i];
                                }

                                work[n + jc - 1] = tau[0];

                                if (Z[jc - 1][jc - 1] >= 0.0) {
                                    work[(3 * n) + jc - 1] = 1.0;
                                } else {
                                    work[(3 * n) + jc - 1] = -1.0;
                                }

                                Z[jc - 1][jc - 1] = 1.0;
                            } // for (jc = 1; jc <= n-1; jc++)

                            Q[n - 1][n - 1] = 1.0;
                            work[n - 1] = 0.0;

                            if (dlarnd(2, iseed) >= 0.0) {
                                work[(3 * n) - 1] = 1.0;
                            } else {
                                work[(3 * n) - 1] = -1.0;
                            }

                            Z[n - 1][n - 1] = 1.0;
                            work[(2 * n) - 1] = 0.0;

                            if (dlarnd(2, iseed) >= 0.0) {
                                work[(4 * n) - 1] = 1.0;
                            } else {
                                work[(4 * n) - 1] = -1.0;
                            }

                            // Apply the diagonal matrices
                            for (jc = 0; jc < n; jc++) {

                                for (jr = 0; jr < n; jr++) {
                                    A[jr][jc] = work[(2 * n) + jr] * work[(3 * n) + jc] * A[jr][jc];
                                    B[jr][jc] = work[(2 * n) + jr] * work[(3 * n) + jc] * B[jr][jc];
                                } // for (jr = 0; jr < n; jr++)
                            } // for (jc = 0; jc < n; jc++)

                            work2 = new double[n];
                            dorm2r('L', 'N', n, n, n - 1, Q, ldq, work, A, lda, work2, ierr);

                            if (ierr[0] != 0) {
                                UI.setDataText("ddrgev had error in first dorm2r\n");
                                UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(ierr[0]);

                                return;
                            }

                            x = new double[n - 1];

                            for (i = 0; i < (n - 1); i++) {
                                x[i] = work[n + i];
                            }

                            dorm2r('R', 'T', n, n, n - 1, Z, ldq, x, A, lda, work2, ierr);

                            if (ierr[0] != 0) {
                                UI.setDataText("ddrgev had error in second dorm2r\n");
                                UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(ierr[0]);

                                return;
                            }

                            dorm2r('L', 'N', n, n, n - 1, Q, ldq, work, B, lda, work2, ierr);

                            if (ierr[0] != 0) {
                                UI.setDataText("ddrgev had error in third dorm2r\n");
                                UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(ierr[0]);

                                return;
                            }

                            dorm2r('R', 'T', n, n, n - 1, Z, ldq, x, B, lda, work2, ierr);

                            if (ierr[0] != 0) {
                                UI.setDataText("ddrgev had error in fourth dorm2r\n");
                                UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(ierr[0]);

                                return;
                            }
                        } // if ((kclass[jtype-1] == 2) && (n > 0))
                    } // if (kclass[jtype-1] < 3)
                    else { // kclass[jtype-1] >= 3

                        // Random matrices
                        for (jc = 0; jc < n; jc++) {

                            for (jr = 0; jr < n; jr++) {
                                A[jr][jc] = rmagn[kamagn[jtype - 1]] * dlarnd(2, iseed);
                                B[jr][jc] = rmagn[kbmagn[jtype - 1]] * dlarnd(2, iseed);
                            } // for (jr = 0; jr < n; jr++)
                        } // for (jc = 0; jc < n; jc++)
                    } // else kclass[jtype-1] >= 3
                } // if (mtypes <= maxtyp)

                for (i = 0; i < 7; i++) {
                    result[i] = -1.0;
                } // for (i = 0; i < 7; i++)

                // Call dggev to compute eigevalues and eigenvectors
                dlacpy(' ', n, n, A, lda, S, lda);
                dlacpy(' ', n, n, B, lda, T, lda);
                dggev('V', 'V', n, S, lda, T, lda, alphar, alphai, beta, Q, ldq, Z, ldq, work, lwork, ierr);

                if ((ierr[0] != 0) && (ierr[0] != (n + 1))) {
                    result[0] = ulpinv;
                    UI.setDataText("ddrgev had error in call to dggev1\n");
                    UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                    UI.setDataText("n = " + n + "\n");
                    UI.setDataText("jtype = " + jtype + "\n");
                    UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                    UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                    UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                    UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    info[0] = Math.abs(ierr[0]);
                } else { // No error in dggev1

                    // Do the tests (1) and (2)
                    dget52(true, n, A, lda, B, lda, Q, ldq, alphar, alphai, beta, work, result);

                    if (result[1] > thresh) {
                        UI.setDataText("ddrgev left eigenvectors from dggev1 incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + result[1] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (result[1] > thresh)

                    // Do the tests 3 and 4
                    x = new double[2];
                    dget52(false, n, A, lda, B, lda, Z, ldq, alphar, alphai, beta, work, x);
                    result[2] = x[0];
                    result[3] = x[1];

                    if (result[3] > thresh) {
                        UI.setDataText("ddrgev right eigenvectors from dggev1 incorrectly normalized\n");
                        UI.setDataText("Bits of error = " + result[3] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                    } // if (result[3] > thresh)

                    // Do the test (5)
                    dlacpy(' ', n, n, A, lda, S, lda);
                    dlacpy(' ', n, n, B, lda, T, lda);
                    dggev('N', 'N', n, S, lda, T, lda, alphr1, alphi1, beta1, Q, ldq, Z, ldq, work, lwork, ierr);

                    if ((ierr[0] != 0) && (ierr[0] != (n + 1))) {
                        result[0] = ulpinv;
                        UI.setDataText("ddrgev had error in call to dggev2\n");
                        UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(ierr[0]);
                    } // if ((ierr[0] != 0) && (ierr[0] != n+1))
                    else { // no error in dggev2

                        for (j = 0; j < n; j++) {

                            if ((alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
                                result[4] = ulpinv;
                            }
                        } // for (j = 0; j < n; j++)

                        // Do the test (6): Compute eigenvalues and left
                        // eigenvectors, and test them
                        dlacpy(' ', n, n, A, lda, S, lda);
                        dlacpy(' ', n, n, B, lda, T, lda);
                        dggev('V', 'N', n, S, lda, T, lda, alphr1, alphi1, beta1, QE, ldqe, Z, ldq, work, lwork, ierr);

                        if ((ierr[0] != 0) && (ierr[0] != (n + 1))) {
                            result[0] = ulpinv;
                            UI.setDataText("ddrgev had error in call to dggev3\n");
                            UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                            UI.setDataText("n = " + n + "\n");
                            UI.setDataText("jtype = " + jtype + "\n");
                            UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                            UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                            UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                            UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                            info[0] = Math.abs(ierr[0]);
                        } // if ((ierr[0] != 0) && (ierr[0] != n+1))
                        else { // no error in dggev3

                            for (j = 0; j < n; j++) {

                                if ((alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
                                    result[5] = ulpinv;
                                }
                            } // for (j = 0; j < n; j++)

                            for (j = 0; j < n; j++) {

                                for (jc = 0; jc < n; jc++) {

                                    if (Q[j][jc] != QE[j][jc]) {
                                        result[5] = ulpinv;
                                    }
                                }
                            } // for (j = 0; j < n; j++)

                            // Do the test(7): Compute eigenvalues and right
                            // eigenvectors, and test them
                            dlacpy(' ', n, n, A, lda, S, lda);
                            dlacpy(' ', n, n, B, lda, T, lda);
                            dggev('N', 'V', n, S, lda, T, lda, alphr1, alphi1, beta1, Q, ldq, QE, ldqe, work, lwork,
                                  ierr);

                            if ((ierr[0] != 0) && (ierr[0] != (n + 1))) {
                                result[0] = ulpinv;
                                UI.setDataText("ddrgev had error in call to dggev4\n");
                                UI.setDataText("ierr[0] = " + ierr[0] + "\n");
                                UI.setDataText("n = " + n + "\n");
                                UI.setDataText("jtype = " + jtype + "\n");
                                UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                                UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                                UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                                UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                                info[0] = Math.abs(ierr[0]);
                            } // if ((ierr[0] != 0) && (ierr[0] != n+1))
                            else { // no error in dggev4

                                for (j = 0; j < n; j++) {

                                    if ((alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
                                        result[6] = ulpinv;
                                    }
                                } // for (j = 0; j < n; j++)

                                for (j = 0; j < n; j++) {

                                    for (jc = 0; jc < n; jc++) {

                                        if (Z[j][jc] != QE[j][jc]) {
                                            result[6] = ulpinv;
                                        }
                                    }
                                } // for (j = 0; j < n; j++)
                            } // else no error in dggev4
                        } // else no error in dggev3
                    } // else no error in dggev2
                } // else no error in dggev1

                // End of loop -- Check for result[j] > thresh
                ntestt = ntestt + 7;

                // Print out which tests fail
                for (jr = 0; jr < 7; jr++) {

                    if (result[jr] >= thresh) {

                        // If this is the first test to fail,
                        // print a header to the data file
                        if (nerrs == 0) {
                            UI.setDataText("dggev real generalized eigenvalue problem driver\n");

                            // Matrix types
                            UI.setDataText("Matrix types (see ddrgev for details):\n");
                            UI.setDataText("Special Matrices:\n");
                            UI.setDataText("J' = transposed Jordan block\n");
                            UI.setDataText("1 = (0,0)\n");
                            UI.setDataText("2 = (I,0)\n");
                            UI.setDataText("3 = (0,I)\n");
                            UI.setDataText("4 = (I,I)\n");
                            UI.setDataText("5 = (J',J')\n");
                            UI.setDataText("6 = (diag(J',I), diag(I,J'))\n");
                            UI.setDataText("Diagonal Matrices: D = diag(0,1,2,...)\n");
                            UI.setDataText("7 = (D,I)\n");
                            UI.setDataText("8 = (I,D)\n");
                            UI.setDataText("9 = (large*D, small*I)\n");
                            UI.setDataText("10 = (small*D, large*I)\n");
                            UI.setDataText("11 = ((large*I, small*D)\n");
                            UI.setDataText("12 = (small*I , large*D)\n");
                            UI.setDataText("13 = (large*D, large*I)\n");
                            UI.setDataText("14 = (small*D, small*I)\n");
                            UI.setDataText("15 = (D, reversed D)\n");
                            UI.setDataText("Matrices Rotated by Random Orthogonal Matrices U,V:\n");
                            UI.setDataText("16 = transposed Jordan Blocks\n");
                            UI.setDataText("17 = arithm. alpha & beta\n");
                            UI.setDataText("18 = clustered alpha, beta = 0,1\n");
                            UI.setDataText("19 = geometric alpha, beta = 0, 1\n");
                            UI.setDataText("20 = arithmetic alpha, beta = 0, 1\n");
                            UI.setDataText("21 = random alpha, beta = 0, 1\n");
                            UI.setDataText("Large & Small Matrices:\n");
                            UI.setDataText("22 = (large, small)\n");
                            UI.setDataText("23 = (small, large)\n");
                            UI.setDataText("24 = (small, small)\n");
                            UI.setDataText("25 = (large, large)\n");
                            UI.setDataText("26 = random O(1) matrices\n");

                            // Tests performed
                            UI.setDataText("Tests performed:\n");
                            UI.setDataText("1 = max | (b A - a B)' * L | / const\n");
                            UI.setDataText("2 = | | Vr[i]| - 1 | / ulp\n");
                            UI.setDataText("3 = max | ( b A - a B) * r | / const\n");
                            UI.setDataText("4 = | | VL[i] | - 1 | / ulp\n");
                            UI.setDataText("5 = 0 if W same no matter if r or L computed\n");
                            UI.setDataText("6 = 0 if L same no matter if L computed\n");
                            UI.setDataText("7 = 0 if r same no matter if r computed\n");
                        } // if (nerrs == 0)

                        nerrs = nerrs + 1;
                        UI.setDataText("Matrix order = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        UI.setDataText("result[" + jr + "] = " + result[jr] + "\n");
                    } // if (result[jr] >= thresh)
                } // for (jr = 0; jr < 7; jr++)
            } // for (jtype = 1; jtype <= mtypes; jtype++)
        } // for (jsize = 1; jsize <= nsizes; jsize++)

        // Summary
        if (nerrs > 0) {
            UI.setDataText(nerrs + " out of " + ntestt + " dggev tests failed to pass the threshold\n");
        } else {
            UI.setDataText("All " + ntestt + " dggev tests passed the threshold\n");
        }

        work[0] = maxwrk;

        return;
    } // ddrgev

    /**
     * This is a port of that portion of the version 3.1 LAPACK test routine DDRVSG that tests the DSYGV that computes
     * all eigenvalues and, optionally, eigenvectors of a real symmetric-definite generalized eigenproblem. Original
     * DDRVSG created by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * When ddrvsg is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified.
     * For each size ("n") and each type of matrix, one matrix A of the given type will be generated; a random
     * well- conditioned matrix B is also generated and the pair (A,B) is used to test the drivers.
     * 
     * For each pair (A,B), the following tests are performed:
     * (1) dsygv with itype = 1 and uplo = 'U': |A Z - B Z D | / (|A| |Z| n ulp)
     * (2) dysgv with itype = 1 and uplo = 'L'
     * (3) dsygv with itype = 2 and uplo = 'U' |A B Z - Z D |/ (|A| |Z| n ulp)
     * (4) dsygv with itype = 2 and uplo = 'L'
     * (5) dsygv with itype = 3 and uplo = 'U' | B A Z - Z D | / ( |A| |Z| n ulp)
     * (6) dsygv with itype = 3 and uplo = 'L'
     *
     * <p>The "sizes" are specified by an array nn(0:nsizes-1); the value of each element nn[j] specifies one size. The
     * "types" are specified by a logical array dotype(0:ntypes-1); if dotype[j] is true, then matrix type "j" will be
     * generated. This type is used for the matrix A which has half-bandwidth ka. B is generated as a well-conditioned
     * positive definite matrix with half-bandwidth kb (<= ka). Currently, the list of possible types for A is:
     * (1) The zero matrix.
     * (2) The identity matrix.
     * (3) A diagonal matrix with evenly spaced entries 1, ..., ulp and random signs. 
     *     (ulp = (first number larger than 1) - 1)
     * (4) A diagonal matrix with geometrically spaced entries 1, ..., ulp and random signs. 
     * (5) A diagonal matrix with "clustered" entries 1, ulp, ... , ulp and random signs.
     * (6) Same as (4), but multiplied by sqrt(overflow threshold)
     * (7) Same as (4), but multiplied by sqrt(underflow threshold)
     * (8) A matrix of the form U* D U, where U is orthogonal and D has evenly spaced entries 1, ..., ulp with random
     *     signs on the diagonal.
     * (9) A matrix of the form U* D U, where U is orthogonal and D has geometrically spaced entries 1, ..., ulp with
     *     random signs on the diagonal.
     * (10) A matrix of the form U* D U, where U is orthgonal and D has "clustered" entries 1, ulp, ..., ulp with random
     *      signs on the diagonal.
     * (11) Same as (8), but multiplied by sqrt(overflow threshold)
     * (12) Same as (8), but multiplied by sqrt(underflow threshold)
     * (13) Symmetric matrix, with random entries chosen from (-1,1).
     * (14) Same as (13), but multiplied by sqrt(overflow threshold).
     * (15) Same as (13), but multiplied by sqrt(underflow threshold).
     * (16) Same as (8), but with ka = 1 and kb = 1.
     * (17) Same as (8), but with ka = 2 and kb = 1.
     * (18) Same as (8), but with ka = 2 and kb = 2. 
     * (19) Same as (8), but with ka = 3 and kb = 1.
     * (20) Same as (8), but with ka = 3 and kb = 2.
     * (21) Same as (8), but with ka = 3 and kb = 3.</p>
     *
     * @param  nsizes  input int The number of sizes of matrices to use. If it is zero, ddrvsg does nothing. It must be
     *                 at least zero.
     * @param  nn      input int[] of dimension nsizes. An array containing the sizes to be used for the matrices. Zero
     *                 values will be skipped. The values must be at least zero.
     * @param  ntypes  input int The number of elements in dotype. If it is zero, ddrvsg does nothing. It must be at
     *                 least zero. If it is maxtyp+1 and nsizes is 1, then an addtional type, maxtyp+1 is defined, which
     *                 is to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and
     *                 dotype(maxtyp) is true.
     * @param  dotype  input boolean[] of dimension ntypes. If dotype[j-1] is true, then for each size in nn a matrix of
     *                 that size and of type j will be generated. If ntypes is smaller than the maximum number of types
     *                 defined by maxtyp, then types ntypes+1 through maxtyp will not be generated. If ntypes is larger
     *                 than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
     * @param  iseed   input/output int[] of dimension 4. On entry, iseed specifies the seed of the random number
     *                 generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
     *                 Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence
     *                 limited to small integers, and so should produce machine independent random numbers. The values
     *                 of iseed are changed on exit, and can be used in the next call to ddrvsg to continue the same
     *                 random number sequence.
     * @param  thresh  input double A test will count as "failed" if the "error", computed as described above, exceeds
     *                 thres. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple
     *                 of 1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double)
     *                 or the size of the matrix. It must be at least zero.
     * @param  A       input/output double[][] of dimension lda by max(nn). Used to hold the matrix whose eigenvalues
     *                 are to be computed. On exit, A contains the last matrix actually used.
     * @param  lda     input int The leading dimension of A and AB. It must be at least 1 and at least max(nn).
     * @param  B       input/output double[][] of dimension ldb by max(nn). Used to hold the symmetric positive definite
     *                 matrix for the generalized problem. On exit, B contains the last matrix actually used.
     * @param  ldb     input int The leading dimension of B and BB. It must be at least 1 and at least max(nn).
     * @param  D       input/output double[] of dimension max(nn). The eigenvalues of A. On exit, the eigevalues in D
     *                 must correspond with the matrix in A.
     * @param  Z       input/output double[][] of dimension ldz by max(nn). The matrix of eigenvectors.
     * @param  ldz     input int The leading dimension of Z. It must be at least 1 and at least max(nn).
     * @param  AB      workspace double[][] of dimension lda by max(nn).
     * @param  BB      workspace double[][] of dimension ldb by max(nn).
     * @param  AP      workspace double[] of dimension (max(nn)**2)
     * @param  BP      workspace double[] of dimension (max(nn)**2)
     * @param  work    workspace double[] of dimension nwork.
     * @param  nwork   input int The number of entries in work. This must be at least 1 + 5*n + 2*n*lg(n) + 3*n**2 where
     *                 n = max(nn[j]) and lg(n) = smallest integer k such that 2**k >= n.
     * @param  iwork   workspace int[] of dimension liwork.
     * @param  liwork  input int The number of entries in iwork. This must be at least 6*n.
     * @param  result  output double[] of dimension 70. The values computed by the tests described above.
     * @param  info    output int[] If 0, then everything ran OK.
     *                                 -1: nsizes < 0
     *                                 -2: Some nn[j] < 0
     *                                 -3: ntypes < 0
     *                                 -5: thresh < 0
     *                                 -9: lda < 1 or lda < nmax, where nmax is max(nn[j]).
     *                                 -16: ldz < 1 or ldz < nmax.
     *                                 -21: nwork too small.
     *                                 -23: liwork too small. 
     *                                 If dsygv returns an error code, the absolute value of it is returned.
     */
    private void ddrvsg(int nsizes, int[] nn, int ntypes, boolean[] dotype, int[] iseed, double thresh, double[][] A,
                        int lda, double[][] B, int ldb, double[] D, double[][] Z, int ldz, double[][] AB, double[][] BB,
                        double[] AP, double[] BP, double[] work, int nwork, int[] iwork, int liwork, double[] result,
                        int[] info) {

        // The number of types defined
        int maxtyp = 21;

        // The number of tests that have been run on this matrix
        int ntest;

        // The total number of tests for this call.
        int ntestt;

        // Largest value in nn
        int nmax;

        // The number of matrices generated so far.
        int nmats;

        // The number of tests which have exceeded thresh so far (computed by
        // dlafts).
        int[] nerrs = new int[1];

        // Values to be passed to the matrix conditioners
        int imode;
        double cond;

        // Norm of A; passed to the matrix generators.
        double anorm;

        // Overflow threshold
        double[] ovfl = new double[1];

        // Underflow threshold
        double[] unfl = new double[1];

        // Finest relative precision
        double ulp;

        // Inverse of finest relative precision
        double ulpinv;

        // Square root of ovfl
        double rtovfl;

        // Square root of unfl
        double rtunfl;

        // The folowing three arrays decode jtype:
        // The general type (1-10) for type "j"
        int[] ktype = new int[] { 1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9, 9, 9, 9 };

        // The mode value to be passed to the matrix generator for type "j".
        int[] kmode = new int[] { 0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 4, 4, 4, 4, 4 };

        // The order of magnitude (O(1), O(overflow^(1/2)), O(underflow^(1/2))
        int[] kmagn = new int[] { 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 1, 1, 1, 1, 1 };
        boolean badnn;
        int i;
        int[] iseed2 = new int[4];
        double aninv;
        int jsize;
        int n;
        int mtypes;
        int jtype;
        int ka9;
        int kb9;
        int[] ioldsd = new int[4];
        int itype = 1;
        int[] iinfo = new int[1];
        int ka;
        int kb = 0;
        int jcol;
        int il;
        int iu;
        int itemp;
        int ibtype;
        int ibuplo;
        char uplo;
        int j;
        double[] work2;
        double[] work3;
        int[] idumma = new int[1];
        double[] resultBuf = new double[1];
        String dsgString = new String("DSG");

        // Check for errors
        ntestt = 0;
        info[0] = 0;

        badnn = false;
        nmax = 0;

        for (j = 0; j < nsizes; j++) {
            nmax = Math.max(nmax, nn[j]);

            if (nn[j] < 0) {
                badnn = true;
            }
        } // for (j = 0; j < nsizes; j++)

        if (nsizes < 0) {
            info[0] = -1;
        } else if (badnn) {
            info[0] = -2;
        } else if (ntypes < 0) {
            info[0] = -3;
        } else if ((lda <= 1) || (lda < nmax)) {
            info[0] = -9;
        } else if ((ldz <= 1) || (ldz < nmax)) {
            info[0] = -16;
        } else if ((2 * Math.max(nmax, 3) * Math.max(nmax, 3)) > nwork) {
            info[0] = -21;
        } else if ((2 * Math.max(nmax, 3) * Math.max(nmax, 3)) > liwork) {
            info[0] = -23;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error ddrvsg had info = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((nsizes == 0) || (ntypes == 0)) {
            return;
        }

        unfl[0] = dlamch('S');
        ovfl[0] = dlamch('O');
        dlabad(unfl, ovfl);
        ulp = dlamch('E') * dlamch('B');
        ulpinv = 1.0 / ulp;
        rtunfl = Math.sqrt(unfl[0]);
        rtovfl = Math.sqrt(ovfl[0]);

        for (i = 0; i < 4; i++) {
            iseed2[i] = iseed[i];
        }

        // Loop over sizes, types
        nerrs[0] = 0;
        nmats = 0;

        for (jsize = 1; jsize <= nsizes; jsize++) {
            n = nn[jsize - 1];
            work2 = new double[n];
            work3 = new double[n];
            aninv = 1.0 / Math.max(1, n);

            if (nsizes != 1) {
                mtypes = Math.min(maxtyp, ntypes);
            } else {
                mtypes = Math.min(maxtyp + 1, ntypes);
            }

            ka9 = 0;
            kb9 = 0;

            for (jtype = 1; jtype <= mtypes; jtype++) {

                if (!dotype[jtype - 1]) {
                    continue;
                }

                nmats = nmats + 1;
                ntest = 0;

                for (j = 0; j < 4; j++) {
                    ioldsd[j] = iseed[j];
                }

                // Compute "A"

                // Control parameters:

                // KMAGN             KMODE               KTYPE
                // = 1 O(1)              clustered 1         zero
                // = 2 large             clustered 2         identity
                // = 3 small             exponential         (none)
                // = 4                   arithmetic          diagonal, w/ eigenvalues
                // = 5                   random log          hermitian, w/ eigenvalues
                // = 6                   random              (none)
                // = 7                                       random diagonal
                // = 8                                       random hermitian
                // = 9                                       banded, w/ eigenvalues

                if (mtypes <= maxtyp) {
                    itype = ktype[jtype - 1];
                    imode = kmode[jtype - 1];

                    // Compute norm
                    switch (kmagn[jtype - 1]) {

                        case 1:
                            anorm = 1.0;
                            break;

                        case 2:
                            anorm = (rtovfl * ulp) * aninv;
                            break;

                        case 3:
                            anorm = rtunfl * n * ulpinv;
                            break;

                        default: // Should never happen
                            anorm = 1.0;
                    } // switch(kmagn[jtype-1]

                    iinfo[0] = 0;
                    cond = ulpinv;

                    // Special Matrices -- Identity & Jordan block

                    if (itype == 1) {

                        // Zero
                        ka = 0;
                        kb = 0;
                        dlaset('F', lda, n, 0.0, 0.0, A, lda);
                    } // if (itype == 1)
                    else if (itype == 2) {
                        // Identity

                        ka = 0;
                        kb = 0;
                        dlaset('F', lda, n, 0.0, 0.0, A, lda);

                        for (jcol = 0; jcol < n; jcol++) {
                            A[jcol][jcol] = anorm;
                        }
                    } // else if (itype == 2)
                    else if (itype == 4) {
                        // Diagonal Matrix, [Eigen]values Specified

                        ka = 0;
                        kb = 0;
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                        }
                    } // else if (itype == 4)
                    else if (itype == 5) {
                        // Symmetric, eigenvalues specified

                        ka = Math.max(0, n - 1);
                        kb = ka;
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                        }
                    } // else if (itype == 5)
                    else if (itype == 7) {
                        // Diagonal, random eigenvalues

                        ka = 0;
                        kb = 0;
                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                            work[i + (2 * n)] = work3[i];
                        }
                    } // else if (itype == 7)
                    else if (itype == 8) {
                        // Symmetric, random eigenvalues

                        ka = Math.max(0, n - 1);
                        kb = ka;
                        dlatmr(n, n, 'S', iseed, 'H', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                            work[i + (2 * n)] = work3[i];
                        }
                    } // else if (itype == 8)
                    else if (itype == 9) {
                        // Symmetric banded, eigenvalues specified

                        // The following values are used for the half-bandwidths.

                        // ka = 1  kb = 1
                        // ka = 2  kb = 1
                        // ka = 2  kb = 2
                        // ka = 3  kb = 1
                        // ka = 3  kb = 2
                        // ka = 3  kb = 3

                        kb9 = kb9 + 1;

                        if (kb9 > ka9) {
                            ka9 = ka9 + 1;
                            kb9 = 1;
                        } // if (kb9 > ka9)

                        ka = Math.max(0, Math.min(n - 1, ka9));
                        kb = Math.max(0, Math.min(n - 1, kb9));
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, ka, ka, 'N', A, lda, work2, iinfo);

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                        }
                    } // else if (itype == 9)
                    else {
                        iinfo[0] = 1;
                    }

                    if (iinfo[0] != 0) {
                        UI.setDataText("ddrvsg generator returned iinfo = " + iinfo[0] + " n = " + n + " jtype = " +
                                       jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + " ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        return;
                    } // if (iinfo[0] != 0)
                } // if (mtypes <= maxtyp)

                if (n <= 1) {
                    il = 1;
                    iu = n;
                } // if (n <= 1)
                else { // n > 1
                    il = (int) (1 + ((n - 1) * dlarnd(1, iseed2)));
                    iu = (int) (1 + ((n - 1) * dlarnd(1, iseed2)));

                    if (il > iu) {
                        itemp = il;
                        il = iu;
                        iu = itemp;
                    } // if (il > iu)
                } // else n > 1

                // Call dsygv, do tests

                // Loop over three generalized problems
                // ibtype = 1: A*x = (lambda)*B*x
                // ibtype = 2: A*B*x = (lambda)*x
                // ibtype = 3: B*A*x = (lambda)*x

                for (ibtype = 1; ibtype <= 3; ibtype++) {

                    // Loop over the setting uplo
                    for (ibuplo = 1; ibuplo <= 2; ibuplo++) {

                        if (ibuplo == 1) {
                            uplo = 'U';
                        } else {
                            uplo = 'L';
                        }

                        // Generate random well-conditioned positive definite matrix B,
                        // of bandwidth not greater than that of A.

                        dlatms(n, n, 'U', iseed, 'P', work, 5, 10.0, 1.0, kb, kb, uplo, B, ldb, work2, iinfo);

                        if (iinfo[0] != 0) {
                            UI.setDataText("On call to create B ddrvsg generator returned iinfo = " + iinfo[0] +
                                           "ibtype = " + ibtype + " n = " + n + " jtype = " + jtype + "\n");
                            UI.setDataText("ioldsd[0] = " + ioldsd[0] + " ioldsd[1] = " + ioldsd[1] + "\n");
                            UI.setDataText("ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = " + ioldsd[3] + "\n");
                            info[0] = Math.abs(iinfo[0]);

                            return;
                        }

                        for (i = 0; i < n; i++) {
                            work[i + n] = work2[i];
                        }

                        // Test dsygv

                        ntest = ntest + 1;

                        dlacpy(' ', n, n, A, lda, Z, ldz);
                        dlacpy(uplo, n, n, B, ldb, BB, ldb);

                        dsygv(ibtype, 'V', uplo, n, Z, ldz, BB, ldb, D, work, nwork, iinfo);

                        if (iinfo[0] != 0) {
                            UI.setDataText("dsygv V uplo = " + uplo + " iinfo[0] = " + iinfo[0] + " n = " + n + "\n");
                            UI.setDataText("jtype = " + jtype + " ioldsd[0] = " + ioldsd[0] + "\n");
                            UI.setDataText("ioldsd[1] = " + ioldsd[1] + " ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = " +
                                           ioldsd[3] + "\n");
                            info[0] = Math.abs(iinfo[0]);

                            if (iinfo[0] < 0) {
                                return;
                            } else {
                                result[ntest - 1] = ulpinv;
                            }
                        } // if (iinfo[0] != 0)
                        else {

                            // Do Test
                            dsgt01(ibtype, uplo, n, n, A, lda, B, ldb, Z, ldz, D, work, resultBuf);
                            result[ntest - 1] = resultBuf[0];
                        }
                    } // for (ibuplo = 1; ibuplo <= 2; ibuplo++)
                } // for (ibtype = 1; ibtype <= 3; ibtype++)

                // End of loop - Check for result[j] > thresh
                ntestt = ntestt + ntest;
                dlafts(dsgString, n, n, jtype, ntest, result, ioldsd, thresh, nerrs);
            } // for (jtype = 1; jtype <= mtypes; jtype++)
        } // for (jsize = 1; jsize <= nsizes; jsize++)

        // Summary
        if (nerrs[0] > 0) {
            UI.setDataText("dsygv: " + nerrs[0] + " out of " + ntestt + " tests failed to pass the threshold\n");
        } else {
            UI.setDataText("All " + ntestt + " tests for dsygv passed the threshold\n");
        }
    } // ddrvsg

    /**
     * This is a port of the part of version 3.1 LAPACK test routine DDRVST used to test dsyev. Original DDRVST created
     * by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * ddrvst checks the symmetric eigenvalue problem driver dsyev. dsyev computes all eigenvalues and, optionally,
     * eigenvectors of a real symmetric matrix.
     *
     * <p>When ddrvst is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For
     * each size ("n") and each type of matrix, one matrix will be generated and used to test the dsyev driver. For each
     * matrix, the following tests will be performed:
     * (1) | A - Z D Z' | / ( |A| n ulp )
     * (2) | I - Z Z' | / ( n ulp ) 
     * (3) | D1 - D2 | / ( |D1| ulp )
     * where Z is the matrix of eigenvectors returned when the eigenvector option is given and D1 and D2 are the eigenvalues
     * returned with and without the eigenvector option.</p>
     *
     * <p>The "sizes" are specified by an array nn(0:nsizes-1); the value of each element nn[j] specifies one size. The
     * "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j] is true, then matrix type "j" will be
     * generated. Currently, the list of possible types is:
     * (1) The zero matrix.
     * (2) The identity matrix.
     * (3) A diagonal matrix with evenly spaced eigenvalues 1, ..., ulp and random signs.
     *     (ulp = (first number larger than 1) - 1)
     * (4) A diagonal matrix with geometrically spaced eigenvalues 1, ..., ulp and random signs.
     * (5) A diagonal matrix with "clustered" eigenvalues 1, ulp, ..., ulp and random signs.
     * (6) Same as (4), but multiplied by sqrt(overflow threshold)
     * (7) Same as (4), but multiplied by sqrt(underflow threshold)
     * (8) A matrix of the form U' D U, where U is orthogonal and D has evenly spaced entries 1, ..., ulp with random
     *     signs on the diagonal.
     * (9) A matrix of the form U' D U, where U is orthogonal and D has geometrically spaced entries 1, ..., ulp
     *     with random signs on the diagonal.
     * (10) A matrix of the form U' D U, where U is orthogonal and D has "clustered" entries 1, ulp, ..., ulp
     *      with random signs on the diagonal.
     * (11) Same as (8), but multiplied by sqrt( overflow threshold)
     * (12) Same as (8), but multiplied by sqrt( underflow threshold)
     * (13) Symmetric matrix with random entries chosen from (-1,1).
     * (14) Same as (13), but multiplied by sqrt( overflow threshold)
     * (15) Same as (13), but multiplied by sqrt(underflow threshold)
     * (16) A band matrix with half bandwidth randomly chosen between 0 and n-1, with evenly spaced
     *      eigenvalues 1, ..., ulp with random signs.
     * (17) Same as (16), but multiplied by sqrt(overflow threshold)
     * (18) Same as (16), but multiplied by sqrt(underflow threshold)</p>
     *
     * <p>The tests performed are:
     * (1) | A - U S U' | / ( |A| n ulp )     dsyev('L', 'V', ... )
     * (2) | I - U U' | / ( n ulp )           dsyev('L', 'V', ... )
     * (3) |D(with Z) - D(w/o Z)| / (|D| ulp) dsyev('L', 'N', ... )
     * Tests 1 through 3 are repeated with uplo = 'U'</p>
     *
     * @param  nsizes  (input) int The number of sizes of matrices to use. If it is zero, ddrvst does nothing. It must
     *                 be at least zero.
     * @param  nn      (input) int[] of dimension (nsizes) An array containing the sizes to be used for the matrices.
     *                 Zero values will be skipped. The values must be at least zero.
     * @param  ntypes  (input) int The number of elements in dotype. If it is zero, ddrvst does nothing. It must be at
     *                 least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined,
     *                 which is to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and
     *                 dotype[maxtyp] is true.
     * @param  dotype  (input) boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix
     *                 of that size and of type j will be generated. If ntypes is smaller than the maximum number of
     *                 types defined (parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If
     *                 ntypes is larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
     * @param  iseed   (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
     *                 generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
     *                 Also, iseed[3] must be odd. The random number generator uses an linear congruential sequence
     *                 limited to small integers, and so should produce machine independent random numbers. The values
     *                 of iseed are changed on exit, and can be used in the next call to ddrvst to continue the same
     *                 random number sequence.
     * @param  thresh  (input) double A test will count as "failed" if the "error", computed as described above, exceeds
     *                 thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple
     *                 of 1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double)
     *                 or the size of the matrix. It must be at least zero.
     * @param  A       (input/workspace/output) double[][] of dimension (lda, max(nn)) Used to hold the matrix whose
     *                 eigenvalues are to be computed. On exit, A contains the last matrix actually used.
     * @param  lda     (input) int The leading dimension of A. It must be at least 1 and at least max(nn).
     * @param  D1      (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr
     *                 simultaneously with Z. On exit, the eigenvalues in D1 correspond with the matrix in A.
     * @param  D2      (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr if
     *                 Z is not computed. On exit, the eigenvalues in D2 correspond with the matrix in A.
     * @param  D3      (workspace/output) double[] of dimension max(nn)) The eigenvalues of A, as computed by dsterf. On
     *                 exit, the eigenvalues in D3 correspond with the matrix in A.
     * @param  D4      double[] of dimension (max(nn))
     * @param  eveigs  double[] of dimension (max(nn)) The eigenvalues as computed by dstev('N', ... )
     * @param  WA1     double[]
     * @param  WA2     double[]
     * @param  WA3     double[]
     * @param  U       (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix computed by
     *                 dsytrd + dorgtr.
     * @param  ldu     (input) int The leading dimension of U, Z and V. It must be at least 1 and at least max(nn).
     * @param  V       (workspace/output) double[][] of dimension (ldu, max(nn)) The Householder vectors computed by
     *                 dsytrd in reducing A to tridiagonal form.
     * @param  tau     (workspace/output) double[] of dimension max(nn) The Householder factors computed by dsytrd in
     *                 reducing A to tridiagonal form.
     * @param  Z       (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix of eigenvectors
     *                 computed by dsteqr.
     * @param  work    (workspace/output) double[] of dimension (lwork)
     * @param  lwork   (input) int The number of entries in work. This must be at least 1 + 4*nmax + 2 * nmax * lg nmax
     *                 + 4 * nmax**2 where nmax = max(nn[j], 2) and lg = log base 2.
     * @param  iwork   workspace int[] of dim (6 + 6*nmax + 5* nmax * lg nmax) where nmax = max(nn[j], 2) and
     *                 lg = log base 2.
     * @param  liwork  (input) int length of iwork
     * @param  result  (output) double[] of dimension (105) The values computed by the tests described above. The values
     *                 are currently limited to 1/ulp, to avoid overflow.
     * @param  info    (output) int[] If 0, then everything ran OK.
     *                                   -1: nsizes < 0 
     *                                   -2: Some nn[j] < 0 
     *                                   -3: ntypes < 0
     *                                   -5: thresh < 0 
     *                                   -9: lda < 1 or lda < nmax, where nmax is max(nn[j])
     *                                   -16: ldu < 1 or ldu < nmax
     *                                   -21: lwork too small.
     * If dlatmr, dlatms, dsytrd, dorgtr, dsteqr, dsterf, or dormtr returns an error code,
     * the absolute value of it is returned.
     */
    private void ddrvst(int nsizes, int[] nn, int ntypes, boolean[] dotype, int[] iseed, double thresh, double[][] A,
                        int lda, double[] D1, double[] D2, double[] D3, double[] D4, double[] eveigs, double[] WA1,
                        double[] WA2, double[] WA3, double[][] U, int ldu, double[][] V, double[] tau, double[][] Z,
                        double[] work, int lwork, int[] iwork, int liwork, double[] result, int[] info) {
        int maxtyp = 18; // The number of types defined
        boolean badnn;
        char uplo;
        int i;
        int idiag;
        int ihbw;
        int[] iinfo = new int[1];
        int iL;
        int imode; // Value to be passed to the matrix generators
        int indx;
        int irow;
        int itemp;
        int itype;
        int iu;
        int iuplo;
        int j;
        int j1;
        int j2;
        int jcol;
        int jsize;
        int jtype;
        int kd;
        int lgn;
        int liwedc;
        int lwedc;
        int m;
        int m2;
        int m3;
        int mtypes;
        int n;
        int[] nerrs = new int[1]; // The number of tests which have exceeded thresh
                                  // so far (computed by dlafts).
        int nmats; // The number of matrices generated so far.
        int nmax; // Largest value in nn.
        int ntest; // The number of tests performed, or which can
                   // be performed so far, for the current matrix
        int ntestt; // The total number of tests performed so far.
        double abstol;
        double aninv;
        double anorm; // Norm of A; passed to the matrix generators.
        double cond; // Value to be passed to the matrix generators.
        double[] ovfl = new double[1]; // Overflow threshold
        double rtovfl; // Square root of overflow threshold
        double rtunfl; // Square root of underflow threshold
        double temp1;
        double temp2;
        double temp3;
        double ulp; // Finest relative precision
        double ulpinv; // Inverse of finest relative precision
        double[] unfl = new double[1]; // Underflow threshold
        double vL;
        double vu;
        int[] idumma = new int[1];
        int[] ioldsd = new int[4];
        int[] iseed2 = new int[4];
        int[] iseed3 = new int[4];

        // The order of magnitude (O(1), O(overflow^(1/2)), O(underflow^(1/2))
        int[] kmagn = new int[] { 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 2, 3 };

        // The mode value to be passed to the matrix generator for type "j".
        int[] kmode = new int[] { 0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 4, 4 };

        // The general type (1-10) for type "j".
        int[] ktype = new int[] { 1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9 };
        double[] work2;
        double[] work3;
        double[] res = new double[2];
        String typeString;

        vL = 0.0;
        vu = 0.0;

        // Check for errors
        ntestt = 0;
        info[0] = 0;

        badnn = false;
        nmax = 1;

        for (j = 0; j < nsizes; j++) {
            nmax = Math.max(nmax, nn[j]);

            if (nn[j] < 0) {
                badnn = true;
            }
        } // for (j = 0; j < nsizes; j++)

        work2 = new double[3 * nmax];
        work3 = new double[nmax];

        if (nsizes < 0) {
            info[0] = -1;
        } else if (badnn) {
            info[0] = -2;
        } else if (ntypes < 0) {
            info[0] = -3;
        } else if (lda < nmax) {
            info[0] = -9;
        } else if (ldu < nmax) {
            info[0] = -16;
        } else if ((2 * Math.max(2, nmax) * Math.max(2, nmax)) > lwork) {
            info[0] = -21;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error ddrvst had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((nsizes == 0) || (ntypes == 0)) {
            return;
        }

        unfl[0] = dlamch('S');
        ovfl[0] = dlamch('O');
        dlabad(unfl, ovfl);
        ulp = dlamch('E') * dlamch('B');
        ulpinv = 1.0 / ulp;
        rtunfl = Math.sqrt(unfl[0]);
        rtovfl = Math.sqrt(ovfl[0]);

        // Loop over sizes, types
        for (i = 0; i < 4; i++) {
            iseed[2] = iseed[i];
            iseed[3] = iseed[i];
        }

        nerrs[0] = 0;
        nmats = 0;

        for (jsize = 1; j <= nsizes; jsize++) {
            n = nn[jsize - 1];

            if (n > 0) {
                lgn = (int) (Math.log((double) n) / Math.log(2.0));

                if (Math.pow(2.0, lgn) < n) {
                    lgn = lgn + 1;
                }

                if (Math.pow(2.0, lgn) < n) {
                    lgn = lgn + 1;
                }

                lwedc = 1 + (4 * n) + (2 * n * lgn) + (4 * n * n);
                liwedc = 3 + 5 * n;
            } // if (n > 0)
            else { // n == 0
                lwedc = 9;
                liwedc = 8;
            } // else n == 0

            aninv = 1.0 / (double) Math.max(1, n);

            if (nsizes != 1) {
                mtypes = Math.min(maxtyp, ntypes);
            } else {
                mtypes = Math.min(maxtyp + 1, ntypes);
            }

            for (jtype = 1; jtype <= mtypes; jtype++) {

                if (!dotype[jtype - 1]) {
                    continue;
                }

                nmats = nmats + 1;
                ntest = 0;

                for (j = 0; j < 4; j++) {
                    ioldsd[j] = iseed[j];
                }

                // Compute "A"
                // Control parameters:
                /*         kmagn  kmode        ktype
                 *    = 1  O(1)   clustered 1  zero   
                 *    = 2  large  clustered 2  identity   
                 *    = 3  small  exponential (none)
                 *    = 4         arithmetic   diagonal, (w/ eigenvalues)   
                 *    = 5         random log   symmetric, w/ eigenvalues   
                 *    = 6         random       (none)   
                 *    = 7                      random diagonal   
                 *    = 8                      random symmetric   
                 *    = 9                      band symmetric, w/ eigenvalues
                 */

                if (mtypes <= maxtyp) {
                    itype = ktype[jtype - 1];
                    imode = kmode[jtype - 1];
                    
                    // Compute norm

                    if (kmagn[jtype - 1] == 1) {
                        anorm = 1.0;
                    } else if (kmagn[jtype - 1] == 2) {
                        anorm = (rtovfl * ulp) * aninv;
                    } else {
                        anorm = rtunfl * n * ulpinv;
                    }

                    dlaset('F', lda, n, 0.0, 0.0, A, lda);
                    iinfo[0] = 0;
                    cond = ulpinv;

                    // Special Matrices -- Identity & Jordan block

                    // Zero
                    if (itype == 1) {
                        iinfo[0] = 0;
                    } else if (itype == 2) {

                        // Identity
                        for (jcol = 0; jcol < n; jcol++) {
                            A[jcol][jcol] = anorm;
                        }
                    } else if (itype == 4) {

                        // Diagonal Matrix, [Eigen]values, Specified
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);
                    } else if (itype == 5) {

                        // Symmetric, eigenvalues specified
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
                    } else if (itype == 7) {

                        // Diagonal, random eigenvalues
                        idumma[0] = 1;
                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);
                    } // else if (itype == 7)
                    else if (itype == 8) {

                        // Symmetric, random eigenvalues
                        idumma[0] = 1;
                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
                               idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);
                    } // else if (itype == 8)
                    else if (itype == 9) {

                        // Symmetric banded, eigenvalues specified
                        ihbw = (int) ((n - 1) * dlarnd(1, iseed3));
                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, ihbw, ihbw, 'Z', U, ldu, work2, iinfo);

                        // Store as dense matrix for most routines
                        dlaset('F', lda, n, 0.0, 0.0, A, lda);

                        for (idiag = -ihbw; idiag <= ihbw; idiag++) {
                            irow = ihbw - idiag + 1;
                            j1 = Math.max(1, idiag + 1);
                            j2 = Math.min(n, n + idiag);

                            for (j = j1; j <= j2; j++) {
                                i = j - idiag;
                                A[i - 1][j - 1] = U[irow - 1][j - 1];
                            }
                        } // for (idiag = -ihbw; idiag <= ihbw; idiag++)
                    } // else if (itype == 9)
                    else {
                        iinfo[0] = 1;
                    } // else

                    if (iinfo[0] != 0) {
                        UI.setDataText("Generator iinfo[0] = " + iinfo[0] + "\n");
                        UI.setDataText("n = " + n + "\n");
                        UI.setDataText("jtype = " + jtype + "\n");
                        UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                        UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                        UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                        UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                        info[0] = Math.abs(iinfo[0]);

                        return;
                    } // if (iinfo[0] != 0)

                } // if (mtypes <= maxtyp)

                abstol = unfl[0] + unfl[0];

                if (n <= 1) {
                    iL = 1;
                    iu = n;
                } else { // n > 1
                    iL = 1 + ((n - 1) * (int) (dlarnd(1, iseed2)));
                    iu = 1 + ((n - 1) * (int) (dlarnd(1, iseed2)));

                    if (iL > iu) {
                        itemp = iL;
                        iL = iu;
                        iu = itemp;
                    }
                } // else n > 1

                // Test storing upper or lower triangular part of matrix.
                for (iuplo = 0; iuplo <= 1; iuplo++) {

                    if (iuplo == 0) {
                        uplo = 'L';
                        ntest = 1;
                    } else {
                        uplo = 'U';
                        ntest = 4;
                    }

loop1:               {
                        dlacpy(' ', n, n, A, lda, V, ldu);
                        dsyev('V', uplo, n, A, ldu, D1, work, lwork, iinfo);

                        if (iinfo[0] != 0) {
                            UI.setDataText("dsyev(V, " + uplo + " ) iinfo[0] = " + iinfo[0] + "\n");
                            UI.setDataText("n = " + n + "\n");
                            UI.setDataText("jtype = " + jtype + "\n");
                            UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                            UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                            UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                            UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                            info[0] = Math.abs(iinfo[0]);

                            if (iinfo[0] < 0) {
                                return;
                            } else {
                                result[ntest - 1] = ulpinv;
                                result[ntest] = ulpinv;
                                result[ntest + 1] = ulpinv;

                                break loop1;
                            }
                        } // if (iinfo[0] != 0)

                        // Do tests 1 and 2 or 4 and 5
                        dsyt21(1, uplo, n, 0, V, ldu, D1, D2, A, ldu, Z, ldu, tau, work, res);
                        result[ntest - 1] = res[0];
                        result[ntest] = res[1];

                        dlacpy(' ', n, n, V, ldu, A, lda);

                        ntest = ntest + 2;
                        dsyev('N', uplo, n, A, ldu, D3, work, lwork, iinfo);

                        if (iinfo[0] != 0) {
                            UI.setDataText("dsyev(N, " + uplo + " ) iinfo[0] = " + iinfo[0] + "\n");
                            UI.setDataText("n = " + n + "\n");
                            UI.setDataText("jtype = " + jtype + "\n");
                            UI.setDataText("ioldsd[0] = " + ioldsd[0] + "\n");
                            UI.setDataText("ioldsd[1] = " + ioldsd[1] + "\n");
                            UI.setDataText("ioldsd[2] = " + ioldsd[2] + "\n");
                            UI.setDataText("ioldsd[3] = " + ioldsd[3] + "\n");
                            info[0] = Math.abs(iinfo[0]);

                            if (iinfo[0] < 0) {
                                return;
                            } else {
                                result[ntest - 1] = ulpinv;

                                break loop1;
                            }
                        } // if (iinfo[0] != 0)

                        // Do test 3 or 6
                        temp1 = 0.0;
                        temp2 = 0.0;

                        for (j = 0; j < n; j++) {
                            temp1 = Math.max(temp1, Math.abs(D1[j]));
                            temp1 = Math.max(temp1, Math.abs(D3[j]));
                            temp2 = Math.max(temp2, Math.abs(D1[j] - D3[j]));
                        } // for (j = 0; j < n; j++)

                        result[ntest - 1] = temp2 / Math.max(unfl[0], ulp * Math.max(temp1, temp2));
                    } // loop1
                } // for (iuplo = 0; iuplo <= 1; iuplo++)

                // End of Loop -- Check for result[j] > thresh
                ntestt = ntestt + ntest;
                typeString = new String("DST");
                dlafts(typeString, n, n, jtype, ntest, result, ioldsd, thresh, nerrs);
            } // for (jtype = 1; jtype <= mtypes; jtype++)
        } // for (jsize = 1; j <= nsizes; jsize++)

        // Summary
        if (nerrs[0] > 0) {
            UI.setDataText("ddrvst " + nerrs[0] + " out of " + ntestt + " tests failed to pass the threshold\n");
        } else {
            UI.setDataText("All " + ntestt + " tests for ddrvst passed the threshold\n");
        }

        return;

    } // ddrvst

    /**
     * This is a port of the 2/8/89 Blas routine Original version written by: Jack Dongarra, Argonne National Laboratory
     * Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms
     * Group Ltd. dgemm performs one of the matrix-matrix operations C = alpha*op(A)*op(B) + beta*C, where op(X) is one
     * of op(X) = X or op(X) = X', alpha and beta are scalars, and A, B, and C are matrices, with op(A) an m by k
     * matrix, op(B) a k by n matrix, and C an m by n matrix.
     *
     * @param  transa  input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication
     *                 as follows:' = 'N' or 'n', op(A) = A. = 'T' or 't', op(A) = A'. = 'C' or 'c', op(A) = A'.
     * @param  transb  input char On entry, transb specifies the form of op(B) to be used in the matrix multiplication
     *                 as follows: = 'N' or 'n', op(B) = B. = 'T' or 't', op(B) = B'. = 'C' or 'c', op(B) = B'.
     * @param  m       input int On entry, m specifies the number of rows of the matrix op(A) and of the matrix C. m
     *                 must be at least zero.
     * @param  n       input int On entry, n specifies the number of columns of the matrix op(B) and the number of
     *                 columns of the matrix C. n must be at least zero.
     * @param  k       input int On entry, k specifies the number of columns of the matrix op(A) and the number of rows
     *                 of the matrix op(B). k must be at least zero.
     * @param  alpha   input double specified scalar
     * @param  A       input double[][] dimension lda by ka, where ka is k when transa = 'N' or 'n', and is m otherwise.
     *                 Before entry with transa = 'N' or 'n', the leading m by k part of the array A must contain the
     *                 matrix A, otherwise the leading k by m part of the array A must contain the matrix A
     * @param  lda     input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                 program. When transa = 'N' or 'n' then lda must be at least max(1,m), otherwise lda must be at
     *                 least max(1,k)
     * @param  B       input double[][] dimension ldb by kb, where kb is n when transb = 'N' or 'n', and is k otherwise.
     *                 Before entry with transb = 'N' or 'n', the leading k by n part of the array B must contain the
     *                 matrix B, otherwise the leading n by k part of the array B must contain the matrix B
     * @param  ldb     input int On entry, ldb specifies the first dimension of B as declared in the calling (sub)
     *                 program. When transb = 'N' or 'n' then ldb must be at least max(1,k), otherwise ldb must be at
     *                 least max(1,n).
     * @param  beta    input double specified scalar When beta is supplied as zero, then C need not be set on input.
     * @param  C       input/output double[][] dimension ldc by n. Before entry, the leading m by n part of the array C
     *                 must contain the matrix C, except when beta is zero, in which case C need not be set on entry. On
     *                 exit, the array C is overwritten by the m by n matrix (alpha*op(A)*op(B) + beta*C).
     * @param  ldc     input int On entry, ldc specifies the first dimension of C as declared in the calling (sub)
     *                 program. ldc must be at least max(1,m).
     */
    private void dgemm(char transa, char transb, int m, int n, int k, double alpha, double[][] A, int lda, double[][] B,
                       int ldb, double beta, double[][] C, int ldc) {
        boolean nota;
        boolean notb;
        int i;
        int info;
        int j;
        int L;
        int nrowa;
        int nrowb;
        double temp;

        // Set nota and notb as true if A and B respectively are not transposed
        // and set nrowa and nrowb as the number of rows of A
        // and the number of rows of B respectively.

        if ((transa == 'N') || (transa == 'n')) {
            nota = true;
        } else {
            nota = false;
        }

        if ((transb == 'N') || (transb == 'n')) {
            notb = true;
        } else {
            notb = false;
        }

        if (nota) {
            nrowa = m;
        } else {
            nrowa = k;
        }

        if (notb) {
            nrowb = k;
        } else {
            nrowb = n;
        }

        // Test the input parameters
        info = 0;

        if ((!nota) && (transa != 'C') && (transa != 'c') && (transa != 'T') && (transa != 't')) {
            info = 1;
        } else if ((!notb) && (transb != 'C') && (transb != 'c') && (transb != 'T') && (transb != 't')) {
            info = 2;
        } else if (m < 0) {
            info = 3;
        } else if (n < 0) {
            info = 4;
        } else if (k < 0) {
            info = 5;
        } else if (lda < Math.max(1, nrowa)) {
            info = 8;
        } else if (ldb < Math.max(1, nrowb)) {
            info = 10;
        } else if (ldc < Math.max(1, m)) {
            info = 13;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dgemm has info = " + info);

            return;
        } // if (info != 0)

        // Quick return if possible
        if ((m == 0) || (n == 0) || (((alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
            return;
        }

        if (alpha == 0.0) {

            if (beta == 0.0) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        C[i][j] = 0.0;
                    }
                }
            } // if (beta == 0.0)
            else { // beta != 0.0

                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        C[i][j] = beta * C[i][j];
                    }
                }
            } // else beta != 0.0

            return;
        } // if (alpha == 0.0)

        if (notb) {

            if (nota) {

                // Form C = alpha*A*B + beta*C.
                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if (B[L][j] != 0.0) {
                            temp = alpha * B[L][j];

                            for (i = 0; i < m; i++) {
                                C[i][j] = C[i][j] + (temp * A[i][L]);
                            }
                        } // if (B[L][j] != 0.0)
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // if (nota)
            else { // !nota

                // Form C = alpha*A'*B + beta*C
                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        temp = 0.0;

                        for (L = 0; L < k; L++) {
                            temp = temp + (A[L][i] * B[L][j]);
                        }

                        if (beta == 0.0) {
                            C[i][j] = alpha * temp;
                        } else {
                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
                        }
                    } // for (i = 0; i < m; i++)
                } // for (j = 0; j < n; j++)
            } // else !nota
        } // if (notb)
        else { // !notb

            if (nota) {

                // Form C = alpha*A*B' + beta*C
                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if (B[j][L] != 0.0) {
                            temp = alpha * B[j][L];

                            for (i = 0; i < m; i++) {
                                C[i][j] = C[i][j] + (temp * A[i][L]);
                            }
                        } // if (B[j][L] != 0.0)
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // if (nota)
            else { // !nota

                // Form C = alpha*A'*B' + beta*C
                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        temp = 0.0;

                        for (L = 0; L < k; L++) {
                            temp = temp + (A[L][i] * B[j][L]);
                        }

                        if (beta == 0.0) {
                            C[i][j] = alpha * temp;
                        } else {
                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
                        }
                    } // for (i = 0; i < m; i++)
                } // for (j = 0; j < n; j++)
            } // else !nota
        } // else !notb

        return;
    } // dgemm

    /**
     * Routine ported from 10/22/86 blas dgemv subroutine Original version written by: Jack Dongarra, Argonne National
     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
     * Labs. dgemv performs one of the matrix-vector operations y = alpha*A*x + beta*y, or y = alpha*A'*x + beta*y,
     * where alpha and beta are scalars, x and y are vectors, and A is an m by n matrix
     *
     * @param  trans  input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' y =
     *                alpha*A*x + beta*y = 'T' or 't' y = alpha*A'*x + beta*y = 'C' or 'c' y = alpha*A'*x + beta*y
     * @param  m      input int On entry, m specifies the mumber of rows of matrix A. m must be at least zero.
     * @param  n      input int On entry, n specifies the number of columns of matrix A. n must be at least zero.
     * @param  alpha  input double specified scalar
     * @param  A      input double[][] dimension lda by n Before entry, the leading m by n part of the array A must
     *                contain the matrix of coefficients.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1, m).
     * @param  x      input double[] array of dimension at least (1 + (n-1)*abs(incx)) when trans = 'N' or 'n' and at
     *                least (1 + (m-1)*abs(incx)) otherwise. Before entry, the incremented array x must contain the
     *                vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     * @param  beta   input double specified scalar When beta is supplied as zero, then y need not be set on input.
     * @param  y      input/output double[] array of dimension at least (1 + (m-1)*abs(incy)) when trans = 'N' or 'n'
     *                and at least (1 + (n-1)*abs(incy)) otherwise. Before entry with beta non-zero, the incremented
     *                array y must contain the vector y. On exit, array y is overwritten with the updated vector y.
     * @param  incy   input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
     */
    private void dgemv(char trans, int m, int n, double alpha, double[][] A, int lda, double[] x, int incx, double beta,
                       double[] y, int incy) {
        int info;
        int lenx;
        int leny;
        int kx;
        int ky;
        int i;
        int iy;
        int jx;
        int j;
        int jy;
        int ix;
        double temp;

        // Test the input parameters
        info = 0;

        if ((trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') && (trans != 'c')) {
            info = 1;
        } else if (m < 0) {
            info = 2;
        } else if (n < 0) {
            info = 3;
        } else if (lda < Math.max(1, m)) {
            info = 6;
        } else if (incx == 0) {
            info = 8;
        } else if (incy == 0) {
            info = 11;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dgemv has info = " + info);

            return;
        } // if (info != 0)

        // Quick return if possible
        if ((m == 0) || (n == 0) || ((alpha == 0.0) && (beta == 1.0))) {
            return;
        }

        // Set lenx and leny, the lengths of vectors x and y, and set up the
        // start points in arrays x and y.

        if ((trans == 'N') || (trans == 'n')) {
            lenx = n;
            leny = m;
        } else {
            lenx = m;
            leny = n;
        }

        if (incx > 0) {
            kx = 1;
        } else {
            kx = 1 - ((lenx - 1) * incx);
        }

        if (incy > 0) {
            ky = 1;
        } else {
            ky = 1 - ((leny - 1) * incy);
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through A.
        // First form y = beta*y.
        if (beta != 1.0) {

            if (incy == 1) {

                if (beta == 0.0) {

                    for (i = 0; i < leny; i++) {
                        y[i] = 0.0;
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (i = 0; i < leny; i++) {
                        y[i] = beta * y[i];
                    }
                } // else beta != 0.0
            } // if (incy == 1)
            else { // incy != 1
                iy = ky - 1;

                if (beta == 0.0) {

                    for (i = 1; i <= leny; i++) {
                        y[iy] = 0.0;
                        iy = iy + incy;
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (i = 1; i <= leny; i++) {
                        y[iy] = beta * y[iy];
                        iy = iy + incy;
                    }
                } // else beta != 0.0
            } // else incy != 1
        } // if (beta != 1.0)

        if (alpha == 0.0) {
            return;
        }

        if ((trans == 'N') || (trans == 'n')) {

            // Form y = alpha*A*x + y.
            jx = kx - 1;

            if (incy == 1) {

                for (j = 0; j < n; j++) {

                    if (x[jx] != 0.0) {
                        temp = alpha * x[jx];

                        for (i = 0; i < m; i++) {
                            y[i] = y[i] + (temp * A[i][j]);
                        } // for (i = 0; i < m; i++)
                    } // if (x[jx] != 0.0)

                    jx = jx + incx;
                } // for (j = 0; j < n; j++)
            } // if (incy == 1)
            else { // incy != 1

                for (j = 0; j < n; j++) {

                    if (x[jx] != 0.0) {
                        temp = alpha * x[jx];
                        iy = ky - 1;

                        for (i = 0; i < m; i++) {
                            y[iy] = y[iy] + (temp * A[i][j]);
                            iy = iy + incy;
                        } // for (i = 0; i < m; i++)
                    } // if (x[jx] != 0.0)

                    jx = jx + incx;
                } // for (j = 0; j < n; j++)
            } // else incy != 1
        } // if (trans == 'N') || (trans == 'n'))
        else { // trans != 'N' && trans != 'n'

            // Form y = alpha*A'*x + y.
            jy = ky - 1;

            if (incx == 1) {

                for (j = 0; j < n; j++) {
                    temp = 0.0;

                    for (i = 0; i < m; i++) {
                        temp = temp + (A[i][j] * x[i]);
                    } // for (i = 0; i < m; i++)

                    y[jy] = y[jy] + (alpha * temp);
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // if (incx == 1)
            else { // incx != 1

                for (j = 0; j < n; j++) {
                    temp = 0.0;
                    ix = kx - 1;

                    for (i = 0; i < m; i++) {
                        temp = temp + (A[i][j] * x[ix]);
                        ix = ix + incx;
                    } // for (i = 0; i < m; i++)

                    y[jy] = y[jy] + (alpha * temp);
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // else incx != 1
        } // else trans != 'N' && trans != 'n'

        return;
    } // dgemv

    /**
     * This is a port of the version 3.1 LAPACK routine DGEQR2 Original DGEQR2 created by Univ. of Tennessee, Univ. of
     * California Berkeley, NAG Ltd. November, 2006 dgeqr2 computes a QR factorization of a real m by n matrix A: A = Q
     * * R
     *
     * @param  m     input int The number of rows of the matrix A. m >= 0.
     * @param  n     input int The number of columns of the matrix A. n >= 0.
     * @param  A     (input/output) double[][] of dimension (lda,n) On entry, the m by n matrix A. On exit, the elements
     *               on and above the diagonal of the array contain the min(m,n) by n upper trapezoidal matrix R (R is
     *               upper triangular if m >= n). The elements below the diagonal, with the array tau, represent the
     *               orthogonal matrix Q as a product of elementary reflectors. The matrix Q is represented as a product
     *               of elementary reflectors Q = H(1) H(2) . . . H(k), where k = min(m,n). Each H(i) has the form H(i)
     *               = I - tau * v * v' where tau is a real scalar, and v is a real vector with v(0:i-2) = 0 and v(i-1)
     *               = 1; v(i:m-1) is stored on exit in A(i:m-1, i-1), and tau in tau[i-1].
     * @param  lda   input int The leading dimension of the array A. lda >= max(1,m).
     * @param  tau   output double[] of dimension min(m,n) The scalar factors of the elementary reflectors.
     * @param  work  (workspace) double[] of dimension (n)
     * @param  info  output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value.
     */
    private void dgeqr2(int m, int n, double[][] A, int lda, double[] tau, double[] work, int[] info) {
        int i;
        int k;
        double aii;
        double[] alpha = new double[1];
        double[] t = new double[1];
        double[] x;
        double[][] array1;
        int row1;
        int j;
        int p;

        // Test the input arguments
        info[0] = 0;

        if (m < 0) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, m)) {
            info[0] = -4;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dgeqr2 had info[0] = " + info[0]);

            return;
        }

        k = Math.min(m, n);

        for (i = 1; i <= k; i++) {

            // Generate elementary reflector H(i) to annihilate A(i:m-1,i-1)
            alpha[0] = A[i - 1][i - 1];
            x = new double[m - i];

            for (j = 0; j < (m - i); j++) {
                x[j] = A[Math.min(i, m - 1) + j][i - 1];
            }

            dlarfg(m - i + 1, alpha, x, 1, t);
            A[i - 1][i - 1] = alpha[0];

            for (j = 0; j < (m - i); j++) {
                A[Math.min(i, m - 1) + j][i - 1] = x[j];
            }

            tau[i - 1] = t[0];

            if (i < n) {

                // Apply H(i) to A(i-1:m-1,i:n-1) from the left
                aii = A[i - 1][i - 1];
                A[i - 1][i - 1] = 1.0;
                x = new double[m - i + 1];

                for (j = 0; j < (m - i + 1); j++) {
                    x[j] = A[i - 1 + j][i - 1];
                }

                row1 = Math.max(1, m - i + 1);
                array1 = new double[row1][n - i];

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < (n - i); p++) {
                        array1[j][p] = A[i - 1 + j][i + p];
                    }
                }

                dlarf('L', m - i + 1, n - i, x, 1, t[0], array1, row1, work);

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < (n - i); p++) {
                        A[i - 1 + j][i + p] = array1[j][p];
                    }
                }

                A[i - 1][i - 1] = aii;
            } // if (i < n)
        } // for (i = 1; i <= k; i++)

        return;
    } // dgeqr2

    /**
     * This is a port of version 3.1 LAPACK routine DGEQRF Original DGEQRF created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., Noovember, 2006 dgeqrf computes a QR factorization of a real m by n matrix A:
     * A = Q * R.
     *
     * @param  m      input int The number of rows of the matrix A. m >= 0.
     * @param  n      input int The number of columns of the matrix A. n >= 0.
     * @param  A      input/output double[][] of dimension (lda,n) On entry, the m by n matrix A. On exit, the elements
     *                on and above the diagonal of the array contain the min(m,n)-by-n upper trapezoidal matrix R ( R is
     *                upper triangular if m >= n); the elements below the diagonal, with the array tau, represent the
     *                orthogonal matrix Q as a product of min(m,n) elementary reflectors. The matrix Q is represented as
     *                a product of elementary reflectors Q = H(1) H(2) . . . H(k), where k = min(m,n) Each H(i) has the
     *                form H(i) = I - tau * v * v' where tau is a real scalar, and v is a real vector with v(0:i-2) = 0
     *                and v(i-1) = 1; v(i:m-1) is stored on exit in A(i:m-1,i-1), and tau in tau[i-1].
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,m).
     * @param  tau    output double[] of dimension min(m,n). The scalar factors of the elementary reflectors.
     * @param  work   (workspace/output) double[] of dimension (max(1,lwork)) On exit, if info[0] = 0, work[0] returns
     *                the optimal lwork.
     * @param  lwork  input int The dimension of the array work. lwork >= max(1,n). For optimum performance, lwork >=
     *                n*nb, where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the
     *                routine only calculates the optimal size of the work array, returns this value as the first entry
     *                of the work array, and no error message related to lwork is output.
     * @param  info   output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value
     */
    private void dgeqrf(int m, int n, double[][] A, int lda, double[] tau, double[] work, int lwork, int[] info) {
        boolean lquery;
        int i;
        int ib;
        int[] iinfo = new int[1];
        int iws;
        int k;
        int ldwork = 1;
        int lwkopt;
        int nb;
        int nbmin;
        int nx;
        String name;
        String opts;
        double[][] array1;
        double[][] array2;
        int row1;
        int p;
        int q;
        double[] x;
        double[][] work2d;
        double[][] w2d;

        // Test the input arguments
        info[0] = 0;
        name = new String("DGEQRF");
        opts = new String(" ");
        nb = ilaenv(1, name, opts, m, n, -1, -1);
        lwkopt = n * nb;
        work[0] = lwkopt;
        lquery = (lwork == -1);

        if (m < 0) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, m)) {
            info[0] = -4;
        } else if ((lwork < Math.max(1, n)) && (!lquery)) {
            info[0] = -7;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dgeqrf had info[0] = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        k = Math.min(m, n);

        if (k == 0) {
            work[0] = 1;

            return;
        } // if (k == 0)

        nbmin = 2;
        nx = 0;
        iws = n;

        if ((nb > 1) && (nb < k)) {

            // Determine when to cross over from blocked to unblocked code.
            nx = Math.max(0, ilaenv(3, name, opts, m, n, -1, -1));

            if (nx < k) {

                // Determine if workspace is large enough for blocked code.
                ldwork = n;
                iws = ldwork * nb;

                if (lwork < iws) {

                    // Not enough space to use optimal nb: reduce nb and
                    // determine the minimum value of nb.
                    nb = lwork / ldwork;
                    nbmin = Math.max(2, ilaenv(2, name, opts, m, n, -1, -1));
                } // if (lwork < iws)
            } // if  (nx < k)
        } // if ((nb > 1) && (nb < k))

        if ((nb >= nbmin) && (nb < k) && (nx < k)) {

            // Use blocked code initially.
            for (i = 1; i <= (k - nx); i += nb) {
                ib = Math.min(k - i + 1, nb);

                // Compute the QR factorization of the current block
                // A(i-1:m-1, i-1:i+ib-2)
                row1 = Math.max(1, m - i + 1);
                array1 = new double[row1][ib];

                for (p = 0; p < row1; p++) {

                    for (q = 0; q < ib; q++) {
                        array1[p][q] = A[i - 1 + p][i - 1 + q];
                    }
                }

                x = new double[Math.min(m - i + 1, ib)];
                dgeqr2(m - i + 1, ib, array1, row1, x, work, iinfo);

                for (p = 0; p < row1; p++) {

                    for (q = 0; q < ib; q++) {
                        A[i - 1 + p][i - 1 + q] = array1[p][q];
                    }
                }

                for (p = 0; p < Math.min(m - i + 1, ib); p++) {
                    tau[i - 1 + p] = x[p];
                }

                if ((i + ib) <= n) {

                    // Form the triangular factor of the block reflector
                    // H = H(i) H(i+1) . . . H(i+ib-1)
                    x = new double[ib];

                    for (p = 0; p < ib; p++) {
                        x[p] = tau[i - 1 + p];
                    }

                    work2d = new double[ldwork][ib];
                    dlarft('F', 'C', m - i + 1, ib, array1, row1, x, work2d, ldwork);

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            A[i - 1 + p][i - 1 + q] = array1[p][q];
                        }
                    }

                    // Apply H' to A(i-1:m-1,i+ib-1:n-1) from the left
                    array2 = new double[m - i + 1][n - i - ib + 1];

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < (n - i - ib + 1); q++) {
                            array2[p][q] = A[i - 1 + p][i + ib - 1 + q];
                        }
                    }

                    w2d = new double[ldwork][ib];
                    dlarfb('L', 'T', 'F', 'C', m - i + 1, n - i - ib + 1, ib, array1, row1, work2d, ldwork, array2,
                           m - i + 1, w2d, ldwork);

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < (n - i - ib + 1); q++) {
                            A[i - 1 + p][i + ib - 1 + q] = array2[p][q];
                        }
                    }
                } // if (i+ib <= n)
            } // for (i = 1; i <= k - nx; i += nb)
        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
        else {
            i = 1;
        }

        // Use unblocked code to factor the last or only block
        if (i <= k) {
            x = new double[Math.min(m - i + 1, n - i + 1)];
            row1 = Math.max(1, m - i + 1);
            array1 = new double[row1][n - i + 1];

            for (p = 0; p < row1; p++) {

                for (q = 0; q < (n - i + 1); q++) {
                    array1[p][q] = A[i - 1 + p][i - 1 + q];
                }
            }

            dgeqr2(m - i + 1, n - i + 1, array1, row1, x, work, iinfo);

            for (p = 0; p < Math.min(m - i + 1, n - i + 1); p++) {
                tau[i - 1 + p] = x[p];
            }

            for (p = 0; p < row1; p++) {

                for (q = 0; q < (n - i + 1); q++) {
                    A[i - 1 + p][i - 1 + q] = array1[p][q];
                }
            }
        }

        work[0] = iws;

        return;
    } // dgeqrf

    /**
     * This is a port of the 10/22/86 Blas routine DGER Original version written by: Jack Dongarra, Argonne National
     * Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
     * Labs. dger performs the rank 1 operation A = alpha*x*y' + A, where alpha is a scalar, x is an m element vector, y
     * is an n element vector, and A is an m by n matrix.
     *
     * @param  m      input int On entry, m specifies the number of rows of the matrix A. m must be at least zero.
     * @param  n      input int On entry, n specifies the number of columns of the matrix A. n must be at least zero.
     * @param  alpha  input double Specified scalar
     * @param  x      input double[] of dimension at least (1 + (m-1)*abs(incx)). Before entry, the incremented array x
     *                must contain the m element vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     * @param  y      input double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented array y
     *                must contain the n element vector y.
     * @param  incy   input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
     * @param  A      double[][] of dimension lda by n. Before entry, the leading m by n part of the array A must
     *                contain the matrix of coefficients. On exit, A is overwritten by the updated matrix.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,m).
     */
    private void dger(int m, int n, double alpha, double[] x, int incx, double[] y, int incy, double[][] A, int lda) {
        double temp;
        int i;
        int info;
        int ix;
        int j;
        int jy;
        int kx;

        // Test the input parameters.
        info = 0;

        if (m < 0) {
            info = 1;
        } else if (n < 0) {
            info = 2;
        } else if (incx == 0) {
            info = 5;
        } else if (incy == 0) {
            info = 7;
        } else if (lda < Math.max(1, m)) {
            info = 9;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dger had info = " + info);

            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0) || (alpha == 0.0)) {
            return;
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through A.
        if (incy > 0) {
            jy = 0;
        } else {
            jy = -(n - 1) * incy;
        }

        if (incx == 1) {

            for (j = 0; j < n; j++) {

                if (y[jy] != 0.0) {
                    temp = alpha * y[jy];

                    for (i = 0; i < m; i++) {
                        A[i][j] = A[i][j] + (x[i] * temp);
                    }
                } // if (y[jy] != 0.0)

                jy = jy + incy;
            } // for (j = 0; j < n; j++)
        } // if (incx == 1)
        else { // incx != 1

            if (incx > 0) {
                kx = 1;
            } else {
                kx = 1 - ((m - 1) * incx);
            }

            for (j = 0; j < n; j++) {

                if (y[jy] != 0.0) {
                    temp = alpha * y[jy];
                    ix = kx - 1;

                    for (i = 0; i < m; i++) {
                        A[i][j] = A[i][j] + (x[ix] * temp);
                        ix = ix + incx;
                    } // for (i = 0; i < m; i++)
                } // if (y[jy] != 0.0)

                jy = jy + incy;
            } // for (j = 0; j < n; j++)
        } // else incx != 1

        return;
    } // dger

    /**
     * This is a port of version 3.1 LAPACK test routine DGET51 Original DGET51 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dget51 generally checks a decomposition of the form A = U B V' where ' means transpose and U and V are
     * orthogonal. Specifically, if itype = 1 result = | A - U B V' | / ( |A| n ulp ) If itype = 2, then:
     * result = | A - B | / ( |A| n ulp ) If itype = 3, then: result = | I - UU' | / ( n ulp )
     *
     * @param  itype   input int Specifies the type of tests to be performed.
     *         = 1: result = | A - U B V' | / ( |A| n ulp )
     *         = 2: result = | A - B | / ( |A| n ulp )
     *         = 3: result = | I - UU' | / ( n ulp )
     * @param  n       input int The size of the matrix. If it is zero, dget51 does nothing. It must be at least zero.
     * @param  A       (input) double[][] of dimension (lda, n) The original (unfactored) matrix.
     * @param  lda     (input) int The leading dimension fo A. It must be at least 1 and at least n.
     * @param  B       (input) double[][] of dimension (ldb,n) The factored matrix.
     * @param  ldb     (input) int The leading dimension of B. It must be at least 1 and at least n.
     * @param  U       (input) double[][] of dimension (ldu, n) The orthogonal matrix on the left-hand side in the
     *                 decomposition. Not referenced if itype = 2.
     * @param  ldu     (input) int The leading dimension of U. ldu must be at least n and at least 1.
     * @param  V       (input) double[][] of dimension (ldv,n) The orthogonal matrix on the right-hand side in the
     *                 decomposition. Not referenced if itype = 2 or itype = 3.
     * @param  ldv     (input) int The leading dimension of V. ldv must be at least n and at least 1.
     * @param  work    (workspace) double[] of dimension (2*n**2)
     * @param  result  (output) double[] The values computed by the test specified by itype. The value is currently
     *                 limited to 1/ulp, to avoid overflow. Errors are flagged by result = 10/ulp.
     */
    private void dget51(int itype, int n, double[][] A, int lda, double[][] B, int ldb, double[][] U, int ldu,
                        double[][] V, int ldv, double[] work, double[] result) {
        int jcol;
        int jdiag;
        int jrow;
        double anorm;
        double ulp;
        double unfl;
        double wnorm;
        double[][] work2d;
        double[][] C;

        result[0] = 0.0;

        if (n <= 0) {
            return;
        }

        unfl = dlamch('S');
        ulp = dlamch('E') * dlamch('B');

        // Some error checks
        if ((itype < 1) || (itype > 3)) {
            result[0] = 10.0 / ulp;

            return;
        }

        if (itype <= 2) {

            // Tests scaled by the norm(A)
            anorm = Math.max(dlange('1', n, n, A, lda, work), unfl);

            if (itype == 1) {

                // itype = 1: Compute W = A - UBV'
                work2d = new double[n][n];
                dlacpy(' ', n, n, A, lda, work2d, n);
                C = new double[n][n];
                dgemm('N', 'N', n, n, n, 1.0, U, ldu, B, ldb, 0.0, C, n);
                dgemm('N', 'C', n, n, n, -1.0, C, n, V, ldv, 1.0, work2d, n);
            } // if (itype == 1)
            else { // itype == 2

                // Compute w = A - B
                work2d = new double[n][n];
                dlacpy(' ', n, n, B, ldb, work2d, n);

                for (jcol = 0; jcol < n; jcol++) {

                    for (jrow = 0; jrow < n; jrow++) {
                        work2d[jrow][jcol] = work2d[jrow][jcol] - A[jrow][jcol];
                    }
                }
            } // else itype == 2

            // Compute norm(W) / (ulp*norm(A))
            wnorm = dlange('1', n, n, work2d, n, work);

            if (anorm > wnorm) {
                result[0] = (wnorm / anorm) / (n * ulp);
            } else if (anorm < 1.0) {
                result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
            } else {
                result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
            }
        } // if (itype <= 2)
        else { // itype == 3

            // Tests not scaled by norm(A)
            // Compute UU" - I
            C = new double[n][n];
            dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, C, n);

            for (jdiag = 0; jdiag < n; jdiag++) {
                C[jdiag][jdiag] = C[jdiag][jdiag] - 1.0;
            } // for (jdiag = 0; jdiag < n; jdiag++)

            result[0] = Math.min(dlange('1', n, n, C, n, work), (double) n) / (n * ulp);
        } // else itype == 3

        return;
    } // dget51

    /**
     * This is a port of version 3.1 LAPACK test routine DGET52 Original DGET52 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dget52 does an eigenvector check for the generalized eigenvalue problem.
     *
     * <p>The basic test for right eigenvectors is:   | b[j] A E[j] - a[j] B E[j] |
     *                              result[0] = max   -------------------------------
     *                                           j    n ulp max( |b[j] A|, |a[j] B|
     * using the 1-norm. Here a[j]/b[j] = w is the (j+1)-th generalized eigenvalue of A - w B, or, equivalently,
     * b[j]/a[j] = m is the (j+1)-st generalized eigenvalue of m A - B.</p>
     *
     * <p>For real eigenvalues, the test is straightforward. For complex eigenvalues, E[j] and a[j] are complex,
     * represented by Er[j] + i*Ei[j] and ar[j] + i*ai[j], respectively, so the test for that eigenvector becomes
     *                             max(|Wr|, |Wi| )
     *               ---------------------------------------------- 
     *               n ulp max( |b[j] A|, (|ar[j]| + |ai[j]|) |B| )
     * where
     *                       Wr = b[j] A Er[j] - ar[j] B Er[j] + ai[j] B Ei[j]
     *                       Wi = b[j] A Ei[j] - ai[j] B Er[j] - ar[j] B Ei[j]
     *                                                    T   T  _ 
     *                            For left eigenvectors, A , B , a, and b are used.</p>
     *
     * <p>dget52 also tests the normalization of E. Each eigenvector is supposed to be normalized so that the maximum
     * "absolute value" of its elements is 1, where in this case, "absolute value" of a complex value x is |Re(x)| +
     * |Im(x)|; let us call this maximum "absolute value" norm of a vector v M(v). If a[j] = b[j] = 0, then the
     * eigenvector is set to be the (j+1)-st coordinate vector. The normalization test is:
     *                                       result[1] = max          | M(v[j]) - 1| / (n ulp)
     *                                              eigenvectors v[j]</p>
     *
     * @param  left    input boolean 
     *         = true: The eigenvectors in the columns of E are assumed to be*left* eigenvectors.
     *         = false: The eigenvectors in the columns of E are assumed to be*right* eigenvectors.
     * @param  n       input int The size of the matrices. If it is zero, dget52 does nothing. It must be at least zero.
     * @param  A       input double[][] of dimension (lda, n) The matrix A.
     * @param  lda     input int The leading dimension of A. It must be at least 1 and at least n.
     * @param  B       input double[][] of dimension (ldb, n) The matrix B.
     * @param  ldb     input int The leading dimension of B. It must be at least 1 and at least n.
     * @param  E       input double[][] of dimension (lde,n) The matrix of eigenvectors. It must be O(1). Complex
     *                 eigenvalues and eigenvectors always come in pairs, the eigenvalue and its conjugate being stored
     *                 in adjacent elements of alphar, alphai, and beta. Thus, if a[j]/b[j] and a[j+1]/b[j+1] are a
     *                 complex conjugate pair of generalized eigenvalues, then E(,j) contains the real part of the
     *                 eigenvector and E(,j+1) contains the imaginary part. Note that whether E(,j) is a real
     *                 eigenvector or part of a complex one is specified by whether alphai[j] is zero or not.
     * @param  lde     input int The leading dimension of E. It must be at least 1 and at least n.
     * @param  alphar  input double[] of dimension (n). The real parts of the values a[j] as described above, which,
     *                 along with b[j], define the generalized eigenvalues. Complex eigenvalues always come in complex
     *                 conjugate pairs a[j]/b[j] and a[j+1]/b[j+1], which are stored in adjacent elements in alphar,
     *                 alphai, and beta. Thus, if the j-th and (j+1)-st eigenvalues form a pair, alphar[j+1]/beta[j+1]
     *                 is assumed to be equal to alphar[j]/beta[j].
     * @param  alphai  input double[] of dimension (n) The imaginary parts of the values of a[j] as described above,
     *                 which, along with b[j], define the generalized eigenvalues. If alphai[j] = 0, then the eigenvalue
     *                 is real, otherwise it is part of a complex conjugate pair. Complex eigenvalues always come in
     *                 complex conjugate pairs a[j]/b[j] and a[j+1]/b[j+1], which are stored in adjacent elements in
     *                 alphar, alphai, and beta. Thus, if the j-th and (j+1)-st eigenvalues form a pair,
     *                 alphai[j+1]/beta[j+1] is assumed to be equal to -alphai[j]/beta[j]. Also, nonzero values in
     *                 alphai are assumed to always come in adjacent pairs.
     * @param  beta    input double[] of dimension (n). The values b[j] as described above, which, along with a[j],
     *                 define the generalized eigenvalues.
     * @param  work    workspace double[] of dimension (n**2+n)
     * @param  result  output double[] of dimension (2) The values computed by the test described above. If A E or B E
     *                 is likely to overflow, then result(0:1) is set to 10 / ulp.
     */
    private void dget52(boolean left, int n, double[][] A, int lda, double[][] B, int ldb, double[][] E, int lde,
                        double[] alphar, double[] alphai, double[] beta, double[] work, double[] result) {
        boolean ilcplx;
        char normab;
        char trans;
        int i;
        int j;
        int p;
        int jvec;
        double abmax;
        double acoef;
        double alfmax;
        double anorm;
        double bcoefi;
        double bcoefr;
        double betmax;
        double bnorm;
        double enorm;
        double enrmer;
        double errnrm;
        double safmax;
        double safmin;
        double salfi;
        double salfr;
        double sbeta;
        double scale;
        double temp1;
        double ulp;
        double[] x = new double[n];
        double[] y = new double[n];
        double[][] array1 = new double[n][n];

        result[0] = 0.0;
        result[1] = 0.0;

        if (n <= 0) {
            return;
        }

        safmin = dlamch('S');
        safmax = 1.0 / safmin;
        ulp = dlamch('E') * dlamch('B');

        if (left) {
            trans = 'T';
            normab = 'I';
        } else {
            trans = 'N';
            normab = 'O';
        }

        // Norm of A, B, and E
        anorm = Math.max(dlange(normab, n, n, A, lda, work), safmin);
        bnorm = Math.max(dlange(normab, n, n, B, ldb, work), safmin);
        enorm = Math.max(dlange('O', n, n, E, lde, work), ulp);
        alfmax = safmax / Math.max(1.0, bnorm);
        betmax = safmax / Math.max(1.0, anorm);

        // Compute error matrix.
        // Column i = (b[i] A - a[i] B) E[i] / max( |a[i] B| | b[i] A| )
        ilcplx = false;

        for (jvec = 1; jvec <= n; jvec++) {

            if (ilcplx) {

                // 2nd Eigenvalue/-vector of pair -- do nothing
                ilcplx = false;
            } // if (ilcplx)
            else { // !ilcplx
                salfr = alphar[jvec - 1];
                salfi = alphai[jvec - 1];
                sbeta = beta[jvec - 1];

                if (salfi == 0.0) {

                    // Real eigenvalue and -vector
                    abmax = Math.max(Math.abs(salfr), Math.abs(sbeta));

                    if ((Math.abs(salfr) > alfmax) || (Math.abs(sbeta) > betmax) || (abmax < 1.0)) {
                        scale = 1.0 / Math.max(abmax, safmin);
                        salfr = scale * salfr;
                        sbeta = scale * sbeta;
                    } // if ((Math.abs(salfr) > alfmax) || (Math.abs(sbeta) > betmax)

                    temp1 = Math.max(Math.abs(salfr) * bnorm, Math.abs(sbeta) * anorm);
                    temp1 = Math.max(temp1, safmin);
                    scale = 1.0 / temp1;
                    acoef = scale * sbeta;
                    bcoefr = scale * salfr;

                    for (j = 0; j < n; j++) {
                        x[j] = E[j][jvec - 1];
                        y[j] = work[(n * (jvec - 1)) + j];
                    }

                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);
                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

                    for (j = 0; j < n; j++) {
                        work[(n * (jvec - 1)) + j] = y[j];
                    }
                } // if (salfi == 0.0)
                else { // salfi != 0.0

                    // Complex conjugate pair
                    ilcplx = true;

                    if (jvec == n) {
                        result[0] = 10.0 / ulp;

                        return;
                    } // if (jvec == n)

                    abmax = Math.max(Math.abs(salfr) + Math.abs(salfi), Math.abs(sbeta));

                    if (((Math.abs(salfr) + Math.abs(salfi)) > alfmax) || (Math.abs(sbeta) > betmax) || (abmax < 1.0)) {
                        scale = 1.0 / Math.max(abmax, safmin);
                        salfr = scale * salfr;
                        salfi = scale * salfi;
                        sbeta = scale * sbeta;
                    } // if ((Math.abs(salfr) + Math.abs(salfi) > alfmax) ||

                    temp1 = Math.max((Math.abs(salfr) + Math.abs(salfi)) * bnorm, Math.abs(sbeta) * anorm);
                    temp1 = Math.max(temp1, safmin);
                    scale = 1.0 / temp1;
                    acoef = scale * sbeta;
                    bcoefr = scale * salfr;
                    bcoefi = scale * salfi;

                    if (left) {
                        bcoefi = -bcoefi;
                    } // if (left)

                    for (j = 0; j < n; j++) {
                        x[j] = E[j][jvec - 1];
                        y[j] = work[(n * (jvec - 1)) + j];
                    }

                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);
                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

                    for (j = 0; j < n; j++) {
                        x[j] = E[j][jvec];
                    }

                    dgemv(trans, n, n, bcoefi, B, lda, x, 1, 1.0, y, 1);

                    for (j = 0; j < n; j++) {
                        work[(n * (jvec - 1)) + j] = y[j];
                    }

                    for (j = 0; j < n; j++) {
                        y[j] = work[(n * jvec) + j];
                    }

                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);

                    for (j = 0; j < n; j++) {
                        x[j] = E[j][jvec - 1];
                    }

                    dgemv(trans, n, n, -bcoefi, B, lda, x, 1, 1.0, y, 1);

                    for (j = 0; j < n; j++) {
                        x[j] = E[j][jvec];
                    }

                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

                    for (j = 0; j < n; j++) {
                        work[(n * jvec) + j] = y[j];
                    }
                } // else salfi != 0.0
            } // else !ilcplx
        } // for (jvec = 1; jvec <= n; jvec++)

        p = 0;

        for (j = 0; j < n; j++) {

            for (i = 0; i < n; i++) {
                array1[i][j] = work[p++];
            }
        }

        errnrm = dlange('O', n, n, array1, n, x) / enorm;

        // Compute result[0]
        result[0] = errnrm / ulp;

        // Normalization of E
        enrmer = 0.0;
        ilcplx = false;

        for (jvec = 1; jvec <= n; jvec++) {

            if (ilcplx) {
                ilcplx = false;
            } // if (ilcplx)
            else { // !ilcplx
                temp1 = 0.0;

                if (alphai[jvec - 1] == 0.0) {

                    for (j = 1; j <= n; j++) {
                        temp1 = Math.max(temp1, Math.abs(E[j - 1][jvec - 1]));
                    }

                    enrmer = Math.max(enrmer, temp1 - 1.0);
                } // if (alphai[jvec-1] == 0.0)
                else { // alphai[jvec-1] != 0.0
                    ilcplx = true;

                    for (j = 1; j <= n; j++) {
                        temp1 = Math.max(temp1, Math.abs(E[j - 1][jvec - 1]) + Math.abs(E[j - 1][jvec]));
                    }

                    enrmer = Math.max(enrmer, temp1 - 1.0);
                } // else alphai[jvec-1] != 0.0
            } // else !ilcplx
        } // for (jvec = 1; jvec <= n; jvec++)

        // Compute result[1]: the nromalization error in E.
        result[1] = enrmer / (n * ulp);

        return;
    } // dget52

    /**
     * This is a port of version 3.1 LAPACK routine DGGBAK Original DGGBAK created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 dggbak forms the right or left eigenvectors of a real
     * generalized eigenvalue problem A*x = lambda*B*x, by backward transformation on the computed eigenvectors of the
     * balanced pair of matrices output by dggbal.
     *
     * @param  job     input char Specifies the type of backward transformation required: = 'N': do nothing, return
     *                 immediately, = 'P': do backward transformation for permutation only, = 'S': do backward
     *                 transformation for scaling only, = 'B': do backward transformations for both permutation and
     *                 scaling job must be the same as the argument job supplied to dggbal.
     * @param  side    input char = 'R': V contains right eigenvectors, = 'L': V contains left eigenvectors
     * @param  n       input int The number of rows of the matrix V. n >= 0.
     * @param  ilo     input int
     * @param  ihi     input int The integers ilo and ihi determined by dggbal. 1 <= ilo <= ihi <= n, if n > 0; ilo = 1
     *                 and ihi = 0, if n = 0.
     * @param  lscale  input double[] of dimension (n) Details of the permutations and/or scaling factors applied to the
     *                 left side of A and B, as returned by dggbal.
     * @param  rscale  input double[] of dimension (n) Details of the permutations and/or scaling factors applied to the
     *                 right side of A and B, as returned by dggbal.
     * @param  m       input int The number of columns of the matrix V. m >= 0.
     * @param  V       (input/output) double[][] of dimension (ldv,m) On entry, the matrix of right or left eigenvectors
     *                 to be transformed, as returned by dtgevc. On exit, V is overwritten by the transformed
     *                 eigenvectors.
     * @param  ldv     input int The leading dimension of the matrix V. ldv >= max(1,n).
     * @param  info    output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value.
     *                 Further Details: See R. C. Ward, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat.
     *                 Comp. 2 (1981), 141-152.
     */
    private void dggbak(char job, char side, int n, int ilo, int ihi, double[] lscale, double[] rscale, int m,
                        double[][] V, int ldv, int[] info) {
        boolean leftv;
        boolean rightv;
        int i;
        int k;
        double[] dx;
        int j;
        double temp;

        // Test the input parameters
        if ((side == 'R') || (side == 'r')) {
            rightv = true;
        } else {
            rightv = false;
        }

        if ((side == 'L') || (side == 'l')) {
            leftv = true;
        } else {
            leftv = false;
        }

        info[0] = 0;

        if ((job != 'N') && (job != 'n') && (job != 'P') && (job != 'p') && (job != 'S') && (job != 's') &&
                (job != 'B') && (job != 'b')) {
            info[0] = -1;
        } else if ((!rightv) && (!leftv)) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (ilo < 1) {
            info[0] = -4;
        } else if ((n == 0) && (ihi == 0) && (ilo != 1)) {
            info[0] = -4;
        } else if ((n > 0) && ((ihi < ilo) || (ihi > Math.max(1, n)))) {
            info[0] = -5;
        } else if ((n == 0) && (ilo == 1) && (ihi != 0)) {
            info[0] = -5;
        } else if (m < 0) {
            info[0] = -8;
        } else if (ldv < Math.max(1, n)) {
            info[0] = -10;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dggbak had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (m == 0) {
            return;
        }

        if ((job == 'N') || (job == 'n')) {
            return;
        }

        if (ilo != ihi) {

            // Backward balance
            if ((job == 'S') || (job == 's') || (job == 'B') || (job == 'b')) {

                // Backward transformation on right eigenvectors
                if (rightv) {
                    dx = new double[m];

                    for (i = ilo - 1; i < ihi; i++) {

                        for (k = 0; k < m; k++) {
                            dx[k] = V[i][k];
                        }

                        dscal(m, rscale[i], dx, 1);

                        for (k = 0; k < m; k++) {
                            V[i][k] = dx[k];
                        }
                    } // for (i = ilo - 1; i < ihi; i++)
                } // if (rightv)

                // Backward transformation on left eigenvectors
                if (leftv) {
                    dx = new double[m];

                    for (i = ilo - 1; i < ihi; i++) {

                        for (k = 0; k < m; k++) {
                            dx[k] = V[i][k];
                        }

                        dscal(m, lscale[i], dx, 1);

                        for (k = 0; k < m; k++) {
                            V[i][k] = dx[k];
                        }
                    } // for (i = ilo - 1; i < ihi; i++)
                } // if (leftv)

            } // if ((job == 'S') || (job == 's') || (job == 'B') || (job == 'b'))
        } // if (ilo != ihi)

        // Backward permutation
        if ((job == 'P') || (job == 'p') || (job == 'B') || (job == 'b')) {

            // Backward permutation on right eigenvectors
            if (rightv) {

                if (ilo != 1) {

                    for (i = ilo - 1; i >= 1; i--) {
                        k = (int) Math.round(rscale[i - 1]);

                        if (k == i) {
                            continue;
                        } // if (k == i)

                        for (j = 0; j < m; j++) {
                            temp = V[i - 1][j];
                            V[i - 1][j] = V[k - 1][j];
                            V[k - 1][j] = temp;
                        }
                    } // for (i = ilo - 1; i >= 1; i--)
                } // if (ilo != 1)

                if (ihi != n) {

                    for (i = ihi + 1; i <= n; i++) {
                        k = (int) Math.round(rscale[i - 1]);

                        if (k == i) {
                            continue;
                        } // if (k == i)

                        for (j = 0; j < m; j++) {
                            temp = V[i - 1][j];
                            V[i - 1][j] = V[k - 1][j];
                            V[k - 1][j] = temp;
                        }
                    } // for (i = ihi+1; i <= n; i++)
                } // if (ihi != n)
            } // if (rightv)

            // Backward permutation on left eigenvectors
            if (leftv) {

                if (ilo != 1) {

                    for (i = ilo - 1; i >= 1; i--) {
                        k = (int) Math.round(lscale[i - 1]);

                        if (k == i) {
                            continue;
                        } // if (k == i)

                        for (j = 0; j < m; j++) {
                            temp = V[i - 1][j];
                            V[i - 1][j] = V[k - 1][j];
                            V[k - 1][j] = temp;
                        }
                    } // for (i = ilo - 1; i >= 1; i--)
                } // if (ilo != 1)

                if (ihi != n) {

                    for (i = ihi + 1; i <= n; i++) {
                        k = (int) Math.round(lscale[i - 1]);

                        if (k == i) {
                            continue;
                        } // if (k == i)

                        for (j = 0; j < m; j++) {
                            temp = V[i - 1][j];
                            V[i - 1][j] = V[k - 1][j];
                            V[k - 1][j] = temp;
                        }
                    } // for (i = ihi+1; i <= n; i++)
                } // if (ihi != n)
            } // if (leftv)

        } // if ((job == 'P') || (job == 'p') || (job == 'B') || (job == 'b'))

        return;
    } // dggbak

    /**
     * This is a port of the version 3.1 LAPACK routine DGGBAL Original DGGBAL created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 dggbal balances a pair of general real matrices (A,B). This
     * involves, first, permuting A and B by similarity transformations to isolate eigenvalues in the first 1 to ilo-1
     * and last ihi+1 to n elements on the diagonal; and second, applying a diagonal similarity transformation to rows
     * and columns ilo to ihi to make the rows and columns as close in norm as possbile. Both steps are optional.
     *
     * <p>Balancing may reduce the 1-norm of the matrices, and improve the accuracy of the computed eigenvalues and/or
     * eigenvectors in the generalized eigenvector problem A*x = lambda*B*x.</p>
     *
     * @param  job     input char Specifies the operations to be performed on A and B: = 'N': none: simply set ilo = 1,
     *                 ihi = n, lscale[i] = 1.0 and rscale[i] = 1.0 for i = 0,...,n-1. = 'P': permute only = 'S': scale
     *                 only = 'B': both permute and scale.
     * @param  n       input int The order of matrices A and B. n >= 0.
     * @param  A       input/output double[][] of dimension (lda,n) On entry, the input matrix A. On exit, A is
     *                 overwritten by the balanced matrix. If job = 'N', A is not referenced.
     * @param  lda     input int The leading dimension of the array A. lda >= max(1,n).
     * @param  B       input/output double[][] of dimension (ldb,n) On entry, the input matrix B. On exit, B is
     *                 overwritten by the balanced matrix. If job = 'N', B is not referenced.
     * @param  ldb     input int The leading dimension of the array B. ldb >= max(1,n).
     * @param  ilo     output int[]
     * @param  ihi     output int[] ilo and ihi are set to integers such that on exit A[i][j] = 0 and B[i][j] = 0 if i >
     *                 j and j = 0,...,ilo-2 and i = ihi,...,n-1. if job = 'N' or 'S', ilo = 1 and ihi = n.
     * @param  lscale  output double[] of dimension n Details of the permutations and scaling factors applied to the
     *                 left side of A and B. If p[j] is the index of the row interchanged with row j, and d[j] is the
     *                 scaling factor applied to row j, then lscale[j] = p[j] for j = 0,...,ilo-2 = d[j] for j =
     *                 ilo-1,...,ihi-1 = p[j] for j = ihi,...,n-1. The order in which the interchanges are made is n-1
     *                 to ihi, then 0 to ilo-2.
     * @param  rscale  output double[] of dimension n Details of the permutations and scaling factors applied to the
     *                 right side of A and B. If p[j] is the index of the column interchanged with column j, and d[j] is
     *                 the scaling factor applied to column j, then rscale[j] = p[j] for j = 0,...,ilo-2 = d[j] for j =
     *                 ilo-1,...,ihi-1 = p[j] for j = ihi,...,n-1. The order in which the interchanges are made is n-1
     *                 to ihi, then 0 to ilo-2.
     * @param  work    workspace double[] of dimension lwork lwork must be at least max(1,6*n) when job = 'S' or 'B',
     *                 and at least 1 when job = 'N' or 'P'.
     * @param  info    output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value.
     *                 Further details: See R.C. Ward, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat.
     *                 Comp. 2 (1981), 141-152.
     */
    private void dggbal(char job, int n, double[][] A, int lda, double[][] B, int ldb, int[] ilo, int[] ihi,
                        double[] lscale, double[] rscale, double[] work, int[] info) {
        double sclfac = 10.0;
        int i;
        int icab;
        int iflow;
        int ip1;
        int ir;
        int irab;
        int it;
        int j;
        int jc;
        int jp1;
        int k;
        int kount;
        int L;
        int lcab;
        int lm1 = 0;
        int lrab;
        int lsfmax;
        int lsfmin;
        int m;
        int nr;
        int nrp2;
        double alpha;
        double basl;
        double beta;
        double cab;
        double cmax;
        double coef;
        double coef2;
        double coef5;
        double cor;
        double ew;
        double ewc;
        double gamma;
        double pgamma = 1.0;
        double rab;
        double sfmax;
        double sfmin;
        double sum;
        double t;
        double ta;
        double tb;
        double tc;
        boolean first;
        boolean second;
        boolean group;
        int p;
        double temp;
        double[] w;
        double[] x;
        double[] y;
        double[] z;
        double dmax;

        // Test the input parameters
        info[0] = 0;

        if ((job != 'N') && (job != 'n') && (job != 'P') && (job != 'p') && (job != 'S') && (job != 's') &&
                (job != 'B') && (job != 'b')) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -4;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -6;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dggbal had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            ilo[0] = 1;
            ihi[0] = n;

            return;
        }

        if (n == 1) {
            ilo[0] = 1;
            ihi[0] = n;
            lscale[0] = 1.0;
            rscale[0] = 1.0;

            return;
        }

        if ((job == 'N') || (job == 'n')) {
            ilo[0] = 1;
            ihi[0] = n;

            for (i = 0; i < n; i++) {
                lscale[i] = 1.0;
                rscale[i] = 1.0;
            }

            return;
        } // if ((job == 'N') || (job == 'n'))

        k = 1;
        L = n;

        if ((job != 'S') && (job != 's')) {
            first = false;
            group = true;
            second = true;

loop1:
            do {

// Permute the matrices A and B to isolate the eigenvalues
// Find row with one nonzero in columns 0 through L-1
loop2:           {

                    if (group) {

                        if (first) {
                            L = lm1;

                            if (L == 1) {
                                rscale[0] = 1.0;
                                lscale[0] = 1.0;

                                break loop1;
                            } // if (L == 1)
                        } // if (first)

                        first = true;
                        lm1 = L - 1;

loop3:
                        for (i = L; i >= 1; i--) {

loop4:                       {

loop5:                           {

                                    for (j = 1; j <= lm1; j++) {
                                        jp1 = j + 1;

                                        if ((A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
                                            break loop5;
                                        }
                                    } // for (j = 1; j <= lm1; j++)

                                    j = L;

                                    break loop4;
                                } // loop5

                                for (j = jp1; j <= L; j++) {

                                    if ((A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
                                        continue loop3;
                                    }
                                } // for (j = jp1; j <= L; j++)

                                j = jp1 - 1;
                            } // loop4

                            m = L;
                            iflow = 1;

                            break loop2;
                        } // for (i = L; i >= 1; i--)

                        second = false;
                    } // if (group)

                    // Find column with one nonzero in rows k through n.
                    if (second) {
                        k = k + 1;
                    } // if (second)

                    second = true;

loop6:
                    for (j = k; j <= L; j++) {

loop7:                   {

loop8:                       {

                                for (i = k; i <= lm1; i++) {
                                    ip1 = i + 1;

                                    if ((A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
                                        break loop8;
                                    }
                                } // for (i = k; i <= lm1; i++)

                                i = L;

                                break loop7;
                            } // loop8

                            for (i = ip1; i <= L; i++) {

                                if ((A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
                                    continue loop6;
                                }
                            } // for (i = ip1; i <= L: i++)

                            i = ip1 - 1;
                        } // loop7

                        m = k;
                        iflow = 2;

                        break loop2;
                    } // for (j = k; j <= L; j++)

                    break loop1;
                } // loop2

                // Permute rows m and i
                lscale[m - 1] = i;

                if (i != m) {

                    for (p = 0; p < (n - k + 1); p++) {
                        temp = A[i - 1][p + k - 1];
                        A[i - 1][p + k - 1] = A[m - 1][p + k - 1];
                        A[m - 1][p + k - 1] = temp;
                        temp = B[i - 1][p + k - 1];
                        B[i - 1][p + k - 1] = B[m - 1][p + k - 1];
                        B[m - 1][p + k - 1] = temp;
                    } // for (p = 0; p < n-k+1; p++)
                } // if (i != m)

                // Permute columns m and j
                rscale[m - 1] = j;

                if (j != m) {

                    for (p = 0; p < L; p++) {
                        temp = A[p][j - 1];
                        A[p][j - 1] = A[p][m - 1];
                        A[p][m - 1] = temp;
                        temp = B[p][j - 1];
                        B[p][j - 1] = B[p][m - 1];
                        B[p][m - 1] = temp;
                    } // for (p = 0; p < L; p++)
                } // if (j != m)

                if (iflow == 1) {
                    group = true;
                } // if (iflow == true)
                else { // iflow == 2
                    group = false;
                } // else iflow == 2
            } while (true); // loop1
        } // if ((job != 'S') && (job != 's'))

        ilo[0] = k;
        ihi[0] = L;

        if ((job == 'P') || (job == 'P')) {

            for (i = ilo[0]; i <= ihi[0]; i++) {
                lscale[i - 1] = 1.0;
                rscale[i - 1] = 1.0;
            }

            return;
        }

        if (ilo[0] == ihi[0]) {
            return;
        }

        // Balance the submatrix in rows ilo to ihi
        nr = ihi[0] - ilo[0] + 1;

        for (i = ilo[0] - 1; i < ihi[0]; i++) {
            rscale[i] = 0.0;
            lscale[i] = 0.0;

            work[i] = 0.0;
            work[i + n] = 0.0;
            work[i + (2 * n)] = 0.0;
            work[i + (3 * n)] = 0.0;
            work[i + (4 * n)] = 0.0;
            work[i + (5 * n)] = 0.0;
        } // for (i = ilo[0]-1; i < ihi[0]; i++)

        // Compute right side vector in resulting linear equations
        basl = 0.434294481903251 * Math.log(sclfac);

        for (i = ilo[0] - 1; i < ihi[0]; i++) {

            for (j = ilo[0] - 1; j < ihi[0]; j++) {
                tb = B[i][j];
                ta = A[i][j];

                if (ta != 0.0) {
                    ta = 0.434294481903251 * Math.log(Math.abs(ta)) / basl;
                }

                if (tb != 0.0) {
                    tb = 0.434294481903251 * Math.log(Math.abs(tb)) / basl;
                }

                work[i + (4 * n)] = work[i + (4 * n)] - ta - tb;
                work[j + (5 * n)] = work[j + (5 * n)] - ta - tb;
            } // for (j = ilo[0] - 1; j < ihi[0]; j++)
        } // for (i = ilo[0] - 1; i < ihi[0]; i++)

        coef = 1.0 / (2.0 * nr);
        coef2 = coef * coef;
        coef5 = 0.5 * coef2;
        nrp2 = nr + 2;
        beta = 0.0;
        it = 1;

// Start generalized conjugate gradient iteration
loop9:
        do {
            x = new double[nr];
            y = new double[nr];

            for (p = 0; p < nr; p++) {
                x[p] = work[ilo[0] - 1 + (4 * n) + p];
                y[p] = work[ilo[0] - 1 + (5 * n) + p];
            }

            gamma = ddot(nr, x, 1, x, 1) + ddot(nr, y, 1, y, 1);
            ew = 0.0;
            ewc = 0.0;

            for (i = ilo[0] - 1; i < ihi[0]; i++) {
                ew = ew + work[i + (4 * n)];
                ewc = ewc + work[i + (5 * n)];
            }

            gamma = (coef * gamma) - (coef2 * ((ew * ew) + (ewc * ewc))) - (coef5 * (ew - ewc) * (ew - ewc));

            if (gamma == 0.0) {
                break loop9;
            }

            if (it != 1) {
                beta = gamma / pgamma;
            }

            t = coef5 * (ewc - (3.0 * ew));
            tc = coef5 * (ew - (3.0 * ewc));

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + p] = beta * work[ilo[0] - 1 + p];
            }

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + n + p] = beta * work[ilo[0] - 1 + n + p];
            }

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + n + p] += coef * work[ilo[0] - 1 + (4 * n) + p];
            }

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + p] += coef * work[ilo[0] - 1 + (5 * n) + p];
            }

            for (i = ilo[0] - 1; i < ihi[0]; i++) {
                work[i] = work[i] + tc;
                work[i + n] = work[i + n] + t;
            }

            // Apply matrix to vector
            for (i = ilo[0] - 1; i < ihi[0]; i++) {
                kount = 0;
                sum = 0.0;

                for (j = ilo[0] - 1; j < ihi[0]; j++) {

                    if (A[i][j] != 0.0) {
                        kount = kount + 1;
                        sum = sum + work[j];
                    } // if (A[i][j] != 0.0)

                    if (B[i][j] != 0.0) {
                        kount = kount + 1;
                        sum = sum + work[j];
                    } // if (B[i][j] != 0.0)
                } // for (j = ilo[0]-1; j < ihi[0]; j++)

                work[i + (2 * n)] = (kount * work[i + n]) + sum;
            } // for (i = ilo[0]-1; i < ihi[0]; i++)

            for (j = ilo[0] - 1; j < ihi[0]; j++) {
                kount = 0;
                sum = 0.0;

                for (i = ilo[0] - 1; i < ihi[0]; i++) {

                    if (A[i][j] != 0.0) {
                        kount = kount + 1;
                        sum = sum + work[i + n];
                    } // if (A[i][j] != 0.0)

                    if (B[i][j] != 0.0) {
                        kount = kount + 1;
                        sum = sum + work[i + n];
                    } // if (B[i][j] != 0.0)
                } // for (i = ilo[0]-1; i < ihi[0]; i++)

                work[j + (3 * n)] = (kount * work[j]) + sum;
            } // for (j = ilo[0]-1; j < ihi[0]; j++)

            w = new double[nr];
            x = new double[nr];
            y = new double[nr];
            z = new double[nr];

            for (p = 0; p < nr; p++) {
                w[p] = work[ilo[0] - 1 + n + p];
                x[p] = work[ilo[0] - 1 + (2 * n) + p];
                y[p] = work[ilo[0] - 1 + p];
                z[p] = work[ilo[0] - 1 + (3 * n) + p];
            }

            sum = ddot(nr, w, 1, x, 1) + ddot(nr, y, 1, z, 1);
            alpha = gamma / sum;

            // Determine correction to current iteration
            cmax = 0.0;

            for (i = ilo[0] - 1; i < ihi[0]; i++) {
                cor = alpha * work[i + n];

                if (Math.abs(cor) > cmax) {
                    cmax = Math.abs(cor);
                }

                lscale[i] = lscale[i] + cor;
                cor = alpha * work[i];

                if (Math.abs(cor) > cmax) {
                    cmax = Math.abs(cor);
                }

                rscale[i] = rscale[i] + cor;
            } // for (i = ilo[0]-1; i < ihi[0]; i++)

            if (cmax < 0.5) {
                break loop9;
            } // if (cmax < 0.5)

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + (4 * n) + p] += -alpha * work[ilo[0] - 1 + (2 * n) + p];
            }

            for (p = 0; p < nr; p++) {
                work[ilo[0] - 1 + (5 * n) + p] += -alpha * work[ilo[0] - 1 + (3 * n) + p];
            }

            pgamma = gamma;
            it = it + 1;
        } while (it <= nrp2); // loop9

        // End generalized conjugate gradient iteration
        sfmin = dlamch('S');
        sfmax = 1.0 / sfmin;
        lsfmin = (int) ((0.434294481903251 * Math.log(sfmin) / basl) + 1.0);
        lsfmax = (int) (0.434294481903251 * Math.log(sfmax) / basl);

        for (i = ilo[0]; i <= ihi[0]; i++) {
            dmax = A[i - 1][ilo[0] - 1];
            irab = 1;

            for (p = 1; p < (n - ilo[0] + 1); p++) {

                if (A[i - 1][ilo[0] - 1 + p] > dmax) {
                    dmax = A[i - 1][ilo[0] - 1 + p];
                    irab = p + 1;
                }
            }

            rab = Math.abs(A[i - 1][irab + ilo[0] - 2]);
            dmax = B[i - 1][ilo[0] - 1];
            irab = 1;

            for (p = 1; p < (n - ilo[0] + 1); p++) {

                if (B[i - 1][ilo[0] - 1 + p] > dmax) {
                    dmax = B[i - 1][ilo[0] - 1 + p];
                    irab = p + 1;
                }
            }

            rab = Math.max(rab, Math.abs(B[i - 1][irab + ilo[0] - 2]));
            lrab = (int) ((0.434294481903251 * Math.log(rab + sfmin) / basl) + 1.0);

            if (lscale[i - 1] >= 0) {
                ir = (int) (lscale[i - 1] + 0.5);
            } else {
                ir = (int) (lscale[i - 1] - 0.5);
            }

            ir = Math.min(Math.max(ir, lsfmin), lsfmax);
            ir = Math.min(ir, lsfmax - lrab);
            lscale[i - 1] = Math.pow(sclfac, (double) (ir));
            dmax = A[0][i - 1];
            icab = 1;

            for (p = 1; p < ihi[0]; p++) {

                if (A[p][i - 1] > dmax) {
                    dmax = A[p][i - 1];
                    icab = p + 1;
                }
            }

            cab = Math.abs(A[icab - 1][i - 1]);
            dmax = B[0][i - 1];
            icab = 1;

            for (p = 1; p < ihi[0]; p++) {

                if (B[p][i - 1] > dmax) {
                    dmax = B[p][i - 1];
                    icab = p + 1;
                }
            }

            cab = Math.max(cab, Math.abs(B[icab - 1][i - 1]));
            lcab = (int) ((0.434294481903251 * Math.log(cab + sfmin) / basl) + 1.0);

            if (rscale[i - 1] >= 0.0) {
                jc = (int) (rscale[i - 1] + 0.5);
            } else {
                jc = (int) (rscale[i - 1] - 0.5);
            }

            jc = Math.min(Math.max(jc, lsfmin), lsfmax);
            jc = Math.min(jc, lsfmax - lcab);
            rscale[i - 1] = Math.pow(sclfac, (double) (jc));
        } // for (i = ilo[0]; i <= ihi[0]; i++)

        // Row scaling of matrices A and B
        for (i = ilo[0]; i <= ihi[0]; i++) {

            for (p = 0; p < (n - ilo[0] + 1); p++) {
                A[i - 1][ilo[0] - 1 + p] = lscale[i - 1] * A[i - 1][ilo[0] - 1 + p];
                B[i - 1][ilo[0] - 1 + p] = lscale[i - 1] * B[i - 1][ilo[0] - 1 + p];
            }
        } // for (i = ilo[0]; i <= ihi[0]; i++)

        // Column scaling of matrices A and B
        for (j = ilo[0]; j <= ihi[0]; j++) {

            for (p = 0; p < ihi[0]; p++) {
                A[p][j - 1] = rscale[j - 1] * A[p][j - 1];
                B[p][j - 1] = rscale[j - 1] * B[p][j - 1];
            }
        } // for (j = ilo[0]; j <= ihi[0]; j++)

        return;
    } // dggbal

    /**
     * This is a port of version 3.1 LAPACK routine DGGHRD Original DGGHRD created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 dgghrd reduces a pair of real matrices (A,B) to generalized
     * upper Hessenberg form using orthogonal transformations, where A is a general matrix and B is upper triangular.
     * The form of the generalized eigenvalue problem is A*x = lambda*B*x and B is typically made upper triangular by
     * computing its QR factorization and moving the orthogonal matrix Q to the left side of the equation.
     *
     * <p>This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**T * A * Z = H and transforms B to
     * another upper triangular matrix T: Q**T * B * Z = T in order to reduce the problem to its standard form H*y =
     * lambda*T*y where y = z**T * x</p>
     *
     * <p>The orthogonal matrices Q and Z are determined as products of Givens rotations. They may either be formed
     * explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**T = (Q1*Q) * H *
     * (Z1*Z)**T Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T</p>
     *
     * <p>If Q1 is the orthogonal matrix from the QR factorization of B in the original equation A*x = lambda*b*x, then
     * dgghrd reduces the original problem to the generalized Hessenberg form.</p>
     *
     * @param  compq  input char = 'N': do not compute Q = 'I': Q is initialized to the unit matrix, and the orthogonal
     *                matrix Q is returned = 'V': Q must contain an orthogonal matrix Q1 on entry, and the product Q1*Q
     *                is returned
     * @param  compz  input char = 'N': do not compute Z = 'I': Z is initialized to the unit matrix, and the orthogonal
     *                matrix Z is returned = 'V': Z must contain an orthogonal matrix Z1 on entry, and the product Z1*Z
     *                is returned
     * @param  n      input int The order of the matrices A and B. n >= 0.
     * @param  ilo    input int
     * @param  ihi    input int ilo and ihi mark the rows and columns of A which are to be reduced. It is assumed that A
     *                is already upper triangular in rows and columns 0:ilo-2 and ih:n-1. ilo and ihi are normally set
     *                by a previous call to dggbal; otherwise they should be set to 1 and n respectively. 1 <= ilo <=
     *                ihi <= n, if n > 0; ilo = 1 and ihi = 0, if n == 0.
     * @param  A      input/output double[][] of dimension (lda,n) On entry, the n by n general matrix to be reduced. On
     *                exit, the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg
     *                matrix H, and the rest is set to zero.
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,n).
     * @param  B      input/output double[][] of dimension (ldb,n) On entry, the n by n upper triangular matrix B. On
     *                exit, the upper triangular matrix T = Q**T B Z. The elements below the diagonal are set to zero.
     * @param  ldb    input int The leading dimension of the array B. ldb >= max(1,n).
     * @param  Q      input/output double[][] of dimension (ldq,n). On entry, if compq = 'V', the orthogonal matix Q1,
     *                typically from the QR factorization of B. On exit, if compq = 'I', the orthogonal matrix Q, and if
     *                compq = 'V', the product Q1*Q. Not referenced if compq = 'N'.
     * @param  ldq    input int The leading dimension of the array Q. ldq >= n if compq = 'V' or 'I'; ldq >= 1
     *                otherwise.
     * @param  Z      input/output double[][] of dimension (ldz,n) On entry, if compz = 'V', the orthogonal matrix Z1.
     *                On exit, if compz = 'I', the orthogonal matrix Z, and if compz = 'V', the product Z1*Z. Not
     *                referenced if compz = 'N'.
     * @param  ldz    input int The leading dimension of the array Z. ldz >= n if compz = 'V' or 'I'; ldz >= 1
     *                otherwise.
     * @param  info   output int[] = 0: successful exit. < 0: If info = -i, the i-th argument had an illegal value.
     *                Further details: This routine reduces A to Hessenberg and B to triangular form by an unblocked
     *                reduction, as described in Matrix Computations by Golub and Van Loan (Johns Hopkins Press).
     */
    private void dgghrd(char compq, char compz, int n, int ilo, int ihi, double[][] A, int lda, double[][] B, int ldb,
                        double[][] Q, int ldq, double[][] Z, int ldz, int[] info) {
        boolean ilq;
        boolean ilz;
        int icompq;
        int icompz;
        int jcol;
        int jrow;
        double[] c = new double[1];
        double[] s = new double[1];
        double temp;
        double[] aout = new double[1];
        double[] bout = new double[1];
        double[] dx;
        double[] dy;
        int i;

        // Decode compq
        if ((compq == 'N') || (compq == 'n')) {
            ilq = false;
            icompq = 1;
        } else if ((compq == 'V') || (compq == 'v')) {
            ilq = true;
            icompq = 2;
        } else if ((compq == 'I') || (compq == 'i')) {
            ilq = true;
            icompq = 3;
        } else {
            ilq = false;
            icompq = 0;
        }

        // Decode compz
        if ((compz == 'N') || (compz == 'n')) {
            ilz = false;
            icompz = 1;
        } else if ((compz == 'V') || (compz == 'v')) {
            ilz = true;
            icompz = 2;
        } else if ((compz == 'I') || (compz == 'i')) {
            ilz = true;
            icompz = 3;
        } else {
            ilz = false;
            icompz = 0;
        }

        // Test the input parameters
        info[0] = 0;

        if (icompq <= 0) {
            info[0] = -1;
        } else if (icompz <= 0) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (ilo < 1) {
            info[0] = -4;
        } else if ((ihi > n) || (ihi < (ilo - 1))) {
            info[0] = -5;
        } else if (lda < Math.max(1, n)) {
            info[0] = -7;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -9;
        } else if ((ilq && (ldq < n)) || (ldq < 1)) {
            info[0] = -11;
        } else if ((ilz && (ldz < n)) || (ldz < 1)) {
            info[0] = -13;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dgghrd had info[0] = " + info[0]);

            return;
        }

        // Initialize Q and Z if desired
        if (icompq == 3) {
            dlaset('F', n, n, 0.0, 1.0, Q, ldq);
        }

        if (icompz == 3) {
            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
        }

        // Quick return if possible
        if (n <= 1) {
            return;
        }

        // Zero out lower triangle of B
        for (jcol = 0; jcol < (n - 1); jcol++) {

            for (jrow = jcol + 1; jrow < n; jrow++) {
                B[jrow][jcol] = 0.0;
            }
        }

        // Reduce A and B
        for (jcol = ilo; jcol <= (ihi - 2); jcol++) {

            for (jrow = ihi; jrow >= (jcol + 2); jrow--) {

                // Step 1: rotate rows jrow-2, jrow-1 to kill A[jrow-1][jcol-1]
                temp = A[jrow - 2][jcol - 1];
                dlartg(temp, A[jrow - 1][jcol - 1], c, s, aout);
                A[jrow - 2][jcol - 1] = aout[0];
                A[jrow - 1][jcol - 1] = 0.0;
                dx = new double[n - jcol];
                dy = new double[n - jcol];

                for (i = 0; i < (n - jcol); i++) {
                    dx[i] = A[jrow - 2][jcol + i];
                    dy[i] = A[jrow - 1][jcol + i];
                }

                drot(n - jcol, dx, 1, dy, 1, c[0], s[0]);

                for (i = 0; i < (n - jcol); i++) {
                    A[jrow - 2][jcol + i] = dx[i];
                    A[jrow - 1][jcol + i] = dy[i];
                }

                dx = new double[n + 2 - jrow];
                dy = new double[n + 2 - jrow];

                for (i = 0; i < (n + 2 - jrow); i++) {
                    dx[i] = B[jrow - 2][jrow - 2 + i];
                    dy[i] = B[jrow - 1][jrow - 2 + i];
                }

                drot(n + 2 - jrow, dx, 1, dy, 1, c[0], s[0]);

                for (i = 0; i < (n + 2 - jrow); i++) {
                    B[jrow - 2][jrow - 2 + i] = dx[i];
                    B[jrow - 1][jrow - 2 + i] = dy[i];
                }

                if (ilq) {
                    dx = new double[n];
                    dy = new double[n];

                    for (i = 0; i < n; i++) {
                        dx[i] = Q[i][jrow - 2];
                        dy[i] = Q[i][jrow - 1];
                    }

                    drot(n, dx, 1, dy, 1, c[0], s[0]);

                    for (i = 0; i < n; i++) {
                        Q[i][jrow - 2] = dx[i];
                        Q[i][jrow - 1] = dy[i];
                    }
                } // if (ilq)

                // Step 2: Rotate columns jrow-1, jrow-2 to kill B[jrow-1][jrow-2]
                temp = B[jrow - 1][jrow - 1];
                dlartg(temp, B[jrow - 1][jrow - 2], c, s, bout);
                B[jrow - 1][jrow - 1] = bout[0];
                B[jrow - 1][jrow - 2] = 0.0;
                dx = new double[ihi];
                dy = new double[ihi];

                for (i = 0; i < ihi; i++) {
                    dx[i] = A[i][jrow - 1];
                    dy[i] = A[i][jrow - 2];
                }

                drot(ihi, dx, 1, dy, 1, c[0], s[0]);

                for (i = 0; i < ihi; i++) {
                    A[i][jrow - 1] = dx[i];
                    A[i][jrow - 2] = dy[i];
                }

                dx = new double[jrow - 1];
                dy = new double[jrow - 1];

                for (i = 0; i < (jrow - 1); i++) {
                    dx[i] = B[i][jrow - 1];
                    dy[i] = B[i][jrow - 2];
                }

                drot(jrow - 1, dx, 1, dy, 1, c[0], s[0]);

                for (i = 0; i < (jrow - 1); i++) {
                    B[i][jrow - 1] = dx[i];
                    B[i][jrow - 2] = dy[i];
                }

                if (ilz) {
                    dx = new double[n];
                    dy = new double[n];

                    for (i = 0; i < n; i++) {
                        dx[i] = Z[i][jrow - 1];
                        dy[i] = Z[i][jrow - 2];
                    }

                    drot(n, dx, 1, dy, 1, c[0], s[0]);

                    for (i = 0; i < n; i++) {
                        Z[i][jrow - 1] = dx[i];
                        Z[i][jrow - 2] = dy[i];
                    }
                } // if (ilz)
            } // for (jrow = ihi; jrow >= jcol+2; jrow--)
        } // for (jcol = ilo; jcol <= ihi-2; jcol++)

        return;
    } // dgghrd

    /**
     * This is a port of version 3.1 LAPACK routine DHGEQZ Original DHGEQZ created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 dhgeqz computes the eigenvalues of a real matrix pair (H,T),
     * where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. Matrix pairs
     * of this type are produced by the reduction to generalized upper Hessenberg form of a real matrix pair (A, B); A =
     * Q1*H*Z**T, B = Q1*T*Z1**T, as computed by dgghrd.
     *
     * <p>If job = 'S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H =
     * Q*S*Z**T, T = Q*P*Z**T, where Q and Z are orthogonal matrices, P is an upper triangular matrix, and S is a
     * quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal blocks.</p>
     *
     * <p>The 1-by-1 blocks correspond to real eigenvalues of the matrix pair (H, T) and the 2-by-2 blocks correspond to
     * complex conjugate pairs of eigenvalues.</p>
     *
     * <p>Additionally, the 2-by-2 upper triangular diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced
     * to positive diagonal form, i.e., if (S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0, P(j,j) > 0, and
     * P(j+1,j+1) > 0.</p>
     *
     * <p>Optionally, the orthogonal matrix Q from the generalized Schur factorization may be postmultiplied into an
     * input matrix Q1, and the orthogonal matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the
     * orthogonal matrices from dgghrd that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the
     * output matrices Q1*Q and Z1*Z are the orthogonal factors from the generalized Schur factorization of (A,B): A =
     * (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.</p>
     *
     * <p>To avoid overflow, eignevalues of the matrix pair (H,T) (equivalently, of (A,b)) are computed as a pair of
     * values (alpha, beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an
     * eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu
     * = beta / alpha is an eigenvalue fo the alternate form of the GNEP mu*A*y = B*y Real eigenvalues can be read
     * directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i)</p>
     *
     * <p>Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix Eigenvalue Problems", SIAM J. Numer.
     * Anal., 10(1973), pp. 241- 256.</p>
     *
     * @param  job     input char = 'E': Compute eigenvalues only = 'S': Compute eigenvalues and the Schur form.
     * @param  compq   input char = 'N': Left Schur vectors (Q) are not computed. = 'I': Q is initialized to the unit
     *                 matrix and the matrix Q of left Schur vectors of (H,T) is returned. = 'V': Q must contain an
     *                 orthogonal matrix Q1 on entry and the product Q1*Q is returned.
     * @param  compz   input char = 'N': Right Schur vectors (Z) are not computed. = 'I': Z is initialized to the unit
     *                 matrix and the matrix Z of right Schur vectors of (H,T) is returned. = 'V': Z must contain an
     *                 orthogonal matrix Z1 on entry and the product Z1*Z is returned.
     * @param  n       input int The order of matrices H, T, Q, and Z. n >= 0.
     * @param  ilo     input int
     * @param  ihi     input int ilo and ihi mark the rows and columns of H which are in Hessenberg form. It is assumed
     *                 that A is already upper triangular in rows and columns 0:ilo-2 and ihi:n-1. If n > 0, 1 <= ilo <=
     *                 ihi <= n; if n = 0, ilo = 1 and ihi = 0.
     * @param  H       (input/output) double[][] of dimension (ldh,n) On entry, the n by n upper Hessenberg matrix H. On
     *                 exit, if job = 'S', H contains the upper quasi-triangluar matrix S from the generalized Schur
     *                 factorization; 2-by-2 diagonal blocks (corresponding to complex conjugate pairs of eigenvalues)
     *                 are returned in standard form, with H(i,i) = H(i+1,i+1) and H(i+1,i) * H(i,i+1) < 0. if job =
     *                 'E', the diagonal blocks of H match those of S, but the rest of H is unspecified
     * @param  ldh     input int The leading dimension of the array H. ldh >= max(1, n).
     * @param  T       (input/output) double[][] of dimension (ldt,n) On entry, the n by n upper triangular matrix T. On
     *                 exit, if job = 'S', T contains the upper triangular matrix P from the generalized Schur
     *                 factorization; 2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to
     *                 postive diagonal form, i.e., if H(j+1,j) is non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) > 0,
     *                 and T(j+1,j+1) > 0. if job = 'E', the diagonal blocks of T match those of P, but the rest of T is
     *                 unspecified.
     * @param  ldt     input int The leading dimension of the array T. ldt >= max(1,n).
     * @param  alphar  output double[] of dimension (n) The real parts of each scalar alpha definfing an eigenvalue of
     *                 GNEP.
     * @param  alphai  output double[] of dimension (n) The imaginary parts of each scalar alpha defining an eigenvalue
     *                 of GNEP. If alphai[j] is zero, then the j-th eigenvalue is real; if positive, then the j-th and
     *                 (j+1)-st eigenvalues are a complex conjugate pair, with alpha(j+1) = -alpha(j).
     * @param  beta    output double[] of dimension (n) The scalars beta that define the eigenvalues of GNEP. Together,
     *                 the quantities alpha = (alphar[j], alphai[j]) and beta = beta[j] represent the j-th eigenvalue of
     *                 the matrix pair (A,B), in one of the forms lambda = alpha/beta or mu = beta/alpha. Since either
     *                 lambda or mu may overflow, they should not, in general, be computed.
     * @param  Q       (input/output) double[][] of dimension (ldq,n) On entry, if compz = 'V', the orthogonal matrix Q1
     *                 is used in the reduction of (A,B) to generalized Hessenberg form. On exit, if compz = 'I', the
     *                 orthogonal matrix of left Schur vectors of (H,T), and if compz = 'V', the orthogonal matrix of
     *                 left Schur vectors of (A,B). Not referenced if compz = 'N'.
     * @param  ldq     input int The leading dimension of the array Q. ldq >= 1. If compq = 'V' or 'I', then ldq >= n.
     * @param  Z       (input/output) double[][] of dimension (ldz,n) On entry, if compz = 'V', the orthogonal matrix Z1
     *                 is used in the reduction of (A,B) to generalized Hessenberg form. On exit, if compz = 'I', the
     *                 orthogonal matrix of right Schur vectors of (H,T), and if compz = 'V', the orthogonal matrix of
     *                 right Schur vectors of (A,B). Not referenced if compz = 'N'.
     * @param  ldz     input int The leading dimension of the array Z. ldz >= 1. If compz = 'V' or 'I', then ldz >= n.
     * @param  work    (workspace/output) double[] of dimension max(1,lwork) On exit, if info[0] >= 0, work[0] returns
     *                 the optimal lwork.
     * @param  lwork   input int The dimension of the array work. lwork >= max(1,n). If lwork = -1, then a workspace
     *                 query is assumed; the routine only calculates the optimal size of the work array, returns this
     *                 value as the first entry of the work array, and no error message related to lwork is output.
     * @param  info    output int[] = 0: successful exit. < 0: If info[0] = -i, the i-th argument had an illegal value =
     *                 1,...,n: the QZ iteration did not converge. (H,T) is not in Schur form, but alphar[i], alphai[i],
     *                 and beta[i], i = info,...,n-1 should be correct. = n+1,...,2*n: the shift calculation failed.
     *                 (H,T) is not in Schur form, but alphar[i], alphai[i], and beta[i], i = info-n,...,n-1 should be
     *                 correct
     */
    private void dhgeqz(char job, char compq, char compz, int n, int ilo, int ihi, double[][] H, int ldh, double[][] T,
                        int ldt, double[] alphar, double[] alphai, double[] beta, double[][] Q, int ldq, double[][] Z,
                        int ldz, double[] work, int lwork, int[] info) {
        double safety = 100.0;
        boolean ilazr2;
        boolean ilazro;
        boolean ilpivt;
        boolean ilq;
        boolean ilschr;
        boolean ilz;
        boolean lquery;
        int i;
        int icompq;
        int icompz;
        int ifirst;
        int ifrstm;

        // Counts iterations run since ilast was last changed.  This is therefore
        // reset only when a 1 by 1 or a 2 by 2 block deflates off the bottom.
        int iiter;
        int ilast;
        int ilastm;
        int in;
        int ischur;
        int istart;
        int j;
        int jc;
        int jch;

        // Counts iterations
        int jiter;
        int jr;
        int k;
        int maxit;
        double a11;
        double a12;
        double a1i;
        double a1r;
        double a21;
        double a22;
        double a2i;
        double a2r;
        double ad11;
        double ad11L;
        double ad12;
        double ad12L;
        double ad21;
        double ad21L;
        double ad22;
        double ad22L;
        double ad32L;
        double an;
        double anorm;
        double[] hout = new double[1];
        double ascale;
        double atol;
        double[] b11 = new double[1];
        ;

        double b1a;
        double b1i;
        double b1r;
        double[] b22 = new double[1];
        double b2a;
        double b2i;
        double b2r;
        double bn;
        double bnorm;
        double[] tout = new double[1];
        double bscale;
        double btol;
        double[] c = new double[1];
        double c11i;
        double c11r;
        double c12;
        double c21;
        double c22i;
        double c22r;
        double[] cL = new double[1];
        double cq;
        double[] cr = new double[1];
        double cz;
        double[] dx;
        double[] dy;
        double eshift;
        double[] s = new double[1];
        double[] s1 = new double[1];
        double s1inv;
        double[] s2 = new double[1];
        double safmax;
        double safmin;
        double scale;
        double[] sL = new double[1];
        double sqi;
        double sqr;
        double[] sr = new double[1];
        double szi;
        double szr;
        double t1;
        double[] tau = new double[1];
        double[] temp = new double[1];
        double[] temp2 = new double[1];
        double tempi;
        double[] tempr = new double[1];
        double u1;
        double u12;
        double u12L;
        double u2;
        double ulp;
        double vs;
        double w11;
        double w12;
        double w21;
        double w22;
        double wabs;
        double[] wi = new double[1];
        double[] wr = new double[1];
        double[] wr2 = new double[1];
        double[] v = new double[3];
        double[][] array1;
        double[][] array2;


        // Decode job, compq, compz
        if ((job == 'E') || (job == 'e')) {
            ilschr = false;
            ischur = 1;
        } else if ((job == 'S') || (job == 's')) {
            ilschr = true;
            ischur = 2;
        } else {
            ilschr = false;
            ischur = 0;
        }

        if ((compq == 'N') || (compq == 'n')) {
            ilq = false;
            icompq = 1;
        } else if ((compq == 'V') || (compq == 'v')) {
            ilq = true;
            icompq = 2;
        } else if ((compq == 'I') || (compq == 'i')) {
            ilq = true;
            icompq = 3;
        } else {
            ilq = false;
            icompq = 0;
        }

        if ((compz == 'N') || (compz == 'n')) {
            ilz = false;
            icompz = 1;
        } else if ((compz == 'V') || (compz == 'v')) {
            ilz = true;
            icompz = 2;
        } else if ((compz == 'I') || (compz == 'i')) {
            ilz = true;
            icompz = 3;
        } else {
            ilz = false;
            icompz = 0;
        }

        // Check argument values
        info[0] = 0;
        work[0] = Math.max(1, n);
        lquery = (lwork == -1);

        if (ischur == 0) {
            info[0] = -1;
        } else if (icompq == 0) {
            info[0] = -2;
        } else if (icompz == 0) {
            info[0] = -3;
        } else if (n < 0) {
            info[0] = -4;
        } else if (ilo < 1) {
            info[0] = -5;
        } else if ((ihi > n) || (ihi < (ilo - 1))) {
            info[0] = -6;
        } else if (ldh < n) {
            info[0] = -8;
        } else if (ldt < n) {
            info[0] = -10;
        } else if ((ldq < 1) || (ilq && (ldq < n))) {
            info[0] = -15;
        } else if ((ldz < 1) || (ilz && (ldz < n))) {
            info[0] = -17;
        } else if ((lwork < Math.max(1, n)) && (!lquery)) {
            info[0] = -19;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dhgeqz had info[0] = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n <= 0) {
            work[0] = 1.0;

            return;
        }

        // Initialize Q and Z
        if (icompq == 3) {
            dlaset('F', n, n, 0.0, 1.0, Q, ldq);
        }

        if (icompz == 3) {
            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
        }

        // Machine constants
        in = ihi + 1 - ilo;
        safmin = dlamch('S');
        safmax = 1.0 / safmin;
        ulp = dlamch('E') * dlamch('B');
        array1 = new double[in][in];

        for (i = 0; i < in; i++) {

            for (j = 0; j < in; j++) {
                array1[i][j] = H[ilo - 1 + i][ilo - 1 + j];
            }
        }

        anorm = dlanhs('F', in, array1, in, work);

        for (i = 0; i < in; i++) {

            for (j = 0; j < in; j++) {
                array1[i][j] = T[ilo - 1 + i][ilo - 1 + j];
            }
        }

        bnorm = dlanhs('F', in, array1, in, work);
        atol = Math.max(safmin, ulp * anorm);
        btol = Math.max(safmin, ulp * bnorm);
        ascale = 1.0 / Math.max(safmin, anorm);
        bscale = 1.0 / Math.max(safmin, bnorm);

        // Set Eigenvalues ihi+1:n
        for (j = ihi; j < n; j++) {

            if (T[j][j] < 0.0) {

                if (ilschr) {

                    for (jr = 0; jr <= j; jr++) {
                        H[jr][j] = -H[jr][j];
                        T[jr][j] = -T[jr][j];
                    }
                } // if (ilschr)
                else { // !ilschr
                    H[j][j] = -H[j][j];
                    T[j][j] = -T[j][j];
                } // else !ilschr

                if (ilz) {

                    for (jr = 0; jr < n; jr++) {
                        Z[jr][j] = -Z[jr][j];
                    } // for (jr = 0; jr < n; jr++)
                } // if (ilz)
            } // if (B[j][j] < 0.0)

            alphar[j] = H[j][j];
            alphai[j] = 0.0;
            beta[j] = T[j][j];
        } // for (j = ihi; j < n; j++)

// If ihi < ilo, skip QZ steps
loop1:   {

            if (ihi < ilo) {
                break loop1;
            }
            // Main QZ iteration loop

            // Initialize dynamic indices

            // Eigenvalues ilast+1:n have been found.
            // Column operations modify rows ifrstm-1:whatever-1.
            // Row operations operations modify columns whatever-1:ilastm-1.

            // If only eigenvalues are being computed, then ifrstm-1 is the row
            // of the last splitting row above row ilast-1;  this is always at
            // least ilo-1.
            // iiter counts iterations since the last eigenvalue was found, to
            // tell when to use an extraordinary shift.
            // maxit is the maximum number of qz sweeps allowed.

            ilast = ihi;

            if (ilschr) {
                ifrstm = 1;
                ilastm = n;
            } else {
                ifrstm = ilo;
                ilastm = ihi;
            }

            iiter = 0;
            eshift = 0.0;
            maxit = 300 * (ihi - ilo + 1);

            for (jiter = 1; jiter <= maxit; jiter++) {
                // Split the matrix if possible

// Two tests:
// 1: H[j][j-1] = 0 or j = ilo
// 2: T[j][j] = 0
loop2:           {

loop4:               {

loop5:                   {

loop6:                       {

                                if (ilast == ilo) {

                                    // Special case: j = ilast
                                    break loop6;
                                } else if (Math.abs(H[ilast - 1][ilast - 2]) <= atol) {
                                    H[ilast - 1][ilast - 2] = 0.0;

                                    break loop6;
                                } // else if (Math.abs(H[ilast-1][ilast-2]) <= atol)

loop7:                           {

                                    if (Math.abs(T[ilast - 1][ilast - 1]) <= btol) {
                                        T[ilast - 1][ilast - 1] = 0.0;

                                        break loop7;
                                    } // if (Math.abs(T[ilast-1][ilast-1]) <= btol)

                                    // General case: j < ilast
                                    for (j = ilast - 1; j >= ilo; j--) {

                                        // Test 1: for H[j-1][j-2] = 0 or j = ilo
                                        if (j == ilo) {
                                            ilazro = true;
                                        } else if (Math.abs(H[j - 1][j - 2]) <= atol) {
                                            H[j - 1][j - 2] = 0.0;
                                            ilazro = true;
                                        } // else if (Math.abs(H[j-1][j-2]) <= atol)
                                        else {
                                            ilazro = false;
                                        } // else

                                        // Test2: for T[j-1][j-1] = 0
                                        if (Math.abs(T[j - 1][j - 1]) < btol) {
                                            T[j - 1][j - 1] = 0.0;

                                            // Test 1a: Check for 2 consecutive small
                                            // subdiagonals in H
                                            ilazr2 = false;

                                            if (!ilazro) {
                                                temp[0] = Math.abs(H[j - 1][j - 2]);
                                                temp2[0] = Math.abs(H[j - 1][j - 1]);
                                                tempr[0] = Math.max(temp[0], temp2[0]);

                                                if ((tempr[0] < 1.0) && (tempr[0] != 0.0)) {
                                                    temp[0] = temp[0] / tempr[0];
                                                    temp2[0] = temp2[0] / tempr[0];
                                                } // if ((tempr[0] < 1.0) && (tempr[0] != 0.0))

                                                if ((temp[0] * (ascale * Math.abs(H[j][j - 1]))) <=
                                                        (temp2[0] * (ascale * atol))) {
                                                    ilazr2 = true;
                                                } // if (temp[0]*(ascale*Math.abs(A[j][j-1])) <=
                                            } // if (!ilazro)

                                            // If both tests pass (1 & 2), i.e., the leading
                                            // diagonal of T in the block is zero, split a 1x1
                                            // block off at the top. (i.e., at the (j-1)-th
                                            // row/column)  The leading diagonal element of
                                            // the remainder can also be zero, so this may have
                                            // to be done repeatedly.

                                            if (ilazro || ilazr2) {

                                                for (jch = j; jch <= (ilast - 1); jch++) {
                                                    temp[0] = H[jch - 1][jch - 1];
                                                    dlartg(temp[0], H[jch][jch - 1], c, s, hout);
                                                    H[jch - 1][jch - 1] = hout[0];
                                                    H[jch][jch - 1] = 0.0;
                                                    dx = new double[ilastm - jch];
                                                    dy = new double[ilastm - jch];

                                                    for (i = 0; i < (ilastm - jch); i++) {
                                                        dx[i] = H[jch - 1][jch + i];
                                                        dy[i] = H[jch][jch + i];
                                                    }

                                                    drot(ilastm - jch, dx, 1, dy, 1, c[0], s[0]);

                                                    for (i = 0; i < (ilastm - jch); i++) {
                                                        H[jch - 1][jch + i] = dx[i];
                                                        H[jch][jch + i] = dy[i];
                                                    }

                                                    for (i = 0; i < (ilastm - jch); i++) {
                                                        dx[i] = T[jch - 1][jch + i];
                                                        dy[i] = T[jch][jch + i];
                                                    }

                                                    drot(ilastm - jch, dx, 1, dy, 1, c[0], s[0]);

                                                    for (i = 0; i < (ilastm - jch); i++) {
                                                        T[jch - 1][jch + i] = dx[i];
                                                        T[jch][jch + i] = dy[i];
                                                    }

                                                    if (ilq) {
                                                        dx = new double[n];
                                                        dy = new double[n];

                                                        for (i = 0; i < n; i++) {
                                                            dx[i] = Q[i][jch - 1];
                                                            dy[i] = Q[i][jch];
                                                        }

                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

                                                        for (i = 0; i < n; i++) {
                                                            Q[i][jch - 1] = dx[i];
                                                            Q[i][jch] = dy[i];
                                                        }
                                                    } // if (ilq)

                                                    if (ilazr2) {
                                                        H[jch - 1][jch - 2] = H[jch - 1][jch - 2] * c[0];
                                                    } // if (ilazr2)

                                                    ilazr2 = false;

                                                    if (Math.abs(T[jch][jch]) >= btol) {

                                                        if ((jch + 1) >= ilast) {
                                                            break loop6;
                                                        } // if (jch+1 >= ilast)
                                                        else {
                                                            ifirst = jch + 1;

                                                            break loop5;
                                                        } // else
                                                    } // if (Math.abs(T[jch][jch]) >= btol)

                                                    T[jch][jch] = 0.0;
                                                } // for (jch = j; jch <= ilast-1; jch++)

                                                break loop7;
                                            } // if (ilazro || ilazr2)
                                            else { // !(ilazro || ilazr2)

                                                // Only test 2 passed -- chase the zero to
                                                // T[ilast-1][ilast-1]
                                                // Then process as in the case
                                                // T[ilast-1][ilast-1] = 0
                                                for (jch = j; jch <= (ilast - 1); jch++) {
                                                    temp[0] = T[jch - 1][jch];
                                                    dlartg(temp[0], T[jch][jch], c, s, tout);
                                                    T[jch - 1][jch] = tout[0];
                                                    T[jch][jch] = 0.0;

                                                    if (jch < (ilastm - 1)) {
                                                        dx = new double[ilastm - jch - 1];
                                                        dy = new double[ilastm - jch - 1];

                                                        for (i = 0; i < (ilastm - jch - 1); i++) {
                                                            dx[i] = T[jch - 1][jch + 1 + i];
                                                            dy[i] = T[jch][jch + 1 + i];
                                                        } // for (i = 0; i < ilastm-jch-1; i++)

                                                        drot(ilastm - jch - 1, dx, 1, dy, 1, c[0], s[0]);

                                                        for (i = 0; i < (ilastm - jch - 1); i++) {
                                                            T[jch - 1][jch + 1 + i] = dx[i];
                                                            T[jch][jch + 1 + i] = dy[i];
                                                        } // for (i = 0; i < ilastm-jch-1; i++)
                                                    } // if (jch < ilastm-1)

                                                    dx = new double[ilastm - jch + 2];
                                                    dy = new double[ilastm - jch + 2];

                                                    for (i = 0; i < (ilastm - jch + 2); i++) {
                                                        dx[i] = H[jch - 1][jch - 2 + i];
                                                        dy[i] = H[jch][jch - 2 + i];
                                                    } // for (i = 0; i < ilastm-jch+2; i++)

                                                    drot(ilastm - jch + 2, dx, 1, dy, 1, c[0], s[0]);

                                                    for (i = 0; i < (ilastm - jch + 2); i++) {
                                                        H[jch - 1][jch - 2 + i] = dx[i];
                                                        H[jch][jch - 2 + i] = dy[i];
                                                    } // for (i = 0; i < ilastm-jch+2; i++)

                                                    if (ilq) {
                                                        dx = new double[n];
                                                        dy = new double[n];

                                                        for (i = 0; i < n; i++) {
                                                            dx[i] = Q[i][jch - 1];
                                                            dy[i] = Q[i][jch];
                                                        }

                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

                                                        for (i = 0; i < n; i++) {
                                                            Q[i][jch - 1] = dx[i];
                                                            Q[i][jch] = dy[i];
                                                        }
                                                    } // if (ilq)

                                                    temp[0] = H[jch][jch - 1];
                                                    dlartg(temp[0], H[jch][jch - 2], c, s, hout);
                                                    H[jch][jch - 1] = hout[0];
                                                    H[jch][jch - 2] = 0.0;
                                                    dx = new double[jch + 1 - ifrstm];
                                                    dy = new double[jch + 1 - ifrstm];

                                                    for (i = 0; i < (jch + 1 - ifrstm); i++) {
                                                        dx[i] = H[ifrstm - 1 + i][jch - 1];
                                                        dy[i] = H[ifrstm - 1 + i][jch - 2];
                                                    }

                                                    drot(jch + 1 - ifrstm, dx, 1, dy, 1, c[0], s[0]);

                                                    for (i = 0; i < (jch + 1 - ifrstm); i++) {
                                                        H[ifrstm - 1 + i][jch - 1] = dx[i];
                                                        H[ifrstm - 1 + i][jch - 2] = dy[i];
                                                    }

                                                    dx = new double[jch - ifrstm];
                                                    dy = new double[jch - ifrstm];

                                                    for (i = 0; i < (jch - ifrstm); i++) {
                                                        dx[i] = T[ifrstm - 1 + i][jch - 1];
                                                        dy[i] = T[ifrstm - 1 + i][jch - 2];
                                                    }

                                                    drot(jch - ifrstm, dx, 1, dy, 1, c[0], s[0]);

                                                    for (i = 0; i < (jch - ifrstm); i++) {
                                                        T[ifrstm - 1 + i][jch - 1] = dx[i];
                                                        T[ifrstm - 1 + i][jch - 2] = dy[i];
                                                    }

                                                    if (ilz) {
                                                        dx = new double[n];
                                                        dy = new double[n];

                                                        for (i = 0; i < n; i++) {
                                                            dx[i] = Z[i][jch - 1];
                                                            dy[i] = Z[i][jch - 2];
                                                        }

                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

                                                        for (i = 0; i < n; i++) {
                                                            Z[i][jch - 1] = dx[i];
                                                            Z[i][jch - 2] = dy[i];
                                                        }
                                                    } // if (ilz)
                                                } // for (jch = j; jch <= ilast-1; jch++)

                                                break loop7;
                                            } // else !(ilazro || ilazr2)
                                        } // if (Math.abs(B[j-1][j-1]) < btol)
                                        else if (ilazro) {

                                            // Only 1 test passed -- work on j-1:ilast-1
                                            ifirst = j;

                                            break loop5;
                                        } // else if (ilazro)
                                        // Neither test passed -- try next j
                                    } // for (j = ilast-1; j >= ilo; j--)

                                    // (Drop-through is impossible)
                                    info[0] = n + 1;
                                    work[0] = n;

                                    return;

                                    // T[ilast-1][ilast-1] = 0 -- Clear H[ilast-1][ilast-2]
                                    // to split off a 1x1 block.
                                } // loop7

                                temp[0] = H[ilast - 1][ilast - 1];
                                dlartg(temp[0], H[ilast - 1][ilast - 2], c, s, hout);
                                H[ilast - 1][ilast - 1] = hout[0];
                                H[ilast - 1][ilast - 2] = 0.0;
                                dx = new double[ilast - ifrstm];
                                dy = new double[ilast - ifrstm];

                                for (i = 0; i < (ilast - ifrstm); i++) {
                                    dx[i] = H[ifrstm - 1 + i][ilast - 1];
                                    dy[i] = H[ifrstm - 1 + i][ilast - 2];
                                }

                                drot(ilast - ifrstm, dx, 1, dy, 1, c[0], s[0]);

                                for (i = 0; i < (ilast - ifrstm); i++) {
                                    H[ifrstm - 1 + i][ilast - 1] = dx[i];
                                    H[ifrstm - 1 + i][ilast - 2] = dy[i];
                                }

                                for (i = 0; i < (ilast - ifrstm); i++) {
                                    dx[i] = T[ifrstm - 1 + i][ilast - 1];
                                    dy[i] = T[ifrstm - 1 + i][ilast - 2];
                                }

                                drot(ilast - ifrstm, dx, 1, dy, 1, c[0], s[0]);

                                for (i = 0; i < (ilast - ifrstm); i++) {
                                    T[ifrstm - 1 + i][ilast - 1] = dx[i];
                                    T[ifrstm - 1 + i][ilast - 2] = dy[i];
                                }

                                if (ilz) {
                                    dx = new double[n];
                                    dy = new double[n];

                                    for (i = 0; i < n; i++) {
                                        dx[i] = Z[i][ilast - 1];
                                        dy[i] = Z[i][ilast - 2];
                                    }

                                    drot(n, dx, 1, dy, 1, c[0], s[0]);

                                    for (i = 0; i < n; i++) {
                                        Z[i][ilast - 1] = dx[i];
                                        Z[i][ilast - 2] = dy[i];
                                    }
                                } // if (ilz)
                                // H{ilast-1][ilast-2] = 0 -- Standardize T, set alphar,
                                // alphai, and beta
                            } // loop6

                            if (T[ilast - 1][ilast - 1] < 0.0) {

                                if (ilschr) {

                                    for (j = ifrstm - 1; j < ilast; j++) {
                                        H[j][ilast - 1] = -H[j][ilast - 1];
                                        T[j][ilast - 1] = -T[j][ilast - 1];
                                    } // for (j = ifrstm-1; j < ilast; j++)
                                } // if (ilschr)
                                else { // !ilschr
                                    H[ilast - 1][ilast - 1] = -H[ilast - 1][ilast - 1];
                                    T[ilast - 1][ilast - 1] = -T[ilast - 1][ilast - 1];
                                } // else !ilschr

                                if (ilz) {

                                    for (j = 0; j < n; j++) {
                                        Z[j][ilast - 1] = -Z[j][ilast - 1];
                                    }
                                } // if (ilz)
                            } // if (T[ilast-1][ilast-1] < 0.0)

                            alphar[ilast - 1] = H[ilast - 1][ilast - 1];
                            alphai[ilast - 1] = 0.0;
                            beta[ilast - 1] = T[ilast - 1][ilast - 1];

                            // Go to next block -- exit if finished.
                            ilast = ilast - 1;

                            if (ilast < ilo) {
                                break loop1;
                            } // if (ilast < ilo)

                            // Reset counters
                            iiter = 0;
                            eshift = 0.0;

                            if (!ilschr) {
                                ilastm = ilast;

                                if (ifrstm > ilast) {
                                    ifrstm = ilo;
                                } // if (ifrstm > ilast)
                            } // if (!ilschr)

                            break loop2;
                        } // loop5

                        // QZ step
                        // This iteration only involves rows/columns ifirst-1:ilast-1.
                        // We assume ifirst < ilast, and that the diagonal of T is
                        // nonzero.
                        iiter = iiter + 1;

                        if (!ilschr) {
                            ifrstm = ifirst;
                        } // if (!ilschr)

                        // compute single shifts

                        // At this point, ifirst < ilast, and the diagonal elements of
                        // T[(ifirst-1:ilast-1,ifirst-1:ilast-1) are larger than btol
                        // (in magnitude)
                        if (((iiter / 10) * 10) == iiter) {

                            // Exceptional shift.  Chosen for no particularly good
                            // reason (Single shift only.)
                            if (((maxit * safmin) * Math.abs(H[ilast - 2][ilast - 1])) <
                                    Math.abs(T[ilast - 2][ilast - 2])) {
                                eshift = eshift + (H[ilast - 2][ilast - 1] / T[ilast - 2][ilast - 2]);
                            } // if ((maxit*safmin)*Math.abs(H[ilast-2][ilast-1]) <
                            else {
                                eshift = eshift + (1.0 / (safmin * maxit));
                            } // else

                            s1[0] = 1.0;
                            wr[0] = eshift;
                        } // if ((iiter/10)*10 == iiter)
                        else { // ((iiter/10)*10 != iiter)

                            // Shifts based on the generalized eigenvalues of the
                            // bottom-right 2x2 block of H and T.  Ths first eigenvalue
                            // returned by dlag2 is the Wilkinson shift (AEP p.512).
                            array1 = new double[2][2];
                            array2 = new double[2][2];

                            for (i = 0; i < 2; i++) {

                                for (k = 0; k < 2; k++) {
                                    array1[i][k] = H[ilast - 2 + i][ilast - 2 + k];
                                    array2[i][k] = T[ilast - 2 + i][ilast - 2 + k];
                                }
                            }

                            dlag2(array1, 2, array2, 2, safmin * safety, s1, s2, wr, wr2, wi);
                            temp[0] = Math.max(1.0, Math.abs(wr[0]));
                            temp[0] = safmin * Math.max(temp[0], Math.abs(wi[0]));
                            temp[0] = Math.max(s1[0], temp[0]);

                            if (wi[0] != 0.0) {
                                break loop4;
                            } // if (wi[0] != 0.0)
                        } // else ((iiter/10)*10 != iiter)

                        // Fiddle with shift to avoid overflow
                        temp[0] = Math.min(ascale, 1.0) * (0.5 * safmax);

                        if (s1[0] > temp[0]) {
                            scale = temp[0] / s1[0];
                        } else {
                            scale = 1.0;
                        }

                        temp[0] = Math.min(bscale, 1.0) * (0.5 * safmax);

                        if (Math.abs(wr[0]) > temp[0]) {
                            scale = Math.min(scale, temp[0] / Math.abs(wr[0]));
                        }

                        s1[0] = scale * s1[0];
                        wr[0] = scale * wr[0];

// Now check for two consecutive small subdiagonals
loop8:                   {

                            for (j = ilast - 1; j >= (ifirst + 1); j--) {
                                istart = j;
                                temp[0] = Math.abs(s1[0] * H[j - 1][j - 2]);
                                temp2[0] = Math.abs((s1[0] * H[j - 1][j - 1]) - (wr[0] * T[j - 1][j - 1]));
                                tempr[0] = Math.max(temp[0], temp2[0]);

                                if ((tempr[0] < 1.0) && (tempr[0] != 0.0)) {
                                    temp[0] = temp[0] / tempr[0];
                                    temp2[0] = temp2[0] / tempr[0];
                                } // if ((tempr[0] < 1.0) && (tempr[0] != 0.0))

                                if (Math.abs((ascale * H[j][j - 1]) * temp[0]) <= ((ascale * atol) * temp2[0])) {
                                    break loop8;
                                } // if (Math.abs((ascale*A[j][j-1])*temp) <=
                            } // for (j = ilast-1; j >= ifirst+1; j--)

                            istart = ifirst;
                        } // loop8

                        // Do an implicit single-shift QZ sweep.
                        // Initial Q;
                        temp[0] = (s1[0] * H[istart - 1][istart - 1]) - (wr[0] * T[istart - 1][istart - 1]);
                        temp2[0] = s1[0] * H[istart][istart - 1];
                        dlartg(temp[0], temp2[0], c, s, tempr);

                        // Sweep
                        for (j = istart; j <= (ilast - 1); j++) {

                            if (j > istart) {
                                temp[0] = H[j - 1][j - 2];
                                dlartg(temp[0], H[j][j - 2], c, s, hout);
                                H[j - 1][j - 2] = hout[0];
                                H[j][j - 2] = 0.0;
                            } // if (j > istart)

                            for (jc = j; jc <= ilastm; jc++) {
                                temp[0] = (c[0] * H[j - 1][jc - 1]) + (s[0] * H[j][jc - 1]);
                                H[j][jc - 1] = (-s[0] * H[j - 1][jc - 1]) + (c[0] * H[j][jc - 1]);
                                H[j - 1][jc - 1] = temp[0];
                                temp2[0] = (c[0] * T[j - 1][jc - 1]) + (s[0] * T[j][jc - 1]);
                                T[j][jc - 1] = (-s[0] * T[j - 1][jc - 1]) + (c[0] * T[j][jc - 1]);
                                T[j - 1][jc - 1] = temp2[0];
                            } // for (jc = j; jc <= ilastm; jc++)

                            if (ilq) {

                                for (jr = 1; jr <= n; jr++) {
                                    temp[0] = (c[0] * Q[jr - 1][j - 1]) + (s[0] * Q[jr - 1][j]);
                                    Q[jr - 1][j] = (-s[0] * Q[jr - 1][j - 1]) + (c[0] * Q[jr - 1][j]);
                                    Q[jr - 1][j - 1] = temp[0];
                                } // for (jr = 1; jr <= n; jr++)
                            } // if (ilq)

                            temp[0] = T[j][j];
                            dlartg(temp[0], T[j][j - 1], c, s, tout);
                            T[j][j] = tout[0];
                            T[j][j - 1] = 0.0;

                            for (jr = ifrstm; jr <= Math.min(j + 2, ilast); jr++) {
                                temp[0] = (c[0] * H[jr - 1][j]) + (s[0] * H[jr - 1][j - 1]);
                                H[jr - 1][j - 1] = (-s[0] * H[jr - 1][j]) + (c[0] * H[jr - 1][j - 1]);
                                H[jr - 1][j] = temp[0];
                            } // for (jr = ifrstm; jr <= Math.min(j+2,ilast); jr++)

                            for (jr = ifrstm; jr <= j; jr++) {
                                temp[0] = (c[0] * T[jr - 1][j]) + (s[0] * T[jr - 1][j - 1]);
                                T[jr - 1][j - 1] = (-s[0] * T[jr - 1][j]) + (c[0] * T[jr - 1][j - 1]);
                                T[jr - 1][j] = temp[0];
                            } // for (jr = ifrstm; jr <= j; jr++)

                            if (ilz) {

                                for (jr = 1; jr <= n; jr++) {
                                    temp[0] = (c[0] * Z[jr - 1][j]) + (s[0] * Z[jr - 1][j - 1]);
                                    Z[jr - 1][j - 1] = (-s[0] * Z[jr - 1][j]) + (c[0] * Z[jr - 1][j - 1]);
                                    Z[jr - 1][j] = temp[0];
                                } // for (jr = 1; jr <= n; jr++)
                            } // if (ilz)
                        } // for (j = istart; j <= ilast-1; j++)

                        break loop2;
                    } // loop4:

                    // Use Francis double-shift
                    // Note:  The Francis double-shift should work with real shifts,
                    // but only if the code is at least 3x3.  This code may break
                    // if this point is reached with a 2x2 block with real
                    // eigenvalues.
                    if ((ifirst + 1) == ilast) {

                        // Special case -- 2x2 block with complex eigenvalues
                        // Step 1: Standardize, that is, rotate so that
                        //      ( T11   0  )
                        // T =  (          ) with T11 non-negative.
                        //      (  0   T22 )
                        dlasv2(T[ilast - 2][ilast - 2], T[ilast - 2][ilast - 1], T[ilast - 1][ilast - 1], b22, b11, sr,
                               cr, sL, cL);

                        if (b11[0] < 0.0) {
                            cr[0] = -cr[0];
                            sr[0] = -sr[0];
                            b11[0] = -b11[0];
                            b22[0] = -b22[0];
                        } // if (b11[0] < 0.0)

                        dx = new double[ilastm + 1 - ifirst];
                        dy = new double[ilastm + 1 - ifirst];

                        for (i = 0; i < (ilastm + 1 - ifirst); i++) {
                            dx[i] = H[ilast - 2][ilast - 2 + i];
                            dy[i] = H[ilast - 1][ilast - 2 + i];
                        }

                        drot(ilastm + 1 - ifirst, dx, 1, dy, 1, cL[0], sL[0]);

                        for (i = 0; i < (ilastm + 1 - ifirst); i++) {
                            H[ilast - 2][ilast - 2 + i] = dx[i];
                            H[ilast - 1][ilast - 2 + i] = dy[i];
                        }

                        dx = new double[ilast + 1 - ifrstm];
                        dy = new double[ilast + 1 - ifrstm];

                        for (i = 0; i < (ilast + 1 - ifrstm); i++) {
                            dx[i] = H[ifrstm - 1 + i][ilast - 2];
                            dy[i] = H[ifrstm - 1 + i][ilast - 1];
                        }

                        drot(ilast + 1 - ifrstm, dx, 1, dy, 1, cr[0], sr[0]);

                        for (i = 0; i < (ilast + 1 - ifrstm); i++) {
                            H[ifrstm - 1 + i][ilast - 2] = dx[i];
                            H[ifrstm - 1 + i][ilast - 1] = dy[i];
                        }

                        if (ilast < ilastm) {
                            dx = new double[ilastm - ilast];
                            dy = new double[ilastm - ilast];

                            for (i = 0; i < (ilastm - ilast); i++) {
                                dx[i] = T[ilast - 2][ilast + i];
                                dy[i] = T[ilast - 1][ilast + i];
                            }

                            drot(ilastm - ilast, dx, 1, dy, 1, cL[0], sL[0]);

                            for (i = 0; i < (ilastm - ilast); i++) {
                                T[ilast - 2][ilast + i] = dx[i];
                                T[ilast - 1][ilast + i] = dy[i];
                            }
                        } // if (ilast < ilastm)

                        if (ifrstm < (ilast - 1)) {
                            dx = new double[ifirst - ifrstm];
                            dy = new double[ifirst - ifrstm];

                            for (i = 0; i < (ifirst - ifrstm); i++) {
                                dx[i] = T[ifrstm - 1 + i][ilast - 2];
                                dy[i] = T[ifrstm - 1 + i][ilast - 1];
                            }

                            drot(ifirst - ifrstm, dx, 1, dy, 1, cr[0], sr[0]);

                            for (i = 0; i < (ifirst - ifrstm); i++) {
                                T[ifrstm - 1 + i][ilast - 2] = dx[i];
                                T[ifrstm - 1 + i][ilast - 1] = dy[i];
                            }
                        } // if (ifrstm < ilast-1)

                        if (ilq) {
                            dx = new double[n];
                            dy = new double[n];

                            for (i = 0; i < n; i++) {
                                dx[i] = Q[i][ilast - 2];
                                dy[i] = Q[i][ilast - 1];
                            }

                            drot(n, dx, 1, dy, 1, cL[0], sL[0]);

                            for (i = 0; i < n; i++) {
                                Q[i][ilast - 2] = dx[i];
                                Q[i][ilast - 1] = dy[i];
                            }
                        } // if (ilq)

                        if (ilz) {
                            dx = new double[n];
                            dy = new double[n];

                            for (i = 0; i < n; i++) {
                                dx[i] = Z[i][ilast - 2];
                                dy[i] = Z[i][ilast - 1];
                            }

                            drot(n, dx, 1, dy, 1, cr[0], sr[0]);

                            for (i = 0; i < n; i++) {
                                Z[i][ilast - 2] = dx[i];
                                Z[i][ilast - 1] = dy[i];
                            }
                        } // if (ilz)

                        T[ilast - 2][ilast - 2] = b11[0];
                        T[ilast - 2][ilast - 1] = 0.0;
                        T[ilast - 1][ilast - 2] = 0.0;
                        T[ilast - 1][ilast - 1] = b22[0];

                        // If b22[0] is negative, negate column ilast-1
                        if (b22[0] < 0.0) {

                            for (j = ifrstm; j <= ilast; j++) {
                                H[j - 1][ilast - 1] = -H[j - 1][ilast - 1];
                                T[j - 1][ilast - 1] = -T[j - 1][ilast - 1];
                            } // for (j = ifrstm; j <= ilast; j++)

                            if (ilz) {

                                for (j = 0; j < n; j++) {
                                    Z[j][ilast - 1] = -Z[j][ilast - 1];
                                }
                            } // if (ilz)
                        } // if (b22[0] < 0.0)

                        // Step2: Compute alphar, alphai, and beta (see refs.)
                        // Recompute shift
                        array1 = new double[2][2];
                        array2 = new double[2][2];

                        for (i = 0; i < 2; i++) {

                            for (k = 0; k < 2; k++) {
                                array1[i][k] = H[ilast - 2 + i][ilast - 2 + k];
                                array2[i][k] = T[ilast - 2 + i][ilast - 2 + k];
                            }
                        }

                        dlag2(array1, 2, array2, 2, safmin * safety, s1, temp, wr, temp2, wi);

                        // If standardization has perturbed the shift onto real line,
                        // do another (real single-shift) QR step.
                        if (wi[0] == 0.0) {
                            break loop2;
                        }

                        s1inv = 1.0 / s1[0];

                        // Do EISPACK (QZVAL) computation of alpha and beta
                        a11 = H[ilast - 2][ilast - 2];
                        a21 = H[ilast - 1][ilast - 2];
                        a12 = H[ilast - 2][ilast - 1];
                        a22 = H[ilast - 1][ilast - 1];

                        // Compute complex Givens rotation on right
                        // (Assume come element of C = (sA - wB) > unfl)
                        // (sA - wB)(CZ comp(-SZ))
                        //          (SZ       CZ )
                        c11r = (s1[0] * a11) - (wr[0] * b11[0]);
                        c11i = -wi[0] * b11[0];
                        c12 = s1[0] * a12;
                        c21 = s1[0] * a21;
                        c22r = (s1[0] * a22) - (wr[0] * b22[0]);
                        c22i = -wi[0] * b22[0];

                        if ((Math.abs(c11r) + Math.abs(c11i) + Math.abs(c12)) >
                                (Math.abs(c21) + Math.abs(c22r) + Math.abs(c22i))) {
                            t1 = dlapy3(c12, c11r, c11i);
                            cz = c12 / t1;
                            szr = -c11r / t1;
                            szi = -c11i / t1;
                        } // if (Math.abs(c11r)+Math.abs(c11i)+Math.abs(c12) >
                        else {
                            cz = dlapy2(c22r, c22i);

                            if (cz <= safmin) {
                                cz = 0.0;
                                szr = 1.0;
                                szi = 0.0;
                            } // if (cz <= safmin)
                            else {
                                tempr[0] = c22r / cz;
                                tempi = c22i / cz;
                                t1 = dlapy2(cz, c21);
                                cz = cz / t1;
                                szr = -c21 * tempr[0] / t1;
                                szi = c21 * tempi / t1;
                            } // else
                        } // else

                        // Compute Givens rotation on left
                        // ( CQ        SQ)
                        // (             )  H or T
                        // (comp(-SQ)  CQ)
                        an = Math.abs(a11) + Math.abs(a12) + Math.abs(a21) + Math.abs(a22);
                        bn = Math.abs(b11[0]) + Math.abs(b22[0]);
                        wabs = Math.abs(wr[0]) + Math.abs(wi[0]);

                        if ((s1[0] * an) > (wabs * bn)) {
                            cq = cz * b11[0];
                            sqr = szr * b22[0];
                            sqi = -szi * b22[0];
                        } // if (s1[0]*an > wabs*bn)
                        else {
                            a1r = (cz * a11) + (szr * a12);
                            a1i = szi * a12;
                            a2r = (cz * a21) + (szr * a22);
                            a2i = szi * a22;
                            cq = dlapy2(a1r, a1i);

                            if (cq <= safmin) {
                                cq = 0.0;
                                sqr = 1.0;
                                sqi = 0.0;
                            } // if (cq <= safmin)
                            else {
                                tempr[0] = a1r / cq;
                                tempi = a1i / cq;
                                sqr = (tempr[0] * a2r) + (tempi * a2i);
                                sqi = (tempi * a2r) - (tempr[0] * a2i);
                            } // else
                        } // else

                        t1 = dlapy3(cq, sqr, sqi);
                        cq = cq / t1;
                        sqr = sqr / t1;
                        sqi = sqi / t1;

                        // Compute diagonal elements of QBZ
                        tempr[0] = (sqr * szr) - (sqi * szi);
                        tempi = (sqr * szi) + (sqi * szr);
                        b1r = (cq * cz * b11[0]) + (tempr[0] * b22[0]);
                        b1i = tempi * b22[0];
                        b1a = dlapy2(b1r, b1i);
                        b2r = (cq * cz * b22[0]) + (tempr[0] * b11[0]);
                        b2i = -tempi * b11[0];
                        b2a = dlapy2(b2r, b2i);

                        // Normalize so beta > 0, and Im(alpha1) > 0
                        beta[ilast - 2] = b1a;
                        beta[ilast - 1] = b2a;
                        alphar[ilast - 2] = (wr[0] * b1a) * s1inv;
                        alphai[ilast - 2] = (wi[0] * b1a) * s1inv;
                        alphar[ilast - 1] = (wr[0] * b2a) * s1inv;
                        alphai[ilast - 1] = -(wi[0] * b2a) * s1inv;

                        // Step 3: Go to next block -- exit if finished
                        ilast = ifirst - 1;

                        if (ilast < ilo) {
                            break loop1;
                        } // if (ilast < ilo)

                        // Reset counters
                        iiter = 0;
                        eshift = 0.0;

                        if (!ilschr) {
                            ilastm = ilast;

                            if (ifrstm > ilast) {
                                ifrstm = ilo;
                            } // if (ifrstm > ilast)
                        } // if (!ilschr)

                        break loop2;
                    } // if (ifirst+1 == ilast)
                    else {
                        // Usual case: 3x3 or larger block, using Francis implicit
                        // double-shift

                        // Eigenvalue equation is w**2 - cw + d = 0,
                        // so compute 1st column of (HTInverse)**2 - c H TInverse + d
                        // using the formula in QZIT (from EISPACK)

                        // We assume the block is at least 3x3
                        ad11 = (ascale * H[ilast - 2][ilast - 2]) / (bscale * T[ilast - 2][ilast - 2]);
                        ad21 = (ascale * H[ilast - 1][ilast - 2]) / (bscale * T[ilast - 2][ilast - 2]);
                        ad12 = (ascale * H[ilast - 2][ilast - 1]) / (bscale * T[ilast - 1][ilast - 1]);
                        ad22 = (ascale * H[ilast - 1][ilast - 1]) / (bscale * T[ilast - 1][ilast - 1]);
                        u12 = T[ilast - 2][ilast - 1] / T[ilast - 1][ilast - 1];
                        ad11L = (ascale * H[ifirst - 1][ifirst - 1]) / (bscale * T[ifirst - 1][ifirst - 1]);
                        ad21L = (ascale * H[ifirst][ifirst - 1]) / (bscale * T[ifirst - 1][ifirst - 1]);
                        ad12L = (ascale * H[ifirst - 1][ifirst]) / (bscale * T[ifirst][ifirst]);
                        ad22L = (ascale * H[ifirst][ifirst]) / (bscale * T[ifirst][ifirst]);
                        ad32L = (ascale * H[ifirst + 1][ifirst]) / (bscale * T[ifirst][ifirst]);
                        u12L = T[ifirst - 1][ifirst] / T[ifirst][ifirst];

                        v[0] = ((ad11 - ad11L) * (ad22 - ad11L) * ad12 * ad21) + (ad21 * u12 * ad11L) +
                               ((ad12L - (ad11L * u12L)) * ad21L);
                        v[1] = ((ad22L - ad11L) - (ad21L * u12L) - (ad11 - ad11L) - (ad22 - ad11L) + (ad21 * u12)) *
                                   ad21L;
                        v[2] = ad32L * ad21L;

                        istart = ifirst;
                        dx = new double[2];
                        dx[0] = v[1];
                        dx[1] = v[2];
                        dlarfg(3, v, dx, 1, tau);
                        v[1] = dx[0];
                        v[2] = dx[1];
                        v[0] = 1.0;

                        // Sweep
                        for (j = istart; j <= (ilast - 2); j++) {

                            // All but last elements: use 3x3 Householder transforms.
                            // Zero (j-2)st column of H
                            if (j > istart) {
                                v[0] = H[j - 1][j - 2];
                                v[1] = H[j][j - 2];
                                v[2] = H[j + 1][j - 2];
                                dx = new double[1];
                                dx[0] = H[j - 1][j - 2];
                                dy = new double[2];
                                dy[0] = v[1];
                                dy[1] = v[2];
                                dlarfg(3, dx, dy, 1, tau);
                                H[j - 1][j - 2] = dx[0];
                                v[1] = dy[0];
                                v[2] = dy[1];
                                v[0] = 1.0;
                                H[j][j - 2] = 0.0;
                                H[j + 1][j - 2] = 0.0;
                            } // if (j > istart)

                            for (jc = j; jc <= ilastm; jc++) {
                                temp[0] = tau[0] *
                                              (H[j - 1][jc - 1] + (v[1] * H[j][jc - 1]) + (v[2] * H[j + 1][jc - 1]));
                                H[j - 1][jc - 1] = H[j - 1][jc - 1] - temp[0];
                                H[j][jc - 1] = H[j][jc - 1] - (temp[0] * v[1]);
                                H[j + 1][jc - 1] = H[j + 1][jc - 1] - (temp[0] * v[2]);
                                temp2[0] = tau[0] *
                                               (T[j - 1][jc - 1] + (v[1] * T[j][jc - 1]) + (v[2] * T[j + 1][jc - 1]));
                                T[j - 1][jc - 1] = T[j - 1][jc - 1] - temp2[0];
                                T[j][jc - 1] = T[j][jc - 1] - (temp2[0] * v[1]);
                                T[j + 1][jc - 1] = T[j + 1][jc - 1] - (temp2[0] * v[2]);
                            } // for (jc = j; jc <= ilastm; jc++)

                            if (ilq) {

                                for (jr = 1; jr <= n; jr++) {
                                    temp[0] = tau[0] *
                                                  (Q[jr - 1][j - 1] + (v[1] * Q[jr - 1][j]) + (v[2] * Q[jr - 1][j + 1]));
                                    Q[jr - 1][j - 1] = Q[jr - 1][j - 1] - temp[0];
                                    Q[jr - 1][j] = Q[jr - 1][j] - (temp[0] * v[1]);
                                    Q[jr - 1][j + 1] = Q[jr - 1][j + 1] - (temp[0] * v[2]);
                                } // for (jr = 1; jr <= n; jr++)
                            } // if (ilq)

                            // Zero (j-1)-st column of T (see dlagbc for details)
                            // Swap rows to pivot
                            ilpivt = false;
                            temp[0] = Math.max(Math.abs(T[j][j]), Math.abs(T[j][j + 1]));
                            temp2[0] = Math.max(Math.abs(T[j + 1][j]), Math.abs(T[j + 1][j + 1]));

loop3:                       {

                                if (Math.max(temp[0], temp2[0]) < safmin) {
                                    scale = 0.0;
                                    u1 = 1.0;
                                    u2 = 0.0;

                                    break loop3;
                                } // if (Math.max(temp[0],temp2[0]) < safmin)
                                else if (temp[0] >= temp2[0]) {
                                    w11 = T[j][j];
                                    w21 = T[j + 1][j];
                                    w12 = T[j][j + 1];
                                    w22 = T[j + 1][j + 1];
                                    u1 = T[j][j - 1];
                                    u2 = T[j + 1][j - 1];
                                } // else if (temp[0] >= temp2[0])
                                else {
                                    w21 = T[j][j];
                                    w11 = T[j + 1][j];
                                    w22 = T[j][j + 1];
                                    w12 = T[j + 1][j + 1];
                                    u2 = T[j][j - 1];
                                    u1 = T[j + 1][j - 1];
                                } // else

                                // Sweap columns if necessary
                                if (Math.abs(w12) > Math.abs(w11)) {
                                    ilpivt = true;
                                    temp[0] = w12;
                                    temp2[0] = w22;
                                    w12 = w11;
                                    w22 = w21;
                                    w11 = temp[0];
                                    w21 = temp2[0];
                                } // if (Math.abs(w12) > Math.abs(w11))

                                // LU-factor
                                temp[0] = w21 / w11;
                                u2 = u2 - (temp[0] * u1);
                                w22 = w22 - (temp[0] * w12);
                                w21 = 0.0;

                                // Compute scale
                                scale = 1.0;

                                if (Math.abs(w22) < safmin) {
                                    scale = 0.0;
                                    u2 = 1.0;
                                    u1 = -w12 / w11;

                                    break loop3;
                                } // if (Math.abs(w22) < safmin)

                                if (Math.abs(w22) < Math.abs(u2)) {
                                    scale = Math.abs(w22 / u2);
                                } // if (Math.abs(w22) < Math.abs(u2))

                                if (Math.abs(w11) < Math.abs(u1)) {
                                    scale = Math.min(scale, Math.abs(w11 / u1));
                                } // if (Math.abs(w11) < Math.abs(u1))

                                // Solve
                                u2 = (scale * u2) / w22;
                                u1 = ((scale * u1) - (w12 * u2)) / w11;
                            } // loop3

                            if (ilpivt) {
                                temp[0] = u2;
                                u2 = u1;
                                u1 = temp[0];
                            } // if (ilpivt)

                            // Compute Householder vector
                            t1 = Math.sqrt((scale * scale) + (u1 * u1) + (u2 * u2));
                            tau[0] = 1.0 + (scale / t1);
                            vs = -1.0 / (scale + t1);
                            v[0] = 1.0;
                            v[1] = vs * u1;
                            v[2] = vs * u2;

                            // Apply transformations from the right
                            for (jr = ifrstm; jr <= Math.min(j + 3, ilast); jr++) {
                                temp[0] = tau[0] *
                                              (H[jr - 1][j - 1] + (v[1] * H[jr - 1][j]) + (v[2] * H[jr - 1][j + 1]));
                                H[jr - 1][j - 1] = H[jr - 1][j - 1] - temp[0];
                                H[jr - 1][j] = H[jr - 1][j] - (temp[0] * v[1]);
                                H[jr - 1][j + 1] = H[jr - 1][j + 1] - (temp[0] * v[2]);
                            } // for (jr = ifrstm; jr <= Math.min(j+3,ilast); jr++)

                            for (jr = ifrstm; jr <= (j + 2); jr++) {
                                temp[0] = tau[0] *
                                              (T[jr - 1][j - 1] + (v[1] * T[jr - 1][j]) + (v[2] * T[jr - 1][j + 1]));
                                T[jr - 1][j - 1] = T[jr - 1][j - 1] - temp[0];
                                T[jr - 1][j] = T[jr - 1][j] - (temp[0] * v[1]);
                                T[jr - 1][j + 1] = T[jr - 1][j + 1] - (temp[0] * v[2]);
                            } // for (jr = ifrstm; jr <= j+2; jr++)

                            if (ilz) {

                                for (jr = 1; jr <= n; jr++) {
                                    temp[0] = tau[0] *
                                                  (Z[jr - 1][j - 1] + (v[1] * Z[jr - 1][j]) + (v[2] * Z[jr - 1][j + 1]));
                                    Z[jr - 1][j - 1] = Z[jr - 1][j - 1] - temp[0];
                                    Z[jr - 1][j] = Z[jr - 1][j] - (temp[0] * v[1]);
                                    Z[jr - 1][j + 1] = Z[jr - 1][j + 1] - (temp[0] * v[2]);
                                } // for (jr = 1; jr <= n; jr++)
                            } // if (ilz)

                            T[j][j - 1] = 0.0;
                            T[j + 1][j - 1] = 0.0;
                        } // for (j = istart; j <= ilast-2; j++)

                        // Last elements: Use Givens rotations
                        // Rotations from the left
                        j = ilast - 1;
                        temp[0] = H[j - 1][j - 2];
                        dlartg(temp[0], H[j][j - 2], c, s, hout);
                        H[j - 1][j - 2] = hout[0];
                        H[j][j - 2] = 0.0;

                        for (jc = j; jc <= ilastm; jc++) {
                            temp[0] = (c[0] * H[j - 1][jc - 1]) + (s[0] * H[j][jc - 1]);
                            H[j][jc - 1] = (-s[0] * H[j - 1][jc - 1]) + (c[0] * H[j][jc - 1]);
                            H[j - 1][jc - 1] = temp[0];
                            temp2[0] = (c[0] * T[j - 1][jc - 1]) + (s[0] * T[j][jc - 1]);
                            T[j][jc - 1] = (-s[0] * T[j - 1][jc - 1]) + (c[0] * T[j][jc - 1]);
                            T[j - 1][jc - 1] = temp2[0];
                        } // for (jc = j; jc <= ilastm; jc++)

                        if (ilq) {

                            for (jr = 1; jr <= n; jr++) {
                                temp[0] = (c[0] * Q[jr - 1][j - 1]) + (s[0] * Q[jr - 1][j]);
                                Q[jr - 1][j] = (-s[0] * Q[jr - 1][j - 1]) + (c[0] * Q[jr - 1][j]);
                                Q[jr - 1][j - 1] = temp[0];
                            } // for (jr = 1; jr <= n; jr++)
                        } // if (ilq)

                        // Rotations from the right
                        temp[0] = T[j][j];
                        dlartg(temp[0], T[j][j - 1], c, s, tout);
                        T[j][j] = tout[0];
                        T[j][j - 1] = 0.0;

                        for (jr = ifrstm; jr <= ilast; jr++) {
                            temp[0] = (c[0] * H[jr - 1][j]) + (s[0] * H[jr - 1][j - 1]);
                            H[jr - 1][j - 1] = (-s[0] * H[jr - 1][j]) + (c[0] * H[jr - 1][j - 1]);
                            H[jr - 1][j] = temp[0];
                        } // for (jr = ifrstm; jr <= ilast; jr++)

                        for (jr = ifrstm; jr <= (ilast - 1); jr++) {
                            temp[0] = (c[0] * T[jr - 1][j]) + (s[0] * T[jr - 1][j - 1]);
                            T[jr - 1][j - 1] = (-s[0] * T[jr - 1][j]) + (c[0] * T[jr - 1][j - 1]);
                            T[jr - 1][j] = temp[0];
                        } // for (jr = ifrstm; jr <= ilast-1; jr++)

                        if (ilz) {

                            for (jr = 1; jr <= n; jr++) {
                                temp[0] = (c[0] * Z[jr - 1][j]) + (s[0] * Z[jr - 1][j - 1]);
                                Z[jr - 1][j - 1] = (-s[0] * Z[jr - 1][j]) + (c[0] * Z[jr - 1][j - 1]);
                                Z[jr - 1][j] = temp[0];
                            } // for (jr = 1; jr <= n; jr++)
                        } // if (ilz)

                        // End of Double-Shift code
                    } // else

                    // End of iteration loop
                } // loop2
            } // for (jiter = 1; jiter <= maxit; jiter++)

            // Drop-through = non-convergence
            info[0] = ilast;
            work[0] = (double) n;

            return;
        } // loop1

        // Successful completion of all QZ steps
        // Set eigenvalues 0:ilo-2
        for (j = 0; j < (ilo - 1); j++) {

            if (T[j][j] < 0.0) {

                if (ilschr) {

                    for (jr = 0; jr <= j; jr++) {
                        H[jr][j] = -H[jr][j];
                        T[jr][j] = -T[jr][j];
                    } // for (jr = 0; jr <= j; jr++)
                } // if (ilschr)
                else {
                    H[j][j] = -H[j][j];
                    T[j][j] = -T[j][j];
                } // else

                if (ilz) {

                    for (jr = 0; jr < n; jr++) {
                        Z[jr][j] = -Z[jr][j];
                    } // for (jr = 0; jr < n; jr++)
                } // if (ilz)
            } // if (B[j][j] < 0.0)

            alphar[j] = H[j][j];
            alphai[j] = 0.0;
            beta[j] = T[j][j];
        } // for (j = 0; j < ilo-1; j++)

        // Normal termination
        info[0] = 0;

        // Exit (other than argument error) -- return optimal workspace size
        work[0] = (double) n;

        return;
    } // dhgeqz

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLABAD Original DLABAD created by Univ. of Tennessee,
     * Univ. of California Berkeley,  and NAG Ltd., November, 2006
     * dlabad takes as input the values computed by dlamch for underflow and overflow, and returns the square root
     * of each of these values if the log of large is sufficiently big. This routine is intended to identify machines
     * with a large exponent range, such as the Crays, and redefine the underflow and overflow limits to be the square
     * roots fo the values computed by dlamch. This subroutine is needed because dlamch does not compensate for poor
     * arithmetic in the upper half of the exponent range, as is found on a Cray.
     *
     * @param  small  input/ouptut double[] On entry, the underflow threshold as computed by dlamch. On exit, if
     *                log10(large) is sufficiently large, the square root of small, otherwise unchanged.
     * @param  large  input/output double[] On entry, the overflow threshold as computed by dlamch. On exit, if
     *                log10(large) is sufficiently large, the square root of large, otherwise unchanged.
     */
    private void dlabad(double[] small, double[] large) {

        // If it looks like we're on a Cray, take the square root of small and
        // large to avoid overflow and underflow problems.
        if ((0.4342944819 * Math.log(large[0])) > 2000.0) {
            small[0] = Math.sqrt(small[0]);
            large[0] = Math.sqrt(large[0]);
        }

        return;
    } // dlabad

    /**
     * This is a port of LAPACK version 3.1 auxiliary routine DLACPY. Original DLACPY created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlacpy copies all or part of a two-dimensional matrix A to another matrix B.
     *
     * @param  uplo  input char Specifies the part of the matrix A to be copied to B. 
     *               = 'U': Upper triangular part
     *               = 'L': Lower triangular part
     *               Otherwise: All of the matrix A
     * @param  m     input int The number of rows of the matrix A. m >= 0.
     * @param  n     input int The number of columns of the matrix A. n >= 0.
     * @param  A     input double[][] of dimension (lda,n). Has m by n matrix A. If uplo = 'U', only the upper triangle
     *               or trapezoid is accessed; if uplo = 'L', only the lower triangle or trapezoid is accessed.
     * @param  lda   input int The leading dimension of the array A. lda >= max(1,m).
     * @param  B     output double[][] of dimension (ldb,n). On exit, B = A in the locations specified by uplo.
     * @param  ldb   input int The leading dimension of the array B. ldb >= max(1,m).
     */
    private void dlacpy(char uplo, int m, int n, double[][] A, int lda, double[][] B, int ldb) {
        int i, j;

        if ((uplo == 'U') || (uplo == 'u')) {

            for (j = 0; j < n; j++) {

                for (i = 0; i <= Math.min(j, m - 1); i++) {
                    B[i][j] = A[i][j];
                }
            }
        } // if ((uplo == 'U') || (uplo == 'u'))
        else if ((uplo == 'L') || (uplo == 'l')) {

            for (j = 0; j < n; j++) {

                for (i = j; i < m; i++) {
                    B[i][j] = A[i][j];
                }
            }
        } // else if ((uplo == 'L') || (uplo == 'l'))
        else {

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    B[i][j] = A[i][j];
                }
            }
        } // else
    } // dlacpy

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLADIV Original DLADIV created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dladiv performs complex division in real arithmetic p + i*q = (a + i*b) / (c + i*d) The algorithm is due to
     * Robert L. Smith and can be found in D. Knuth, The Art of Computer Programming, Vol. 2, p.195.
     *
     * @param  a  input double
     * @param  b  input double
     * @param  c  input double
     * @param  d  input double
     * @param  p  input double[]
     * @param  q  input double[]
     */
    private void dladiv(double a, double b, double c, double d, double[] p, double[] q) {
        double e;
        double f;

        if (Math.abs(d) < Math.abs(c)) {
            e = d / c;
            f = c + (d * e);
            p[0] = (a + (b * e)) / f;
            q[0] = (b - (a * e)) / f;
        } else {
            e = c / d;
            f = d + (c * e);
            p[0] = (b + (a * e)) / f;
            q[0] = (-a + (b * e)) / f;
        }

        return;
    } // dladiv

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLAE2 Original DLAE2 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlae2 computes the eigenvalues of a 2-by-2 symmetric matrix
     *       [ A B ]
     *       [ B C ]
     * On return, rt1[0] is the eigenvalue of the larger absolute value,
     * and rt2[0] is the eigenvalue of the smaller absolute value.
     *
     * @param  a    input double The 0,0 element of the 2-by-2 matrix.
     * @param  b    input double The 0,1 and 1,0 elements of the 2-by-2 matrix.
     * @param  c    input double The 1,1 element of the 2-by-2 matrix.
     * @param  rt1  output double[] The eigenvalue of the larger absolute value.
     * @param  rt2  output double[] The eigenvalue of the smaller absolute value.
     * Further Details: rt1 is accurate to a few ulps barring over/underflow.
     *              rt2 may be inaccurate if there is massive cancellation in the determinant A*C - B*B;
     *              higher precision or correctly rounded or correctly truncated arithmetic would be needed to compute
     *              rt2 accurately in all cases. Overflow is possible only if rt1 is within a factor of 5 of overflow.
     *              Underflow is harmless if the input data is 0 or exceeds underflow_threshold / macheps.
     */
    private void dlae2(double a, double b, double c, double[] rt1, double[] rt2) {
        double ab;
        double acmn;
        double acmx;
        double adf;
        double df;
        double rt;
        double sm;
        double tb;
        double ratio;

        // Compute the eigenvalues
        sm = a + c;
        df = a - c;
        adf = Math.abs(df);
        tb = b + b;
        ab = Math.abs(tb);

        if (Math.abs(a) > Math.abs(c)) {
            acmx = a;
            acmn = c;
        } else {
            acmx = c;
            acmn = a;
        }

        if (adf > ab) {
            ratio = ab / adf;
            rt = adf * Math.sqrt(1.0 + (ratio * ratio));
        } else if (adf < ab) {
            ratio = adf / ab;
            rt = ab * Math.sqrt(1.0 + (ratio * ratio));
        } else {

            // Includes case ab = adf = 0
            rt = ab * Math.sqrt(2.0);
        }

        if (sm < 0.0) {
            rt1[0] = 0.5 * (sm - rt);
            rt2[0] = ((acmx / rt1[0]) * acmn) - ((b / rt1[0]) * b);
        } else if (sm > 0.0) {
            rt1[0] = 0.5 * (sm + rt);
            rt2[0] = ((acmx / rt1[0]) * acmn) - ((b / rt1[0]) * b);
        } else {

            // Includes cases rt1[0] = rt2[0] = 0
            rt1[0] = 0.5 * rt;
            rt2[0] = -0.5 * rt;
        }

        return;
    } // dlae2

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLAEV2 Original DLAEV2 created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlaev2 computes the eigendecomposition of a 2-by-2 symmetric matrix
     *  [ a b ]
     *  [ b c ]
     * On return rt1[0] is the eigenvalue of the larger absolute value, rt2[0] is the eigenvalue of the smaller
     * absolute value, and (cs1, sn1) is the unit right eigenvector for rt1[0], giving the decomposition
     *  [ cs1 sn1 ] [ a b ] [cs1 -sn1] = [rt1 0 ]
     *  [-sn1 cs1 ] [ b c ] [sn1  cs1]   [ 0 rt2]
     *
     * @param  a    input double The (0,0) element of the 2-by-2 matrix
     * @param  b    input double The (0,1) element and the conjugate of the (1,0) element of the 2-by-2 matrix.
     * @param  c    input double The (1,1) element of the 2-by-2 matrix.
     * @param  rt1  output double[] The eigenvalue of larger absolute value.
     * @param  rt2  output double[] The eigenvalue of smaller absolute value.
     * @param  cs1  output double[]
     * @param  sn1  output double[] The vector (cs1, sn1) is a unit right eigenvector for rt1[0].
     *              Further details:
     *              rt1[0] is accurate to a few ulps barring over/underflow. rt2[0] may be inaccurate if there is
     *              massive cancellation in the determinant a*c - b*b; higher precision or correctly rounded or
     *              correctly truncated arithmetic would be needed to compute rt2[0] accurately in all cases. cs1[0] and
     *              sn1[0] are accurate to a few ulps barring over/underflow. Overflow if possible only if rt1[0] is
     *              within a factor of 5 of overflow. Underflow is harmless if the input data is 0 or exceeds
     *              underflow_threshold/macheps.
     */
    private void dlaev2(double a, double b, double c, double[] rt1, double[] rt2, double[] cs1, double[] sn1) {
        int sgn1;
        int sgn2;
        double ab;
        double acmn;
        double acmx;
        double acs;
        double adf;
        double cs;
        double ct;
        double df;
        double rt;
        double sm;
        double tb;
        double tn;
        double ratio;

        // Compute the eigenvalues.
        sm = a + c;
        df = a - c;
        adf = Math.abs(df);
        tb = b + b;
        ab = Math.abs(tb);

        if (Math.abs(a) > Math.abs(c)) {
            acmx = a;
            acmn = c;
        } else {
            acmx = c;
            acmn = a;
        }

        if (adf > ab) {
            ratio = ab / adf;
            rt = adf * Math.sqrt(1.0 + (ratio * ratio));
        } else if (adf < ab) {
            ratio = adf / ab;
            rt = ab * Math.sqrt(1.0 + (ratio * ratio));
        } else {

            // Includes case ab = adf = 0
            rt = ab * Math.sqrt(2.0);
        }

        if (sm < 0.0) {
            rt1[0] = 0.5 * (sm - rt);
            sgn1 = -1;
            rt2[0] = ((acmx / rt1[0]) * acmn) - ((b / rt1[0]) * b);
        } else if (sm > 0.0) {
            rt1[0] = 0.5 * (sm + rt);
            sgn1 = 1;
            rt2[0] = ((acmx / rt1[0]) * acmn) - ((b / rt1[0]) * b);
        } else {

            // Includes case rt1[0] = rt2[0] = 0
            rt1[0] = 0.5 * rt;
            rt2[0] = -0.5 * rt;
            sgn1 = 1;
        }

        // Compute the eigenvector
        if (df >= 0.0) {
            cs = df + rt;
            sgn2 = 1;
        } else {
            cs = df - rt;
            sgn2 = -1;
        }

        acs = Math.abs(cs);

        if (acs > ab) {
            ct = -tb / cs;
            sn1[0] = 1.0 / Math.sqrt(1.0 + (ct * ct));
            cs1[0] = ct * sn1[0];
        } else {

            if (ab == 0.0) {
                cs1[0] = 1.0;
                sn1[0] = 0.0;
            } else {
                tn = -cs / tb;
                cs1[0] = 1.0 / Math.sqrt(1.0 + (tn * tn));
                sn1[0] = tn * cs1[0];
            }
        }

        if (sgn1 == sgn2) {
            tn = cs1[0];
            cs1[0] = -sn1[0];
            sn1[0] = tn;
        }

        return;
    } // dlaev2

    /**
     * This is a port of the version 3.1 LAPACK auxiliary test routine DLAFTS Original DLAFTS created by Univ. of
     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlafts tests the result vector against the threshold value to see which tests for this matrix type
     * failed to pass the threshold.
     *
     * @param  type    input String On entry, type specifies the matrix type to be used in the printed messages
     * @param  m       input int rows of matrix
     * @param  n       input int On entry, n specifies the order the of test matrix. columns of matrix
     * @param  imat    input int On entry, imat specifies the type of the test matrix. A listing of the different types
     *                 is printed by dlahd2 if a test fails to pass the threshold.
     * @param  ntests  input int On entry, ntests is the number of tests performed on the subroutines in the path given
     *                 by type.
     * @param  result  input double[] of dimension ntests On entry, result contains the test ratios from the tests
     *                 performed in the calling program.
     * @param  iseed   input int[] of dimension 4. Contains the random seed that generated the matrix used for the tests
     *                 whose ratios are in result.
     * @param  thresh  input double On entry, thresh specifies the acceptable threshold of the test ratios. if
     *                 result[k-1] > thresh, then the k-th test did not pass the threshold and a message will be
     *                 printed.
     * @param  ie      input/output int[] On entry, ie contains the number of tests which have failed to pass the
     *                 threshold so far. Updated on exit if any of the ratios in result also fail.
     */
    private void dlafts(String type, int m, int n, int imat, int ntests, double[] result, int[] iseed, double thresh,
                        int[] ie) {
        int k;

        if (m == n) {

            // Output for square matrices
            for (k = 0; k < ntests; k++) {

                if (result[k] >= thresh) {

                    // If this is the first test to fail, call dlahd2 to print
                    // a header to the file
                    if (ie[0] == 0) {
                        dlahd2(type);
                    }

                    ie[0] = ie[0] + 1;
                    UI.setDataText("Matrix of order = " + n + " type = " + imat + "\n");
                    UI.setDataText("Test = " + (k + 1) + " ratio = " + result[k] + "\n");
                    UI.setDataText("iseed[0] = " + iseed[0] + " iseed[1] = " + iseed[1] + "\n");
                    UI.setDataText("iseed[2] = " + iseed[2] + " iseed[3] = " + iseed[3] + "\n");
                } // if (result[k] >= thresh)
            } // for (k = 0; k < ntests; k++)
        } // if (m == n)
        else { // m != n

            // Output for rectangular matrices
            for (k = 0; k < ntests; k++) {

                if (result[k] >= thresh) {

                    // If this is the first test to fail, call dlahd2 to print
                    // a header to the file
                    if (ie[0] == 0) {
                        dlahd2(type);
                    }

                    ie[0] = ie[0] + 1;
                    UI.setDataText("Matrix of size = " + m + " by " + n + " type = " + imat + "\n");
                    UI.setDataText("Test = " + (k + 1) + " ratio = " + result[k] + "\n");
                    UI.setDataText("iseed[0] = " + iseed[0] + " iseed[1] = " + iseed[1] + "\n");
                    UI.setDataText("iseed[2] = " + iseed[2] + " iseed[3] = " + iseed[3] + "\n");
                } // if (result[k] >= thresh)
            } // for (k = 0; k < ntests; k++)
        } // else m!= n
    } // dlafts

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLAG2 Original DLAG2 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlag2 computes eigenvalues of a 2 x 2 generalized eigenvalue problem A - w B, with scaling as necessary to
     * avoid over-/underflow.
     *
     * <p>The scaling factor "s" results in a modified eigenvalue equation s A - w B where s is a nonnegative scaling
     * factor chosen so that w, w B, and s A do not overflow and, if possible, do not underflow, either.</p>
     *
     * @param  A       input double[][] of dimension (lda,2) On entry, the 2 x 2 matrix A. It is assumed that its 1-norm
     *                 is less than 1/safmin. Entries less than sqrt(safmin)*norm(A) are subject to being treated as
     *                 zero.
     * @param  lda     input int The leading dimension of the array A. lda >= 2.
     * @param  B       input double[][] of dimension (ldb,2) On entry, the 2 x 2 upper triangular matrix B. It is
     *                 assumed that the one-norm of B is less than 1/safmin. The diagonals should be at least
     *                 sqrt(safmin) times the largest element of B (in absolute value); if a diagonal is smaller than
     *                 that, then +/- sqrt(safmin) will be used instead of that diagonal.
     * @param  ldb     input int The leading dimension of the array B. ldb >= 2.
     * @param  safmin  input double The smallest positive number such that 1/safmin does not overflow. (This should
     *                 always be dlamch('S') -- it is an argument in order to avoid having to call dlamch frequently.)
     * @param  scale1  output double[] A scaling factor used to avoid over-/ underflow in the eigenvalue equation which
     *                 defines the first eigenvalue. If the eigenvalues are complex, then the eigenvalues are (wr1 +/-
     *                 wi*i)/scale1 (which may lie outside the exponent range of the machine), scale1 = scale2, and
     *                 scale1 will always be positive. If the eigenvalues are real, then the first (real) eigenvalue is
     *                 wr1/scale1, but this may overflow or underflow, and in fact, scale1 may be zero or less than the
     *                 underflow threshold if the exact eigenvalue is sufficiently large.
     * @param  scale2  output double[] A scaling factor used to avoid over-/ underflow in th eigenvalue equation which
     *                 defines the second eigenvalue. If the eigenvalues are complex, then scale2 = scale1. If the
     *                 eigenvalues are real, then the second (real) eigenvalue is wr2 / scale2, but this may overflow or
     *                 underflow, and in fact, scale2 may be zero or less than the underflow threshold if the exact
     *                 eigenvalue is sufficiently large.
     * @param  wr1     output double[] If the eigenvalue is real, then wr1 is scale1 times the eigenvalue closest to the
     *                 (1,1) element of A B**(-1). If the eigenvalue is complex, then wr1 = wr2 is scale1 times the real
     *                 part of the eigenvalues.
     * @param  wr2     output double[] If the eigenvalue is real, then wr2 is scale2 times the other eigenvalue. If the
     *                 eigenvalue is complex, then wr1 = wr2 is scale1 times the real part of the eigenvalues.
     * @param  wi      output double[] If the eigenvalue is real, then wi is 0.0. If the eigenvalue is complex, then wi
     *                 is scale1 times the imaginary part of the eigenvalues. wi will always be nonnegative.
     */
    private void dlag2(double[][] A, int lda, double[][] B, int ldb, double safmin, double[] scale1, double[] scale2,
                       double[] wr1, double[] wr2, double[] wi) {
        double fuzzy1 = 1.0E-5;
        double a11;
        double a12;
        double a21;
        double a22;
        double abi22;
        double anorm;
        double as11;
        double as12;
        double as22;
        double ascale;
        double b11;
        double b12;
        double b22;
        double binv11;
        double binv22;
        double bmin;
        double bnorm;
        double bscale;
        double bsize;
        double c1;
        double c2;
        double c3;
        double c4;
        double c5;
        double diff;
        double discr;
        double pp;
        double qq;
        double r;
        double rtmax;
        double rtmin;
        double s1;
        double s2;
        double safmax;
        double shift;
        double ss;
        double sum;
        double wabs;
        double wbig;
        double wdet;
        double wscale;
        double wsize;
        double wsmall;

        rtmin = Math.sqrt(safmin);
        rtmax = 1.0 / rtmin;
        safmax = 1.0 / safmin;

        // Scale A
        anorm = Math.max(Math.abs(A[0][0]) + Math.abs(A[1][0]), Math.abs(A[0][1]) + Math.abs(A[1][1]));
        anorm = Math.max(anorm, safmin);
        ascale = 1.0 / anorm;
        a11 = ascale * A[0][0];
        a21 = ascale * A[1][0];
        a12 = ascale * A[0][1];
        a22 = ascale * A[1][1];

        // Perturb B if necessary to insure non-singularity
        b11 = B[0][0];
        b12 = B[0][1];
        b22 = B[1][1];
        bmin = Math.max(Math.abs(b11), Math.abs(b12));
        bmin = Math.max(bmin, Math.abs(b22));
        bmin = Math.max(bmin, rtmin);
        bmin = rtmin * bmin;

        if (Math.abs(b11) < bmin) {

            if (b11 >= 0.0) {
                b11 = Math.abs(bmin);
            } else {
                b11 = -Math.abs(bmin);
            }
        } // if (Math.abs(b11) < bmin)

        if (Math.abs(b22) < bmin) {

            if (b22 >= 0.0) {
                b22 = Math.abs(bmin);
            } else {
                b22 = -Math.abs(bmin);
            }
        } // if (Math.abs(b22) < bmin)

        // Scale B
        bnorm = Math.max(Math.abs(b11), Math.abs(b12) + Math.abs(b22));
        bnorm = Math.max(bnorm, safmin);
        bsize = Math.max(Math.abs(b11), Math.abs(b22));
        bscale = 1.0 / bsize;
        b11 = b11 * bscale;
        b12 = b12 * bscale;
        b22 = b22 * bscale;

        // Compute the larger eigenvalue by method described by C. van Loan
        // (as is A shifted by -shift*B)
        binv11 = 1.0 / b11;
        binv22 = 1.0 / b22;
        s1 = a11 * binv11;
        s2 = a22 * binv22;

        if (Math.abs(s1) <= Math.abs(s2)) {
            as12 = a12 - (s1 * b12);
            as22 = a22 - (s1 * b22);
            ss = a21 * (binv11 * binv22);
            abi22 = (as22 * binv22) - (ss * b12);
            pp = 0.5 * abi22;
            shift = s1;
        } // if (Math.abs(s1) <= Math.abs(s2))
        else {
            as12 = a12 - (s2 * b12);
            as11 = a11 - (s2 * b11);
            ss = a21 * (binv11 * binv22);
            abi22 = -ss * b12;
            pp = 0.5 * ((as11 * binv11) + abi22);
            shift = s2;
        } // else

        qq = ss * as12;

        if (Math.abs(pp * rtmin) >= 1.0) {
            discr = ((rtmin * pp) * (rtmin * pp)) + (qq * safmin);
            r = Math.sqrt(Math.abs(discr)) * rtmax;
        } else if (((pp * pp) + Math.abs(qq)) <= safmin) {
            discr = ((rtmax * pp) * (rtmax * pp)) + (qq * safmax);
            r = Math.sqrt(Math.abs(discr)) * rtmin;
        } else {
            discr = (pp * pp) + qq;
            r = Math.sqrt(Math.abs(discr));
        }

        // Note: the test of R in the following if is to cover the case when
        // discr is small and negative and is flushed to zero during the
        // calculation of R.  On machines which have a consistent flush-to-zero
        // threshold and handle numbers above that threshold correctly, it would
        // not be necessary
        if ((discr >= 0.0) || (r == 0.0)) {

            if (pp >= 0.0) {
                sum = pp + Math.abs(r);
                diff = pp - Math.abs(r);
            } // if (pp >= 0.0)
            else {
                sum = pp - Math.abs(r);
                diff = pp + Math.abs(r);
            }

            wbig = shift + sum;

            // Compute smaller eigenvalue
            wsmall = shift + diff;

            if ((0.5 * Math.abs(wbig)) > Math.max(Math.abs(wsmall), safmin)) {
                wdet = ((a11 * a22) - (a12 * a21)) * (binv11 * binv22);
                wsmall = wdet / wbig;
            }

            // Choose (real) eigenvalue closest to 1,1 element of A*B**(-1) for
            // wr1.
            if (pp > abi22) {
                wr1[0] = Math.min(wbig, wsmall);
                wr2[0] = Math.max(wbig, wsmall);
            } else {
                wr1[0] = Math.max(wbig, wsmall);
                wr2[0] = Math.min(wbig, wsmall);
            }

            wi[0] = 0.0;
        } // if ((discr >= 0.0) || (r == 0.0))
        else {

            // Complex eigenvalues
            wr1[0] = shift + pp;
            wr2[0] = wr1[0];
            wi[0] = r;
        }

        // Further scaling to avoid underflow and overflow in computing scale1
        // and overflow in computing w*B.
        // This scale factor (wscale) is bounded from above using c1 and c2, and
        // from below using c3 and c4.
        // c1 implements the condition s A must never overflow.
        // c2 implements the condition w B must never overflow.
        // c3, with c2, implement the condition that s A - w B must never
        // overflow.
        // c4 implements the condition s should not underflow.
        // c5 implements the condition max(s,|w|) should be at least 2.
        c1 = bsize * (safmin * Math.max(1.0, ascale));
        c2 = safmin * Math.max(1.0, bnorm);
        c3 = bsize * safmin;

        if ((ascale <= 1.0) && (bsize <= 1.0)) {
            c4 = Math.min(1.0, (ascale / safmin) * bsize);
        } else {
            c4 = 1.0;
        }

        if ((ascale <= 1.0) || (bsize <= 1.0)) {
            c5 = Math.min(1.0, ascale * bsize);
        } else {
            c5 = 1.0;
        }

        // Scale first eigenvalue
        wabs = Math.abs(wr1[0]) + Math.abs(wi[0]);
        wsize = Math.max(safmin, c1);
        wsize = Math.max(wsize, fuzzy1 * ((wabs * c2) + c3));
        wsize = Math.max(wsize, Math.min(c4, 0.5 * Math.max(wabs, c5)));

        if (wsize != 1.0) {
            wscale = 1.0 / wsize;

            if (wsize > 1.0) {
                scale1[0] = (Math.max(ascale, bsize) * wscale) * Math.min(ascale, bsize);
            } else {
                scale1[0] = (Math.min(ascale, bsize) * wscale) * Math.max(ascale, bsize);
            }

            wr1[0] = wr1[0] * wscale;

            if (wi[0] != 0.0) {
                wi[0] = wi[0] * wscale;
                wr2[0] = wr1[0];
                scale2[0] = scale1[0];
            }
        } // if (wsize != 1.0)
        else {
            scale1[0] = ascale * bsize;
            scale2[0] = scale1[0];
        }

        // Scale second eigenvalue (if real)
        if (wi[0] == 0.0) {
            wsize = Math.max(safmin, c1);
            wsize = Math.max(wsize, fuzzy1 * ((Math.abs(wr2[0]) * c2) + c3));
            wsize = Math.max(wsize, Math.min(c4, 0.5 * Math.max(Math.abs(wr2[0]), c5)));

            if (wsize != 1.0) {
                wscale = 1.0 / wsize;

                if (wsize > 1.0) {
                    scale2[0] = (Math.max(ascale, bsize) * wscale) * Math.min(ascale, bsize);
                } else {
                    scale2[0] = (Math.min(ascale, bsize) * wscale) * Math.max(ascale, bsize);
                }

                wr2[0] = wr2[0] * wscale;
            } // if (wsize > 1.0)
            else {
                scale2[0] = ascale * bsize;
            }
        } // if (wi[0] == 0.0)

        return;
    } // dlag2

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLAGGE Original DLAGGE created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlagge generates a real general m by n matrix A, by pre- and post- multiplying a real diagonal matrix D
     * with random orthogonal matrices: A = U*D*V. The lower and upper bandwidths may then be reduced to kl and ku by
     * additional orthogonal transformations.
     *
     * @param  m      input int The number of rows of the matrix A. m >= 0.
     * @param  n      input int The number of columns of the matrix A. n >= 0.
     * @param  kl     input int The number of nonzero subdiagonals within the band of A. 0 <= kl <= m-1.
     * @param  ku     input int The number of nonzero superdiagonals within the band of A. 0 <= ku <= n-1.
     * @param  D      input double[] of dimension (min(m,n)) The diagonal elements of the diagonal matrix D
     * @param  A      output double[][] of dimension (lda,n) The generated m by n matrix A.
     * @param  lda    input int The leading dimension of the array A. lda >= m.
     * @param  iseed  input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
     *                elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
     * @param  work   workspace double[] of dimension (m+n)
     * @param  info   output int[] 
     *         = 0: successful exit 
     *         < 0: If info = -i, the i-th argument had an illegal value
     */
    private void dlagge(int m, int n, int kl, int ku, double[] D, double[][] A, int lda, int[] iseed, double[] work,
                        int[] info) {
        int i;
        int j;
        int k;
        double tau;
        double wa;
        double wb;
        double wn;
        double[][] B;
        double[] work2;
        double[] x;

        // Test the input arguments
        info[0] = 0;

        if (m < 0) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if ((kl < 0) || (kl > (m - 1))) {
            info[0] = -3;
        } else if ((ku < 0) || (ku > (n - 1))) {
            info[0] = -4;
        } else if (lda < Math.max(1, m)) {
            info[0] = -7;
        }

        if (info[0] < 0) {
            MipavUtil.displayError("Error dlagge had info[0] = " + info[0]);

            return;
        }

        // Initialize A to diagonal matrix
        for (j = 0; j < n; j++) {

            for (i = 0; i < m; i++) {
                A[i][j] = 0.0;
            }
        }

        for (i = 0; i < Math.min(m, n); i++) {
            A[i][i] = D[i];
        }

        // pre- and post- multiply by random orthogonal matrices
        for (i = Math.min(m, n); i >= 1; i--) {

            if (i < m) {

                // generate random reflection
                dlarnv(3, iseed, m - i + 1, work);
                wn = dnrm2(m - i + 1, work, 1);

                if (work[0] >= 0) {
                    wa = Math.abs(wn);
                } else {
                    wa = -Math.abs(wn);
                }

                if (wn == 0.0) {
                    tau = 0.0;
                } else {
                    wb = work[0] + wa;

                    for (j = 0; j < (m - i); j++) {
                        work[j + 1] = (1.0 / wb) * work[j + 1];
                    }

                    work[0] = 1.0;
                    tau = wb / wa;
                }

                // multiply A(i-1:m-1,i-1:n-1) by random reflection from the left
                B = new double[m - i + 1][n - i + 1];

                for (j = 0; j < (m - i + 1); j++) {

                    for (k = 0; k < (n - i + 1); k++) {
                        B[j][k] = A[j + i - 1][k + i - 1];
                    }
                }

                work2 = new double[work.length - m];

                for (j = 0; j < (work.length - m); j++) {
                    work2[j] = work[m + j];
                }

                dgemv('T', m - i + 1, n - i + 1, 1.0, B, m - i + 1, work, 1, 0.0, work2, 1);
                dger(m - i + 1, n - i + 1, -tau, work, 1, work2, 1, B, m - i + 1);

                for (j = 0; j < (m - i + 1); j++) {

                    for (k = 0; k < (n - i + 1); k++) {
                        A[j + i - 1][k + i - 1] = B[j][k];
                    }
                }

                for (j = 0; j < (work.length - m); j++) {
                    work[m + j] = work2[j];
                }
            } // if (i < m)

            if (i < n) {

                // generate random reflection
                dlarnv(3, iseed, n - i + 1, work);
                wn = dnrm2(n - i + 1, work, 1);

                if (work[0] >= 0) {
                    wa = Math.abs(wn);
                } else {
                    wa = -Math.abs(wn);
                }

                if (wn == 0.0) {
                    tau = 0.0;
                } else {
                    wb = work[0] + wa;

                    for (j = 0; j < (n - i); j++) {
                        work[j + 1] = (1.0 / wb) * work[j + 1];
                    }

                    work[0] = 1.0;
                    tau = wb / wa;
                }

                // multiply A(i-1:m-1,i-1:n-1) by random reflection from right
                B = new double[m - i + 1][n - i + 1];

                for (j = 0; j < (m - i + 1); j++) {

                    for (k = 0; k < (n - i + 1); k++) {
                        B[j][k] = A[j + i - 1][k + i - 1];
                    }
                }

                work2 = new double[work.length - n];

                for (j = 0; j < (work.length - n); j++) {
                    work2[j] = work[n + j];
                }

                dgemv('N', m - i + 1, n - i + 1, 1.0, B, m - i + 1, work, 1, 0.0, work2, 1);
                dger(m - i + 1, n - i + 1, -tau, work2, 1, work, 1, B, m - i + 1);

                for (j = 0; j < (m - i + 1); j++) {

                    for (k = 0; k < (n - i + 1); k++) {
                        A[j + i - 1][k + i - 1] = B[j][k];
                    }
                }

                for (j = 0; j < (work.length - n); j++) {
                    work[n + j] = work2[j];
                }
            } // if (i < n)
        } // for (i = Math.min(m,n); i >= 1; i--)

        // Reduce number of subdiagonals to kl and number of superdiagonals to
        // ku
        for (i = 1; i <= Math.max(m - 1 - kl, n - 1 - ku); i++) {

            if (kl <= ku) {

                // annihilate subdiagonal elements first (necessary if kl = 0)
                if (i <= Math.min(m - 1 - kl, n)) {

                    // generate reflection to annihilate A(kl+i:m-1,i-1)
                    x = new double[m - kl - i + 1];

                    for (j = 0; j < (m - kl - i + 1); j++) {
                        x[j] = A[kl + i - 1 + j][i - 1];
                    }

                    wn = dnrm2(m - kl - i + 1, x, 1);

                    if (A[kl + i - 1][i - 1] >= 0) {
                        wa = Math.abs(wn);
                    } else {
                        wa = -Math.abs(wn);
                    }

                    if (wn == 0.0) {
                        tau = 0.0;
                    } else {
                        wb = A[kl + i - 1][i - 1] + wa;

                        for (j = 0; j < (m - kl - i); j++) {
                            A[kl + i + j][i - 1] = (1.0 / wb) * A[kl + i + j][i - 1];
                        }

                        A[kl + i - 1][i - 1] = 1.0;
                        tau = wb / wa;
                    }

                    // apply reflection to A(kl+i-1:m-1,i:n-1) from the left
                    B = new double[m - kl - i + 1][n - i];

                    for (j = 0; j < (m - kl - i + 1); j++) {

                        for (k = 0; k < (n - i); k++) {
                            B[j][k] = A[kl + i - 1 + j][i + k];
                        }
                    }

                    x = new double[m - kl - i + 1];

                    for (j = 0; j < (m - kl - i + 1); j++) {
                        x[j] = A[kl + i - 1 + j][i - 1];
                    }

                    dgemv('T', m - kl - i + 1, n - i, 1.0, B, m - kl - i + 1, x, 1, 0.0, work, 1);
                    dger(m - kl - i + 1, n - i, -tau, x, 1, work, 1, B, m - kl - i + 1);

                    for (j = 0; j < (m - kl - i + 1); j++) {

                        for (k = 0; k < (n - i); k++) {
                            A[kl + i - 1 + j][i + k] = B[j][k];
                        }
                    }

                    A[kl + i - 1][i - 1] = -wa;
                } // if (i <= Math.min(m-1-kl, n))

                if (i <= Math.min(n - 1 - ku, m)) {

                    // generate reflection to annihilate A(i-1,ku+i:n-1)
                    x = new double[n - ku - i + 1];

                    for (j = 0; j < (n - ku - i + 1); j++) {
                        x[j] = A[i - 1][ku + i - 1 + j];
                    }

                    wn = dnrm2(n - ku - i + 1, x, 1);

                    if (A[i - 1][ku + i - 1] >= 0) {
                        wa = Math.abs(wn);
                    } else {
                        wa = -Math.abs(wn);
                    }

                    if (wn == 0.0) {
                        tau = 0.0;
                    } else {
                        wb = A[i - 1][ku + i - 1] + wa;

                        for (j = 0; j < (n - ku - i); j++) {
                            A[i - 1][ku + i + j] = (1.0 / wb) * A[i - 1][ku + i + j];
                        }

                        A[i - 1][ku + i - 1] = 1.0;
                        tau = wb / wa;
                    }

                    // Apply reflection to A(i:m-1,ku+i-1:n-1) from the right
                    B = new double[m - i][n - ku - i + 1];

                    for (j = 0; j < (m - i); j++) {

                        for (k = 0; k < (n - ku - i + 1); k++) {
                            B[j][k] = A[i + j][ku + i - 1 + k];
                        }
                    }

                    x = new double[n - ku - i + 1];

                    for (j = 0; j < (n - ku - i + 1); j++) {
                        x[j] = A[i - 1][ku + i - 1 + j];
                    }

                    dgemv('N', m - i, n - ku - i + 1, 1.0, B, m - i, x, 1, 0.0, work, 1);
                    dger(m - i, n - ku - i + 1, -tau, work, 1, x, 1, B, m - i);

                    for (j = 0; j < (m - i); j++) {

                        for (k = 0; k < (n - ku - i + 1); k++) {
                            A[i + j][ku + i - 1 + k] = B[j][k];
                        }
                    }

                    A[i - 1][ku + i - 1] = -wa;
                } // if (i <= Math.min(n-1-ku, m))
            } // if (kl <= ku)
            else { // kl > ku

                // annihilate superdiagonal elements first (necessary if ku = 0)
                if (i <= Math.min(n - 1 - ku, m)) {

                    // generate reflection to annihilate A(i-1,ku+i:n-1)
                    x = new double[n - ku - i + 1];

                    for (j = 0; j < (n - ku - i + 1); j++) {
                        x[j] = A[i - 1][ku + i - 1 + j];
                    }

                    wn = dnrm2(n - ku - i + 1, x, 1);

                    if (A[i - 1][ku + i - 1] >= 0) {
                        wa = Math.abs(wn);
                    } else {
                        wa = -Math.abs(wn);
                    }

                    if (wn == 0.0) {
                        tau = 0.0;
                    } else {
                        wb = A[i - 1][ku + i - 1] + wa;

                        for (j = 0; j < (n - ku - i); j++) {
                            A[i - 1][ku + i + j] = (1.0 / wb) * A[i - 1][ku + i + j];
                        }

                        A[i - 1][ku + i - 1] = 1.0;
                        tau = wb / wa;
                    }

                    // apply reflection to A(i:m-1,ku+i-1:n-1) from the right
                    B = new double[m - i][n - ku - i + 1];

                    for (j = 0; j < (m - i); j++) {

                        for (k = 0; k < (n - ku - i + 1); k++) {
                            B[j][k] = A[i + j][ku + i - 1 + k];
                        }
                    }

                    x = new double[n - ku - i + 1];

                    for (j = 0; j < (n - ku - i + 1); j++) {
                        x[j] = A[i - 1][ku + i - 1 + j];
                    }

                    dgemv('N', m - i, n - ku - i + 1, 1.0, B, m - i, x, 1, 0.0, work, 1);
                    dger(m - i, n - ku - i + 1, -tau, work, 1, x, 1, B, m - i);

                    for (j = 0; j < (m - i); j++) {

                        for (k = 0; k < (n - ku - i + 1); k++) {
                            A[i + j][ku + i - 1 + k] = B[j][k];
                        }
                    }

                    A[i - 1][ku + i - 1] = -wa;
                } // if (i <= Math.min(n-1-ku,m))

                if (i <= Math.min(m - 1 - kl, n)) {

                    // generate reflection to annihilate A(kl+i:m-1,i-1)
                    x = new double[m - kl - i + 1];

                    for (j = 0; j < (m - kl - i + 1); j++) {
                        x[j] = A[kl + i - 1 + j][i - 1];
                    }

                    wn = dnrm2(m - kl - i + 1, x, 1);

                    if (A[kl + i - 1][i - 1] >= 0.0) {
                        wa = Math.abs(wn);
                    } else {
                        wa = -Math.abs(wn);
                    }

                    if (wn == 0.0) {
                        tau = 0.0;
                    } else {
                        wb = A[kl + i - 1][i - 1] + wa;

                        for (j = 0; j < (m - kl - i); j++) {
                            A[kl + i + j][i - 1] = (1.0 / wb) * A[kl + i + j][i - 1];
                        }

                        A[kl + i - 1][i - 1] = 1.0;
                        tau = wb / wa;
                    }

                    // apply reflection to A(kl+i-1:m-1,i:n-1) from the left
                    B = new double[m - kl - i + 1][n - i];

                    for (j = 0; j < (m - kl - i + 1); j++) {

                        for (k = 0; k < (n - i); k++) {
                            B[j][k] = A[kl + i - 1 + j][i + k];
                        }
                    }

                    x = new double[m - kl - i + 1];

                    for (j = 0; j < (m - kl - i + 1); j++) {
                        x[j] = A[kl + i - 1 + j][i - 1];
                    }

                    dgemv('T', m - kl - i + 1, n - i, 1.0, B, m - kl - i + 1, x, 1, 0.0, work, 1);
                    dger(m - kl - i + 1, n - i, -tau, x, 1, work, 1, B, m - kl - i + 1);

                    for (j = 0; j < (m - kl - i + 1); j++) {

                        for (k = 0; k < (n - i); k++) {
                            A[kl + i - 1 + j][i + k] = B[j][k];
                        }
                    }

                    A[kl + i - 1][i - 1] = -wa;
                } // if (i <= Math.min(m-1-kl, n))
            } // else kl > ku

            for (j = kl + i + 1; j <= m; j++) {
                A[j - 1][i - 1] = 0.0;
            }

            for (j = ku + i + 1; j <= n; j++) {
                A[i - 1][j - 1] = 0.0;
            }
        } // for (i = 1; i <= Math.max(m-1-kl, n-1-ku); i++)

        return;
    } // dlagge

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine dlagsy Original DLAGSY created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlagsy generates a real symmetric matrix A, by pre- and post- multiplying a real diagonal matrix D with
     * a random orthogonal matrix: A = U*D*U'. The semi-bandwidth may then be reduced to k by additional orthogonal
     * transformations.
     *
     * @param  n      input int The order of the matrix A. n >= 0.
     * @param  k      input int The number of nonzero subdiagonals within the band of A. 0 <= k <= n-1.
     * @param  D      input double[] of dimension n. The diagonal elements of the diagonal matrix D.
     * @param  A      output double[][] of dimension (lda,n) The generated n by n symmetric matrix A (the full matrix is
     *                stored).
     * @param  lda    input int The leading dimension of the array A. lda >= n.
     * @param  iseed  input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
     *                elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
     * @param  work   workspace double[] of dimension (2*n)
     * @param  info   output int[] 
     *         = 0: successful exit 
     *         < 0: If info[0] = -i, the i-th argument had an illegal value
     */
    private void dlagsy(int n, int k, double[] D, double[][] A, int lda, int[] iseed, double[] work, int[] info) {
        int i;
        int j;
        int m;
        double alpha;
        double tau;
        double wa;
        double wb = 0.0;
        double wn;
        double[][] B;
        double[] work2 = new double[n];
        double[] x;

        // Test the input arguments
        info[0] = 0;

        if (n < 0) {
            info[0] = -1;
        } else if ((k < 0) || (k > (n - 1))) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -5;
        }

        if (info[0] < 0) {
            MipavUtil.displayError("Error dlagsy had info[0] = " + info[0]);

            return;
        }

        // initialize lower triangle of A to diagonal matrix
        for (j = 0; j < n; j++) {

            for (i = j + 1; i < n; i++) {
                A[i][j] = 0.0;
            }
        }

        for (i = 0; i < n; i++) {
            A[i][i] = D[i];
        }

        // Generate lower triangle of symmetric matrix
        for (i = n - 1; i >= 1; i--) {

            // generate random reflection
            dlarnv(3, iseed, n - i + 1, work);
            wn = dnrm2(n - i + 1, work, 1);

            if (work[0] >= 0.0) {
                wa = Math.abs(wn);
            } else {
                wa = -Math.abs(wn);
            }

            if (wn == 0.0) {
                tau = 0.0;
            } else {
                wb = work[0] + wa;

                for (j = 0; j < (n - i); j++) {
                    work[j + 1] = (1.0 / wb) * work[j + 1];
                }

                work[0] = 1.0;
                tau = wb / wa;
            }

            // apply random reflection to A(i-1:n-1,i-1:n-1) from the left and
            // the right
            // compute y = tau * A * u
            B = new double[n - i + 1][n - i + 1];

            for (j = 0; j < (n - i + 1); j++) {

                for (m = 0; m < (n - i + 1); m++) {
                    B[j][m] = A[i - 1 + j][i - 1 + m];
                }
            }

            dsymv('L', n - i + 1, tau, B, n - i + 1, work, 1, 0.0, work2, 1);

            // compute v = y - 1/2 * tau * (y, u) * u
            alpha = -0.5 * tau * ddot(n - i + 1, work2, 1, work, 1);
            daxpy(n - i + 1, alpha, work, 1, work2, 1);

            // apply the transformation as a rank-2 update to A(i-1:n-1,i-1:n-1)
            dsyr2('L', n - i + 1, -1.0, work, 1, work2, 1, B, n - i + 1);

            for (j = 0; j < (n - i + 1); j++) {

                for (m = 0; m < (n - i + 1); m++) {
                    A[i - 1 + j][i - 1 + m] = B[j][m];
                }
            }
        } // for (i = n-1; i >= 1; i--)

        // Reduce number of subdiagonals to k
        for (i = 1; i <= (n - 1 - k); i++) {

            // generate reflection to annihilate A(k+i:n-1,i-1)
            x = new double[n - k - i + 1];

            for (j = 0; j < (n - k - i + 1); j++) {
                x[j] = A[k + i - 1 + j][i - 1];
            }

            wn = dnrm2(n - k - i + 1, x, 1);

            if (A[k + i - 1][i - 1] >= 0.0) {
                wa = Math.abs(wn);
            } else {
                wa = -Math.abs(wn);
            }

            if (wn == 0.0) {
                tau = 0.0;
            } else {
                wb = A[k + i - 1][i - 1] + wa;

                for (j = 0; j < (n - k - i); j++) {
                    A[k + i + j][i - 1] = (1.0 / wb) * A[k + i + j][i - 1];
                }

                A[k + i - 1][i - 1] = 1.0;
                tau = wb / wa;
            }

            // apply reflection to A(k+i-1:n-1,i:k+i-2) from the left
            B = new double[n - k - i + 1][k - 1];

            for (j = 0; j < (n - k - i + 1); j++) {

                for (m = 0; m < (k - 1); m++) {
                    B[j][m] = A[k + i - 1 + j][i + m];
                }
            }

            x = new double[n - k - i + 1];

            for (j = 0; j < (n - k - i + 1); j++) {
                x[j] = A[k + i - 1 + j][i - 1];
            }

            dgemv('T', n - k - i + 1, k - 1, 1.0, B, n - k - i + 1, x, 1, 0.0, work, 1);
            dger(n - k - i + 1, k - 1, -tau, x, 1, work, 1, B, n - k - i + 1);

            for (j = 0; j < (n - k - i + 1); j++) {

                for (m = 0; m < (k - 1); m++) {
                    A[k + i - 1 + j][i + m] = B[j][m];
                }
            }

            // apply reflection to A(k+i-1:n-1,k+i-1:n-1) from the left and
            // the right
            // compute y = tau * A * u
            B = new double[n - k - i + 1][n - k - i + 1];

            for (j = 0; j < (n - k - i + 1); j++) {

                for (m = 0; m < (n - k - i + 1); m++) {
                    B[j][m] = A[k + i - 1 + j][k + i - 1 + m];
                }
            }

            x = new double[n - k - i + 1];

            for (j = 0; j < (n - k - i + 1); j++) {
                x[j] = A[k + i - 1 + j][i - 1];
            }

            dsymv('L', n - k - i + 1, tau, B, n - k - i + 1, x, 1, 0.0, work, 1);

            // compute v = y - 1/2 * tau * (y, u) * u
            alpha = -0.5 * tau * ddot(n - k - i + 1, work, 1, x, 1);
            daxpy(n - k - i + 1, alpha, x, 1, work, 1);

            // apply symmetric rank-2 update to A(k+i-1:n-1,k+i-1:n-1)
            dsyr2('L', n - k - i + 1, -1.0, x, 1, work, 1, B, n - k - i + 1);

            for (j = 0; j < (n - k - i + 1); j++) {

                for (m = 0; m < (n - k - i + 1); m++) {
                    A[k + i - 1 + j][k + i - 1 + m] = B[j][m];
                }
            }

            A[k + i - 1][i - 1] = -wa;

            for (j = k + i + 1; j <= n; j++) {
                A[j - 1][i - 1] = 0.0;
            }
        } // for (i = 1; i <= n - 1 - k; i++)

        // Store full symmetric matrix
        for (j = 0; j < n; j++) {

            for (i = j + 1; i < n; i++) {
                A[j][i] = A[i][j];
            }
        }

        return;
    } // dlagsy

    /**
     * Port of some code contained in the version 2.0 LAPACK auxiliary test routine DLAHD2 Original DLAHD2 created by
     * Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlahd2 prints header information for the different test paths
     *
     * @param  path  String Name of the path for which the header information is to be printed. DSG real symmetric
     *               generalized eigenvalue problem
     */
    private void dlahd2(String path) {

        if (path.equalsIgnoreCase("DSG")) {
            UI.setDataText("Real symmetric generalized eigenvalue problem\n");
            UI.setDataText("Matrix types\n");
            UI.setDataText("Special matrices\n");
            UI.setDataText("1 = zero matrix\n");
            UI.setDataText("2 = Identity matrix\n");
            UI.setDataText("3 = Diagonal: evenly spaced entries\n");
            UI.setDataText("4 = Diagonal: geometrically spaced entries\n");
            UI.setDataText("5 = Diagonal: clustered entries\n");
            UI.setDataText("6 = Diagonal: large evenly spaced\n");
            UI.setDataText("7 = Diagonal: small, evenly spaced\n\n");
            UI.setDataText("Dense or banded symmetric matrices\n");
            UI.setDataText("8 = Evenly spaced eigenvalues\n");
            UI.setDataText("9 = Geometrically spaced eigenvalues\n");
            UI.setDataText("10 = Clustered eigenvalues\n");
            UI.setDataText("11 = Large, evenly spaced eigenvalues\n");
            UI.setDataText("12 = Small, evenly spaced eigenvalues\n");
            UI.setDataText("13 = Matrix with random O(1) entries\n");
            UI.setDataText("14 = Matrix with large random entries\n");
            UI.setDataText("15 = Matrix with small random entries\n");
            UI.setDataText("16 = Evenly spaced eigenvalues, ka = 1, kb = 1\n");
            UI.setDataText("17 = Evenly spaced eigenvalues, ka = 2, kb = 1\n");
            UI.setDataText("18 = Evenly spaced eigenvalues, ka = 2, kb = 2\n");
            UI.setDataText("19 = Evenly spaced eigenvalues, ka = 3, kb = 1\n");
            UI.setDataText("20 = Evenly spaced eigenvalues, ka = 3, kb = 2\n");
            UI.setDataText("21 = Evenly spaced eigenvalues, ka = 3, kb = 3\n\n");
            UI.setDataText("Tests performed\n");
            UI.setDataText("For each pair (A,B), where A is of the given type\n");
            UI.setDataText("and B is a random well-conditioned matrix.  D is\n");
            UI.setDataText("diagonal, and Z is orthogonal.\n");
            UI.setDataText("1 = dsygv, with itype = 1 and uplo = 'U'\n");
            UI.setDataText("|A Z - B Z D| / (|A| |Z| n ulp)\n");
            UI.setDataText("2 = dsygv, with itype = 1 and uplo = 'L'\n");
            UI.setDataText("|A Z - B Z D| / (|A| |Z| n ulp)\n");
            UI.setDataText("3 = dsygv, with itype = 2 and uplo = 'U'\n");
            UI.setDataText("|A B Z - Z D| / (|A| |Z| n ulp)\n");
            UI.setDataText("4 = dsygv, with itype = 2 and uplo = 'L'\n");
            UI.setDataText("|A B Z - Z D| / (|A| |Z| n ulp)\n");
            UI.setDataText("5 = dsygv, with itype = 3 and uplo = 'U'\n");
            UI.setDataText("|B A Z - Z D| / (|A| |Z| n ulp)\n");
            UI.setDataText("6 = dsygv, with itype = 3 and uplo = 'L'\n");
            UI.setDataText("|B A Z - Z D| / (|A| |Z| n ulp)\n");
        }
    } // dlahd2

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLALN2 Original DLALN2 created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlaln2 solves a system of the form (ca A - w D) X = s B or (ca A' - w D) X = s B with possible scaling ("s") and
     * perturbation of A. (A' means A-transpose.)
     *
     * <p>A is an na by na real matrix, ca is a real scalar, D is an na by na real diagonal matrix, w is a real or
     * complex value, and X and B are na by 1 matrices -- real if w is real, complex if w is complex. na may be 1 or 2.
     * </p>
     *
     * <p>If w is complex, X and B are represented as na by 2 matrices, the first column of each being the real part and
     * the second being the imaginary part.</p>
     *
     * <p>"s" is a scaling factor (<= 1), computed by dlaln2, which is so chosen that X can be computed without
     * overflow. X is further scaled if necessary to assure that norm(ca A - w D)*norm(X) is less than overflow.</p>
     *
     * <p>If both singular values of (ca A - w D) are less than smin, smin*identity will be used instead of (ca A - w
     * D). If only one singular value is less than smin, one element of (ca A - w D) will be perturbed enough to make
     * the smallest singular value roughly smin. If both singular values are at least smin, (ca A - w D) will not be
     * perturbed. In any case, perturbation will be at most some small multiple of max(smin, ulp*norm(ca A - w D) ). The
     * singular values are computed by infinity-norm approximations, and thus will only be correct to a factor of 2 or
     * so.</p>
     *
     * <p>Note: All input quantities are assumed to be smaller than overflow by a reasonable factor. (See bignum.)</p>
     *
     * @param  ltrans  input boolean 
     *                 = true: A-transpose will be used. 
     *                 = false: A will be used (not transposed.)
     * @param  na      input int The size of the matrix A. It may (only) be 1 or 2.
     * @param  nw      input int 1 if "w" is real, 2 if "w" is complex. It may only be 1 or 2.
     * @param  smin    input double The desired lower bound on the singular values of A. This should be a safe distance
     *                 away from underflow or overflow, say, between (underflow/machine precision) and (machine
     *                 precision * overflow ). (See bignum and ulp.)
     * @param  ca      input double The coefficient c, which A is multiplied by.
     * @param  A       input double[][] of dimension (lda,na) The na by na matrix A.
     * @param  lda     input int The leading dimension of A. It must be at least na.
     * @param  d1      input double The 0,0 element in diagonal matrix D.
     * @param  d2      input double The 1,1 element in the diagonal matrix D. Not used if nw = 1.
     * @param  B       input double[][] of dimension (ldb,nw) The na by nw matrix B (right-hand side). If nw = 2 ("w" is
     *                 complex), column 0 contains the real part of B and column 1 contains the imaginary part.
     * @param  ldb     input int The leading dimension of B. It must be at least na.
     * @param  wr      input double The real part of the scalar "w".
     * @param  wi      input double The imaginary part of the scalar "w". Not used if nw = 1.
     * @param  X       output double[][] of dimension (ldx,nw). The na by nw matrix X (unknowns), as computed by dlaln2.
     *                 If nw = 2 ("w" is complex), on exit, column 0 will contain the real part of X and column 1 will
     *                 contain the imaginary part.
     * @param  ldx     input int The leading dimension of X. It must be at least na.
     * @param  scale   output double[] The scale factor that B must be multiplied by to insure that overflow does not
     *                 occur when computing X. Thus, (ca A - w D) X will be scale*B, not B(ignoring perturbations of A.)
     *                 It will be at most 1.
     * @param  xnorm   output double[] The infinity-norm of X, when X is regarded as an na by nw real matrix.
     * @param  info    output int[] An error flag. It will be set to zero if no error occurs, a negative number if an
     *                 argument is in error, or a positive number if ca A - w D had to be perturbed. The possible values
     *                 are: 
     *                 = 0: No error occurred, and (ca A - w D) did not have to be perturbed.
     *                 = 1: (ca A - w D) had to be perturbed to make its smallest (or only) singular value greater than smin.
     * Note: In the interests of speed, this routine does not check the inputs for errors.
     */
    private void dlaln2(boolean ltrans, int na, int nw, double smin, double ca, double[][] A, int lda, double d1,
                        double d2, double[][] B, int ldb, double wr, double wi, double[][] X, int ldx, double[] scale,
                        double[] xnorm, int[] info) {
        int icmax;
        int j;
        double bbnd;
        double bi1;
        double bi2;
        double bignum;
        double bnorm;
        double br1;
        double br2;
        double ci21;
        double ci22;
        double cmax;
        double cnorm;
        double cr21;
        double cr22;
        double csi;
        double csr;
        double li21;
        double lr21;
        double smini;
        double smlnum;
        double temp;
        double u22abs;
        double ui11;
        double ui11r;
        double ui12;
        double ui12s;
        double ui22;
        double ur11;
        double ur11r;
        double ur12;
        double ur12s;
        double ur22;
        double xi1;
        double[] xi2 = new double[1];
        double xr1;
        double[] xr2 = new double[1];
        boolean[] rswap = new boolean[] { false, true, false, true };
        boolean[] zswap = new boolean[] { false, false, true, true };
        int[][] ipivot = new int[4][4];
        ipivot[0][0] = 1;
        ipivot[1][0] = 2;
        ipivot[2][0] = 3;
        ipivot[3][0] = 4;
        ipivot[0][1] = 2;
        ipivot[1][1] = 1;
        ipivot[2][1] = 4;
        ipivot[3][1] = 3;
        ipivot[0][2] = 3;
        ipivot[1][2] = 4;
        ipivot[2][2] = 1;
        ipivot[3][2] = 2;
        ipivot[0][3] = 4;
        ipivot[1][3] = 3;
        ipivot[2][3] = 2;
        ipivot[3][3] = 1;

        double[] civ = new double[4];
        double[] crv = new double[4];
        double[] pout = new double[1];
        double[] qout = new double[1];

        // Compute bignum
        smlnum = 2.0 * dlamch('S');
        bignum = 1.0 / smlnum;
        smini = Math.max(smin, smlnum);

        // Don't check for input errors
        info[0] = 0;

        // Standard initializations
        scale[0] = 1.0;

        if (na == 1) {

            // 1 by 1 (i.e., scalar) system C X = B
            if (nw == 1) {

                // Real 1 by 1 system
                // C = ca A - w D
                csr = (ca * A[0][0]) - (wr * d1);
                cnorm = Math.abs(csr);

                // If |C| < smini, use C = smini
                if (cnorm < smini) {
                    csr = smini;
                    cnorm = smini;
                    info[0] = 1;
                } // if (cnorm < smini)

                // Check scaling for X = B / C
                bnorm = Math.abs(B[0][0]);

                if ((cnorm < 1.0) && (bnorm > 1.0)) {

                    if (bnorm > (bignum * cnorm)) {
                        scale[0] = 1.0 / bnorm;
                    }
                } // if ((cnorm < 1.0) && (bnorm > 1.0))

                // Compute X
                X[0][0] = (B[0][0] * scale[0]) / csr;
                xnorm[0] = Math.abs(X[0][0]);
            } // if (nw == 1)
            else { // nw == 2

                // Complex 1 by 1 system (w is complex)
                // C = ca A - w D
                csr = (ca * A[0][0]) - (wr * d1);
                csi = -wi * d1;
                cnorm = Math.abs(csr) + Math.abs(csi);

                // If |C| < smini, use C = smini
                if (cnorm < smini) {
                    csr = smini;
                    csi = 0.0;
                    cnorm = smini;
                    info[0] = 1;
                } // if (cnorm < smini)

                // Check scaling for X = B / C
                bnorm = Math.abs(B[0][0]) + Math.abs(B[0][1]);

                if ((cnorm < 1.0) && (bnorm > 1.0)) {

                    if (bnorm > (bignum * cnorm)) {
                        scale[0] = 1.0 / bnorm;
                    }
                } // if ((cnorm < 1.0) && (bnorm > 1.0))

                // Compute X
                dladiv(scale[0] * B[0][0], scale[0] * B[0][1], csr, csi, pout, qout);
                X[0][0] = pout[0];
                X[0][1] = qout[0];
                xnorm[0] = Math.abs(X[0][0]) + Math.abs(X[0][1]);
            } // else nw == 2
        } // if (na == 1)
        else { // na == 2

            // 2 by 2 System
            // Compute the real part of C = ca A - w D (or ca A' - w D)
            crv[0] = (ca * A[0][0]) - (wr * d1);
            crv[3] = (ca * A[1][1]) - (wr * d2);

            if (ltrans) {
                crv[2] = ca * A[1][0];
                crv[1] = ca * A[0][1];
            } else {
                crv[1] = ca * A[1][0];
                crv[2] = ca * A[0][1];
            }

            if (nw == 1) {

                // Real 2 by 2 system (w is real)
                // Find the largest element in C
                cmax = 0.0;
                icmax = -1;

                for (j = 0; j < 4; j++) {

                    if (Math.abs(crv[j]) > cmax) {
                        cmax = Math.abs(crv[j]);
                        icmax = j;
                    }
                } // for (j = 0; j < 4; j++)

                // If norm(C) < smini, use smini*identity
                if (cmax < smini) {
                    bnorm = Math.max(Math.abs(B[0][0]), Math.abs(B[1][0]));

                    if ((smini < 1.0) && (bnorm > 1.0)) {

                        if (bnorm > (bignum * smini)) {
                            scale[0] = 1.0 / bnorm;
                        }
                    } // if ((smini < 1.0) && (bnorm > 1.0))

                    temp = scale[0] / smini;
                    X[0][0] = temp * B[0][0];
                    X[1][0] = temp * B[1][0];
                    xnorm[0] = temp * bnorm;
                    info[0] = 1;

                    return;
                } // if (cmax < smini)

                // Gaussian elimination with complete pivoting
                ur11 = crv[icmax];
                cr21 = crv[ipivot[1][icmax] - 1];
                ur12 = crv[ipivot[2][icmax] - 1];
                cr22 = crv[ipivot[3][icmax] - 1];
                ur11r = 1.0 / ur11;
                lr21 = ur11r * cr21;
                ur22 = cr22 - (ur12 * lr21);

                // If smaller pivot < smini, use smini
                if (Math.abs(ur22) < smini) {
                    ur22 = smini;
                    info[0] = 1;
                }

                if (rswap[icmax]) {
                    br1 = B[1][0];
                    br2 = B[0][0];
                } else {
                    br1 = B[0][0];
                    br2 = B[1][0];
                }

                br2 = br2 - (lr21 * br1);
                bbnd = Math.max(Math.abs(br1 * (ur22 * ur11r)), Math.abs(br2));

                if ((bbnd > 1.0) && (Math.abs(ur22) < 1.0)) {

                    if (bbnd >= (bignum * Math.abs(ur22))) {
                        scale[0] = 1.0 / bbnd;
                    }
                } // if ((bbnd > 1.0) && (Math.abs(ur22) < 1.0))

                xr2[0] = (br2 * scale[0]) / ur22;
                xr1 = ((scale[0] * br1) * ur11r) - (xr2[0] * (ur11r * ur12));

                if (zswap[icmax]) {
                    X[0][0] = xr2[0];
                    X[1][0] = xr1;
                } else {
                    X[0][0] = xr1;
                    X[1][0] = xr2[0];
                }

                xnorm[0] = Math.max(Math.abs(xr1), Math.abs(xr2[0]));

                // Further scaling if norm(A) norm(X) > overflow
                if ((xnorm[0] > 1.0) && (cmax > 1.0)) {

                    if (xnorm[0] > (bignum / cmax)) {
                        temp = cmax / bignum;
                        X[0][0] = temp * X[0][0];
                        X[1][0] = temp * X[1][0];
                        xnorm[0] = temp * xnorm[0];
                        scale[0] = temp * scale[0];
                    } // if (xnorm[0] > bignum / cmax)
                } // if ((xnorm[0] > 1.0) && (cmax > 1.0))
            } // if (nw == 1)
            else { // nw == 2

                // Complex 2 by 2 system ( w is complex)
                // Find the largest element in C
                civ[0] = -wi * d1;
                civ[1] = 0.0;
                civ[2] = 0.0;
                civ[3] = -wi * d2;
                cmax = 0.0;
                icmax = -1;

                for (j = 0; j < 4; j++) {

                    if ((Math.abs(crv[j]) + Math.abs(civ[j])) > cmax) {
                        cmax = Math.abs(crv[j]) + Math.abs(civ[j]);
                        icmax = j;
                    }
                } // for (j = 0; j < 4; j++)

                // If norm(C) < smini, use smini * identity
                if (cmax < smini) {
                    bnorm = Math.max(Math.abs(B[0][0]) + Math.abs(B[0][1]), Math.abs(B[1][0]) + Math.abs(B[1][1]));

                    if ((smini < 1.0) && (bnorm > 1.0)) {

                        if (bnorm > (bignum * smini)) {
                            scale[0] = 1.0 / bnorm;
                        }
                    } // if ((smini < 1.0) && (bnorm > 1.0))

                    temp = scale[0] / smini;
                    X[0][0] = temp * B[0][0];
                    X[1][0] = temp * B[1][0];
                    X[0][1] = temp * B[0][1];
                    X[1][1] = temp * B[1][1];
                    xnorm[0] = temp * bnorm;
                    info[0] = 1;

                    return;
                } // if (cmax < smini)

                // Gaussian elimination with complete pivoting
                ur11 = crv[icmax];
                ui11 = civ[icmax];
                cr21 = crv[ipivot[1][icmax] - 1];
                ci21 = civ[ipivot[1][icmax] - 1];
                ur12 = crv[ipivot[2][icmax] - 1];
                ui12 = civ[ipivot[2][icmax] - 1];
                cr22 = crv[ipivot[3][icmax] - 1];
                ci22 = civ[ipivot[3][icmax] - 1];

                if ((icmax == 0) || (icmax == 3)) {

                    // Code when off-diagonals of pivoted C are real
                    if (Math.abs(ur11) > Math.abs(ui11)) {
                        temp = ui11 / ur11;
                        ur11r = 1.0 / (ur11 * (1.0 + (temp * temp)));
                        ui11r = -temp * ur11r;
                    } // if (Math.abs(ur11) > Math.abs(ui11))
                    else {
                        temp = ur11 / ui11;
                        ui11r = -1.0 / (ui11 * (1.0 + (temp * temp)));
                        ur11r = -temp * ui11r;
                    }

                    lr21 = cr21 * ur11r;
                    li21 = cr21 * ui11r;
                    ur12s = ur12 * ur11r;
                    ui12s = ur12 * ui11r;
                    ur22 = cr22 - (ur12 * lr21);
                    ui22 = ci22 - (ur12 * li21);
                } // if ((icmax == 0) || (icmax == 3))
                else {

                    // Code when diagonals of pivoted C are real
                    ur11r = 1.0 / ur11;
                    ui11r = 0.0;
                    lr21 = cr21 * ur11r;
                    li21 = ci21 * ur11r;
                    ur12s = ur12 * ur11r;
                    ui12s = ui12 * ur11r;
                    ur22 = cr22 - (ur12 * lr21) + (ui12 * li21);
                    ui22 = (-ur12 * li21) - (ui12 * lr21);
                } // else

                u22abs = Math.abs(ur22) + Math.abs(ui22);

                // If smaller pivot < smini, use smini
                if (u22abs < smini) {
                    ur22 = smini;
                    ui22 = 0.0;
                    info[0] = 1;
                } // if (u22abs < smini)

                if (rswap[icmax]) {
                    br2 = B[0][0];
                    br1 = B[1][0];
                    bi2 = B[0][1];
                    bi1 = B[1][1];
                } // if (rswap[icmax])
                else {
                    br1 = B[0][0];
                    br2 = B[1][0];
                    bi1 = B[0][1];
                    bi2 = B[1][1];
                } // else

                br2 = br2 - (lr21 * br1) + (li21 * bi1);
                bi2 = bi2 - (li21 * br1) - (lr21 * bi1);
                bbnd = Math.max((Math.abs(br1) + Math.abs(bi1)) * (u22abs * (Math.abs(ur11r) + Math.abs(ui11r))),
                                Math.abs(br2) + Math.abs(bi2));

                if ((bbnd > 1.0) && (u22abs < 1.0)) {

                    if (bbnd >= (bignum * u22abs)) {
                        scale[0] = 1.0 / bbnd;
                        br1 = scale[0] * br1;
                        bi1 = scale[0] * bi1;
                        br2 = scale[0] * br2;
                        bi2 = scale[0] * bi2;
                    } // if (bbnd >= bignum * u22abs)
                } // if ((bbnd > 1.0) && (u22abs < 1.0))

                dladiv(br2, bi2, ur22, ui22, xr2, xi2);
                xr1 = (ur11r * br1) - (ui11r * bi1) - (ur12s * xr2[0]) + (ui12s * xi2[0]);
                xi1 = (ui11r * br1) + (ur11r * bi1) - (ui12s * xr2[0]) - (ur12s * xi2[0]);

                if (zswap[icmax]) {
                    X[0][0] = xr2[0];
                    X[1][0] = xr1;
                    X[0][1] = xi2[0];
                    X[1][1] = xi1;
                } else {
                    X[0][0] = xr1;
                    X[1][0] = xr2[0];
                    X[0][1] = xi1;
                    X[1][1] = xi2[0];
                }

                xnorm[0] = Math.max(Math.abs(xr1) + Math.abs(xi1), Math.abs(xr2[0]) + Math.abs(xi2[0]));

                // Further scaling if norm(A) norm(X) > overflow
                if ((xnorm[0] > 1.0) && (cmax > 1.0)) {

                    if (xnorm[0] > (bignum / cmax)) {
                        temp = cmax / bignum;
                        X[0][0] = temp * X[0][0];
                        X[1][0] = temp * X[1][0];
                        X[0][1] = temp * X[0][1];
                        X[1][1] = temp * X[1][1];
                        xnorm[0] = temp * xnorm[0];
                        scale[0] = temp * scale[0];
                    } // if (xnorm[0] > bignum / cmax)
                } // if ((xnorm[0] > 1.0) && (cmax > 1.0))
            } // else nw == 2
        } // else na == 2

        return;
    } // dlaln2

    /**
     * Port of version 3.1 LAPACK auxiliary routine DLAMC1 Original DLAMC1 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dlamc1 determines the machine parameters given by beta, t, rnd, and ieee1.
     *
     * @param  beta   output int[] The base of the machine.
     * @param  t      output int[] The number of (beta) digits in the mantissa
     * @param  rnd    output boolean[] Specifies whether proper rounding (rnd = true) or chopping (rnd = false) occurs in
     *                addition. This may not be a reliable guide to the way in which the machine performs its
     *                arithmetic.
     * @param  ieee1  output boolean[] Specifies whether rounding appears to be done in the IEEE 'round to nearest'
     *                style.
     * This routine is based on the routine ENVRON by Malcolm and incorporates suggestions by Gentleman and Marovich. See
     * Malcolm, M. A. (1972) Algorithms to reveal properties of floating-point arithmetic.  Comms. of the ACM, 15,
     * pp. 949-951.
     * Gentleman, W. M. and Marovich S. B. (1974) More on algorithms that reveal properties of floating point
     * arithmetic units.  Comms. of the ACM, 17, pp. 276-277.
     */
    private void dlamc1(int[] beta, int[] t, boolean[] rnd, boolean[] ieee1) {
        boolean lieee1;
        boolean lrnd;
        int lbeta;
        int lt;
        double a;
        double b;
        double c;
        double f;
        double one;
        double qtr;
        double savec;
        double t1;
        double t2;

        one = 1;

        // lbeta, lieee1, lt, and lrnd are the local values of beta, ieee1, t, and
        // rnd.

        // Throughout this routine we use the function dlamc3 to ensure that
        // relevant values are stored and not held in registers, or are not
        // affected by optimizers.

        // Compute a = 2.0**m with the smallest positive integer m such that
        // computed value(a + 1.0) = a.
        a = 1;
        c = 1;

        while (c == one) {
            a = 2 * a;
            c = dlamc3(a, one);
            c = dlamc3(c, -a);
        } // while (c == one)

        // Now compute b = 2.0**m with the smallest positive integer m such that
        // computed value(a + b) > a
        b = 1;
        c = dlamc3(a, b);

        while (c == a) {
            b = 2 * b;
            c = dlamc3(a, b);
        } // while (c == a)

        // Now compute the base.  a and c are neighboring floating point numbers
        // in the interval (beta**t, beta**(t+1)) and so their difference is beta.
        // Adding 0.25 to c is to ensure that it is truncated to beta and not
        // (beta - 1).

        qtr = one / 4;
        savec = c;
        c = dlamc3(c, -a);
        lbeta = (int) (c + qtr);

        // Now determine whether rounding or chopping occurs, by adding a
        // bit less than beta/2 and a bit more than beta/2 to a.

        b = lbeta;
        f = dlamc3(b / 2, -b / 100);
        c = dlamc3(f, a);

        if (c == a) {
            lrnd = true;
        } else {
            lrnd = false;
        }

        f = dlamc3(b / 2, b / 100);
        c = dlamc3(f, a);

        if ((lrnd) && (c == a)) {
            lrnd = false;
        }

        // Try and decide whether rounding is done in the IEEE 'round to nearest'
        // style. b/2 is half a unit in the last place of the two numbers a and
        // savec.  Furthermore, a is even, i.e. has last bit zero, and savec is
        // odd. Thus adding b/2 to a should not change a, but adding b/2 to savec
        // should change savec.

        t1 = dlamc3(b / 2, a);
        t2 = dlamc3(b / 2, savec);
        lieee1 = (t1 == a) && (t2 > savec) && lrnd;

        // Now find the mantissa, t.  It should be the integer part of log to the
        // base beta of a, however it is safer to determine t by powering.  So we
        // find t as the smallest positive integer for which
        // computed value(beta**t + 1.0) = 1.0.

        lt = 0;
        a = 1;
        c = 1;

        while (c == one) {
            lt = lt + 1;
            a = a * lbeta;
            c = dlamc3(a, one);
            c = dlamc3(c, -a);
        } // while (c == one)

        beta[0] = lbeta;
        t[0] = lt;
        rnd[0] = lrnd;
        ieee1[0] = lieee1;

        return;
    } // dlamc1

    /**
     * Port of LAPACK version 3.1 auxiliary routine DLAMC2 Original DLAMC2 created by Univ. of Tennessee, Univ. of
     * California Berkeley, nad NAG Ltd., November, 2006
     * Determines machine parameters 3 globals are determined: 1.) eps double The smallest positive number such that
     * computed value(1.0 - eps) < 1.0 2.) rmin double The smallest normalized number for the machine, given by
     * base**(emin - 1), where base is the floating point value of beta. 3.) rmax double The largest positive number for
     * the machine, given by base**emax*(1-eps), where base is the floating point value of beta.
     *
     * @param  beta  output int[] The base of the machine.
     * @param  t     output int[] The number of (beta) digits in the mantissa.
     * @param  rnd   ouptut boolean Specifies whether proper rounding (rnd == true) or chopping (rnd == false) occurs in
     *               addition. This may not be a reliable guide to the way in which the machine performs its arithmetic
     * @param  emin  output int[] The minimum exponent before (gradual) underflow occurs
     * @param  emax  output int[] The maximum exponent before overflow occurs
     * The computation of EPS is based on a routine PARANOIA by W. Kahan of the University of California at Berkeley.
     */
    private void dlamc2(int[] beta, int[] t, boolean[] rnd, int[] emin, int[] emax) {
        boolean ieee;
        boolean iwarn = false;
        boolean[] lieee1 = new boolean[1];
        boolean[] lrnd = new boolean[1];
        int[] gnmin = new int[1];
        int[] gpmin = new int[1];
        int i;
        int[] lbeta = new int[1];
        int[] lemax = new int[1];
        int lemin;
        int[] lt = new int[1];
        int[] ngnmin = new int[1];
        int[] ngpmin = new int[1];
        double a;
        double b;
        double c;
        double half;
        double leps;
        double[] lrmax = new double[1];
        double lrmin;
        double one;
        double rbase;
        double sixth;
        double small;
        double third;
        double two;
        double zero;

        zero = 0;
        one = 1;
        two = 2;

        // lbeta, lt, lrnd, leps, lemin, and lrmin are local values of beta, t,
        // rnd, eps, emin, and rmin.

        // Throughout this routine we use the function dlamc3 to ensure that
        // relevant values are stored and not held in registers, or are not
        // affected by optimizers.

        // dlamc1 returns the parameters lbeta, lt, lrnd, and lieee1.
        dlamc1(lbeta, lt, lrnd, lieee1);

        // Start to find eps

        b = lbeta[0];
        a = Math.pow(b, -lt[0]);
        leps = a;

        // Try some tricks to see whether or not this is the correct eps.
        b = two / 3;
        half = one / 2;
        sixth = dlamc3(b, -half);
        third = dlamc3(sixth, sixth);
        b = dlamc3(third, -half);
        b = dlamc3(b, sixth);
        b = Math.abs(b);

        if (b < leps) {
            b = leps;
        }

        leps = 1;

        while ((leps > b) && (b > zero)) {
            leps = b;
            c = dlamc3(half * leps, Math.pow(two, 5.0) * (leps * leps));
            c = dlamc3(half, -c);
            b = dlamc3(half, c);
            c = dlamc3(half, -b);
            b = dlamc3(half, c);
        } // while ((leps > b) && (b > zero))

        if (a < leps) {
            leps = a;
        }

        // Computation of eps complete.

        // Now find emin.  let a = + or - 1, and + or - (1 + base**(-3)).
        // Keep dividing a by beta until (gradual) underflow occurs. This
        // is detected when we cannot recover the previous a.

        rbase = one / lbeta[0];
        small = one;

        for (i = 1; i <= 3; i++) {
            small = dlamc3(small * rbase, zero);
        }

        a = dlamc3(one, small);
        dlamc4(ngpmin, one, lbeta[0]);
        dlamc4(ngnmin, -one, lbeta[0]);
        dlamc4(gpmin, a, lbeta[0]);
        dlamc4(gnmin, -a, lbeta[0]);
        ieee = false;

        if ((ngpmin[0] == ngnmin[0]) && (gpmin[0] == gnmin[0])) {

            if (ngpmin[0] == gpmin[0]) {
                lemin = ngpmin[0];
                // Non twos-complement machnines, no gradual underflow; e.g., VAX
            } else if ((gpmin[0] - ngpmin[0]) == 3) {
                lemin = ngpmin[0] - 1 + lt[0];
                ieee = true;
                // Non twos-complement machines, with gradual underflow; e.g, IEEE
                // standard followers
            } else {
                lemin = Math.min(ngpmin[0], gpmin[0]);

                // A guess; no known machine
                iwarn = true;
            }
        } // if ((ngpmin[0] == ngnmin[0]) && (gpmin[0] == gnmin[0]))
        else if ((ngpmin[0] == gpmin[0]) && (ngnmin[0] == gnmin[0])) {

            if (Math.abs(ngpmin[0] - ngnmin[0]) == 1) {
                lemin = Math.max(ngpmin[0], ngnmin[0]);
                // Twos-complement machines, no gradual underflow, e.g., CYBER 205
            } else {
                lemin = Math.min(ngpmin[0], ngnmin[0]);

                // A guess; no known machine
                iwarn = true;
            }
        } // else if ((ngpmin[0] == gpmin[0]) && (ngnmin[0] == gnmin[0]))
        else if ((Math.abs(ngpmin[0] - ngnmin[0]) == 1) && (gpmin[0] == gnmin[0])) {

            if ((gpmin[0] - Math.min(ngpmin[0], ngnmin[0])) == 3) {
                lemin = Math.max(ngpmin[0], ngnmin[0]) - 1 + lt[0];
                // Twos-complement machines with gradual underflow; no known machine
            } else {
                lemin = Math.min(ngpmin[0], ngnmin[0]);

                // A guess; no known machine
                iwarn = true;
            }
        } // else if ((Math.abs(ngpmin[0] - ngnmin[0]) == 1) && (gpmin[0] == gnmin[0]))
        else {
            lemin = Math.min(ngpmin[0], Math.min(ngnmin[0], Math.min(gpmin[0], gnmin[0])));

            // A guess; no known machine
            iwarn = true;
        }

        if (iwarn) {
            Preferences.debug("iwarn is true in dlamc2 emin = " + lemin + "\n");
            Preferences.debug("The emin value may be incorrect\n");
        }

        // Assume IEEE arithmetic if we found denormalized numbers above, or if
        // arithmetic seems to round in the IEEE style, determined in routine
        // dlamc1.  A true IEEE machine should have both things true; however,
        // faulty macines may have one or the other.
        ieee = ieee || lieee1[0];

        // Compute rmin by successive division by beta.  We could compute rmin as
        // base**(emin-1), but some machines underflow during this computation.

        lrmin = 1;

        for (i = 1; i <= (1 - lemin); i++) {
            lrmin = dlamc3(lrmin * rbase, zero);
        }

        // Finally, call dlamc5 to compute emax and rmax
        dlamc5(lbeta[0], lt[0], lemin, ieee, lemax, lrmax);

        beta[0] = lbeta[0];
        t[0] = lt[0];
        rnd[0] = lrnd[0];
        eps = leps;
        emin[0] = lemin;
        rmin = lrmin;
        emax[0] = lemax[0];
        rmax = lrmax[0];

        return;
    } // dlamc2

    /**
     * This is a port of the LAPACK version 3.1 auxiliary routine DLAMC3 Original DLAMC3 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlamc3 is intended to force a and b to be stored prior to doing the addition of a and b, for use in
     * situations where optimizers might hold one of these in a register
     *
     * @param   a  double
     * @param   b  double
     *
     * @return  double
     */
    private double dlamc3(double a, double b) {
        double answer = a + b;

        return answer;
    }

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLAMC4 Original DLAMC4 created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlamc4 is a service routine for dlamc2
     *
     * @param  emin   output int[] The minimum exponent before (gradual) underflow, computed by setting a = start and
     *                dividing by base until the previous a cannot be recovered
     * @param  start  input double The starting point for determining emin.
     * @param  base   input int The base of the machine.
     */
    private void dlamc4(int[] emin, double start, int base) {
        int i;
        double a;
        double b1;
        double b2;
        double c1;
        double c2;
        double d1;
        double d2;
        double one;
        double rbase;
        double zero;

        a = start;
        one = 1;
        rbase = one / base;
        zero = 0;
        emin[0] = 1;
        b1 = dlamc3(a * rbase, zero);
        c1 = a;
        c2 = a;
        d1 = a;
        d2 = a;

        while ((c1 == a) && (c2 == a) && (d1 == a) && (d2 == a)) {
            emin[0] = emin[0] - 1;
            a = b1;
            b1 = dlamc3(a / base, zero);
            c1 = dlamc3(b1 * base, zero);
            d1 = zero;

            for (i = 1; i <= base; i++) {
                d1 = d1 + b1;
            }

            b2 = dlamc3(a * rbase, zero);
            c2 = dlamc3(b2 / rbase, zero);
            d2 = zero;

            for (i = 1; i <= base; i++) {
                d2 = d2 + b2;
            }
        } // while ((c1 == a) && (c2 == a) && (d1 == a) && (d2 == a))

        return;
    }

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLAMC5 Original DLAMC5 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlamc5 attempts to compute rmax, the largest machine floating-point number, without overflow. It assumes
     * that emax + abs(emin) sum approximately to a power of 2. It will fail on machines where this assumption does not
     * hold, for example, the Cyber 205 (emin = -28625, emax = 28718). It will also fail if the value supplied for emin
     * is too large (i.e. too close to zero), probably with overflow
     *
     * @param  beta  input int The base of floating-point arithmetic.
     * @param  p     input int The number of base beta digits in the mantissa of a floating-point value.
     * @param  emin  input int The minimum exponent before (gradual) underflow.
     * @param  ieee  input boolean A logical flag specifying whether or not the arithmetic system is thought to comply
     *               with the IEEE standard.
     * @param  emax  output int[] The largest exponent before overflow.
     * @param  rmax  output double[] The largest machine floating-point number.
     */
    private void dlamc5(int beta, int p, int emin, boolean ieee, int[] emax, double[] rmax) {
        int exbits;
        int expsum;
        int i;
        int lexp;
        int nbits;
        int trya;
        int uexp;
        double oldy = 0.0;
        double recbas;
        double y;
        double z;

        // First compute lexp and uexp, two powers of 2 that bound abs(emin).  We
        // then assume that emax + abs(emin) will sum approximately to the bound
        // that is closest to abs(emin).  (emax is the exponent of the required
        // number rmax).

        lexp = 1;
        exbits = 1;
        trya = lexp * 2;

        while (trya <= (-emin)) {
            lexp = trya;
            exbits = exbits + 1;
            trya = lexp * 2;
        } // while (trya <= (-emin))

        if (lexp == -emin) {
            uexp = lexp;
        } else {
            uexp = trya;
            exbits = exbits + 1;
        }

        // Now -lexp is less than or equal to emin, and -uexp is greater than or
        // equal to emin.  exbits is the number of bits needed to store the
        // exponent.

        if ((uexp + emin) > (-lexp - emin)) {
            expsum = 2 * lexp;
        } else {
            expsum = 2 * uexp;
        }

        // expsum is the exponent range, approximately equal to emax - emin + 1
        emax[0] = expsum + emin - 1;
        nbits = 1 + exbits + p;

        // nbits is the total number of bits needed to store a floating-point
        // number.

        if (((nbits % 2) == 1) && (beta == 2)) {

            // Either there are an odd number of bits used to store a floating-point
            // number, which is unlikely, or some bits are not used in the
            // representation of numbers, which is possible, (e.g Cray machines) or
            // the mantissa has an implicit bit, (e.g. IEEE machines, Dec VAX
            // machines), which is perhaps the most likely.  We have to assume the
            // last alternative.  If this is true, then we need to reduce emax by
            // one because there must be some way of representing zero in an
            // implicit-bit system.  On machines like the Cray, we are reducing
            // emax by one unnecessarily.
            emax[0] = emax[0] - 1;
        }

        if (ieee) {

            // Assume we are on an IEEE machine which reserves one exponent for
            // infinity and NaN
            emax[0] = emax[0] - 1;
        }

        // Now create rmax, the largest machine number, which should be equal to
        // (1.0 - beta**(-p))* beta**emax.

        // First compute 1.0 - beta**(-p), being careful that the result is less
        // than 1.0.

        recbas = 1.0 / beta;
        z = beta - 1.0;
        y = 0.0;

        for (i = 1; i <= p; i++) {
            z = z * recbas;

            if (y < 1.0) {
                oldy = y;
            }

            y = dlamc3(y, z);
        } // for (i = 1; i <= p; i++)

        if (y >= 1.0) {
            y = oldy;
        }

        // Now multiply by beta**emax to get rmax

        for (i = 1; i <= emax[0]; i++) {
            y = dlamc3(y * beta, 0.0);
        }

        rmax[0] = y;

        return;
    }

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLAMCH Original DLAMCH created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlamch determines double precision machine parameters.
     *
     * @param   cmach  input char Specifies the value to be returned by dlamch
     *                 = 'E' or 'e', returns eps, relative machine precision 
     *                 = 'S' or 's', returns sfmin, safe minimum, such that 1/sfmin does not overflow
     *                 = 'B' or 'b', returns base, base of the machine
     *                 = 'P' or 'p', returns prec = eps*base
     *                 = 'N' or 'n', returns t, number of (base) digits in the mantissa
     *                 = 'R' or 'r', returns rnd = 1.0 when rounding occurs in addition, 0.0 otherwise 
     *                 = 'M' or 'm', returns emin, minimum exponent before (gradual) underflow 
     *                 = 'U' or 'u', returns rmin, underflow threshold = base**(emin-1)
     *                 = 'L' or 'l', emax, largest exponent before overflow 
     *                 = 'O' or 'o', rmax, overflow threshold = (base**emax)*(1-eps)
     *
     * @return  double
     */
    private double dlamch(char cmach) {

        boolean[] lrnd = new boolean[1];
        int[] beta = new int[1];
        int[] imax = new int[1];
        int[] imin = new int[1];
        int[] it = new int[1];
        double rmach = 0.0;
        double small;

        if (first) {
            first = false;
            dlamc2(beta, it, lrnd, imin, imax);
            base = beta[0];
            t = it[0];

            if (lrnd[0]) {
                rnd = 1.0;
                eps = Math.pow(base, (1 - it[0])) / 2.0;
            } else {
                rnd = 0.0;
                eps = Math.pow(base, (1 - it[0]));
            }

            prec = eps * base;
            emin = imin[0];
            emax = imax[0];
            sfmin = rmin;
            small = 1.0 / rmax;

            if (small >= sfmin) {

                // Use small plus a bit, to avoid the possibility of rounding causing
                // overflow when computing 1/sfmin.
                sfmin = small * (1.0 + eps);
            }
        } // if (first)

        if ((cmach == 'E') || (cmach == 'e')) {
            rmach = eps;
        } else if ((cmach == 'S') || (cmach == 's')) {
            rmach = sfmin;
        } else if ((cmach == 'B') || (cmach == 'b')) {
            rmach = base;
        } else if ((cmach == 'P') || (cmach == 'p')) {
            rmach = prec;
        } else if ((cmach == 'N') || (cmach == 'N')) {
            rmach = t;
        } else if ((cmach == 'R') || (cmach == 'r')) {
            rmach = rnd;
        } else if ((cmach == 'M') || (cmach == 'm')) {
            rmach = emin;
        } else if ((cmach == 'U') || (cmach == 'u')) {
            rmach = rmin;
        } else if ((cmach == 'L') || (cmach == 'l')) {
            rmach = emax;
        } else if ((cmach == 'O') || (cmach == 'o')) {
            rmach = rmax;
        }

        return rmach;
    } // dlamch

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLANGB Original DLANGB created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlangb returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest
     * absolute value of an n by n band matrix A, with kl sub-diagonals and ku super-diagonals.
     *
     * @param   norm  input char Specifies the value to be returned as: 
     *                = 'M' or 'm', returns max(abs(A[i][j])), which is not a matrix norm. 
     *                = '1', 'O', or 'o', returns norm1(A), where norm1 denotes the one norm of a matrix
     *                                   (maximum column sum) 
     *                = 'I' or 'i', returns normI(A), the infinity norm of a matrix (maximum row sum) 
     *                = 'F', 'f', 'E', or 'e', returns normF(A), the Frobenius norm of a matrix (square root of
     *                                         sum of squares)
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, dlangb returns zero.
     * @param   kl    input int The number of sub-diagonals of the matrix A. kl >= 0.
     * @param   ku    input int The number of super-diagonals of the matrix A. ku >= 0.
     * @param   ab    input double[][] of dimension (ldab,n) The band matrix A, stored in rows 0 to kl + ku. The
     *                j-th column of A is stored in the j-th column of the array ab as follows: ab[ku+1+i-j][j] =
     *                A[i][j] for max(0,j-ku) <= i <= min(n-1,j+kl)
     * @param   ldab  input int The leading dimension of the array ab. ldab >= kl + ku + 1
     * @param   work  workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I';
     *                otherwise work is notreferenced.
     *
     * @return  double
     */
    private double dlangb(char norm, int n, int kl, int ku, double[][] ab, int ldab, double[] work) {
        int i;
        int j;
        int k;
        int L;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double value = 0.0;
        double[] x;

        if (n == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {

            // Find max(abs(A[i][j]))
            value = 0.0;

            for (j = 1; j <= n; j++) {

                for (i = Math.max(ku + 2 - j, 1); i <= Math.min(n + ku + 1 - j, kl + ku + 1); i++) {
                    value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
                }
            }
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find norm1(A)
            value = 0.0;

            for (j = 1; j <= n; j++) {
                sum[0] = 0.0;

                for (i = Math.max(ku + 2 - j, 1); i <= Math.min(n + ku + 1 - j, kl + ku + 1); i++) {
                    sum[0] = sum[0] + Math.abs(ab[i - 1][j - 1]);
                }

                value = Math.max(value, sum[0]);
            }
        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
        else if ((norm == 'I') || (norm == 'i')) {

            // Find normI(A)
            for (i = 0; i < n; i++) {
                work[i] = 0.0;
            }

            for (j = 1; j <= n; j++) {
                k = ku + 1 - j;

                for (i = Math.max(1, j - ku); i <= Math.min(n, j + kl); i++) {
                    work[i - 1] = work[i - 1] + Math.abs(ab[k + i - 1][j - 1]);
                }
            }

            value = 0.0;

            for (i = 0; i < n; i++) {
                value = Math.max(value, work[i]);
            }
        } // else if ((norm == 'I') || (norm == 'i'))
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

            // Find normF(A)
            scale[0] = 0.0;
            sum[0] = 1.0;

            for (j = 1; j <= n; j++) {
                L = Math.max(1, j - ku);
                k = ku + 1 - j + L;
                x = new double[Math.min(n, j + kl) - L + 1];

                for (i = 0; i < (Math.min(n, j + kl) - L + 1); i++) {
                    x[i] = ab[k + i - 1][j - 1];
                }

                dlassq(Math.min(n, j + kl) - L + 1, x, 1, scale, sum);
            }

            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E')

        return value;
    }

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLANGE Original DLANGE created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlange returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of the
     * largest absolute value of a real matrix A.
     *
     * @param   norm  input char Specifies the value to be returned from dlange as:
     *                = 'M' or 'm' returns max(abs(A[i][j])). Note that this is not a matrix norm. 
     *                = '1', 'O' or 'o' returns norm1(A), where norm1 denotes the one norm of a matrix
     *                                 (maximum column sum) 
     *                = 'I' or 'i' returns normI(A), where normI denotes the infinity norm of a matrix (maximum row sum)
     *                = 'F', 'f', 'E', or 'e' returns normF(A), where normF denotes the Frobenius norm of a matrix
     *                                       (square root of sum of squares).
     * @param   m     input int The number of rows of the matrix A. m >= 0. When m = 0, dlange returns zero.
     * @param   n     input int The number of columns of the matrix A. n >= 0. When n = 0, dlange returns zero.
     * @param   A     input double[][] array of dimension (lda,n). Contains the m by n matrix A.
     * @param   lda   input int The leading dimension of the array A. lda >= max(1,m).
     * @param   work  workspace double[] of dimension max(1, lwork), where lwork >= m when norm = 'I';
     *                otherwise, work is not referenced.
     *
     * @return  double
     */
    private double dlange(char norm, int m, int n, double[][] A, int lda, double[] work) {
        int i;
        int j;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double value = 0.0;
        double[] x;

        if (Math.min(m, n) == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {
            // Find max(abs(A[i][j]))

            value = 0.0;

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    value = Math.max(value, Math.abs(A[i][j]));
                }
            }
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find norm1(A)
            value = 0.0;

            for (j = 0; j < n; j++) {
                sum[0] = 0.0;

                for (i = 0; i < m; i++) {
                    sum[0] = sum[0] + Math.abs(A[i][j]);
                }

                value = Math.max(value, sum[0]);
            } // for (j = 0; j < n; j++)
        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
        else if ((norm == 'I') || (norm == 'i')) {

            // Find normI(A)
            for (i = 0; i < m; i++) {
                work[i] = 0.0;
            }

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    work[i] = work[i] + Math.abs(A[i][j]);
                }
            } // for (j = 0; j < n; j++)

            value = 0.0;

            for (i = 0; i < m; i++) {
                value = Math.max(value, work[i]);
            }
        } // else if ((norm == 'I') || (norm == 'i'))
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

            // Find normF(A)
            scale[0] = 0.0;
            sum[0] = 1.0;
            x = new double[m];

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    x[i] = A[i][j];
                }

                dlassq(m, x, 1, scale, sum);
            } // for (j = 0; j < n; j++)

            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

        return value;
    } // dlange

    /**
     * This is a port the the version 3.1 LAPACK auxiliary routine DLANHS Original DLANHS created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlanhs returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of
     * largest absolute value of a Hessenberg matrix A.
     *
     * @param   norm  norm char Specifies the value to be returned in dlanhs as: 
     *                = 'M' or 'm', max(abs(A[i][j])), which is not a matrix norm 
     *                = '1', 'O', or 'o', norm1(A), the one norm of a matrix (maximum column sum) 
     *                = 'I' or 'i', normI(A), the infinity norm of a matrix (maximum row sum) 
     *                = 'F', 'f', 'E', or 'e', normF(A), the Frobenius norm of a matrix (square root of sum of squares)
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, dlanhs returns 0.0.
     * @param   A     input double[][] of dimension (lda,n) The n by n upper Hessenberg matrix A; the part of A below
     *                the first subdiagonal is not referenced.
     * @param   lda   input int The leading dimension of the array A. lda >= max(n,1).
     * @param   work  workspace double[] of dimension max(1, lwork) where lwork >= n when norm = 'I';
     *                otherwise, work is not referenced.
     *
     * @return  double
     */
    private double dlanhs(char norm, int n, double[][] A, int lda, double[] work) {
        int i;
        int j;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double value = 0.0;
        double[] x;

        if (n == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {

            // Find max(abs(A[i][j]))
            value = 0.0;

            for (j = 0; j < n; j++) {

                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
                    value = Math.max(value, Math.abs(A[i][j]));
                }
            }
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find norm1(A)
            value = 0.0;

            for (j = 0; j < n; j++) {
                sum[0] = 0.0;

                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
                    sum[0] = sum[0] + Math.abs(A[i][j]);
                }

                value = Math.max(value, sum[0]);
            }
        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
        else if ((norm == 'I') || (norm == 'i')) {

            // Find normI(A)
            for (i = 0; i < n; i++) {
                work[i] = 0.0;
            }

            for (j = 0; j < n; j++) {

                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
                    work[i] = work[i] + Math.abs(A[i][j]);
                }
            }

            value = 0.0;

            for (i = 0; i < n; i++) {
                value = Math.max(value, work[i]);
            }
        } // else if ((norm == 'I') || (norm == 'i'))
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

            // Find normF(A)
            scale[0] = 0.0;
            sum[0] = 1.0;

            for (j = 1; j <= n; j++) {
                x = new double[Math.min(n, j + 1)];

                for (i = 0; i < Math.min(n, j + 1); i++) {
                    x[i] = A[i][j - 1];
                }

                dlassq(Math.min(n, j + 1), x, 1, scale, sum);
            } // for (j = 1; j <= n; j++)

            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

        return value;
    } // dlanhs

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLANSB Original DLANSB created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlansb retruns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest
     * absolute value of an n by n symmetric band matrix A, with k super-diagonals.
     *
     * @param   norm  input char Specifies the value to be returned as: 
     *                = 'M' or 'm', returns max(abs(A[i][j])), which is not a matrix norm 
     *                = '1', 'O', or 'o', returns norm1(A), the one norm of a matrix (maximum column sum) 
     *                = 'I' or 'i', returns normI(A), the inifinity norm of a matrix (maximum row sum) 
     *                = 'F', 'f', 'E', or 'e', returns normF(A), the Frobenius norm of a matrix
     *                  (square root of sum of squares)
     * @param   uplo  input char Specifies whether the upper or lower triangular part of the band matrix A is supplied 
     *                = 'U': Upper triangular part is supplied. 
     *                = 'L': Lower triangular part is supplied.
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, dlansb returns zero.
     * @param   k     input int The number of super-diagonals or sub-diagonals of the band matrix A. k >= 0.
     * @param   ab    input double[][] of dimension (ldab,n) The upper or lower triangle of the symmetric band matrix A,
     *                stored in the first k+1 rows of ab. The j-th column of A is stored in the j-th column of the array
     *                ab as follows:
     *                If uplo = 'U', ab[k+1+i-j][j] = A[i][j] for max(0,j-k) <= i <= j
     *                If uplo = 'L', ab[1+i-j][j] = A[i][j] for j <= i <= min(n-1,j+k)
     * @param   ldab  input int The leading dimension of array ab. ldab >= k + 1.
     * @param   work  workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I' or '1' or 'O';
     *                otherwise, work is not referenced.
     *
     * @return  DOCUMENT ME!
     */
    private double dlansb(char norm, char uplo, int n, int k, double[][] ab, int ldab, double[] work) {
        int i;
        int j;
        int L;
        double absa;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double value = 0.0;
        double[] x;

        if (n == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {

            // Find max(abs(A[i][j]))
            value = 0.0;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 1; j <= n; j++) {

                    for (i = Math.max(k + 2 - j, 1); i <= (k + 1); i++) {
                        value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
                    }
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= Math.min(n + 1 - j, k + 1); i++) {
                        value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
                    }
                }
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find normI(A) = norm1(A), since A is symmetric
            value = 0.0;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 1; j <= n; j++) {
                    sum[0] = 0.0;
                    L = k + 1 - j;

                    for (i = Math.max(1, j - k); i <= (j - 1); i++) {
                        absa = Math.abs(ab[L + i - 1][j - 1]);
                        sum[0] = sum[0] + absa;
                        work[i - 1] = work[i - 1] + absa;
                    }

                    work[j - 1] = sum[0] + Math.abs(ab[k][j - 1]);
                } // for (j = 1; j <= n; j++)

                for (i = 0; i < n; i++) {
                    value = Math.max(value, work[i]);
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (i = 0; i < n; i++) {
                    work[i] = 0.0;
                }

                for (j = 1; j <= n; j++) {
                    sum[0] = work[j - 1] + Math.abs(ab[0][j - 1]);
                    L = 1 - j;

                    for (i = j + 1; i <= Math.min(n, j + k); i++) {
                        absa = Math.abs(ab[L + i - 1][j - 1]);
                        sum[0] = sum[0] + absa;
                        work[i - 1] = work[i - 1] + absa;
                    }

                    value = Math.max(value, sum[0]);
                } // for (j = 1; j <= n; j++)
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') ||
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

            // Find normF(A)
            scale[0] = 0.0;
            sum[0] = 1.0;

            if (k > 0) {

                if ((uplo == 'U') || (uplo == 'u')) {

                    for (j = 2; j <= n; j++) {
                        x = new double[Math.min(j - 1, k)];

                        for (i = 0; i < Math.min(j - 1, k); i++) {
                            x[i] = ab[Math.max(k + 1 - j, 0) + i][j - 1];
                        }

                        dlassq(Math.min(j - 1, k), x, 1, scale, sum);
                    }

                    L = k + 1;
                } // if ((uplo == 'U') || (uplo == 'u'))
                else { // ((uplo == 'L') || (uplo == 'l'))

                    for (j = 1; j <= (n - 1); j++) {
                        x = new double[Math.min(n - j, k)];

                        for (i = 0; i <= Math.min(n - j, k); i++) {
                            x[i] = ab[i + 1][j - 1];
                        }

                        dlassq(Math.min(n - j, k), x, 1, scale, sum);
                    }

                    L = 1;
                } // else ((uplo == 'L') || (uplo == 'l'))

                sum[0] = 2.0 * sum[0];
            } // if (k > 0)
            else { // k == 0
                L = 1;
            } // else k == 0

            x = new double[n];

            for (i = 0; i < n; i++) {
                x[i] = ab[L - 1][i];
            }

            dlassq(n, x, 1, scale, sum);
            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

        return value;
    } // dlansb

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLANSP Original DLANSP created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlansp returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of
     * largest absolute value of a real symmetric matrix A, supplied in packed form.
     *
     * @param   norm  input char Specifies the value to be returned as: 
     *                = 'M' or 'm' , max(abs(A[i,j])) Note that this is not a matrix norm. 
     *                = '1', 'O', or 'o', norm1(A) where norm1 denotes the one norm of a matrix (maximum column sum) 
     *                = 'I' or 'i', normI(A) where normI denotes the infinity norm of a matrix (maximum row sum) 
     *                = 'F', 'f', 'E', or 'e', normF(A) where normF denotes the Frobenius norm of a matrix 
     *                  (square root of sum of squares)
     * @param   uplo  input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
     *                supplied. 
     *                = 'U': Upper triangular part of A is supplied 
     *                = 'L': Lower triangular part of A is supplied
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, dlansp is set to zero.
     * @param   ap    input double[] of dimension (n*(n+1)/2) The upper or lower triangle of the symmetric matrix A,
     *                packed columnwise in a linear array. The j-th column of A is stored in the array AP as follows:
     *                If uplo = 'U', ap[i + (j-1)*j/2] = A[i][j] for 0 <= i <= j
     *                If uplo = 'L', ap[i + (j-1)*(2n-j)/2] = A[i][j] for j <= i <= n-1.
     * @param   work  workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I' or '1' or 'O';
     *                otherwise work is not referenced.
     *
     * @return  double
     */
    private double dlansp(char norm, char uplo, int n, double[] ap, double[] work) {
        int i;
        int j;
        int k;
        double absa;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double[] x;
        double value = 0.0;
        double ratio;

        if (n == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {

            // Find max(abs(A[i][j]))
            value = 0.0;

            if ((uplo == 'U') || (uplo == 'u')) {
                k = 1;

                for (j = 1; j <= n; j++) {

                    for (i = k; i <= (k + j - 1); i++) {
                        value = Math.max(value, Math.abs(ap[i - 1]));
                    }

                    k = k + j;
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))
                k = 1;

                for (j = 1; j <= n; j++) {

                    for (i = k; i <= (k + n - j); i++) {
                        value = Math.max(value, Math.abs(ap[i - 1]));
                    }

                    k = k + n - j + 1;
                }
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find normI(A) == norm1(A), since A is symmetric
            value = 0.0;
            k = 1;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 1; j <= n; j++) {
                    sum[0] = 0.0;

                    for (i = 1; i <= (j - 1); i++) {
                        absa = Math.abs(ap[k - 1]);
                        sum[0] = sum[0] + absa;
                        work[i - 1] = work[i - 1] + absa;
                        k = k + 1;
                    }

                    work[j - 1] = sum[0] + Math.abs(ap[k - 1]);
                    k = k + 1;
                } // for (j = 1; j <= n; j++)

                for (i = 0; i < n; i++) {
                    value = Math.max(value, work[i]);
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (i = 0; i < n; i++) {
                    work[i] = 0.0;
                }

                for (j = 1; j <= n; j++) {
                    sum[0] = work[j - 1] + Math.abs(ap[k - 1]);
                    k = k + 1;

                    for (i = j + 1; i <= n; i++) {
                        absa = Math.abs(ap[k - 1]);
                        sum[0] = sum[0] + absa;
                        work[i - 1] = work[i - 1] + absa;
                        k = k + 1;
                    } // for (i = j+1; i <= n; i++)

                    value = Math.max(value, sum[0]);
                } // for (j = 1; j <= n; j++)
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') ||
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

            // Find normF(A)
            scale[0] = 0.0;
            sum[0] = 1.0;
            k = 2;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 2; j <= n; j++) {
                    x = new double[j - 1];

                    for (i = 0; i < (j - 1); i++) {
                        x[i] = ap[k - 1 + i];
                    }

                    dlassq(j - 1, x, 1, scale, sum);
                    k = k + j;
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (j = 1; j <= (n - 1); j++) {
                    x = new double[n - j];

                    for (i = 0; i < (n - j); i++) {
                        x[i] = ap[k - 1 + i];
                    }

                    dlassq(n - j, x, 1, scale, sum);
                    k = k + n - j + 1;
                }
            } // else ((uplo == 'L') || (uplo == 'l'))

            sum[0] = 2.0 * sum[0];
            k = 1;

            for (i = 1; i <= n; i++) {

                if (ap[k - 1] != 0.0) {
                    absa = Math.abs(ap[k - 1]);

                    if (scale[0] < absa) {
                        ratio = scale[0] / absa;
                        sum[0] = 1.0 + (sum[0] * ratio * ratio);
                        scale[0] = absa;
                    } else {
                        ratio = absa / scale[0];
                        sum[0] = sum[0] + (ratio * ratio);
                    }
                } // if (ap[k-1] != 0.0)

                if ((uplo == 'U') || (uplo == 'u')) {
                    k = k + i + 1;
                } else {
                    k = k + n - i + 1;
                }
            } // for (i = 1; i <= n; i++)

            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

        return value;
    } // dlansp

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLANST Original DLANST created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlanst returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of the
     * largest absolute value of a real symmetric tridiagonal matrix A
     *
     * @param   norm  input char Specifies the value to be returned as: 
     *                = 'M' or 'm', max(abs(A[i][j])). This is not a matrix norm. 
     *                = '1', 'O', or 'o', norm1(A), the one norm of a matrix (maximum column sum). 
     *                = 'I' or 'i', normI(A), the infinity norm of a matrix (maximum row sum).
     *                = 'F', 'f', 'E', or 'e', normF(A), the Frobenius norm of a matrix 
     *                (square root of sum of squares).
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, zero is returned.
     * @param   d     input double[] of dimension n. The diagonal elements of A.
     * @param   e     input double[] of dimension n-1. The (n-1) sub-diagonal or super-diagonal elements of A.
     *
     * @return  double
     */
    private double dlanst(char norm, int n, double[] d, double[] e) {
        int i;
        double anorm = 0.0;
        double[] scale = new double[1];
        double[] sum = new double[1];

        if (n <= 0) {
            anorm = 0.0;
        } // if (n <= 0)
        else if ((norm == 'M') || (norm == 'm')) {
            // Find max(abs(A[i][j]))

            anorm = Math.abs(d[n - 1]);

            for (i = 0; i < (n - 1); i++) {
                anorm = Math.max(anorm, Math.abs(d[i]));
                anorm = Math.max(anorm, Math.abs(e[i]));
            } // for (i = 0; i < n-1; i++)
        } // else if ((norm == 'M') == (norm == 'm'))
        else if ((norm == 'O') || (norm == 'o') || (norm == '1') || (norm == 'I') || (norm == 'i')) {

            // Find norm1(A).
            if (n == 1) {
                anorm = Math.abs(d[0]);
            } // if (n == 1)
            else { // n != 1
                anorm = Math.max(Math.abs(d[0]) + Math.abs(e[0]), Math.abs(e[n - 2]) + Math.abs(d[n - 1]));

                for (i = 1; i <= (n - 2); i++) {
                    anorm = Math.max(anorm, Math.abs(d[i]) + Math.abs(e[i]) + Math.abs(e[i - 1]));
                } // for (i = 1; i <= n-2; i++)
            } // else n != 1
        } // else if ((norm == '0') ||
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {
            // find normF(A).

            scale[0] = 0.0;
            sum[0] = 1.0;

            if (n > 1) {
                dlassq(n - 1, e, 1, scale, sum);
                sum[0] = 2 * sum[0];
            } // if (n > 1)

            dlassq(n, d, 1, scale, sum);
            anorm = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') ||

        return anorm;
    } // dlanst

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLANSY. Original DLANSY created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlansy returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of
     * largest absolute value of a real symmetric matrix A.
     *
     * @param   norm  input char Specifies the value to be returned by dlansy as follows: 
     *                = 'M' or 'm', max(abs(A[i][j])); this is not a matrix norm. 
     *                = '1', 'O', or 'o', norm1(A), where norm1 denotes the one norm of a matrix (maximum column sum) 
     *                = 'I' or 'i', normI(A), where normI denotes the infinity norm of a matrix (maximum row sum) 
     *                = 'F', 'f', 'E', or 'e', normF(A) , where normF denotes the Frobenius norm of a matrix
     *                  (square root of sum of squares)
     * @param   uplo  input char Specifies whether the upper or lower triangular part of the symmetric matrix A is to be
     *                referenced.
     *                = 'U': Upper triangular part of A is referenced 
     *                = 'L': Lower triangular part of A is referenced
     * @param   n     input int The order of the matrix A. n >= 0. When n = 0, the answer returned by dlansy is zero.
     * @param   A     input double[][] of dimension lda by n. The symmetric matrix A. If uplo = 'U', the leading n by n
     *                upper triangular part of A contains the upper triangular part of the matrix A, and the strictly
     *                lower triangular part of A is not referenced. If uplo = 'L', the leading n by n lower triangular
     *                part of A contains the lower triangular part of the matrix A, and the strictly upper triangular
     *                part of A is not referenced.
     * @param   lda   input int The leading dimension of the array A. lda >= max(n,1).
     * @param   work  workspace double[] of dimension max(1, lwork), where lwork >= n when used with one norm or infinity norm;
     *                otherwise work is not referenced.
     *
     * @return  double
     */
    private double dlansy(char norm, char uplo, int n, double[][] A, int lda, double[] work) {
        int i;
        int j;
        double absa;
        double[] scale = new double[1];
        double[] sum = new double[1];
        double value = 0.0;
        double[] vector1;

        if (n == 0) {
            value = 0.0;
        } else if ((norm == 'M') || (norm == 'm')) {

            // Find max(abs(A[i][j]))
            value = 0.0;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i <= j; i++) {
                        value = Math.max(value, Math.abs(A[i][j]));
                    }
                }
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (j = 0; j < n; j++) {

                    for (i = j; i < n; i++) {
                        value = Math.max(value, Math.abs(A[i][j]));
                    }
                }
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'M') || (norm == 'm'))
        else if ((norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

            // Find normI(A) (== norm1(A), since A is symmetric).
            value = 0.0;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 0; j < n; j++) {
                    sum[0] = 0.0;

                    for (i = 0; i <= (j - 1); i++) {
                        absa = Math.abs(A[i][j]);
                        sum[0] = sum[0] + absa;
                        work[i] = work[i] + absa;
                    } // for (i = 0; i <= j-1; i++)

                    work[j] = sum[0] + Math.abs(A[j][j]);
                } // for (j = 0; j < n; j++)

                for (i = 0; i < n; i++) {
                    value = Math.max(value, work[i]);
                } // for (i = 0; i < n; i++)
            } // if (uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (i = 0; i < n; i++) {
                    work[i] = 0.0;
                } // for (i = 0; i < n; i++)

                for (j = 0; j < n; j++) {
                    sum[0] = work[j] + Math.abs(A[j][j]);

                    for (i = j + 1; i < n; i++) {
                        absa = Math.abs(A[i][j]);
                        sum[0] = sum[0] + absa;
                        work[i] = work[i] + absa;
                    } // for (i = j+1; i < n; i++)

                    value = Math.max(value, sum[0]);
                } // for (j = 0; j < n; j++)
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o')
        else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {
            // Find normF(A)

            scale[0] = 0.0;
            sum[0] = 1.0;

            if ((uplo == 'U') || (uplo == 'u')) {

                for (j = 2; j <= n; j++) {
                    vector1 = new double[j - 1];

                    for (i = 0; i < (j - 1); i++) {
                        vector1[i] = A[i][j - 1];
                    }

                    dlassq(j - 1, vector1, 1, scale, sum);
                } // for (j = 2; j <= n; j++)
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                for (j = 1; j <= (n - 1); j++) {
                    vector1 = new double[n - j];

                    for (i = 0; i < (n - j); i++) {
                        vector1[i] = A[j + i][j - 1];
                    }

                    dlassq(n - j, vector1, 1, scale, sum);
                } // for (j = 1; j <= n-1; j++)
            } // else ((uplo == 'L') || (uplo == 'l'))

            sum[0] = 2 * sum[0];
            vector1 = new double[n];

            for (i = 0; i < n; i++) {
                vector1[i] = A[i][i];
            }

            dlassq(n, vector1, 1, scale, sum);
            value = scale[0] * Math.sqrt(sum[0]);
        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e'))

        return value;
    } // dlansy

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLAPY2 Original DLAPY2 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlapy2 returns sqrt(x**2 + y**2), taking care not to cause unnecessary overflow.
     *
     * @param   x  input double
     * @param   y  input double
     *
     * @return  double
     */
    private double dlapy2(double x, double y) {
        double w;
        double xabs;
        double yabs;
        double z;
        double ratio;

        xabs = Math.abs(x);
        yabs = Math.abs(y);
        w = Math.max(xabs, yabs);
        z = Math.min(xabs, yabs);

        if (z == 0.0) {
            return w;
        } else {
            ratio = z / w;

            return (w * Math.sqrt(1.0 + (ratio * ratio)));
        }
    } // dlapy2

    /**
     * dlapy3 is a port of hte version 3.1 LAPLACK auxiliary routine DLAPY3 Original DLAPY3 created by Univ. of
     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlapy3 returns sqrt(x**2+y**2+z**2), taking care not to cause unnecessary overflow.
     *
     * @param   x  input double
     * @param   y  input double
     * @param   z  input double
     *
     * @return  double
     */
    private double dlapy3(double x, double y, double z) {
        double w;
        double xabs;
        double yabs;
        double zabs;
        double result;

        xabs = Math.abs(x);
        yabs = Math.abs(y);
        zabs = Math.abs(z);
        w = Math.max(xabs, yabs);
        w = Math.max(w, zabs);

        if (w == 0.0) {
            // w can be zero for max(0, NaN, 0)
            // Adding all three entries together will make sure NaN will not disappear
            result = xabs + yabs + zabs;
        } else {
            xabs = xabs / w;
            yabs = yabs / w;
            zabs = zabs / w;
            result = w * Math.sqrt((xabs * xabs) + (yabs * yabs) + (zabs * zabs));
        }

        return result;
    } // dlapy3

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARAN Original DLAAN created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlaran returns a random real number from a uniform (0,1) distribution This routine uses a multiplicative
     * congruential method with modulus 2**48 and multiplier 33952834046453 (see G. S. Fishman, "Multiplicative
     * congruential random number generators with modulus 2**b: an exhaustive analysis for b = 32 and a partial analysis
     * for b = 48", Math. Comp. 189, pp. 331-344, 1990).
     *
     * <p>48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is portable
     * across machines with integers of 32 bits or more.</p>
     *
     * @param   iseed  (input/output) int[] of dimension 4. On entry, the seed of the random number generator; the array
     *                 elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
     *
     * @return  double
     */
    private double dlaran(int[] iseed) {
        int m1 = 494;
        int m2 = 322;
        int m3 = 2508;
        int m4 = 2549;
        int ipw2 = 4096;
        double r = 1.0 / ipw2;
        int it1;
        int it2;
        int it3;
        int it4;
        double rndout = 1.0;

        while (rndout == 1.0) {
        // Multiply the seed by the multiplier module 2**48
        it4 = iseed[3] * m4;
        it3 = it4 / ipw2;
        it4 = it4 - (ipw2 * it3);
        it3 = it3 + (iseed[2] * m4) + (iseed[3] * m3);
        it2 = it3 / ipw2;
        it3 = it3 - (ipw2 * it2);
        it2 = it2 + (iseed[1] * m4) + (iseed[2] * m3) + (iseed[3] * m2);
        it1 = it2 / ipw2;
        it2 = it2 - (ipw2 * it1);
        it1 = it1 + (iseed[0] * m4) + (iseed[1] * m3) + (iseed[2] * m2) + (iseed[3] * m1);
        it1 = it1 % ipw2;

        // Return updated seed
        iseed[0] = it1;
        iseed[1] = it2;
        iseed[2] = it3;
        iseed[3] = it4;

        // Convert 48-bit integer to a real number in the interval (0,1)
        rndout =  r * (it1 + (r * (it2 + (r * (it3 + (r * it4))))));
        // If a real number has n bits of precision, and the first n bits of the 48-bit integer above happen
        // to be all 1 (which will occur about once every 2**n calls), then rndout will be rounded to exactly 1.0
        // Since dlaran is not supposed to return exactly 0.0 or 1.0, the statistically correct thing to do in
        // this situation is simply to iterate again.  
        // N.B. The case rndout = 0.0 should not be possible.
        } // while (rndout == 1.0)
        return rndout;
    } // dlaran

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLARF Original DLARF created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlarf applies a real elementary reflector H to a real
     * m by n matrix C, from either the left or right. H is represented in the form H = I - tau * v * v' where tau is a
     * real scalar and v is a real vector If tau = 0, then H is taken to be the unit matrix.
     *
     * @param  side  input char = 'L': form H * C, = 'R': form C * H
     * @param  m     input int The number of rows of the matrix C
     * @param  n     input int The number of columns of the matrix C.
     * @param  v     input double[] If side = 'L' dimension = (1 + (m-1)*abs(incv)) If side = 'R' dimension = (1 +
     *               (n-1)*abs(incv)) The vector v in the representation of H. v is not used if tau = 0.
     * @param  incv  input int The increment between elements of v. incv <> 0.
     * @param  tau   input double The value of tau in the representation of H.
     * @param  C     input/output double[][] of dimension ldc by n. On entry, the m by n matrix C. On exit, C is
     *               overwritten by the matrix H * C if side = 'L', or C * H if side = 'R'.
     * @param  ldc   input int The leading dimension of array C. ldc >= max(1,m).
     * @param  work  workspace double[] If side = 'L', dimension = n. If side = 'R', dimension = m.
     */
    private void dlarf(char side, int m, int n, double[] v, int incv, double tau, double[][] C, int ldc,
                       double[] work) {

        if ((side == 'L') || (side == 'l')) {

            // Form H * C
            if (tau != 0.0) {

                // w = C' * v
                dgemv('T', m, n, 1.0, C, ldc, v, incv, 0.0, work, 1);

                // C = C - v * w'
                dger(m, n, -tau, v, incv, work, 1, C, ldc);
            } // if (tau != 0.0)
        } // if ((side == 'L') || (side == 'l'))
        else { // ((side == 'R') || (side == 'r'))

            // Form C * H
            if (tau != 0.0) {

                // w = C * v
                dgemv('N', m, n, 1.0, C, ldc, v, incv, 0.0, work, 1);

                // C = C - w * v'
                dger(m, n, -tau, work, 1, v, incv, C, ldc);
            } // if (tau != 0.0)
        } // else ((side == 'R') || (side == 'r'))

        return;
    } // dlarf

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARFB Original DLARFB created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlarfb applies a real block reflector H or its transpose H' to a real m by n matrix C, from either the left or
     * the right.
     *
     * @param  side    input char 
     *                 = 'L': apply H or H' from the left 
     *                 = 'R': apply H or H' from the right
     * @param  trans   input char 
     *                 = 'N': Apply H (No transpose) 
     *                 = 'T': Apply H' (Transpose)
     * @param  direct  input char Indicates how H is formed from a product of elementary reflectors 
     *                 = 'F': H = H[0] H[1] ... H[k-1] (Forward) 
     *                 = 'B': H = H[k-1] ... H[1] H[0] (Backward)
     * @param  storev  input char Indicates how the vectors which define the elementary reflectors are stored: 
     *                 = 'C': Columnwise 
     *                 = 'R': Rowwise
     * @param  m       input int The number of rows of the matrix C.
     * @param  n       input int The number of columns of the matrix C.
     * @param  k       input int The order of the matrix T (= the number of elementary reflectors whose product defines
     *                 the block reflector).
     * @param  V       input double[][] If storev = 'C', dimensions are ldv by k. If storev = 'R' and side = 'L',
     *                 dimensions are ldv by m. If storev = 'R' and side = 'R', dimensions are ldv by n.
     * @param  ldv     input int The leading dimension of the array V. 
     *                 If storev = 'C' and side = 'L', ldv >= max(1,m).
     *                 If storev = 'C' and side = 'R', ldv >= max(1,n). 
     *                 If storev = 'R', ldv >= k.
     * @param  T       input double[][] of dimensions ldt by k The triangular k by k matrix T in the representation of
     *                 the block reflector.
     * @param  ldt     input int The leading dimension of the array T. ldt >= k.
     * @param  C       input/output double[][] of dimensions ldc by n. On entry, the m by n matrix C. On exit, C is
     *                 overwritten by H*C or H'*C or C*H or C*H'.
     * @param  ldc     input int The leading dimension of the array C. ldc >= max(1,m).
     * @param  work    workspace double[][] of dimensions ldwork by k
     * @param  ldwork  input int The leading dimension of the array work. 
     *                 If side = 'L', ldwork >= max(1,n). 
     *                 If side = 'R', ldwork >= max(1,m).
     */
    private void dlarfb(char side, char trans, char direct, char storev, int m, int n, int k, double[][] V, int ldv,
                        double[][] T, int ldt, double[][] C, int ldc, double[][] work, int ldwork) {
        char transt;
        int i;
        int j;
        int p;
        int q;
        double[][] array1;
        double[][] array2;

        // Quick return if possible
        if ((m <= 0) || (n <= 0)) {
            return;
        }

        if ((trans == 'N') || (trans == 'n')) {
            transt = 'T';
        } else {
            transt = 'N';
        }

        if ((storev == 'C') || (storev == 'c')) {

            if ((direct == 'F') || (direct == 'f')) {

                // Let V = (V1)  (first k rows)
                //         (V2)
                // where V1 is unit lower triangular
                if ((side == 'L') || (side == 'l')) {

                    // Form H * C or H' * C where C = ( C1 )
                    //                                ( C2 )
                    // W = C' * V = (C1'*V1 + C2'*V2) (stored in work)
                    // W = C1'
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < n; p++) {
                            work[p][j] = C[j][p];
                        }
                    } // for (j = 0; j < k; j++)

                    // W = W * V1
                    dtrmm('R', 'L', 'N', 'U', n, k, 1.0, V, ldv, work, ldwork);

                    if (m > k) {

                        // W = W + C2'* V2
                        array1 = new double[m - k][n];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                array1[p][q] = C[p + k][q];
                            }
                        }

                        array2 = new double[m - k][k];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < k; q++) {
                                array2[p][q] = V[p + k][q];
                            }
                        }

                        dgemm('T', 'N', n, k, m - k, 1.0, array1, m - k, array2, m - k, 1.0, work, ldwork);
                    } // if (m > k)

                    // W = W * T' or W * T
                    dtrmm('R', 'U', transt, 'N', n, k, 1.0, T, ldt, work, ldwork);

                    // C = C - V * W'
                    if (m > k) {

                        // C2 = C2 - V2 * W'
                        array1 = new double[m - k][k];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < k; q++) {
                                array1[p][q] = V[p + k][q];
                            }
                        }

                        array2 = new double[m - k][n];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                array2[p][q] = C[p + k][q];
                            }
                        }

                        dgemm('N', 'T', m - k, n, k, -1.0, array1, m - k, work, ldwork, 1.0, array2, m - k);

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                C[p + k][q] = array2[p][q];
                            }
                        }
                    } // if (m > k)

                    // W = W * V1'
                    dtrmm('R', 'L', 'T', 'U', n, k, 1.0, V, ldv, work, ldwork);

                    // C1 = C1 - W'
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < n; i++) {
                            C[j][i] = C[j][i] - work[i][j];
                        }
                    }
                } // if ((side == 'L') || (side == 'l'))
                else if ((side == 'R') || (side == 'r')) {

                    // Form C * H or C * H' where C = ( C1 C2 )
                    // W = C * V = (C1*V1 + C2*V2) (stored in work)
                    // W = C1
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < m; p++) {
                            work[p][j] = C[p][j];
                        }
                    } // for (j = 0; j < k; j++)

                    // W = W * V1
                    dtrmm('R', 'L', 'N', 'U', m, k, 1.0, V, ldv, work, ldwork);

                    if (n > k) {

                        // W = W + C2 * V2
                        array1 = new double[m][n - k];

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array1[p][q] = C[p][q + k];
                            }
                        }

                        array2 = new double[n - k][k];

                        for (p = 0; p < (n - k); p++) {

                            for (q = 0; q < k; q++) {
                                array2[p][q] = V[p + k][q];
                            }
                        }

                        dgemm('N', 'N', m, k, n - k, 1.0, array1, m, array2, n - k, 1.0, work, ldwork);
                    } // if (n > k)

                    // W = W * T or W * T'
                    dtrmm('R', 'U', trans, 'N', m, k, 1.0, T, ldt, work, ldwork);

                    // C = C - W * V'
                    if (n > k) {

                        // C2 = C2 - W * V2'
                        array1 = new double[n - k][k];

                        for (p = 0; p < (n - k); p++) {

                            for (q = 0; q < k; q++) {
                                array1[p][q] = V[p + k][q];
                            }
                        }

                        array2 = new double[m][n - k];

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array2[p][q] = C[p][q + k];
                            }
                        }

                        dgemm('N', 'T', m, n - k, k, -1.0, work, ldwork, array1, n - k, 1.0, array2, m);

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                C[p][q + k] = array2[p][q];
                            }
                        }
                    } // if (n > k)

                    // W = W * V1'
                    dtrmm('R', 'L', 'T', 'U', m, k, 1.0, V, ldv, work, ldwork);

                    // C1 = C1 - W
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = C[i][j] - work[i][j];
                        }
                    }
                } // else if ((side == 'R') || (side == 'r'))
            } // if ((direct == 'F') || (direct == 'f'))
            else { // ((direct == 'B') || (direct == 'b'))

                // Let V =  ( V1 )
                //          ( V2 )  (last k rows)
                // where V2 is unit upper triangular.
                if ((side == 'L') || (side == 'l')) {

                    // Form H * C or H' * C where C = ( C1 )
                    //                                ( C2 )
                    // W = C' * V = (C1'*V1 + C2'*V2) (stored in work)
                    // W = C2'
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < n; p++) {
                            work[p][j] = C[m - k + j][p];
                        }
                    } // for (j = 0; j < k; j++)

                    // W = W * V2
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p + m - k][q];
                        }
                    }

                    dtrmm('R', 'U', 'N', 'U', n, k, 1.0, array1, k, work, ldwork);

                    if (m > k) {

                        // W = W + C1' * V1
                        dgemm('T', 'N', n, k, m - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
                    } // if (m > k)

                    // W = W * T' or W * T
                    dtrmm('R', 'L', transt, 'N', n, k, 1.0, T, ldt, work, ldwork);

                    // C = C - V * W'
                    if (m > k) {

                        // C1 = C1 - V1 * W'
                        dgemm('N', 'T', m - k, n, k, -1.0, V, ldv, work, ldwork, 1.0, C, ldc);
                    } // if (m > k)

                    // W = W * V2'
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p + m - k][q];
                        }
                    }

                    dtrmm('R', 'U', 'T', 'U', n, k, 1.0, array1, k, work, ldwork);

                    // C2 = C2 - W'
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < n; i++) {
                            C[m - k + j][i] = C[m - k + j][i] - work[i][j];
                        }
                    }
                } // if ((side == 'L') || (side == 'l'))
                else if ((side == 'R') || (side == 'r')) {

                    // Form C * H or C * H' where C = ( C1 C2 )
                    // W = C * V = (C1*V1 + C2*V2) (stored in work)
                    // W = C2
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < m; p++) {
                            work[p][j] = C[p][n - k + j];
                        }
                    }

                    // W = W * V2
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p + n - k][q];
                        }
                    }

                    dtrmm('R', 'U', 'N', 'U', m, k, 1.0, array1, k, work, ldwork);

                    if (n > k) {

                        // W = W + C1 * V1
                        dgemm('N', 'N', m, k, n - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
                    } // if (n > k)

                    // W = W * T or W * T'
                    dtrmm('R', 'L', trans, 'N', m, k, 1.0, T, ldt, work, ldwork);

                    // C = C - W * V'
                    if (n > k) {

                        // C1 = C1 - W * V1'
                        dgemm('N', 'T', m, n - k, k, -1.0, work, ldwork, V, ldv, 1.0, C, ldc);
                    } // if (n > k)

                    // W = W * V2'
                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p + n - k][q];
                        }
                    }

                    dtrmm('R', 'U', 'T', 'U', m, k, 1.0, array1, k, work, ldwork);

                    // C2 = C2 - W
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < m; i++) {
                            C[i][n - k + j] = C[i][n - k + j] - work[i][j];
                        }
                    }
                } // else if ((side == 'R') || (side == 'r'))
            } // else ((direct == 'B') || (direct == 'b'))
        } // if ((storev == 'C') || (storev == 'c'))
        else if ((storev == 'R') || (storev == 'r')) {

            if ((direct == 'F') || (direct == 'f')) {

                // Let V = ( V1 V2 )  (V1: first k columns)
                // where V1 is unit upper triangular
                if ((side == 'L') || (side == 'l')) {

                    // Form H * C or H' * C where C = ( C1 )
                    //                                ( C2 )
                    // W = C' * V' = (C1'*V1' + C2'V2') (stored in work)
                    // W = C1'
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < n; p++) {
                            work[p][j] = C[j][p];
                        }
                    }

                    // W = W * V1'
                    dtrmm('R', 'U', 'T', 'U', n, k, 1.0, V, ldv, work, ldwork);

                    if (m > k) {

                        // W = W + C2'*V2'
                        array1 = new double[m - k][n];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                array1[p][q] = C[p + k][q];
                            }
                        }

                        array2 = new double[k][m - k];

                        for (p = 0; p < k; p++) {

                            for (q = 0; q < (m - k); q++) {
                                array2[p][q] = V[p][q + k];
                            }
                        }

                        dgemm('T', 'T', n, k, m - k, 1.0, array1, m - k, array2, k, 1.0, work, ldwork);
                    } // if (m > k)

                    // W = W * T' or W * T
                    dtrmm('R', 'U', transt, 'N', n, k, 1.0, T, ldt, work, ldwork);

                    // C = C - V' * W'
                    if (m > k) {

                        // C2 = C2 - V2' * W'
                        array1 = new double[k][m - k];

                        for (p = 0; p < k; p++) {

                            for (q = 0; q < (m - k); q++) {
                                array1[p][q] = V[p][q + k];
                            }
                        }

                        array2 = new double[m - k][n];

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                array2[p][q] = C[p + k][q];
                            }
                        }

                        dgemm('T', 'T', m - k, n, k, -1.0, array1, k, work, ldwork, 1.0, array2, m - k);

                        for (p = 0; p < (m - k); p++) {

                            for (q = 0; q < n; q++) {
                                C[p + k][q] = array2[p][q];
                            }
                        }
                    } // if (m > k)

                    // W = W * V1
                    dtrmm('R', 'U', 'N', 'U', n, k, 1.0, V, ldv, work, ldwork);

                    // C1 = C1 - W'
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < n; i++) {
                            C[j][i] = C[j][i] - work[i][j];
                        }
                    }
                } // if ((side == 'L') || (side == 'l'))
                else if ((side == 'R') || (side == 'r')) {

                    // Form C * H or C * H' where C = ( C1 C2 )
                    // W = C * V' = (C1*V1' + C2*V2') (stored in work)
                    // W = C1
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < m; p++) {
                            work[p][j] = C[p][j];
                        }
                    }

                    // W = W * V1'
                    dtrmm('R', 'U', 'T', 'U', m, k, 1.0, V, ldv, work, ldwork);

                    if (n > k) {

                        // W = W + C2 * V2'
                        array1 = new double[m][n - k];

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array1[p][q] = C[p][q + k];
                            }
                        }

                        array2 = new double[k][n - k];

                        for (p = 0; p < k; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array2[p][q] = V[p][q + k];
                            }
                        }

                        dgemm('N', 'T', m, k, n - k, 1.0, array1, m, array2, k, 1.0, work, ldwork);
                    } // if (n > k)

                    // W = W * T or W * T'
                    dtrmm('R', 'U', trans, 'N', m, k, 1.0, T, ldt, work, ldwork);

                    // C = C - W * V
                    if (n > k) {

                        // C2 = C2 - W * V2
                        array1 = new double[k][n - k];

                        for (p = 0; p < k; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array1[p][q] = V[p][q + k];
                            }
                        }

                        array2 = new double[m][n - k];

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                array2[p][q] = C[p][q + k];
                            }
                        }

                        dgemm('N', 'N', m, n - k, k, -1.0, work, ldwork, array1, k, 1.0, array2, m);

                        for (p = 0; p < m; p++) {

                            for (q = 0; q < (n - k); q++) {
                                C[p][q + k] = array2[p][q];
                            }
                        }
                    } // if (n > k)

                    // W = W * V1
                    dtrmm('R', 'U', 'N', 'U', m, k, 1.0, V, ldv, work, ldwork);

                    // C1 = C1 - W
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < m; i++) {
                            C[i][j] = C[i][j] - work[i][j];
                        }
                    }
                } // else if ((side == 'R') || (side == 'r'))
            } // if ((direct == 'F') || (direct == 'f'))
            else { // ((direct == 'B') || (direct == 'B'))

                // Let V = ( V1 V2 )  (V2: last k columns)
                // where V2 is unit lower triangular
                if ((side == 'L') || (side == 'l')) {

                    // Form H * C or H' * C where C = ( C1 )
                    //                                ( C2 )
                    // W = C' * V' = (C1'*V1' + C2'*V2') (stored in work)
                    // W = C2'
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < n; p++) {
                            work[p][j] = C[m - k + j][p];
                        }
                    }

                    // W = W * V2'
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p][q + m - k];
                        }
                    }

                    dtrmm('R', 'L', 'T', 'U', n, k, 1.0, array1, k, work, ldwork);

                    if (m > k) {

                        // W = W + C1'*V1'
                        dgemm('T', 'T', n, k, m - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
                    } // if (m > k)

                    // W = W * T' or W * T
                    dtrmm('R', 'L', transt, 'N', n, k, 1.0, T, ldt, work, ldwork);

                    // C = C - V' * W'
                    if (m > k) {

                        // C1 = C1 - V1' * W'
                        dgemm('T', 'T', m - k, n, k, -1.0, V, ldv, work, ldwork, 1.0, C, ldc);
                    } // if (m > k)

                    // W = W * V2
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p][q + m - k];
                        }
                    }

                    dtrmm('R', 'L', 'N', 'U', n, k, 1.0, array1, k, work, ldwork);

                    // C2 = C2 - W'
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < n; i++) {
                            C[m - k + j][i] = C[m - k + j][i] - work[i][j];
                        }
                    }
                } // if ((side == 'L') || (side == 'l'))
                else if ((side == 'R') || (side == 'r')) {

                    // Form C * H or C * H' where C = ( C1 C2 )
                    // W = C * V' = (C1*V1' + C2*V2') (stored in work)
                    // W = C2
                    for (j = 0; j < k; j++) {

                        for (p = 0; p < m; p++) {
                            work[p][j] = C[p][n - k + j];
                        }
                    }

                    // W = W * V2'
                    array1 = new double[k][k];

                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p][q + n - k];
                        }
                    }

                    dtrmm('R', 'L', 'T', 'U', m, k, 1.0, array1, k, work, ldwork);

                    if (n > k) {

                        // W = W + C1 * V1'
                        dgemm('N', 'T', m, k, n - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
                    } // if (n > k)

                    // W = W * T or W * T'
                    dtrmm('R', 'L', trans, 'N', m, k, 1.0, T, ldt, work, ldwork);

                    // C = C - W * V
                    if (n > k) {

                        // C1 = C1 - W * V1
                        dgemm('N', 'N', m, n - k, k, -1.0, work, ldwork, V, ldv, 1.0, C, ldc);
                    } // if (n > k)

                    // W = W * V2
                    for (p = 0; p < k; p++) {

                        for (q = 0; q < k; q++) {
                            array1[p][q] = V[p][q + n - k];
                        }
                    }

                    dtrmm('R', 'L', 'N', 'U', m, k, 1.0, array1, k, work, ldwork);

                    // C1 = C1 - W
                    for (j = 0; j < k; j++) {

                        for (i = 0; i < m; i++) {
                            C[i][n - k + j] = C[i][n - k + j] - work[i][j];
                        }
                    }
                } // else if ((side == 'R') || (side == 'r'))
            } // else ((direct == 'B') || (direct == 'B'))
        } // else if ((storev == 'R') || (storev == 'r'))

        return;
    } // dlarfb

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARFG Original DLARFG created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006 dlarfg generates a real elementary reflector H of order n,
     * such that H * (alpha) = (beta), H' * H = I. ( x ) ( 0 ) where alpha and beta are scalars, and x is an
     * (n-1)-element real vector. H is represented in the form H = I - tau * (1) * (1 v'), (v) where tau is a real
     * scalar and v is a real (n-1)-element vector. If the elements of x are all zero, then tau = 0 and H is taken to be
     * the unit matrix. Otherwise 1 <= tau <= 2.
     *
     * @param  n      input int The order of the elementary reflector.
     * @param  alpha  input/output double[] On entry, the value alpha. On exit, it is overwritten with the value beta.
     * @param  x      input/output double[] of dimension (1 + (n-2)*abs(incx)) On entry, the vector x. On exit, it is
     *                overwritten with the vector v.
     * @param  incx   input int The increment between elements of x. incx > 0
     * @param  tau    output double[] The value tau
     */
    private void dlarfg(int n, double[] alpha, double[] x, int incx, double[] tau) {
        int j;
        int knt;
        double beta;
        double rsafmn;
        double safmin;
        double xnorm;

        if (n <= 1) {
            tau[0] = 0.0;

            return;
        }

        xnorm = dnrm2(n - 1, x, incx);

        if (xnorm == 0.0) {

            // H = I
            tau[0] = 0.0;
        } // if (xnorm == 0.0)
        else { // general case

            if (alpha[0] >= 0.0) {
                beta = -Math.abs(dlapy2(alpha[0], xnorm));
            } else {
                beta = Math.abs(dlapy2(alpha[0], xnorm));
            }

            safmin = dlamch('S') / dlamch('E');

            if (Math.abs(beta) < safmin) {

                // xnorm, beta may be inaccurate; scale x and recompute them
                rsafmn = 1.0 / safmin;
                knt = 0;

                do {
                    knt = knt + 1;
                    dscal(n - 1, rsafmn, x, incx);
                    beta = beta * rsafmn;
                    alpha[0] = alpha[0] * rsafmn;
                } while (Math.abs(beta) < safmin);

                // New beta is at most 1, at least safmin
                xnorm = dnrm2(n - 1, x, incx);

                if (alpha[0] >= 0.0) {
                    beta = -Math.abs(dlapy2(alpha[0], xnorm));
                } else {
                    beta = Math.abs(dlapy2(alpha[0], xnorm));
                }

                tau[0] = (beta - alpha[0]) / beta;
                dscal(n - 1, 1.0 / (alpha[0] - beta), x, incx);

                // If alpha is subnormal, it may lose relative accuracy
                alpha[0] = beta;

                for (j = 1; j <= knt; j++) {
                    alpha[0] = alpha[0] * safmin;
                }
            } // if (Math.abs(beta) < safmin)
            else { // Math.abs(beta) >= safmin
                tau[0] = (beta - alpha[0]) / beta;
                dscal(n - 1, 1.0 / (alpha[0] - beta), x, incx);
                alpha[0] = beta;
            } // Math.abs(beta) >= safmin)
        } // else general case

        return;
    } // dlarfg

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLARFT Original DLARFT created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlarft forms the triangular factor T of a real block reflector H of order n, which is defined as the
     * product of k elementary reflectors. 
     * If direct = 'F', H = H[0] H[1] ... H[k-1] and T is upper triangular. 
     * If direct = 'B', H = H[k-1] ... H[1] H[0] and T is lower triangular. 
     * If storev = 'C', the vector which defines the elementary reflector H[i] is stored in the i-th column of the array V, and
     *     H = I - V * T * V' 
     * If storev = 'R', the vector which defines the elementary reflector H[i] is stored in the i-th row of the array V, and 
     *     H = I - V' * T * V.
     *
     * @param  direct  input char Specifies the order in which the elementary reflectors are multiplied to form the
     *                 block reflector: 
     *                 = 'F': H = H[0] H[1] ... H[k-1] (forward) 
     *                 = 'B': H = H[k-1] ... H[1] H[0] (Backward)
     * @param  storev  input char Specifies how the vectors which define the elementary reflectors are stored (see also
     *                 Further Details): 
     *                 = 'C': columnwise 
     *                 = 'R': rowwise
     * @param  n       input int The order of the block reflector H. n >= 0.
     * @param  k       input int The order of the triangular factor T ( = the number of elementary reflectors). k >= 1.
     * @param  V       (input/output) double[][] 
     *                 If storev = 'C', dimension = ldv by k. 
     *                 If storev = 'R', dimension = ldv by n. 
     *                 See further details.
     * @param  ldv     input int The leading dimension of the array V. If storev = 'C', ldv >= max(1,n). If storev =
     *                 'R', ldv >= k.
     * @param  tau     input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector
     *                 H[i].
     * @param  T       output double[][] of dimension ldt by k. The k by k triangular factor T of the block reflector.
     *                 If direct = 'F', T is upper triangular. If direct = 'B', T is lower triangular. The rest of the
     *                 array is not used.
     * @param  ldt     input int The leading dimension of the array T. ldt >= k.
     *
     *                 <p>Further Details: The shape of the matrix V and the storage of the vectors which define the
     *                 H[i] is best illustrated by the following example with n = 5 and k = 3. The elements equal to 1
     *                 are not stored; the corresponding array elements are modified but restored on exit. The rest of
     *                 the array is not used. 
     *                 direct = 'F' and storev = 'C': 
     *                 V = ( 1       )
     *                     (v1  1    ) 
     *                     (v1 v2  1 )
     *                     (v1 v2 v3 )
     *                     (v1 v2 v3 ) 
     *                 direct = 'F' and storev = 'R': 
     *                 V = ( 1 v1 v1 v1 v1 ) 
     *                     (    1 v2 v2 v2 ) 
     *                     (       1 v3 v3 )
     *                 direct = 'B' and storev = 'C': 
     *                 V = ( v1 v2 v3 ) 
     *                     ( v1 v2 v3 ) 
     *                     (  1 v2 v3 ) 
     *                     (     1 v3 ) 
     *                     (        1 ) 
     *                 direct = 'B' and storev = 'R': 
     *                 V = ( v1 v1  1      ) 
     *                     ( v2 v2 v2  1   ) 
     *                     ( v3 v3 v3 v3 1 )</p>
     */
    private void dlarft(char direct, char storev, int n, int k, double[][] V, int ldv, double[] tau, double[][] T,
                        int ldt) {
        int i;
        int j;
        double vii;
        double[] vector1;
        double[] vector2 = null;
        double[][] array1;
        int p;
        int q;

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if ((direct == 'F') || (direct == 'f')) {

            for (i = 1; i <= k; i++) {

                if (tau[i - 1] == 0.0) {

                    // H[i-1] = I
                    for (j = 1; j <= i; j++) {
                        T[j - 1][i - 1] = 0.0;
                    }
                } // if (tau[i-1] == 0.0)
                else { // tau[i-1] != 0.0

                    // general case
                    vii = V[i - 1][i - 1];
                    V[i - 1][i - 1] = 1.0;

                    if (i != 1) {

                        if ((storev == 'C') || (storev == 'c')) {

                            // T(0:i-2,i-1) = -tau[i-1] * V(i-1:n-1,0:i-2)' * V(i-1:n-1,i-1)
                            array1 = new double[n - i + 1][i - 1];

                            for (p = 0; p < (n - i + 1); p++) {

                                for (q = 0; q < (i - 1); q++) {
                                    array1[p][q] = V[p + i - 1][q];
                                }
                            }

                            vector1 = new double[n - i + 1];

                            for (p = 0; p < (n - i + 1); p++) {
                                vector1[p] = V[p + i - 1][i - 1];
                            }

                            vector2 = new double[i - 1];

                            for (p = 0; p < (i - 1); p++) {
                                vector2[p] = T[p][i - 1];
                            }

                            dgemv('T', n - i + 1, i - 1, -tau[i - 1], array1, n - i + 1, vector1, 1, 0.0, vector2, 1);

                            for (p = 0; p < (i - 1); p++) {
                                T[p][i - 1] = vector2[p];
                            }
                        } // if ((storev == 'C') || (storev == 'c'))
                        else { // ((storev == 'R') || (storev == 'r'))

                            // T(0:i-2,i-1) = -tau[i-1] * V(0:i-2,i-1:n-1) * V(i-1,i-1:n-1)'
                            array1 = new double[i - 1][n - i + 1];

                            for (p = 0; p < (i - 1); p++) {

                                for (q = 0; q < (n - i + 1); q++) {
                                    array1[p][q] = V[p][q + i - 1];
                                }
                            }

                            vector1 = new double[n - i + 1];

                            for (p = 0; p < (n - i + 1); p++) {
                                vector1[p] = V[i - 1][p + i - 1];
                            }

                            vector2 = new double[i - 1];

                            for (p = 0; p < (i - 1); p++) {
                                vector2[p] = T[p][i - 1];
                            }

                            dgemv('N', i - 1, n - i + 1, -tau[i - 1], array1, i - 1, vector1, 1, 0.0, vector2, 1);

                            for (p = 0; p < (i - 1); p++) {
                                T[p][i - 1] = vector2[p];
                            }
                        } // else ((storev == 'R') || (storev == 'r'))
                    } // if (i != 1)

                    V[i - 1][i - 1] = vii;

                    if (i != 1) {

                        // T(0:i-2,i-1) = T(0:i-2,0:i-2) * T(0:i-2,i-1)
                        dtrmv('U', 'N', 'N', i - 1, T, ldt, vector2, 1);

                        for (p = 0; p < (i - 1); p++) {
                            T[p][i - 1] = vector2[p];
                        }
                    } // if (i != 1)

                    T[i - 1][i - 1] = tau[i - 1];
                } // else tau[i-1] != 0.0
            } // for (i = 1; i <= k; i++)
        } // if ((direct == 'F') || (direct == 'f'))
        else { // ((direct == 'B') || (direct == 'b'))

            for (i = k; i >= 1; i--) {

                if (tau[i - 1] == 0.0) {

                    // H[i-1] = I
                    for (j = i; j <= k; j++) {
                        T[j - 1][i - 1] = 0.0;
                    }
                } // if (tau[i-1] == 0.0)
                else { // tau[i-1] != 0.0

                    // general case
                    if (i < k) {

                        if ((storev == 'C') || (storev == 'c')) {
                            vii = V[n - k + i - 1][i - 1];
                            V[n - k + i - 1][i - 1] = 1.0;

                            // T(i:k-1,i-1) = -tau[i-1] * V(0:n-k+i-1,i:k-1)' *
                            // V(0:n-k+i-1,i-1)
                            array1 = new double[n - k + i][k - i];

                            for (p = 0; p < (n - k + i); p++) {

                                for (q = 0; q < (k - i); q++) {
                                    array1[p][q] = V[p][q + i];
                                }
                            }

                            vector1 = new double[n - k + i];

                            for (p = 0; p < (n - k + i); p++) {
                                vector1[p] = V[p][i - 1];
                            }

                            vector2 = new double[k - i];

                            for (p = 0; p < (k - i); p++) {
                                vector2[p] = T[p + i][i - 1];
                            }

                            dgemv('T', n - k + i, k - i, -tau[i - 1], array1, n - k + i, vector1, 1, 0.0, vector2, 1);

                            for (p = 0; p < (k - i); p++) {
                                T[p + i][i - 1] = vector2[p];
                            }
                            
                            V[n - k + i - 1][i - 1] = vii;
                        } // if ((storev == 'C') || (storev == 'c'))
                        else { // ((storev == 'R') || (storev == 'r'))
                            vii = V[i - 1][n - k + i - 1];
                            V[i - 1][n - k + i - 1] = 1.0;

                            // T(i:k-1,i-1) = -tau[i-1] * V(i:k-1,0:n-k+i-1) *
                            // V(i-1,0:n-k+i-1)'
                            array1 = new double[k - i][n - k + i];

                            for (p = 0; p < (k - i); p++) {

                                for (q = 0; q < (n - k + i); q++) {
                                    array1[p][q] = V[p + i][q];
                                }
                            }

                            vector1 = new double[n - k + i];

                            for (p = 0; p < (n - k + i); p++) {
                                vector1[p] = V[i - 1][p];
                            }

                            vector2 = new double[k - i];

                            for (p = 0; p < (k - i); p++) {
                                vector2[p] = T[p + i][i - 1];
                            }

                            dgemv('N', k - i, n - k + i, -tau[i - 1], array1, k - i, vector1, 1, 0.0, vector2, 1);

                            for (p = 0; p < (k - i); p++) {
                                T[p + i][i - 1] = vector2[p];
                            }

                            V[i - 1][n - k + i - 1] = vii;
                        } // else ((storev == 'R') || (storev == 'r'))

                        // T(i:k-1,i-1) = T(i:k-1,i:k-1) * T(i:k-1,i-1)
                        array1 = new double[k - i][k - i];

                        for (p = 0; p < (k - i); p++) {

                            for (q = 0; q < (k - i); q++) {
                                array1[p][q] = T[p + i][q + i];
                            }
                        }

                        dtrmv('L', 'N', 'N', k - i, array1, k - i, vector2, 1);

                        for (p = 0; p < (k - i); p++) {
                            T[p + i][i - 1] = vector2[p];
                        }
                    } // if (i < k)

                    T[i - 1][i - 1] = tau[i - 1];
                } // else tau[i-1] != 0.0
            } // for (i = k; i >= 1; i--)
        } // else ((direct == 'B') || (direct == 'b'))

        return;
    } // dlarft

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLARFY Original DLARFY created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlarfy applies an elementary reflector, or Householder matrix, H, to an n by n symmetric matrix C, from
     * both the left and the right. H is represented in the form H = I - tau * v * v' where tau is a scalar and v is a
     * vector. If tau is zero, then H is taken to be the unit vector
     *
     * @param  uplo  (input) char Specifies whether the upper or lower triangular part of the matrix C is stored. 
     *                = 'U': Upper triangle 
     *                = 'L': Lower triangle
     * @param  n     (input) int The number of rows and columns of the matrix C. n >= 0.
     * @param  v     (input) double[] of dimension (1 + (n-1)*abs(incv))
     * @param  incv  (input) int The increment between succesive elements of v. incv must not be zero.
     * @param  tau   (input) double
     * @param  C     (input/output) double[][] of dimension (ldc, n) On entry, the matrix C. On exit, C is overwritten
     *               by H * C * H'.
     * @param  ldc   (input) int The leading dimension of the array C. ldc >= max(1,n).
     * @param  work  (workspace) double[] of dimension (n)
     */
    private void dlarfy(char uplo, int n, double[] v, int incv, double tau, double[][] C, int ldc, double[] work) {
        double alpha;

        if (tau == 0.0) {
            return;
        }

        // Form w = C * v
        dsymv(uplo, n, 1.0, C, ldc, v, incv, 0.0, work, 1);
        alpha = -0.5 * tau * ddot(n, work, 1, v, incv);
        daxpy(n, alpha, v, incv, work, 1);

        // C = C - v * w' - w * v'
        dsyr2(uplo, n, -tau, v, incv, work, 1, C, ldc);

        return;
    } // dlarfy

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARND Original DLARND created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlarnd returns a random real number from a uniform or normal distribution. This routine calls the auxiliary
     * routine dlaran to generate a random real number from a uniform (0,1) distribution. The Box-Muller method is used
     * to transform numbers from a uniform to a normal distribution.
     *
     * @param   idist  input int Specifies the distribution of the random numbers: 
     *                 = 1: uniform (0,1) 
     *                 = 2: uniform (-1,1) 
     *                 = 3: normal (0,1)
     * @param   iseed  (input/output) int[] of dimension 4 On entry, the seed of the random number generator; the array
     *                 elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
     *
     * @return  DOCUMENT ME!
     */
    private double dlarnd(int idist, int[] iseed) {
        double t1;
        double t2;
        double result = 0.0;

        // Generate a real random number from a uniform (0,1) distribution
        t1 = dlaran(iseed);

        if (idist == 1) {

            // uniform (0,1)
            result = t1;
        } else if (idist == 2) {

            // Uniform (-1,1)
            result = (2.0 * t1) - 1.0;
        } else if (idist == 3) {

            // Normal (0,1)
            t2 = dlaran(iseed);
            result = Math.sqrt(-2.0 * Math.log(t1)) * Math.cos(2.0 * Math.PI * t2);
        }

        return result;
    } // dlarnd

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARNV Original DLARNV created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlarnv returns a vector of n random real numbers from a uniform or normal distribution
     *
     * @param  idist  input int Specifies the distribution of the random numbers: 
     *                = 1: uniform (0,1) 
     *                = 2: uniform (-1,1)
     *                = 3: normal (0,1)
     * @param  iseed  input/output int[] of dimension 4. On entry, the seed of the random number generator; the array
     *                elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated
     * @param  n      input int The number of random numbers to be generated.
     * @param  x      output double[] of dimension n. The random generated numbers.
     * 
     * The routine calls the auxiliary routine dlaruv to generate random real numbers from a uniform (0,1) distribution,
     * in batches of up to 128 using vectorizable code. The Box-Muller method is used to transform numbers from a uniform
     * to a normal distribution.
     */
    private void dlarnv(int idist, int[] iseed, int n, double[] x) {
        int lv = 128;
        int i;
        int il;
        int il2;
        int iv;
        double[] u = new double[lv];

        for (iv = 1; iv <= n; iv += lv / 2) {
            il = Math.min(lv / 2, n - iv + 1);

            if (idist == 3) {
                il2 = 2 * il;
            } else {
                il2 = il;
            }

            // Call dlaruv to generate il2 numbers from a uniform (0,1)
            // distribution (il2 <= lv)
            dlaruv(iseed, il2, u);

            if (idist == 1) {

                // Copy generated numbers
                for (i = 0; i < il; i++) {
                    x[iv + i - 1] = u[i];
                }
            } // if (idist == 1)
            else if (idist == 2) {

                // Convert generated numbers to uniform (-1,1) distribution
                for (i = 0; i < il; i++) {
                    x[iv + i - 1] = (2.0 * u[i]) - 1.0;
                }
            } // else if (idist == 2)
            else if (idist == 3) {

                // Convert generated numbers to normal (0,1) distribution
                for (i = 1; i <= il; i++) {
                    x[iv + i - 2] = Math.sqrt(-2.0 * Math.log(u[(2 * i) - 2])) *
                                        Math.cos(2.0 * Math.PI * u[(2 * i) - 1]);
                }
            } // else if (idist == 3)

            return;
        } // for (iv = 1; iv <= n; iv += lv/2)
    } // dlarnv

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLAROT Original DLAROT created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlarot applies a (Givens) rotation to two adjacent rows or columns, where one element of the first
     * and/or last column/row may be a separate variable. This is specifically intended for use on matrices stored in
     * some format other than GE, so that elements of the matrix may be used or modified for which no array element is
     * provided.
     *
     * <p>One example is a symmetric matrix in SB format (bandwidth=4), for which uplo = 'L': Two adjacent rows will
     * have the format: 
     * row j:      * * * * * . . . . 
     * row j+1:      * * * * * . . . .
     * '*' indicates elements for which storage is provided, 
     * '.' indicates elements for which no storage is provided, but are not necessrily zero; their values are
     *     determined by symmetry. 
     * ' ' indicatres elements which are mecessarily zero, and have no storage provided.</p>
     *
     * <p>Those columns which have two '*'s can be handled by drot. Those columns which have no '*'s can be ignored,
     * since as long as the Givens rotations are carefully applied to preserve symmetry, their values are determined.
     * Those columns which have one '*' have to be handled separately, by using separate variables "p" and "q": 
     * row j:          * * * * * p . . . 
     * row j+1:        q * * * * * . . . .</p>
     *
     * <p>The element p would have to be set correctly, then that column is rotated, setting p to its new value. The
     * next call to dlarot would rotate columns j and j+1, using p, and restore symmetry. The element q would start out
     * being zero, and be made non-zero by the rotation. Later, rotations would presumably be chosen to zero q out.</p>
     *
     * <p>Typical Calling Sequences: rotating the i-th and (i+1)-st rows.</p>
     *
     * <p>General dense matrix: dlarot(true, false, false, n, c, s, A[i-1][0], lda, dummy, dummy);</p>
     *
     * <p>General banded matrix in GB format: j = Math.max(1, i-kl); nl = Math.min(n, i+ku+1) + 1 - j; dlarot(true,
     * (i-kl) >= 1, (i+ku) < n, nl, c,s,A[ku+i-j][j-1], lda - 1, xleft, xright); Note that i+1-j is just min(i,kl+1)</p>
     *
     * <p>Symmetric banded matrix in SY format, bandwidth k, lower triangle only: j = Math.max(1,i-k); nl =
     * Math.min(k+1,i) + 1; dlarot(true, (i-k) >= 1, true, nl, c, s, A[i-1][j-1], lda, xleft, xright);</p>
     *
     * <p>Same, but upper triangle only: nl = Math.min(k+1,n-i) + 1; dlarot(true, true, (i+k) < n, nl, c, s,
     * A[i-1][i-1], lda, xleft, xright);</p>
     *
     * <p>Symmetric banded matrix in SB format, bandwidth k, lower triangle only: same as for sy, except: A[i-j][j-1],
     * lda - 1, xleft, xright); Note that i+1-j is just min(i,k+1)</p>
     *
     * <p>Same, but upper triangle only: A[k][i-1], lda-1, xleft, xright);</p>
     *
     * <p>Rotating columns is just the transpose of rotating rows, except for GB and SB: (rotating columns i and i+1)
     * </p>
     *
     * <p>GB: j = Math.max(1,i-ku); nl = Math.min(n, i+kl+1) + 1 - j; dlarot(true, i-ku >= 1, i+kl < n, nl, c, s,
     * A[ku+j-i][i-1], lda - 1, xtop, xbottm); Note that ku+j+1-i is just max(1,ku+2-i)</p>
     *
     * <p>SB: (upper triangle) ............. A[k+j-i][i-1], lda-1, xtop, xbottm);</p>
     *
     * <p>SB: (lower triangle) ................... A[0][i-1], lda-1, xtop, xbottm);</p>
     *
     * @param  lrows   input boolean If true, then dlarot will rotate two rows. If false, then it will rotate two
     *                 columns.
     * @param  lleft   input boolean If true, then xleft will be used instead of the corresponding element of A for the
     *                 first element in the second row (if lrows = false) or column (if lrows = true) If false, then the
     *                 corresponding element of A will be used.
     * @param  lright  input boolean If true, then xright will be used instead of the corresponding element of A for the
     *                 last element in the first row (if lrows = false) or column (if lrows = true). If false, then the
     *                 corresponding element of A will be used.
     * @param  nl      input int The length of the rows (if lrows = true) or columns (if lrows = false) to be rotated.
     *                 If xleft and/or xright are used, the columns/rows they are in should be included in nl, e.g., if
     *                 lleft = lright = true, then nl must be at least 2. The number of rows/columns to be rotated
     *                 exclusive of those involving xleft and/or xright may not be negative, i.e., nl minus how many of
     *                 lleft and lright are true must be at least zero; if not, an error message will be output.
     * @param  c       input double
     * @param  s       input double c and s specify the Givens rotation to be applied. If lrows is true, then the matrix
     *                 ( c s )
     *                 (-s c ) is applied from the left; if false, then the transpose thereof is applied from
     *                 the right. For a Givens rotation, c**2 + s**2 should be 1, but this is not checked.
     * @param  A       input/output double[] The array containing the rows/columns to be rotated. The first element of A
     *                 should be the upper left element to be rotated.
     * @param  lda     input int The "effective" leading dimension of A. If A contains a matrix stored in GE or SY
     *                 format, then this is just the leading dimension of A as dimensioned in the calling routine. If A
     *                 contains a matrix stored in band (GB or SB) format, then this should be *one less* than the
     *                 leading dimension used in the calling routine. Thus, if A were dimensioned A(lda,*) in dlarot,
     *                 then A[0][j-1] would be the j-th element in the first of the two rows to be rotated, and
     *                 A[1][j-1] would be the j-th in the second, regardless of how the array may be stored in the
     *                 calling routine. [A cannot, however, actually be dimensioned thus, since for band format, the row
     *                 number may exceed lda, which is not legal code.] If lrows = true, then lda must be at least 1,
     *                 otherwise it must be at least nl minus the number of true values in xleft and xright.
     * @param  xleft   input/output double[] If lleft is true, then xleft will be used and modified instead of A[1][0]
     *                 (if lrows = true) or A[0][1] (if lrows = false).
     * @param  xright  input/output double[] If lright is true, then xright will be used and modified instead of
     *                 A[0][nl-1] (if lrows = true) or A[nl-1][0] (if lrows = false).
     */
    private void dlarot(boolean lrows, boolean lleft, boolean lright, int nl, double c, double s, double[] A, int lda,
                        double[] xleft, double[] xright) {
        int iinc;
        int inext;
        int ix;
        int iy;
        int iyt = 0;
        int nt;
        double[] xt = new double[2];
        double[] yt = new double[2];
        double[] dx;
        double[] dy;
        int i;
        int index;

        // Set up indices, arrays for ends
        if (lrows) {
            iinc = lda;
            inext = 1;
        } else {
            iinc = 1;
            inext = lda;
        }

        if (lleft) {
            nt = 1;
            ix = 1 + iinc;
            iy = 2 + lda;
            xt[0] = A[0];
            yt[0] = xleft[0];
        } else {
            nt = 0;
            ix = 1;
            iy = 1 + inext;
        }

        if (lright) {
            iyt = 1 + inext + ((nl - 1) * iinc);
            nt = nt + 1;
            xt[nt - 1] = xright[0];
            yt[nt - 1] = A[iyt - 1];
        }

        // Check for errors
        if (nl < nt) {
            MipavUtil.displayError("dlarot has error 4");

            return;
        }

        if ((lda <= 0) || ((!lrows) && (lda < (nl - nt)))) {
            MipavUtil.displayError("dlarot had error 8");

            return;
        }

        // Rotate
        dx = new double[nl - nt];
        dy = new double[nl - nt];
        index = 0;

        for (i = 0; i < (nl - nt); i++) {
            dx[i] = A[ix + index - 1];
            dy[i] = A[iy + index - 1];
            index += iinc;
        }

        drot(nl - nt, dx, 1, dy, 1, c, s);
        index = 0;

        for (i = 0; i < (nl - nt); i++) {
            A[ix + index - 1] = dx[i];
            A[iy + index - 1] = dy[i];
            index += iinc;
        }

        drot(nt, xt, 1, yt, 1, c, s);

        // Stuff values back into xleft, xright, etc.
        if (lleft) {
            A[0] = xt[0];
            xleft[0] = yt[0];
        }

        if (lright) {
            xright[0] = xt[nt - 1];
            A[iyt - 1] = yt[nt - 1];
        }

        return;
    } // dlarot

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARTG Original DLARTG created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlartg generates a plane rotation so that 
     * [  cs  sn ] . [ f ] = [ r ] where cs*cs + sn*sn = 1.
     * [ -sn  cs ]   [ g ]   [ 0 ] 
     * If g = 0, then cs = 1 and sn = 0. 
     * If f = 0 and g != 0, then cs = 0 and sn = 1 without doing any floating point operations. 
     * If f exceeds g in magnitude, then cs will be positive.
     *
     * @param  f   input double The first component of the vector to be rotated.
     * @param  g   input double The second component of the vector to be rotated.
     * @param  cs  output double[] The cosine of the rotation.
     * @param  sn  output double[] The sine of the rotation.
     * @param  r   output double[] The nonzero component of the rotated vector.
     */
    private void dlartg(double f, double g, double[] cs, double[] sn, double[] r) {
        int count;
        int i;
        double eps;
        double f1;
        double g1;
        double scale;

        if (first_dlartg) {
            first_dlartg = false;
            safmin = dlamch('S');
            eps = dlamch('E');
            safmn2 = Math.pow(dlamch('B'), (int) (Math.log(safmin / eps) / Math.log(dlamch('B')) / 2.0));
            safmx2 = 1.0 / safmn2;
        } // if (first_dlartg)

        if (g == 0.0) {
            cs[0] = 1.0;
            sn[0] = 0.0;
            r[0] = f;
        } else if (f == 0.0) {
            cs[0] = 0.0;
            sn[0] = 1.0;
            r[0] = g;
        } else {
            f1 = f;
            g1 = g;
            scale = Math.max(Math.abs(f1), Math.abs(g1));

            if (scale >= safmx2) {
                count = 0;

                do {
                    count = count + 1;
                    f1 = f1 * safmn2;
                    g1 = g1 * safmn2;
                    scale = Math.max(Math.abs(f1), Math.abs(g1));
                } while (scale >= safmx2);

                r[0] = Math.sqrt((f1 * f1) + (g1 * g1));
                cs[0] = f1 / r[0];
                sn[0] = g1 / r[0];

                for (i = 1; i <= count; i++) {
                    r[0] = r[0] * safmx2;
                }
            } // if (scale >= safmx2)
            else if (scale <= safmn2) {
                count = 0;

                do {
                    count = count + 1;
                    f1 = f1 * safmx2;
                    g1 = g1 * safmx2;
                    scale = Math.max(Math.abs(f1), Math.abs(g1));
                } while (scale <= safmn2);

                r[0] = Math.sqrt((f1 * f1) + (g1 * g1));
                cs[0] = f1 / r[0];
                sn[0] = g1 / r[0];

                for (i = 1; i <= count; i++) {
                    r[0] = r[0] * safmn2;
                }
            } // else if (scale <= safmn2)
            else {
                r[0] = Math.sqrt((f1 * f1) + (g1 * g1));
                cs[0] = f1 / r[0];
                sn[0] = g1 / r[0];
            }

            if ((Math.abs(f) > Math.abs(g)) && (cs[0] < 0.0)) {
                cs[0] = -cs[0];
                sn[0] = -sn[0];
                r[0] = -r[0];
            }
        }

        return;
    } // dlartg

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLARUV Original DLARUV created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlaruv returns a vector of n random real numbers from a uniform (0,1) distribution (n <= 128). This is an
     * auxiliary routine called by dlarnv.
     *
     * @param  iseed  input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
     *                elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
     * @param  n      input int The number of random numbers to be generated. n <= 128.
     * @param  x      output double[] of dimension n. The generated random numbers.
     * 
     * This routine uses a multiplicative congruential method with modulus 2**48 and multiplier 33952834046453
     * (see G.S. Fishman, "Multiplicative congruential random number generators with modulus 2**b: an exhaustive analysis
     * for b = 32 and a partial analysis for b = 48", Math. Comp. 189, pp. 331-344, 1990).
     * 
     * 48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is
     * portable across machines with integers of 32 bits or more.
     */
    private void dlaruv(int[] iseed, int n, double[] x) {
        int lv = 128;
        int ipw2 = 4096;
        double r = 1.0 / ipw2;
        int i;
        int i1;
        int i2;
        int i3;
        int i4;
        int it1 = 0;
        int it2 = 0;
        int it3 = 0;
        int it4 = 0;
        int j;
        int[][] mm = new int[lv][4];

        mm[0][0] = 494;
        mm[0][1] = 322;
        mm[0][2] = 2508;
        mm[0][3] = 2549;
        mm[1][0] = 2637;
        mm[1][1] = 789;
        mm[1][2] = 3754;
        mm[1][3] = 1145;
        mm[2][0] = 255;
        mm[2][1] = 1440;
        mm[2][2] = 1766;
        mm[2][3] = 2253;
        mm[3][0] = 2008;
        mm[3][1] = 752;
        mm[3][2] = 3572;
        mm[3][3] = 305;
        mm[4][0] = 1253;
        mm[4][1] = 2859;
        mm[4][2] = 2893;
        mm[4][3] = 3301;
        mm[5][0] = 3344;
        mm[5][1] = 123;
        mm[5][2] = 307;
        mm[5][3] = 1065;
        mm[6][0] = 4084;
        mm[6][1] = 1848;
        mm[6][2] = 1297;
        mm[6][3] = 3133;
        mm[7][0] = 1739;
        mm[7][1] = 643;
        mm[7][2] = 3966;
        mm[7][3] = 2913;
        mm[8][0] = 3143;
        mm[8][1] = 2405;
        mm[8][2] = 758;
        mm[8][3] = 3285;
        mm[9][0] = 3468;
        mm[9][1] = 2638;
        mm[9][2] = 2598;
        mm[9][3] = 1241;
        mm[10][0] = 688;
        mm[10][1] = 2344;
        mm[10][2] = 3406;
        mm[10][3] = 1197;
        mm[11][0] = 1657;
        mm[11][1] = 46;
        mm[11][2] = 2922;
        mm[11][3] = 3729;
        mm[12][0] = 1238;
        mm[12][1] = 3814;
        mm[12][2] = 1038;
        mm[12][3] = 2501;
        mm[13][0] = 3166;
        mm[13][1] = 913;
        mm[13][2] = 2934;
        mm[13][3] = 1673;
        mm[14][0] = 1292;
        mm[14][1] = 3649;
        mm[14][2] = 2091;
        mm[14][3] = 541;
        mm[15][0] = 3422;
        mm[15][1] = 339;
        mm[15][2] = 2451;
        mm[15][3] = 2753;
        mm[16][0] = 1270;
        mm[16][1] = 3808;
        mm[16][2] = 1580;
        mm[16][3] = 949;
        mm[17][0] = 2016;
        mm[17][1] = 822;
        mm[17][2] = 1958;
        mm[17][3] = 2361;
        mm[18][0] = 154;
        mm[18][1] = 2832;
        mm[18][2] = 2055;
        mm[18][3] = 1165;
        mm[19][0] = 2862;
        mm[19][1] = 3078;
        mm[19][2] = 1507;
        mm[19][3] = 4081;
        mm[20][0] = 697;
        mm[20][1] = 3633;
        mm[20][2] = 1078;
        mm[20][3] = 2725;
        mm[21][0] = 1706;
        mm[21][1] = 2970;
        mm[21][2] = 3273;
        mm[21][3] = 3305;
        mm[22][0] = 491;
        mm[22][1] = 637;
        mm[22][2] = 17;
        mm[22][3] = 3069;
        mm[23][0] = 931;
        mm[23][1] = 2249;
        mm[23][2] = 854;
        mm[23][3] = 3617;
        mm[24][0] = 1444;
        mm[24][1] = 2081;
        mm[24][2] = 2916;
        mm[24][3] = 3733;
        mm[25][0] = 444;
        mm[25][1] = 4019;
        mm[25][2] = 3971;
        mm[25][3] = 409;
        mm[26][0] = 3577;
        mm[26][1] = 1478;
        mm[26][2] = 2889;
        mm[26][3] = 2157;
        mm[27][0] = 3944;
        mm[27][1] = 242;
        mm[27][2] = 3831;
        mm[27][3] = 1361;
        mm[28][0] = 2184;
        mm[28][1] = 481;
        mm[28][2] = 2621;
        mm[28][3] = 3973;
        mm[29][0] = 1661;
        mm[29][1] = 2075;
        mm[29][2] = 1541;
        mm[29][3] = 1865;
        mm[30][0] = 3482;
        mm[30][1] = 4058;
        mm[30][2] = 893;
        mm[30][3] = 2525;
        mm[31][0] = 657;
        mm[31][1] = 622;
        mm[31][2] = 736;
        mm[31][3] = 1409;
        mm[32][0] = 3023;
        mm[32][1] = 3376;
        mm[32][2] = 3992;
        mm[32][3] = 3445;
        mm[33][0] = 3618;
        mm[33][1] = 812;
        mm[33][2] = 787;
        mm[33][3] = 3577;
        mm[34][0] = 1267;
        mm[34][1] = 234;
        mm[34][2] = 2125;
        mm[34][3] = 77;
        mm[35][0] = 1828;
        mm[35][1] = 641;
        mm[35][2] = 2364;
        mm[35][3] = 3761;
        mm[36][0] = 164;
        mm[36][1] = 4005;
        mm[36][2] = 2460;
        mm[36][3] = 2149;
        mm[37][0] = 3798;
        mm[37][1] = 1122;
        mm[37][2] = 257;
        mm[37][3] = 1449;
        mm[38][0] = 3087;
        mm[38][1] = 3135;
        mm[38][2] = 1574;
        mm[38][3] = 3005;
        mm[39][0] = 2400;
        mm[39][1] = 2640;
        mm[39][2] = 3912;
        mm[39][3] = 225;
        mm[40][0] = 2870;
        mm[40][1] = 2302;
        mm[40][2] = 1216;
        mm[40][3] = 85;
        mm[41][0] = 3876;
        mm[41][1] = 40;
        mm[41][2] = 3248;
        mm[41][3] = 3673;
        mm[42][0] = 1905;
        mm[42][1] = 1832;
        mm[42][2] = 3401;
        mm[42][3] = 3117;
        mm[43][0] = 1593;
        mm[43][1] = 2247;
        mm[43][2] = 2124;
        mm[43][3] = 3089;
        mm[44][0] = 1797;
        mm[44][1] = 2034;
        mm[44][2] = 2762;
        mm[44][3] = 1349;
        mm[45][0] = 1234;
        mm[45][1] = 2637;
        mm[45][2] = 149;
        mm[45][3] = 2057;
        mm[46][0] = 3460;
        mm[46][1] = 1287;
        mm[46][2] = 2245;
        mm[46][3] = 413;
        mm[47][0] = 328;
        mm[47][1] = 1691;
        mm[47][2] = 166;
        mm[47][3] = 65;
        mm[48][0] = 2861;
        mm[48][1] = 496;
        mm[48][2] = 466;
        mm[48][3] = 1845;
        mm[49][0] = 1950;
        mm[49][1] = 1597;
        mm[49][2] = 4018;
        mm[49][3] = 697;
        mm[50][0] = 617;
        mm[50][1] = 2394;
        mm[50][2] = 1399;
        mm[50][3] = 3085;
        mm[51][0] = 2070;
        mm[51][1] = 2584;
        mm[51][2] = 190;
        mm[51][3] = 3441;
        mm[52][0] = 3331;
        mm[52][1] = 1843;
        mm[52][2] = 2879;
        mm[52][3] = 1573;
        mm[53][0] = 769;
        mm[53][1] = 336;
        mm[53][2] = 153;
        mm[53][3] = 3689;
        mm[54][0] = 1558;
        mm[54][1] = 1472;
        mm[54][2] = 2320;
        mm[54][3] = 2941;
        mm[55][0] = 2412;
        mm[55][1] = 2407;
        mm[55][2] = 18;
        mm[55][3] = 929;
        mm[56][0] = 2800;
        mm[56][1] = 433;
        mm[56][2] = 712;
        mm[56][3] = 533;
        mm[57][0] = 189;
        mm[57][1] = 2096;
        mm[57][2] = 2159;
        mm[57][3] = 2841;
        mm[58][0] = 287;
        mm[58][1] = 1761;
        mm[58][2] = 2318;
        mm[58][3] = 4077;
        mm[59][0] = 2045;
        mm[59][1] = 2810;
        mm[59][2] = 2091;
        mm[59][3] = 721;
        mm[60][0] = 1227;
        mm[60][1] = 566;
        mm[60][2] = 3443;
        mm[60][3] = 2821;
        mm[61][0] = 2838;
        mm[61][1] = 442;
        mm[61][2] = 1510;
        mm[61][3] = 2249;
        mm[62][0] = 209;
        mm[62][1] = 41;
        mm[62][2] = 449;
        mm[62][3] = 2397;
        mm[63][0] = 2770;
        mm[63][1] = 1238;
        mm[63][2] = 1956;
        mm[63][3] = 2817;
        mm[64][0] = 3654;
        mm[64][1] = 1086;
        mm[64][2] = 2201;
        mm[64][3] = 245;
        mm[65][0] = 3993;
        mm[65][1] = 603;
        mm[65][2] = 3137;
        mm[65][3] = 1913;
        mm[66][0] = 192;
        mm[66][1] = 840;
        mm[66][2] = 3399;
        mm[66][3] = 1997;
        mm[67][0] = 2253;
        mm[67][1] = 3168;
        mm[67][2] = 1321;
        mm[67][3] = 3121;
        mm[68][0] = 3491;
        mm[68][1] = 1499;
        mm[68][2] = 2271;
        mm[68][3] = 997;
        mm[69][0] = 2889;
        mm[69][1] = 1084;
        mm[69][2] = 3667;
        mm[69][3] = 1833;
        mm[70][0] = 2857;
        mm[70][1] = 3438;
        mm[70][2] = 2703;
        mm[70][3] = 2877;
        mm[71][0] = 2094;
        mm[71][1] = 2408;
        mm[71][2] = 629;
        mm[71][3] = 1633;
        mm[72][0] = 1818;
        mm[72][1] = 1589;
        mm[72][2] = 2365;
        mm[72][3] = 981;
        mm[73][0] = 688;
        mm[73][1] = 2391;
        mm[73][2] = 2431;
        mm[73][3] = 2009;
        mm[74][0] = 1407;
        mm[74][1] = 288;
        mm[74][2] = 1113;
        mm[74][3] = 941;
        mm[75][0] = 634;
        mm[75][1] = 26;
        mm[75][2] = 3922;
        mm[75][3] = 2449;
        mm[76][0] = 3231;
        mm[76][1] = 512;
        mm[76][2] = 2554;
        mm[76][3] = 197;
        mm[77][0] = 815;
        mm[77][1] = 1456;
        mm[77][2] = 184;
        mm[77][3] = 2441;
        mm[78][0] = 3524;
        mm[78][1] = 171;
        mm[78][2] = 2099;
        mm[78][3] = 285;
        mm[79][0] = 1914;
        mm[79][1] = 1677;
        mm[79][2] = 3228;
        mm[79][3] = 1473;
        mm[80][0] = 516;
        mm[80][1] = 2657;
        mm[80][2] = 4012;
        mm[80][3] = 2741;
        mm[81][0] = 164;
        mm[81][1] = 2270;
        mm[81][2] = 1921;
        mm[81][3] = 3129;
        mm[82][0] = 303;
        mm[82][1] = 2587;
        mm[82][2] = 3452;
        mm[82][3] = 909;
        mm[83][0] = 2144;
        mm[83][1] = 2961;
        mm[83][2] = 3901;
        mm[83][3] = 2801;
        mm[84][0] = 3480;
        mm[84][1] = 1970;
        mm[84][2] = 572;
        mm[84][3] = 421;
        mm[85][0] = 119;
        mm[85][1] = 1817;
        mm[85][2] = 3309;
        mm[85][3] = 4073;
        mm[86][0] = 3357;
        mm[86][1] = 676;
        mm[86][2] = 3171;
        mm[86][3] = 2813;
        mm[87][0] = 837;
        mm[87][1] = 1410;
        mm[87][2] = 817;
        mm[87][3] = 2337;
        mm[88][0] = 2826;
        mm[88][1] = 3723;
        mm[88][2] = 3039;
        mm[88][3] = 1429;
        mm[89][0] = 2332;
        mm[89][1] = 2803;
        mm[89][2] = 1696;
        mm[89][3] = 1177;
        mm[90][0] = 2089;
        mm[90][1] = 3185;
        mm[90][2] = 1256;
        mm[90][3] = 1901;
        mm[91][0] = 3780;
        mm[91][1] = 184;
        mm[91][2] = 3715;
        mm[91][3] = 81;
        mm[92][0] = 1700;
        mm[92][1] = 663;
        mm[92][2] = 2077;
        mm[92][3] = 1669;
        mm[93][0] = 3712;
        mm[93][1] = 499;
        mm[93][2] = 3019;
        mm[93][3] = 2633;
        mm[94][0] = 150;
        mm[94][1] = 3784;
        mm[94][2] = 1497;
        mm[94][3] = 2269;
        mm[95][0] = 2000;
        mm[95][1] = 1631;
        mm[95][2] = 1101;
        mm[95][3] = 129;
        mm[96][0] = 3375;
        mm[96][1] = 1925;
        mm[96][2] = 717;
        mm[96][3] = 1141;
        mm[97][0] = 1621;
        mm[97][1] = 3912;
        mm[97][2] = 51;
        mm[97][3] = 249;
        mm[98][0] = 3090;
        mm[98][1] = 1398;
        mm[98][2] = 981;
        mm[98][3] = 3917;
        mm[99][0] = 3765;
        mm[99][1] = 1349;
        mm[99][2] = 1978;
        mm[99][3] = 2481;
        mm[100][0] = 1149;
        mm[100][1] = 1441;
        mm[100][2] = 1813;
        mm[100][3] = 3941;
        mm[101][0] = 3146;
        mm[101][1] = 2224;
        mm[101][2] = 3881;
        mm[101][3] = 2217;
        mm[102][0] = 33;
        mm[102][1] = 2411;
        mm[102][2] = 76;
        mm[102][3] = 2749;
        mm[103][0] = 3082;
        mm[103][1] = 1907;
        mm[103][2] = 3846;
        mm[103][3] = 3041;
        mm[104][0] = 2741;
        mm[104][1] = 3192;
        mm[104][2] = 3694;
        mm[104][3] = 1877;
        mm[105][0] = 359;
        mm[105][1] = 2786;
        mm[105][2] = 1682;
        mm[105][3] = 345;
        mm[106][0] = 3316;
        mm[106][1] = 382;
        mm[106][2] = 124;
        mm[106][3] = 2861;
        mm[107][0] = 1749;
        mm[107][1] = 37;
        mm[107][2] = 1660;
        mm[107][3] = 1809;
        mm[108][0] = 185;
        mm[108][1] = 759;
        mm[108][2] = 3997;
        mm[108][3] = 3141;
        mm[109][0] = 2784;
        mm[109][1] = 2948;
        mm[109][2] = 479;
        mm[109][3] = 2825;
        mm[110][0] = 2202;
        mm[110][1] = 1862;
        mm[110][2] = 1141;
        mm[110][3] = 157;
        mm[111][0] = 2199;
        mm[111][1] = 3802;
        mm[111][2] = 886;
        mm[111][3] = 2881;
        mm[112][0] = 1364;
        mm[112][1] = 2423;
        mm[112][2] = 3514;
        mm[112][3] = 3637;
        mm[113][0] = 1244;
        mm[113][1] = 2051;
        mm[113][2] = 1301;
        mm[113][3] = 1465;
        mm[114][0] = 2020;
        mm[114][1] = 2295;
        mm[114][2] = 3604;
        mm[114][3] = 2829;
        mm[115][0] = 3160;
        mm[115][1] = 1332;
        mm[115][2] = 1888;
        mm[115][3] = 2161;
        mm[116][0] = 2785;
        mm[116][1] = 1832;
        mm[116][2] = 1836;
        mm[116][3] = 3365;
        mm[117][0] = 2772;
        mm[117][1] = 2405;
        mm[117][2] = 1990;
        mm[117][3] = 361;
        mm[118][0] = 1217;
        mm[118][1] = 3638;
        mm[118][2] = 2058;
        mm[118][3] = 2685;
        mm[119][0] = 1822;
        mm[119][1] = 3661;
        mm[119][2] = 692;
        mm[119][3] = 3745;
        mm[120][0] = 1245;
        mm[120][1] = 327;
        mm[120][2] = 1194;
        mm[120][3] = 2325;
        mm[121][0] = 2252;
        mm[121][1] = 3660;
        mm[121][2] = 20;
        mm[121][3] = 3609;
        mm[122][0] = 3904;
        mm[122][1] = 716;
        mm[122][2] = 3285;
        mm[122][3] = 3821;
        mm[123][0] = 2774;
        mm[123][1] = 1842;
        mm[123][2] = 2046;
        mm[123][3] = 3537;
        mm[124][0] = 997;
        mm[124][1] = 3987;
        mm[124][2] = 2107;
        mm[124][3] = 517;
        mm[125][0] = 2573;
        mm[125][1] = 1368;
        mm[125][2] = 3508;
        mm[125][3] = 3017;
        mm[126][0] = 1148;
        mm[126][1] = 1848;
        mm[126][2] = 3525;
        mm[126][3] = 2141;
        mm[127][0] = 545;
        mm[127][1] = 2366;
        mm[127][2] = 3801;
        mm[127][3] = 1537;

        i1 = iseed[0];
        i2 = iseed[1];
        i3 = iseed[2];
        i4 = iseed[3];

        for (i = 0; i < Math.min(n, lv); i++) {
            // Multiply the seed by the (i+1)-th power of the multiplier modulo
            // 2**48
            while (true) {
                it4 = i4 * mm[i][3];
                it3 = it4 / ipw2;
                it4 = it4 - (ipw2 * it3);
                it3 = it3 + (i3 * mm[i][3]) + (i4 * mm[i][2]);
                it2 = it3 / ipw2;
                it3 = it3 - (ipw2 * it2);
                it2 = it2 + (i2 * mm[i][3]) + (i3 * mm[i][2]) + (i4 * mm[i][1]);
                it1 = it2 / ipw2;
                it2 = it2 - (ipw2 * it1);
                it1 = it1 + (i1 * mm[i][3]) + (i2 * mm[i][2]) + (i3 * mm[i][1]) + (i4 * mm[i][0]);
                it1 = it1 % ipw2;
    
                // Convert 48-bit integer to a real number in the interval (0,1)
    
                x[i] = r * (it1 + (r * (it2 + (r * (it3 + (r * it4))))));
                if (x[i] != 1.0) {
                    break;    
                } // if (x[i] != 1.0)
                // x[i] == 1.0
                // If a real number has n bits of precision, and the first n bits of the 48-bit integer
                // happen all to be 1 (which will occur about once every 2**n calls), then x[i] will be
                // rounded to exactly 1.0
                // Since x[i] is not supposed to return exactly 0.0 or 1.0, the statistically correct 
                // thing to do in this situation is simply to iterate again.
                // N.B. The case x[i] = 0.0 should not be possible.
                i1 = i1 + 2;
                i2 = i2 + 2;
                i3 = i3 + 2;
                i4 = i4 + 2;
            } // while(true)
        } // for (i = 0; i < Math.min(n,lv); i++)

        // Return final value of seed
        iseed[0] = it1;
        iseed[1] = it2;
        iseed[2] = it3;
        iseed[3] = it4;

        return;
    } // dlaruv

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLASCL Original DLASCL created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlascl multiplies the m by n real matrix A by the real scalar cto/cfrom. This is done without
     * over/underflow as long as the final result cto*A[i][j]/cfrom does not over/underflow. type specifies that A may
     * be full, upper triangular, lower triangular, upper Hessenberg, or banded.
     *
     * @param  type   input char type indicates the storage type of the input matrix. 
     *                = 'G': A is a full matrix. 
     *                = 'L': A is a lower triangular matrix. 
     *                = 'U': A is an upper triangular matrix. 
     *                = 'H': A is an upper Hessenberg matrix. 
     *                = 'B': A is a symmetric band matrix with lower bandwidth kL and upper bandwidth
     *                       ku and with only the lower half stored. 
     *                = 'Q': A is a symmetric band matrix with lower bandwidth kL and upper bandwidth
     *                       ku and with only the upper half stored. 
     *                = 'Z': A is a band matrix with lower bandwith kL and upper bandwidth ku
     * @param  kL     input int The lower bandwidth of A. Referenced only if type = 'B', 'Q', or 'Z'.
     * @param  ku     input int The upper bandwidth of A. Referenced only if type = 'B', 'Q', or 'Z'.
     * @param  cfrom  input double
     * @param  cto    input double The matrix A is multiplied by cto/cfrom. A[i][j] is computed without over/underflow
     *                if the final result cto*A[i][j]/cfrom can be represented without over/underflow. cfrom must be
     *                nonzero.
     * @param  m      input int The number of rows of the matrix A. m >= 0.
     * @param  n      input int The number of columns of the matrix A. n >= 0.
     * @param  A      input/output double[][] of dimension lda by n. The matrix to be multiplied by cto/cfrom.
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,m).
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info = -i, the i-th argument had an illegal value
     */
    private void dlascl(char type, int kL, int ku, double cfrom, double cto, int m, int n, double[][] A, int lda,
                        int[] info) {
        boolean done;
        int i;
        int itype;
        int j;
        int k1;
        int k2;
        int k3;
        int k4;
        double bignum;
        double cfrom1;
        double cfromc;
        double cto1;
        double ctoc;
        double mul;
        double smlnum;

        // Test the input arguments
        info[0] = 0;

        if ((type == 'G') || (type == 'g')) {
            itype = 0;
        } else if ((type == 'L') || (type == 'l')) {
            itype = 1;
        } else if ((type == 'U') || (type == 'u')) {
            itype = 2;
        } else if ((type == 'H') || (type == 'h')) {
            itype = 3;
        } else if ((type == 'B') || (type == 'b')) {
            itype = 4;
        } else if ((type == 'Q') || (type == 'q')) {
            itype = 5;
        } else if ((type == 'Z') || (type == 'z')) {
            itype = 6;
        } else {
            itype = -1;
        }

        if (itype == -1) {
            info[0] = -1;
        } else if (cfrom == 0.0) {
            info[0] = -4;
        } else if (m < 0) {
            info[0] = -6;
        } else if ((n < 0) || ((itype == 4) && (n != m)) || ((itype == 5) && (n != m))) {
            info[0] = -7;
        } else if ((itype <= 3) && (lda < Math.max(1, m))) {
            MipavUtil.displayError("itype = " + itype + " m = " + m + " lda = " + lda);
            info[0] = -9;
        } else if (itype >= 4) {

            if ((kL < 0) || (kL > Math.max(m - 1, 0))) {
                info[0] = -2;
            } else if ((ku < 0) || (ku > Math.max(n - 1, 0)) || (((itype == 4) || (itype == 5)) && (kL != ku))) {
                info[0] = -3;
            } else if (((itype == 4) && (lda < (kL + 1))) || ((itype == 5) && (lda < (ku + 1))) ||
                           ((itype == 6) && (lda < ((2 * kL) + ku + 1)))) {
                info[0] = -9;
            }
        } // else if (itype >= 4)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dlascl had info = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((n == 0) || (m == 0)) {
            return;
        }

        // Get machine parameters
        smlnum = dlamch('S');
        bignum = 1.0 / smlnum;

        cfromc = cfrom;
        ctoc = cto;

        do {
            cfrom1 = cfromc * smlnum;
            cto1 = ctoc / bignum;

            if ((Math.abs(cfrom1) > Math.abs(ctoc)) && (ctoc != 0.0)) {
                mul = smlnum;
                done = false;
                cfromc = cfrom1;
            } else if (Math.abs(cto1) > Math.abs(cfromc)) {
                mul = bignum;
                done = false;
                ctoc = cto1;
            } else {
                mul = ctoc / cfromc;
                done = true;
            }

            if (itype == 0) {

                // Full matrix
                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // if (itype == 0)
            else if (itype == 1) {

                // Lower triangular matrix
                for (j = 0; j < n; j++) {

                    for (i = j; i < m; i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 1)
            else if (itype == 2) {

                // Upper triangular matrix
                for (j = 0; j < n; j++) {

                    for (i = 0; i <= Math.min(j, m - 1); i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 2)
            else if (itype == 3) {

                // Upper Hessenberg matrix
                for (j = 0; j < n; j++) {

                    for (i = 0; i <= Math.min(j + 1, m - 1); i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 3)
            else if (itype == 4) {

                // Lower half of a symmetric band matrix
                k3 = kL + 1;
                k4 = n + 1;

                for (j = 0; j < n; j++) {

                    for (i = 0; i <= Math.min(k3 - 1, k4 - j - 2); i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 4)
            else if (itype == 5) {

                // upper half of a symmetric band matrix
                k1 = ku + 2;
                k3 = ku + 1;

                for (j = 0; j < n; j++) {

                    for (i = Math.max(k1 - j - 2, 0); i <= (k3 - 1); i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 5)
            else if (itype == 6) {

                // Band matrix
                k1 = kL + ku + 2;
                k2 = kL + 1;
                k3 = (2 * kL) + ku + 1;
                k4 = kL + ku + 1 + m;

                for (j = 0; j < n; j++) {

                    for (i = Math.max(k1 - j - 2, k2 - 1); i <= Math.min(k3 - 1, k4 - j - 2); i++) {
                        A[i][j] = A[i][j] * mul;
                    }
                }
            } // else if (itype == 6)
        } while (!done);

        return;
    } // dlascl

    /**
     * This is a port of version 3.1 auxiliary routine DLASET. Original DLASET created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dlaset initializes an m-by-n matrix A to beta on the diagonal and alpha on the offdiagonals.
     *
     * @param  uplo   input char Specifies the part of the matrix to be set. 
     *                = 'U': Upper triangular part is set; the strictly lower triangular part of A is not changed. 
     *                = 'L': Lower triangular part is set; the strictly upper triangular part of A is not changed.
     *                Otherwise: All of the matrix A is set.
     * @param  m      input int The number of rows of the matrix A. m >= 0.
     * @param  n      input int The number of columns of the matrix A. n >= 0.
     * @param  alpha  input double The constant to which the offdiagonal elements are to be set.
     * @param  beta   input double The constant to which the diagonal elements are to be set.
     * @param  A      input/output double[][] of dimension lda by n. On exit, the leading m-by-n submatrix of A is set
     *                as follows: 
     *                If uplo = 'U', A(i,j) = alpha, 0 <= i <= j-1, 0 <= j <= n-1,
     *                If uplo = 'L', A(i,j) = alpha, j+1 <= i <= m-1, 0 <= j <= n-1, 
     *                Otherwise, A(i,j) = alpha, 0 <= i <= m-1, 0 <= j <= n-1, i!= j
     *                and, for all uplo, A(i,i) = beta, 0 <= i <= min(m-1,n-1).
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,m).
     */
    private void dlaset(char uplo, int m, int n, double alpha, double beta, double[][] A, int lda) {
        int i;
        int j;

        if ((uplo == 'U') || (uplo == 'u')) {

            // Set the srictly upper triangular or trapezoidal part of the array to
            // alpha.
            for (j = 1; j < n; j++) {

                for (i = 0; i <= Math.min(j - 1, m - 1); i++) {
                    A[i][j] = alpha;
                }
            }
        } // if ((uplo == 'U') || (uplo == 'u'))
        else if ((uplo == 'L') || (uplo == 'l')) {

            // Set the strictly lower triangular or trapezoidal part of the array to
            // alpha.
            for (j = 0; j <= Math.min(m - 1, n - 1); j++) {

                for (i = j + 1; i <= (m - 1); i++) {
                    A[i][j] = alpha;
                }
            }
        } // else if ((uplo == 'L') || (uplo == 'l'))
        else {

            // Set the leading m-by-n submatrix to alpha
            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    A[i][j] = alpha;
                }
            }
        } // else

        // Set the first min(m,n) diagonal elements to beta
        for (i = 0; i <= Math.min(m - 1, n - 1); i++) {
            A[i][i] = beta;
        }

        return;
    } // dlaset

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLASR Original DLASR created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlasr applies a sequence of plane rotations to a real matrix A, from either the left or the right.
     * when side = 'L', the transformation takes the form
     *     A = P * A
     * and when side = 'R', the transformation takes the form
     *     A = A * P**T
     * where P is an orthogonal matrix consisting of a sequence of z plane rotations, with z = m when side = 'L' and
     * z = n when side = 'R', and P**T is the transpose of P.
     * 
     * When direct = 'F' (Forward sequence), then
     *     P = P(z-2) * ... * P(1) * P(0)
     * and when dired = 'B' (Backward sequence), then
     *     P = P(0) * P(1) * ... * P(z-2)
     * where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
     *     R(k) = (  c(k)  s(k)  )
     *            ( -s(k)  c(k)  )
     *  
     *  When pivot = 'V' (Variable pivot), the rotation is performed for the plane (k,k+1), i.e., P(k) has the form
     *     P(k) = (  1                                                )
     *            (       ...                                         )
     *            (                1                                  )
     *            (                     c(k)   s(k)                   )
     *            (                    -s(k)   c(k)                   )
     *            (                                   1               )
     *            (                                         ...       )
     *            (                                                1  )
     *  where R(k) appears as a rank-2 modification to the identity matrix in rows and columns k and k+1.
     *  
     *  When pivot = 'T' (Top pivot), the rotation is performed for the plane (1,k+1), so P(k) has the form
     *      P(k) = (  c(k)                    s(k)                  )
     *             (        1                                       )
     *             (             ...                                )
     *             (                     1                          )
     *             ( -s(k)                    c(k)                  )
     *             (                                 1              )
     *             (                                     ...        )
     *             (                                             1  )
     * where R(k) appears in rows and column 1 and k+1
     * 
     * 
     * Similarly, when pivot = 'B' (Bottom pivot), the rotation is performed for the plane (k,z), giving 
     * P(k) the form
     *     P(k) = (  1                                          )
     *            (      ...                                    )
     *            (             1                               )
     *            (                  c(k)                  s(k) )
     *            (                        1                    )
     *            (                            ...              )
     *            (                                   1         )
     *            (                 -s(k)                  c(k) )
     * where R(k) appears in rows and columns k and z.  The rotations are performed without ever forming
     * P(k) explicitly.
     *             
     *
     * @param  side    input char Specifies whether the plane rotation matrix P is applied to A on the left or the
     *                 right. 
     *                 = 'L': Left, compute A = P*A 
     *                 = 'R': Right, compute A = A*P'
     * @param  pivot   input char Specifies the plane for which p[k] is a plane rotation matrix. 
     *                            = 'V': Variable pivot, the plane (k,k+1) 
     *                            = 'T': Top pivot, the plane (1,k+1) 
     *                            = 'B': Bottom pivot, the plane (k,z)
     * @param  direct  input char Specifies whether P is a forward or backward sequence of plane rotations. 
     *                            = 'F': Forward, p = p[z-2]*...*p[1]*p[0] 
     *                            = 'B': Backward, p = p[0]*p[1]*...*p[z-2]
     * @param  m       input int The number of rows of the matrix A. If m <= 1, an immediate return is effected.
     * @param  n       input int The number of columns of the matrix A. If n <= 1, an immediate return is effected.
     * @param  c       input double[]
     * @param  s       input double[] c and s are dimension (m-1) if side = 'L', (n-1) if side = 'R' c[k] and s[k]
     *                 contain the cosine and sine that define the matrix p[k]. The two by two plane rotation part of
     *                 the matrix p[k], R[k], has the form R[k] = ( c[k] s[k])
     *                                                            (-s[k] c[k])
     * @param  A       input/output double[][] of dimension lda by n. On entry, the m by n matrix A. On exit, A is
     *                 overwritten by P*A if side = 'L' or by A*P' if side = 'R'.
     * @param  lda     input int The leading dimension of the array A. lda >= max(1,m).
     */
    private void dlasr(char side, char pivot, char direct, int m, int n, double[] c, double[] s, double[][] A,
                       int lda) {
        int i;
        int info;
        int j;
        double ctemp;
        double stemp;
        double temp;

        // Test the input parameters
        info = 0;

        if ((side != 'L') && (side != 'l') && (side != 'R') && (side != 'r')) {
            info = 1;
        } else if ((pivot != 'V') && (pivot != 'v') && (pivot != 'T') && (pivot != 't') && (pivot != 'B') &&
                       (pivot != 'b')) {
            info = 2;
        } else if ((direct != 'F') && (direct != 'f') && (direct != 'B') && (direct != 'b')) {
            info = 3;
        } else if (m < 0) {
            info = 4;
        } else if (n < 0) {
            info = 5;
        } else if (lda < Math.max(1, m)) {
            info = 9;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dlasr had info = " + info);

            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0)) {
            return;
        }

        if ((side == 'L') || (side == 'l')) {

            // Form P*A
            if ((pivot == 'V') || (pivot == 'v')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 0; j < (m - 1); j++) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j + 1][i];
                                A[j + 1][i] = (ctemp * temp) - (stemp * A[j][i]);
                                A[j][i] = (stemp * temp) + (ctemp * A[j][i]);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 0; j < m-1; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = m - 2; j >= 0; j--) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j + 1][i];
                                A[j + 1][i] = (ctemp * temp) - (stemp * A[j][i]);
                                A[j][i] = (stemp * temp) + (ctemp * A[j][i]);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = m-2; j >= 0; j--)
                } // else if ((direct == 'B') || (direct == 'b'))
            } // if ((pivot == 'V') || (pivot == 'v'))
            else if ((pivot == 'T') || (pivot == 't')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 1; j < m; j++) {
                        ctemp = c[j - 1];
                        stemp = s[j - 1];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j][i];
                                A[j][i] = (ctemp * temp) - (stemp * A[0][i]);
                                A[0][i] = (stemp * temp) + (ctemp * A[0][i]);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 1; j < m; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = m - 1; j >= 1; j--) {
                        ctemp = c[j - 1];
                        stemp = s[j - 1];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j][i];
                                A[j][i] = (ctemp * temp) - (stemp * A[0][i]);
                                A[0][i] = (stemp * temp) + (ctemp * A[0][i]);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = m-1; j >= 1; j--)
                } // else if ((direct == 'B') || (direct == 'b'))
            } // else if ((pivot == 'T') || (pivot == 't'))
            else if ((pivot == 'B') || (pivot == 'b')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 0; j < (m - 1); j++) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j][i];
                                A[j][i] = (stemp * A[m - 1][i]) + (ctemp * temp);
                                A[m - 1][i] = (ctemp * A[m - 1][i]) - (stemp * temp);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 0; j < m-1; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = m - 2; j >= 0; j--) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < n; i++) {
                                temp = A[j][i];
                                A[j][i] = (stemp * A[m - 1][i]) + (ctemp * temp);
                                A[m - 1][i] = (ctemp * A[m - 1][i]) - (stemp * temp);
                            } // for (i = 0; i < n; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = m-2; j >= 0; j--)
                } // else if (direct == 'B') || (direct == 'b'))
            } // else if ((pivot == 'B') || (pivot == 'b'))
        } // if ((side == 'L') || (side == 'l'))
        else if ((side == 'R') || (side == 'r')) {

            // Form A * P'
            if ((pivot == 'V') || (pivot == 'v')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 0; j < (n - 1); j++) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j + 1];
                                A[i][j + 1] = (ctemp * temp) - (stemp * A[i][j]);
                                A[i][j] = (stemp * temp) + (ctemp * A[i][j]);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 0; j < n-1; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = n - 2; j >= 0; j--) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j + 1];
                                A[i][j + 1] = (ctemp * temp) - (stemp * A[i][j]);
                                A[i][j] = (stemp * temp) + (ctemp * A[i][j]);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = n-2; j >= 0; j--)
                } // else if ((direct == 'B') || (direct == 'b'))
            } // if ((pivot == 'V') || (pivot == 'v'))
            else if ((pivot == 'T') || (pivot == 't')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 1; j < n; j++) {
                        ctemp = c[j - 1];
                        stemp = s[j - 1];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j];
                                A[i][j] = (ctemp * temp) - (stemp * A[i][0]);
                                A[i][0] = (stemp * temp) + (ctemp * A[i][0]);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 1; j < n; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = n - 1; j >= 1; j--) {
                        ctemp = c[j - 1];
                        stemp = s[j - 1];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j];
                                A[i][j] = (ctemp * temp) - (stemp * A[i][0]);
                                A[i][0] = (stemp * temp) + (ctemp * A[i][0]);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = n-1; j >= 1; j--)
                } // else if ((direct == 'B') || (direct == 'b'))
            } // else if ((pivot == 'T') || (pivot == 't'))
            else if ((pivot == 'B') || (pivot == 'b')) {

                if ((direct == 'F') || (direct == 'f')) {

                    for (j = 0; j < (n - 1); j++) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j];
                                A[i][j] = (stemp * A[i][n - 1]) + (ctemp * temp);
                                A[i][n - 1] = (ctemp * A[i][n - 1]) - (stemp * temp);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = 0; j < n-1; j++)
                } // if ((direct == 'F') || (direct == 'f'))
                else if ((direct == 'B') || (direct == 'b')) {

                    for (j = n - 2; j >= 0; j--) {
                        ctemp = c[j];
                        stemp = s[j];

                        if ((ctemp != 1.0) || (stemp != 0.0)) {

                            for (i = 0; i < m; i++) {
                                temp = A[i][j];
                                A[i][j] = (stemp * A[i][n - 1]) + (ctemp * temp);
                                A[i][n - 1] = (ctemp * A[i][n - 1]) - (stemp * temp);
                            } // for (i = 0; i < m; i++)
                        } // if ((ctemp != 1.0) || (stemp != 0.0))
                    } // for (j = n-2; j >= 0; j--)
                } // else if ((direct == 'B') || (direct == 'b'))
            } // else if ((pivot == 'B') || (pivot == 'b'))
        } // else if ((side == 'R') || (side == 'r'))

        return;
    } // dlasr

    /**
     * This is a port of the version 3.1 LAPACK auxiliary routine DLASRT Original DLASRT created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlasrt sorts the numbers in d in increasing order if id == 'I' or in decreasing order if id == 'D'. Use
     * quick sort, reverting to insertion sort on arrays of size <= 20. Dimension of stack limits n to about 2**32.
     *
     * @param  id    input char 
     *               = 'I': sort d in increasing order 
     *               = 'D': sort d in decreasing order
     * @param  n     input int The length of the array d.
     * @param  d     input/output double[] of dimension n. On entry, the array to be sorted. On exit, d has been sorted
     *               into increasing order (d[0] <= ... <= d[n-1]) or into decreasing order (d[0] >= ... >= d[n-1]),
     *               depending on id.
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info = -i, the i-th argument had an illegal value
     */
    private void dlasrt(char id, int n, double[] d, int[] info) {
        int select = 20;
        int dir;
        int endd;
        int i;
        int j;
        int start;
        int stkpnt;
        double d1;
        double d2;
        double d3;
        double dmnmx;
        double tmp;
        int[][] stack = new int[2][32];

        // Test the input parameters
        info[0] = 0;
        dir = -1;

        if ((id == 'D') || (id == 'd')) {
            dir = 0;
        } else if ((id == 'I') || (id == 'i')) {
            dir = 1;
        }

        if (dir == -1) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dlasrt had info = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n <= 1) {
            return;
        }

        stkpnt = 0;
        stack[0][0] = 0;
        stack[1][0] = n - 1;

        do {
            start = stack[0][stkpnt];
            endd = stack[1][stkpnt];
            stkpnt = stkpnt - 1;

            if (((endd - start) <= select) && ((endd - start) > 0)) {

                // Do insertion sort on d(start:endd)
                if (dir == 0) {

// Sort into decreasing order
loop1:
                    for (i = start + 1; i <= endd; i++) {

                        for (j = i; j >= (start + 1); j--) {

                            if (d[j] > d[j - 1]) {
                                dmnmx = d[j];
                                d[j] = d[j - 1];
                                d[j - 1] = dmnmx;
                            } else {
                                continue loop1;
                            }
                        } // for (j = i; j >= start+1; j--)
                    } // for (i = start+1; i <= endd; i++)
                } // if (dir == 0)
                else { // dir == 1

// Sort into increasing order
loop2:
                    for (i = start + 1; i <= endd; i++) {

                        for (j = i; j >= (start + 1); j--) {

                            if (d[j] < d[j - 1]) {
                                dmnmx = d[j];
                                d[j] = d[j - 1];
                                d[j - 1] = dmnmx;
                            } else {
                                continue loop2;
                            }
                        } // for (j = i; j >= start+1; j--)
                    } // for (i = start+1; i <= endd; i++)
                } // else dir == 1
            } // if (((endd - start) <= select) && ((endd - start) > 0))
            else if ((endd - start) > select) {

                // Partition d(start:endd) and stack parts, largest one first
                // Choose partition entry as median of 3
                d1 = d[start];
                d2 = d[endd];
                i = (start + endd) / 2;
                d3 = d[i];

                if (d1 < d2) {

                    if (d3 < d1) {
                        dmnmx = d1;
                    } else if (d3 < d2) {
                        dmnmx = d3;
                    } else {
                        dmnmx = d2;
                    }
                } // if (d1 < d2)
                else { // d1 >= d2

                    if (d3 < d2) {
                        dmnmx = d2;
                    } else if (d3 < d1) {
                        dmnmx = d3;
                    } else {
                        dmnmx = d1;
                    }
                } // else d1 >= d2

                if (dir == 0) {

                    // Sort into decreasing order
                    i = start - 1;
                    j = endd + 1;

loop3:
                    do {
                        j = j - 1;

                        if (d[j] < dmnmx) {
                            continue loop3;
                        }

                        do {
                            i = i + 1;
                        } while (d[i] > dmnmx);

                        if (i < j) {
                            tmp = d[i];
                            d[i] = d[j];
                            d[j] = tmp;

                            continue loop3;
                        } // if (i < j)

                        break loop3;
                    } // loop3
                    while (true);

                    if ((j - start) > (endd - j - 1)) {
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = start;
                        stack[1][stkpnt] = j;
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = j + 1;
                        stack[1][stkpnt] = endd;
                    } // if ((j - start) > (endd - j - 1))
                    else { // ((j - start) <= (endd - j - 1))
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = j + 1;
                        stack[1][stkpnt] = endd;
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = start;
                        stack[1][stkpnt] = j;
                    } // else ((j - start) <= (endd - j - 1))
                } // if (dir == 0)
                else { // dir == 1

                    // Sort into increasing order
                    i = start - 1;
                    j = endd + 1;

loop4:
                    do {
                        j = j - 1;

                        if (d[j] > dmnmx) {
                            continue loop4;
                        }

                        do {
                            i = i + 1;
                        } while (d[i] < dmnmx);

                        if (i < j) {
                            tmp = d[i];
                            d[i] = d[j];
                            d[j] = tmp;

                            continue loop4;
                        } // if (i < j)

                        break loop4;
                    } // loop4
                    while (true);

                    if ((j - start) > (endd - j - 1)) {
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = start;
                        stack[1][stkpnt] = j;
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = j + 1;
                        stack[1][stkpnt] = endd;
                    } // if ((j-start) > (endd-j-1))
                    else { // ((j-start) <= (endd-j-1))
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = j + 1;
                        stack[1][stkpnt] = endd;
                        stkpnt = stkpnt + 1;
                        stack[0][stkpnt] = start;
                        stack[1][stkpnt] = j;
                    } // else ((j-start) <= (endd-j-1)
                } // else dir == 1
            } // else if ((endd - start) > select)
        } while (stkpnt > -1);

        return;
    } // dlasrt

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLASSQ Original DLASSQ created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlassq returns the values scl and smsq such that
     *  (scl**2)*smsq = x[0]**2 + x[incx]**2 + ... + x[(n-1)*incx]**2 + (scale**2)*sumsq 
     * The value of sumsq is assumed to be non-negative and scl returns the value 
     *  scl =  max(scale,abs(x[i])). 
     * scale and sumsq refer to the original supplied values in scale[] and sumsq[]. scl and smsq
     * are the returned values in scale[] and sumsq[]. This routine makes only one pass through the vector x.
     *
     * @param  n      input int The number of elements to be used from the vector x
     * @param  x      input double[] The vector for which a scaled sum of squares is computed, using x[0], x[incx], ...,
     *                x[(n-1)*incx]
     * @param  incx   input int The increment between successive values of the vector x. incx > 0.
     * @param  scale  input/output double[] On entry, the value scale in the equation above. On exit, scale is
     *                overwritten with scl, the scaling factor for the sum of squares
     * @param  sumsq  input/output double[] On entry, the value sumsq in the equation above. On exit, sumsq is
     *                overwritten with smsq, the basic sum of squares from which scl has been factored out.
     */
    private void dlassq(int n, double[] x, int incx, double[] scale, double[] sumsq) {
        int ix;
        double absxi;
        double ratio;

        if (n > 0) {

            for (ix = 0; ix <= ((n - 1) * incx); ix += incx) {

                if (x[ix] != 0.0) {
                    absxi = Math.abs(x[ix]);

                    if (scale[0] < absxi) {
                        ratio = scale[0] / absxi;
                        sumsq[0] = 1 + (sumsq[0] * ratio * ratio);
                        scale[0] = absxi;
                    } // if (scale[0] < absxi)
                    else { // scale[0] >= absxi
                        ratio = absxi / scale[0];
                        sumsq[0] = sumsq[0] + (ratio * ratio);
                    } // else scale[0] >= absxi
                } // if (x[ix] != 0.0)
            } // for (ix = 0; ix <= (n-1)*incx; ix += incx)
        } // if (n > 0)

        return;
    } // dlassq

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLASV2 Original DLASV2 created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlasv2 computes the singular value decomposition of a 2-by-2 triangular matrix 
     *  [ f g ]
     *  [ 0 h ]. 
     * On return, abs(ssmax[0]) is the larger singular value, abs(ssmin[0]) is the smaller singular value,
     * and (csl[0],snl[0]) and (csr[0],snr[0]) are the left and right singular vectors for abs(ssmax[0]),
     * giving the decomposition
     *  [ csl snl] [f  g ] [ csr -snr] = [ ssmax 0 ] 
     *  [-snl csl] [0  h ] [ snr csr]    [ 0 ssmin ].
     *
     * @param  f      input double The (0,0) element of a 2-by-2 matrix.
     * @param  g      input double The (0,1) element of a 2-by-2 matrix.
     * @param  h      input double The (1,1) element of a 2-by-2 matrix.
     * @param  ssmin  output double[] abs(ssmin[0]) is the smaller singular value.
     * @param  ssmax  output double[] abs(ssmax[0]) is the larger singular value.
     * @param  snr    output double[]
     * @param  csr    output double[] The vector (csr[0],snr[0]) is a unit right singular vector for the singular value
     *                abs(ssmax[0]).
     * @param  snl    output double[]
     * @param  csl    output double[] The vector (csl[0],snl[0]) is a unit left singular vector for the singular value
     *                abs(ssmax[0]).
     * Further details: Any input parameter may be aliased with any output parameter.
     *
     * <p>Barring over/underflow and assuming a guard digit in subtraction, all output quantities are
     *    correct to within a few units in the last place (ulps).</p>
     *
     * <p>In IEEE arithmetic, the code works correctly if one matrix element is infinite.</p>
     *
     * <p>Overflow will not occur unless the largest singular value itself overflows or is within a few
     *    ulps of overflow. (On machines with partial overflow, like the Cray, overflow may occur if the
     *    largest singular value is within a factor of 2 of overflow.)</p>
     *
     * <p>Underflow is harmless if underflow is gradual. Otherwise, results may correspond to a matrix
     *    modified by perturbations of size near the underflow threshold.</p>
     */
    private void dlasv2(double f, double g, double h, double[] ssmin, double[] ssmax, double[] snr, double[] csr,
                        double[] snl, double[] csl) {
        boolean gasmal;
        boolean swap;
        int pmax;
        double a;
        double clt = 0.0;
        double crt = 0.0;
        double d;
        double fa;
        double ft;
        double ga;
        double gt;
        double ha;
        double ht;
        double L;
        double m;
        double mm;
        double r;
        double s;
        double slt = 0.0;
        double srt = 0.0;
        double t;
        double temp;
        double tsign;
        double tt;

        ft = f;
        fa = Math.abs(ft);
        ht = h;
        ha = Math.abs(h);

        // pmax points to the maximum value of the matrix
        // pmax = 1 if f largest in absolute value
        // pmax = 2 if g largest in absolute value
        // pmax = 3 if h largest in absolute value
        pmax = 1;
        swap = (ha > fa);

        if (swap) {
            pmax = 3;
            temp = ft;
            ft = ht;
            ht = temp;
            temp = fa;
            fa = ha;
            ha = temp;
            // Now fa >= ha
        } // if (swap)

        gt = g;
        ga = Math.abs(gt);

        if (ga == 0.0) {

            // Diagonal matrix
            ssmin[0] = ha;
            ssmax[0] = fa;
            clt = 1.0;
            crt = 1.0;
            slt = 0.0;
            srt = 0.0;
        } // if (ga == 0.0)
        else {
            gasmal = true;

            if (ga > fa) {
                pmax = 2;

                if ((fa / ga) < dlamch('E')) {

                    // Case of very large ga
                    gasmal = false;
                    ssmax[0] = ga;

                    if (ha > 1.0) {
                        ssmin[0] = fa / (ga / ha);
                    } else {
                        ssmin[0] = (fa / ga) * ha;
                    }

                    clt = 1.0;
                    slt = ht / gt;
                    srt = 1.0;
                    crt = ft / gt;
                } // if ((fa/ga) < dlamch('E'))
            } // if (ga > fa)

            if (gasmal) {

                // Normal case
                d = fa - ha;

                if (d == fa) {

                    // Copes with infinite F or H
                    L = 1.0;
                } // if (d == fa)
                else {
                    L = d / fa;
                } // else

                // Note that 0 <= L <= 1
                m = gt / ft;

                // Note that abs(m) <= 1/macheps
                t = 2.0 - L;

                // Note that t >= 1
                mm = m * m;
                tt = t * t;
                s = Math.sqrt(tt + mm);

                // Note that 1 <= s <= 1 + 1/macheps
                if (L == 0.0) {
                    r = Math.abs(m);
                } else {
                    r = Math.sqrt((L * L) + mm);
                }

                // Note that 0 <= r <= 1 + 1/macheps
                a = 0.5 * (s + r);

                // Note that 1 <= a <= 1 + abs(m);
                ssmin[0] = ha / a;
                ssmax[0] = fa * a;

                if (mm == 0.0) {

                    // Note that m is very tiny
                    if (L == 0.0) {

                        if (((ft >= 0.0) && (gt >= 0.0)) || ((ft < 0.0) && (gt < 0.0))) {
                            t = 2.0;
                        } else {
                            t = -2.0;
                        }
                    } // if (L == 0.0)
                    else if (ft >= 0.0) {
                        t = (gt / Math.abs(d)) + (m / t);
                    } // else if (ft >= 0.0)
                    else {
                        t = (-gt / Math.abs(d)) + (m / t);
                    } // else
                } // if (mm == 0.0)
                else {
                    t = ((m / (s + t)) + (m / (r + L))) * (1.0 + a);
                }

                L = Math.sqrt((t * t) + 4.0);
                crt = 2.0 / L;
                srt = t / L;
                clt = (crt + (srt * m)) / a;
                slt = (ht / ft) * srt / a;
            } // if (gasmal)
        } // else

        if (swap) {
            csl[0] = srt;
            snl[0] = crt;
            csr[0] = slt;
            snr[0] = clt;
        } // if (swap)
        else {
            csl[0] = clt;
            snl[0] = slt;
            csr[0] = crt;
            snr[0] = srt;
        } // else

        // Correct signs of ssmax and ssmin
        tsign = 1.0;

        if (pmax == 1) {

            if (csr[0] < 0.0) {
                tsign = -tsign;
            }

            if (csl[0] < 0.0) {
                tsign = -tsign;
            }

            if (f < 0) {
                tsign = -tsign;
            }
        } // if (pmax == 1)

        if (pmax == 2) {

            if (snr[0] < 0.0) {
                tsign = -tsign;
            }

            if (csl[0] < 0.0) {
                tsign = -tsign;
            }

            if (g < 0.0) {
                tsign = -tsign;
            }
        } // if (pmax == 2)

        if (pmax == 3) {

            if (snr[0] < 0.0) {
                tsign = -tsign;
            }

            if (snl[0] < 0.0) {
                tsign = -tsign;
            }

            if (h < 0.0) {
                tsign = -tsign;
            }
        } // if (pmax == 3)

        if (tsign >= 0.0) {
            ssmax[0] = Math.abs(ssmax[0]);
        } else {
            ssmax[0] = -Math.abs(ssmax[0]);
        }

        if (f < 0.0) {
            tsign = -tsign;
        }

        if (h < 0.0) {
            tsign = -tsign;
        }

        if (tsign >= 0.0) {
            ssmin[0] = Math.abs(ssmin[0]);
        } else {
            ssmin[0] = -Math.abs(ssmin[0]);
        }

        return;
    } // dlasv2

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM1 Original DLATM1 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlatm1 computes the entries of D[0...n-1] as specified by mode, cond, and irsign. idist and iseed
     * determine the generation of random numbers. dlatm1 is called by dlatmr to generate random test matrices for
     * LAPACK programs.
     *
     * @param  mode    input int On entry describes how D is to be computed: 
     *                 = 0 means do not change D. 
     *                 = 1 sets D[0] = 1 and D[1:n-1] = 1.0/cond. 
     *                 = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond. 
     *                 = 3 sets D[i] = cond**(-(i)/(n-1)) 
     *                 = 4 sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) 
     *                 = 5 sets D to random numbers in the range (1/cond, 1) such that their logarithms are uniformly distributed.
     *                 = 6 sets D to random numbers from the same distribution as the rest of the matrix. 
     *                 < 0 has the same meaning as abs(mode), except that the order of the elements of D is reversed.
     *                    Thus if mode is positive, D has entries ranging from 1 to 1/cond. If negative, from 1/cond to 1.
     * @param  cond    input double On entry, used as described under mode above. If used, it must be >= 1.
     * @param  irsign  input int On entry, if mode neither -6, 0, or 6, determines sign of entries of D. 
     *                 0 => leave entries of D unchanged 
     *                 1 => multiply each entry of D by 1 or -1 with probability 0.5
     * @param  idist   input int On entry, idist specifies the type of distribution to be used to generate a random
     *                 matrix. 
     *                 1 => uniform(0,1) 
     *                 2 => uniform(-1,1) 
     *                 3 => normal(0,1)
     * @param  iseed   input/output int[] On entry iseed specifies the seed of the random number generator. The random
     *                 number generator uses a linear congruential sequence limited to small integers, and so should
     *                 produce machine independent random numbers. The values of iseed are changed on exit, and can be
     *                 used in the next call to dlatm1 to continue the same random number sequence.
     * @param  D       input/output double[] of dimension min(m,n). Array to be computed according to mode, cond, and
     *                 irsign. May be changed on exit if mode is nonzero.
     * @param  n       input int The number of entries of D.
     * @param  info    output int[] 
     *                 0 => normal termination 
     *                 -1 => if mode not in range -6 to 6. 
     *                 -2 => if mode neither -6, 0, or 6, and irsign neither 0 nor 1 
     *                 -3 => if mode neither -6, 0, or 6 and cond less than 1 
     *                 -4 => if mode equals 6 or -6 and idist not in range 1 to 3
     *                 -7 => if n negative
     */
    private void dlatm1(int mode, double cond, int irsign, int idist, int[] iseed, double[] D, int n, int[] info) {
        int i;
        double alpha;
        double temp;

        // Decode and test the input parameters.  Initialiize flags & seed.
        info[0] = 0;

        // Quick return if possible
        if (n == 0) {
            return;
        }

        // Set info if an error
        if ((mode < -6) || (mode > 6)) {
            info[0] = -1;
        } else if ((mode != -6) && (mode != 0) && (mode != 6) && (irsign != 0) && (irsign != 1)) {
            info[0] = -2;
        } else if ((mode != -6) && (mode != 0) && (mode != 6) && (cond < 1.0)) {
            info[0] = -3;
        } else if (((mode == 6) || (mode == -6)) && ((idist < 1) || (idist > 3))) {
            info[0] = -4;
        } else if (n < 0) {
            info[0] = -7;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dlatm1 had info[0] = " + info[0]);

            return;
        }

        // Compute D according to cond and mode
        if (mode != 0) {

            switch (Math.abs(mode)) {

                case 1:

                    // One large D value
                    for (i = 1; i < n; i++) {
                        D[i] = 1.0 / cond;
                    }

                    D[0] = 1.0;
                    break;

                case 2:

                    // One small D value
                    for (i = 0; i < (n - 1); i++) {
                        D[i] = 1.0;
                    }

                    D[n - 1] = 1.0 / cond;
                    break;

                case 3:

                    // Exponentially distributed D values
                    D[0] = 1.0;
                    if (n > 1) {
                        alpha = Math.pow(cond, -1.0 / (n - 1));

                        for (i = 1; i < n; i++) {
                            D[i] = Math.pow(alpha, i);
                        }
                    } // if (n > 1)

                    break;

                case 4:

                    // Arithmetically distributed D values
                    D[0] = 1.0;
                    if (n > 1) {
                        temp = 1.0 / cond;
                        alpha = (1.0 - temp) / (n - 1.0);

                        for (i = 2; i <= n; i++) {
                            D[i - 1] = ((n - i) * alpha) + temp;
                        }
                    } // if (n > 1)

                    break;

                case 5:

                    // Randomly distributed D values on (1/cond, 1)
                    alpha = Math.log(1.0 / cond);
                    for (i = 0; i < n; i++) {
                        D[i] = Math.exp(alpha * dlaran(iseed));
                    }

                    break;

                case 6:

                    // Randomly distributed values from idist
                    dlarnv(idist, iseed, n, D);
                    break;
            } // switch(Math.abs(mode))

            // If mode neither -6, nor 0, or nor 6, and irsign = 1, assign random
            // signs to D
            if ((mode != -6) && (mode != 0) && (mode != 6) && (irsign == 1)) {

                for (i = 0; i < n; i++) {
                    temp = dlaran(iseed);

                    if (temp > 0.5) {
                        D[i] = -D[i];
                    }
                }
            } // if ((mode != -6) && (mode != 0) && (mode != 6) && (irsign == 1))

            // Reverse if mode < 0
            if (mode < 0) {

                for (i = 1; i <= (n / 2); i++) {
                    temp = D[i - 1];
                    D[i - 1] = D[n - i];
                    D[n - i] = temp;
                }
            } // if (mode < 0)
        } // if (mode != 0)

        return;
    } // dlatm1

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM2 Original DLATM2 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlatm2 returns the (i,j) entry of a random matrix of dimension (m,n) described by the other parameters.
     * It is called by the dlatmr routine in order to build random test matrices. No error checking on parameters is
     * done, because this routine is called in a tight loop by dlatmr which has already checked the parameters.
     *
     * <p>Use of dlatm2 differs from dlatm3 in the order in which the random number generator is called to fill in
     * random matrix entries. With dlatm2, the generator is called to fill in the pivoted matrix columnwise. With
     * dlatm3, the generator is called to fill in the matrix columnwise, after which it is pivoted. Thus, dlatm3 can be
     * used to construct random matrices which differ only in their order of rows and/or columns. dlatm2 is used to
     * construct band matrices while avoiding calling the random number generator for entries outisde the band (and
     * therefore generating random numbers).</p>
     *
     * <p>The matrix whose (i,j) entry is returned is constructed as follows (this routine only computes one entry):</p>
     *
     * <p>If i is outside (1..m) or j is outside (1..n), return zero. (This is convenient for generating matrices in
     * band format).</p>
     *
     * <p>Generate a matrix A with random entries of distribution idist.</p>
     *
     * <p>Set the diagonal to D.</p>
     *
     * <p>Grade the matrix, if desired, from the left (by dl) and/or from the right (by dr or dl) as specified by
     * igrade.</p>
     *
     * <p>Permute, if desired, the rows and/or columns as specified by ipvtng and iwork.</p>
     *
     * <p>Band the matrix to have lower bandwidth kl and upper bandwidth ku.</p>
     *
     * <p>Set random entries to zero as specified by sparse.</p>
     *
     * @param   m       input int Number of rows of the matrix.
     * @param   n       input int Number of columns of the matrix.
     * @param   i       input int Row of entry to be returned.
     * @param   j       input int Column of entry to be returned.
     * @param   kl      input int Lower bandwidth.
     * @param   ku      input int Upper bandwidth.
     * @param   idist   input int On entry, idist specifies the type of distribution to be used to generate a random
     *                  matrix. 
     *                  1 => uniform(0,1) 
     *                  2 => uniform(-1,1) 
     *                  3 => normal(0,1)
     * @param   iseed   input/output int[] of dimension 4 Seed for random number generator. Changed on exit.
     * @param   D       input double[] of dimension min(i,j) Diagonal entries of matrix.
     * @param   igrade  input int Specifies grading of matrix as follows: 
     *                  0 => no grading 
     *                  1 => matrix premultiplied by diag(dl) 
     *                  2 => matrix postmultiplied by diag(dr) 
     *                  3 => matrix premultiplied by diag(dl) and postmultiplied by diag(dr) 
     *                  4 => matrix premultiplied by diag(dl) and postmultiplied by inv(diag(dl)) 
     *                  5 => matrix premultiplied by diag(dl) and postmultiplied by diag(dl)
     * @param   dl      input double[] of dimension i or j, as appropriate Left scale factors for grading matrix.
     * @param   dr      input double[] of dimension i or j, as appropriate Right scale factors for grading matrix.
     * @param   ipvtng  input int On entry specifies pivoting permutations as follows: 
     *                  0 => none. 
     *                  1 => row pivoting. 
     *                  2 => column pivoting. 
     *                  3 => full pivoting, i.e., on both sides
     * @param   iwork   input int[] of dimension i or j, as appropriate This array specifies the permutation used. The
     *                  row (or column) in position k was originally in position iwork[k-1]. This differs from iwork for
     *                  dlatm3.
     * @param   sparse  input double between 0.0 and 1.0. On entry specifies the sparsity of the matrix if sparse matrix
     *                  is to be generated. A uniform (0,1) random number x is generated and compared to sparse; if x is
     *                  larger the matrix entry is unchanged and if x is smaller the entry is set to zero. Thus on
     *                  average a fraction sparse of the entries will be set to zero.
     *
     * @return  double
     */
    private double dlatm2(int m, int n, int i, int j, int kl, int ku, int idist, int[] iseed, double[] D, int igrade,
                          double[] dl, double[] dr, int ipvtng, int[] iwork, double sparse) {
        int isub = 0;
        int jsub = 0;
        double temp;

        // Check for i and j in range
        if ((i < 1) || (i > m) || (j < 1) || (j > n)) {
            return 0.0;
        }

        // Check for banding
        if ((j > (i + ku)) || (j < (i - kl))) {
            return 0.0;
        }

        // Check for sparsity
        if (sparse > 0.0) {

            if (dlaran(iseed) < sparse) {
                return 0.0;
            }
        }

        // Compute subscripts depending on ipvtng
        if (ipvtng == 0) {
            isub = i;
            jsub = j;
        } else if (ipvtng == 1) {
            isub = iwork[i - 1];
            jsub = j;
        } else if (ipvtng == 2) {
            isub = i;
            jsub = iwork[j - 1];
        } else if (ipvtng == 3) {
            isub = iwork[i - 1];
            jsub = iwork[j - 1];
        }

        // Compute entry and grade it according to igrade
        if (isub == jsub) {
            temp = D[isub - 1];
        } else {
            temp = dlarnd(idist, iseed);
        }

        if (igrade == 1) {
            temp = temp * dl[isub - 1];
        } else if (igrade == 2) {
            temp = temp * dr[jsub - 1];
        } else if (igrade == 3) {
            temp = temp * dl[isub - 1] * dr[jsub - 1];
        } else if ((igrade == 4) && (isub != jsub)) {
            temp = temp * dl[isub - 1] / dl[jsub - 1];
        } else if (igrade == 5) {
            temp = temp * dl[isub - 1] * dl[jsub - 1];
        }

        return temp;
    } // dlatm2

    /**
     * This is the port of the version 3.1 LAPACK auxiliary test routine DLATM3 Original DLATM3 created by Univ. of
     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlatm3 returns the (isub, jsub) entry of a random matrix of dimension (m,n) described by the
     * other parameters. (isub, jsub) is the final position of the (i,j) entry after pivoting according to ipvtng and
     * iwork. dlatm3 is called by the dlatmr routine in order to build random test matrices. No error checking is done,
     * because this routine is called in a tight loop by dlatmr which has already checked the parameters.
     *
     * <p>Use of dlatm3 differs from dlatm2 in the order in which the random number generator is called to fill in
     * random matrix entries. With dlatm2, the generator is called to fill in the pivoted matrix columnwise. With
     * dlatm3, the generator is called to fill in the matrix columnwise, after which it is pivoted. Thus, dlatm3 can be
     * used to construct random matrices which differ only in their order of rows and/or columns. dlatm2 is used to
     * construct band matrices while avoiding calling the random number generator for entries outside the band (and
     * therefore generating random numbers in different orders for different pivot orders).</p>
     *
     * <p>The matrix whose (isub, jsub) entry is returned is constructed as follows (this routine only computes one
     * entry):</p>
     *
     * <p>If isub is outside (1...m) or jsub is outside (1...n), return zero. (this is convenient for generating
     * matrices in band format).</p>
     *
     * <p>Generate a matrix A with random entries of distribution idist.</p>
     *
     * <p>Set the diagonal to D.</p>
     *
     * <p>Grade the matrix, if desired, from the left (by dl) and/or from the right (by dr or dl) as specified by
     * igrade.</p>
     *
     * <p>Permute, if desired, the rows and/or columns as specified by ipvtng and iwork.</p>
     *
     * <p>Band the matrix to have lower bandwidth kl and upper bandwidth ku.</p>
     *
     * <p>Set random entries to zero as specified by sparse.</p>
     *
     * @param   m       input int Number of rows of matrix
     * @param   n       input int Number of columns of matrix.
     * @param   i       input int Row of unpivoted entry to be returned.
     * @param   j       input int Column of unpivoted entry to be returned.
     * @param   isub    output int[] Row of pivoted entry to be returned.
     * @param   jsub    output int[] Column of pivoted entry to be returned.
     * @param   kl      input int Lower bandwidth
     * @param   ku      input int Upper bandwidth
     * @param   idist   input int On entry, idist specifies the type of distribution to be used to generate a random
     *                  matrix. 
     *                  1 => uniform (0,1) 
     *                  2 => uniform (-1,1) 
     *                  3 => normal (0,1)
     * @param   iseed   input/output int[] of dimension 4 Seed for random number generator. Changed on exit.
     * @param   D       input double[] of dimension min(i,j). Diagonal entries of matrix.
     * @param   igrade  input int Specifies the grading of the matrix as follows: 
     *                  0 => no grading 
     *                  1 => matrix premultiplied by diag (dl) 
     *                  2 => matrix postmultiplied by diag (dr) 
     *                  3 => matrix premultiplied by diag (dl) and postmultiplied by diag (dr) 
     *                  4 => matrix premultiplied by diag (dl) and postmultiplied by inv(diag(dl)) 
     *                  5 => matrix premultiplied by diag(dl) and postmultiplied by diag(dl)
     * @param   dl      input double[] of dimension i or j, as appropriate Left scale factors for grading matrix.
     * @param   dr      input double[] of dimension i or j, as appropriate Right scale factors for grading matrix.
     * @param   ipvtng  input int On entry specifies the pivoting permutations as follows: 
     *                  0 => none 
     *                  1 => row pivoting 
     *                  2 => column pivoting 
     *                  3 => full pivoting, i.e., on both sides
     * @param   iwork   input int[] of dimension i or j, as appropriate This array specifies the permutation used. The
     *                  row (or column) originally in position k is in position iwork[k-1] after pivoting. This differs
     *                  from iwork for dlatm2.
     * @param   sparse  input double between 0.0 and 1.0. On entry specifies the sparsity of the matrix if sparse matrix
     *                  is to be generated. A uniform (0,1) random number x is generated and compared to sparse; if x is
     *                  larger the matrix entry is unchanged and if x is smaller the entry is set to zero. Thus on the
     *                  average a fraction sparse of the entries will be set to zero.
     *
     * @return  double
     */
    private double dlatm3(int m, int n, int i, int j, int[] isub, int[] jsub, int kl, int ku, int idist, int[] iseed,
                          double[] D, int igrade, double[] dl, double[] dr, int ipvtng, int[] iwork, double sparse) {
        double temp;

        // Check for i and j in range
        if ((i < 1) || (i > m) || (j < 1) || (j > n)) {
            isub[0] = i;
            jsub[0] = j;

            return 0.0;
        }

        // Compute subscripts depending on ipvtng
        if (ipvtng == 0) {
            isub[0] = i;
            jsub[0] = j;
        } else if (ipvtng == 1) {
            isub[0] = iwork[i - 1];
            jsub[0] = j;
        } else if (ipvtng == 2) {
            isub[0] = i;
            jsub[0] = iwork[j - 1];
        } else if (ipvtng == 3) {
            isub[0] = iwork[i - 1];
            jsub[0] = iwork[j - 1];
        }

        // Check for banding
        if ((jsub[0] > (isub[0] + ku)) || (jsub[0] < (isub[0] - kl))) {
            return 0.0;
        }

        // Check for sparsity
        if (sparse > 0.0) {

            if (dlaran(iseed) < sparse) {
                return 0.0;
            }
        }

        // Compute entry and grade it according it according to igrade
        if (i == j) {
            temp = D[i - 1];
        } else {
            temp = dlarnd(idist, iseed);
        }

        if (igrade == 1) {
            temp = temp * dl[i - 1];
        } else if (igrade == 2) {
            temp = temp * dr[j - 1];
        } else if (igrade == 3) {
            temp = temp * dl[i - 1] * dr[j - 1];
        } else if ((igrade == 4) && (i != j)) {
            temp = temp * dl[i - 1] / dl[j - 1];
        } else if (igrade == 5) {
            temp = temp * dl[i - 1] * dl[j - 1];
        }

        return temp;
    } // dlatm3

    /**
     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM4 Original DLATM4 created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dlatm4 generates basic square matrices, which may later be multiplied by others in order to produce test
     * matrices. It is intended mainly to be used to test the generalized eigenvalue routines.
     *
     * <p>It first generates the diagonal and (possibly) subdiagonal, according to the value of itype, nz1, nz2, isign,
     * amagn, and rcond. It then fills in the upper triangle with random numbers, if triang is non-zero.</p>
     *
     * @param  itype   input int The "type" of matrix on the diagonal and sub-diagonal. If itype < 0, then type
     *                 abs(itype) is generated and then swapped end for end (A[i][j] := A'([n-1-j][n-1-i].) See also the
     *                 description of amagn and isign. Special types: 
     *                 = 0: the zero matrix. 
     *                 = 1: the identity 
     *                 = 2: a transposed Jordan block. 
     *                 = 3: If n is odd, then a k+1 by k+1 transposed Jordan block followed by
                            a k by k identity block, where k = (n-1)/2. If n is even, then k = (n-2)/2,
                            and a zero diagona entry is tacked onto the end.
     *
     *                 <p>Diagonal types. The diagonal consists of nz1 zeros, then k = n-nz1-nz2 nonzeros. The
     *                 subdiagonal is zero. itype specifies the nonzero diagonal entries as follows: 
     *                 = 4: 1, ..., k 
     *                 = 5: 1, rcond, ..., rcond 
     *                 = 6: 1, ..., 1, rcond 
     *                 = 7: 1, a, a**2, ..., a**(k-1) = rcond 
     *                 = 8: 1, 1-d, 1-2*d, ..., 1-(k-1)*d = rcond 
     *                 = 9: random numbers chosen from (rcond,1) 
     *                 = 10: random numbers with distribution idist (see dlarnd.)</p>
     * @param  n       input int The order of the matrix.
     * @param  nz1     input int If abs(itype) > 3, then the first nz1 diagonal entries will be zero.
     * @param  nz2     input int If the abs(itype) > 3, the the last nz2 diagonal entries will be zero.
     * @param  isign   input int 
     *                 = 0: The sign of the diagonal and subdiagonal entries will be left unchanged. 
     *                 = 1: The diagonal and subdiagonal entries will have their sign changed at random. 
     *                 = 2: If itype is 2 or 3, then the same as isign = 1. Otherwise, with probability 0.5,
     *                      even-odd pairs of diagonal entries A[2*j][2*j], A[2*j+1][2*j+1] will be converted
     *                      to a 2 by 2 block by pre- and post-multiplying by distinct random orthogonal rotations.
     *                      The remaining diagonal entries will have their sign changed at random.
     * @param  amagn   input double The diagonal and subdiagonal entries will be multiplied by amagn.
     * @param  rcond   input double If abs(itype) > 4, then the smallest diagonal entry will be rcond. rcond must be
     *                 between 0 and 1.
     * @param  triang  input double The entries above the diagonal will be random numbers with magnitude bounded by
     *                 triang (i.e., random numbers multiplied by triang.)
     * @param  idist   input int Specifies the type of distribution to be used to generate a random matrix. 
     *                 = 1: uniform (0, 1) 
     *                 = 2: uniform (-1, 1) 
     *                 = 3: normal (0, 1)
     * @param  iseed   (input/output) int[] of dimension 4 On entry iseed specifies the seed of the random number
     *                 generator. The values of iseed are changed on exit, and can be used in the next call to dlatm4 to
     *                 continue the same random number sequence. Note: iseed[3] should be odd, for the random number
     *                 generator used at present.
     * @param  A       output double[][] of dimension (lda,n) Array to be computed.
     * @param  lda     input int Leading dimension of A. Must be at least 1 and at least n.
     */
    private void dlatm4(int itype, int n, int nz1, int nz2, int isign, double amagn, double rcond, double triang,
                        int idist, int[] iseed, double[][] A, int lda) {
        int i;
        int ioff;
        int isdb;
        int isde;
        int jc;
        int jd;
        int jr;
        int k;
        int kbeg;
        int kend;
        int klen;
        double alpha;
        double cl;
        double cr;
        double safmin;
        double sl;
        double sr;
        double sv1;
        double sv2;
        double temp;

        if (n <= 0) {
            return;
        }

        dlaset('F', n, n, 0.0, 0.0, A, lda);

        // Insure a correct iseed
        if ((iseed[3] % 2) != 1) {
            iseed[3] = iseed[3] + 1;
        }

        // Compute diagonal and subdiagonal according to itype, nz1, nz2, and
        // rcond
        if (itype != 0) {

            if (Math.abs(itype) >= 4) {
                kbeg = Math.max(1, Math.min(n, nz1 + 1));
                kend = Math.max(kbeg, Math.min(n, n - nz2));
                klen = kend + 1 - kbeg;
            } // if (Math.abs(itype) >= 4)
            else { // Math.abs(itype) < 4
                kbeg = 1;
                kend = n;
                klen = n;
            } // else Math.abs(itype) < 4

            isdb = 1;
            isde = 0;

            switch (Math.abs(itype)) {

                case 1: // Identity
                    for (jd = 0; jd < n; jd++) {
                        A[jd][jd] = 1.0;
                    }

                    break;

                case 2: // Transposed Jordan block
                    for (jd = 0; jd < (n - 1); jd++) {
                        A[jd + 1][jd] = 1.0;
                    }

                    isdb = 1;
                    isde = n - 1;
                    break;

                case 3: // Transposed Jordan block , followed by identity.
                    k = (n - 1) / 2;
                    for (jd = 0; jd < k; jd++) {
                        A[jd + 1][jd] = 1.0;
                    }

                    isdb = 1;
                    isde = k;
                    for (jd = k + 1; jd <= (2 * k); jd++) {
                        A[jd][jd] = 1.0;
                    }

                    break;

                case 4: // 1, ..., k
                    for (jd = kbeg; jd <= kend; jd++) {
                        A[jd - 1][jd - 1] = (double) (jd - nz1);
                    }

                    break;

                case 5: // One large D value
                    for (jd = kbeg; jd < kend; jd++) {
                        A[jd][jd] = rcond;
                    }

                    A[kbeg - 1][kbeg - 1] = 1.0;
                    break;

                case 6: // One small D value
                    for (jd = kbeg - 1; jd < (kend - 1); jd++) {
                        A[jd][jd] = 1.0;
                    }

                    A[kend - 1][kend - 1] = rcond;
                    break;

                case 7: // Exponentially distributed D values
                    A[kbeg - 1][kbeg - 1] = 1.0;
                    if (klen > 1) {
                        alpha = Math.pow(rcond, 1.0 / (klen - 1));

                        for (i = 2; i <= klen; i++) {
                            A[nz1 + i - 1][nz1 + i - 1] = Math.pow(alpha, (double) (i - 1));
                        }
                    } // if (klen > 1)

                    break;

                case 8: // Arithmetically distributed D values
                    A[kbeg - 1][kbeg - 1] = 1.0;
                    if (klen > 1) {
                        alpha = (1.0 - rcond) / (klen - 1);

                        for (i = 2; i <= klen; i++) {
                            A[nz1 + i - 1][nz1 + i - 1] = ((klen - i) * alpha) + rcond;
                        } // for (i = 2; i <= klen; i++)
                    } // if (klen > 1)

                    break;

                case 9: // Randomly distributed D values on (rcond, 1)
                    alpha = Math.log(rcond);
                    for (jd = kbeg - 1; jd < kend; jd++) {
                        A[jd][jd] = Math.exp(alpha * dlaran(iseed));
                    }

                    break;

                case 10: // Randomly distributed D values from dist
                    for (jd = kbeg - 1; jd < kend; jd++) {
                        A[jd][jd] = dlarnd(idist, iseed);
                    }

                    break;

                default:
            } // switch(Math.abs(itype))

            // Scale by amagn
            for (jd = kbeg - 1; jd < kend; jd++) {
                A[jd][jd] = amagn * A[jd][jd];
            }

            for (jd = isdb - 1; jd < isde; jd++) {
                A[jd + 1][jd] = amagn * A[jd + 1][jd];
            }

            // If isign = 1 or 2, assign random signs to diagonal and subdiagonal
            if (isign > 0) {

                for (jd = kbeg - 1; jd < kend; jd++) {

                    if (A[jd][jd] != 0.0) {

                        if (dlaran(iseed) > 0.5) {
                            A[jd][jd] = -A[jd][jd];
                        } // if (dlaran(iseed} > 0.5)
                    } // if (A[jd][jd] != 0.0)
                } // for (jd = kbeg-1; jd < kend; jd++)

                for (jd = isdb - 1; jd < isde; jd++) {

                    if (A[jd + 1][jd] != 0.0) {

                        if (dlaran(iseed) > 0.5) {
                            A[jd + 1][jd] = -A[jd + 1][jd];
                        } // if (dlaran(iseed) > 0.5)
                    } // if (A[jd+1][jd] != 0.0)
                } // for (jd = isdb-1; jd < isde; jd++)
            } // if (isign > 0)

            // Reverse if itype < 0
            if (itype < 0) {

                for (jd = kbeg; jd <= ((kbeg + kend - 1) / 2); jd++) {
                    temp = A[jd - 1][jd - 1];
                    A[jd - 1][jd - 1] = A[kbeg + kend - jd - 1][kbeg + kend - jd - 1];
                    A[kbeg + kend - jd - 1][kbeg + kend - jd - 1] = temp;
                } // for (jd = kbeg; jd <= (kbeg+kend-1)/2; jd++)

                for (jd = 1; jd <= ((n - 1) / 2); jd++) {
                    temp = A[jd][jd - 1];
                    A[jd][jd - 1] = A[n - jd][n - 1 - jd];
                    A[n - jd][n - 1 - jd] = temp;
                } // for (jd = 1; jd <= (n-1)/2; jd++)
            } // if (itype < 0)

            // If isign = 2 and no subdiagonals already, then apply random
            // rotations to make 2 by 2 blocks
            if ((isign == 2) && (itype != 2) && (itype != 3)) {
                safmin = dlamch('S');

                for (jd = kbeg - 1; jd < (kend - 1); jd += 2) {

                    if (dlaran(iseed) > 0.5) {

                        // Rotation on left
                        cl = (2.0 * dlaran(iseed)) - 1.0;
                        sl = (2.0 * dlaran(iseed)) - 1.0;
                        temp = 1.0 / Math.max(safmin, Math.sqrt((cl * cl) + (sl * sl)));
                        cl = cl * temp;
                        sl = sl * temp;

                        // Rotation on right
                        cr = (2.0 * dlaran(iseed)) - 1.0;
                        sr = (2.0 * dlaran(iseed)) - 1.0;
                        temp = 1.0 / Math.max(safmin, Math.sqrt((cr * cr) + (sr * sr)));
                        cr = cr * temp;
                        sr = sr * temp;

                        // Apply
                        sv1 = A[jd][jd];
                        sv2 = A[jd + 1][jd + 1];
                        A[jd][jd] = (cl * cr * sv1) + (sl * sr * sv2);
                        A[jd + 1][jd] = (-sl * cr * sv1) + (cl * sr * sv2);
                        A[jd][jd + 1] = (-cl * sr * sv1) + (sl * cr * sv2);
                        A[jd + 1][jd + 1] = (sl * sr * sv1) + (cl * cr * sv2);
                    } // if (dlaran(iseed) > 0.5)
                } // for (jd = kbeg-1; jd < kend-1; jd += 2)
            } // if ((isign == 2) && (itype != 2) && (itype != 3))
        } // if (itype != 0)

        // Fill in upper triangle (except for 2 by 2 blocks)
        if (triang != 0.0) {

            if ((isign != 2) || (itype == 2) || (itype == 3)) {
                ioff = 1;
            } // if ((isign != 2) || (itype == 2) || (itype == 3))
            else {
                ioff = 2;

                for (jr = 0; jr < (n - 1); jr++) {

                    if (A[jr + 1][jr] == 0.0) {
                        A[jr][jr + 1] = triang * dlarnd(idist, iseed);
                    } // if (A[jr+1][jr] == 0.0)
                } // for (jr = 0; jr < n-1; jr++)
            } // else

            for (jc = 1; jc < n; jc++) {

                for (jr = 0; jr <= (jc - ioff); jr++) {
                    A[jr][jc] = triang * dlarnd(idist, iseed);
                }
            } // for (jc = 1; jc < n; jc++)
        } // if (triang != 0.0)

        return;
    } // dlatm4


    /**
     * This is a port of version 3.1 LAPACK test routine DLATMR Original DLATMR created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dlatmr generates random matrices of various types for testing LAPACK programs. dlatmr operates by applying the
     * following sequence of operations: 1.) Generate a matrix A with random entries of distribution dist which is
     * symmetric if sym = 'S' and nonsymmetric if sym = 'N'. 2.) Set the diagonal to D, where D may be input or computed
     * according to mode, cond, dmax, and rsign as described below. 3.) Grade the matrix, if desired, from the left
     * and/or right as specified by grade. The inputs dl, model, condl, dr, moder, and condr also determine the grading
     * as described below. 4.) Permute, if desired, the rows and/or columns as specified by pivtng and ipivot. 5.) Set
     * random entries to zero, if desired, to get a random sparse matrix as specified by sparse. 6.) Make A a band
     * matrix, if desired, by zeroing out the matrix outside a band of lower bandwidth kl and upper bandwidth ku. 7.)
     * Scale A, if desired, to have maximum entry anorm 8.) Pack the matrix if desired. Options specified by pack are:
     * no packing, zero out upper half (if symmetric), zero out lower half (if symmetric), store the upper half columnwise
     * (if symmetric or square upper triangular), store the lower half columnwise (if symmetric or square lower
     * triangular), same as upper half rowwise if symmetric, store the lower triangle in banded format (if symmetric),
     * store the upper triangle if banded format (if symmetric), and store the entire matrix in banded format
     *
     * <p>Note: If two calls to dlatmr differ only in the pack parameter, they will generate mathematically equivalent
     * matrices.</p>
     *
     * <p>If two calls to dlatmr both have full bandwidth (kl = m-1 and ku = n-1), and differ only in the pivtng and
     * pack parameters, then the matrices generated will differ only in the order of the rows and/or columns, and
     * otherwise contain the same data. This consistency cannot be and is not maintained with less than full bandwidth.
     * </p>
     *
     * @param  m       input int Number of rows of A.
     * @param  n       input int Number of columns of A.
     * @param  dist    input char On entry, dist specifies the type of distribution to be used to generate a random
     *                 matrix. 
     *                 'U' => uniform(0,1) ('U' for uniform) 
     *                 'S' => uniform(-1,1) ('S' for symmetric) 
     *                 'N' => normal(0,1) ('N' for normal)
     * @param  iseed   input/output int[] of dimension 4 On entry iseed specifies the seed of the random number
     *                 generator. They should lie between 0 and 4095 inclusive, and iseed[3] should be odd. The random
     *                 number generator uses a linear congruential sequence limited to small integers, and so should
     *                 produce machine independent random numbers. The values of iseed are changed on exit, and can be
     *                 used in the next call to dlatmr to continue the same random number sequence.
     * @param  sym     input char 
     *                 If sym = 'S' or 'H', generated matrix is symmetric. 
     *                 If sym = 'N', generated matrix is nonsymmetric.
     * @param  D       (input/output) double[] of dimension (min(m,n)) On entry this array specifies the diagonal
     *                 entries of the diagonal of A. D may either be specified on entry, or set according to mode and
     *                 cond as described below. May be changed on exit if mode is nonzero.
     * @param  mode    input int On entry describes how D is to be used: 
     *                 = 0 means use D as input 
     *                 = 1 sets D[0] = 1 and D[1:n-1] = 1.0/cond 
     *                 = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond 
     *                 = 3 sets D[i] = cond**(-(i)/(n-1)) 
     *                 = 4 sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) 
     *                 = 5 sets D to random numbers in the range (1/cond, 1) such that their logarithms are uniformly distributed.
     *                 = 6 sets D to random numbers from the same distribution as the rest of the matrix. 
     *                 < 0 has the same meaning as abs(mode), except that the order of the elements of D is reversed.
     *                    Thus, if mode is positive, D has entries ranging from 1 to 1/cond, and if negative, from 1/cond to 1.
     * @param  cond    input double On entry, used as described under mode above. If used, it must be >= 1.
     * @param  dmax    input double If mode is neither -6, 0, nor 6, the diagonal is scaled by dmax/max(abs(D[i])), so
     *                 that maximum absolute entry of diagonal is abs(dmax). If dmax is negative (or zero), diagonal
     *                 will be scaled by a negative number (or zero).
     * @param  rsign   input char If mode is neither -6, 0, nor 6, specifies sign of diagonal as follows: 
     *                 'T' => diagonal entries are multiplied by 1 or -1 with probability 0.5. 
     *                 'F' => diagonal unchanged
     * @param  grade   input char Specifies grading of matrix as follows: 
     *                 'N' => no grading 
     *                 'L' => matrix premultiplied by diag(dl) (only if matrix nonsymmetric) 
     *                 'R' => matrix postmultiplied by diag(dr) (only if matrix nonsymmetric) 
     *                 'B' => matrix premultiplied by diag(dl) and postmultiplied by diag(dr) (only if matrix nonsymmetric)
     *                 'S' or 'H' => matrix premultiplied by diag(dl) and postmultiplied by diag(dl) 
     *                              ('S' for symmetric, or 'H' for Hermitian)
     *                 'E' => matrix premultiplied for diag(dl) and postmultiplied by inv(diag(dl))
     *                        ( 'E' for eigenvalue invariance) (only if matrix nonsymmetric)
     *                        Note: If grade = 'E', then m must equal n.
     * @param  dl      input/output double[] of dimension m If model = 0, then on entry this array specifies the
     *                 diagonal entries of a diagonal matrix used as described under grade above. If model is not zero,
     *                 then dl will be set according to model and condl, analagous to the way D is set according to mode
     *                 and cond (except that there is no dmax parameter for dl). If grade = 'E', then dl cannot have
     *                 zero entries. Not referenced if grade = 'N' or 'R'.
     * @param  model   input int This specifies how the diagonal array dl is to be computed, just as mode specifies how
     *                 D is to be computed.
     * @param  condl   input double When model is not zero, this specifies the condition number of the computed dl.
     * @param  dr      input/output double[] of dimension n. If moder = 0, then on entry this array specifies the
     *                 diaognal entries of a diagonal matrix used as described under grade above. If moder is not zero,
     *                 then dr will be set according to moder and condr, analagous to the way D is set according to mode
     *                 and cond (except that there is no dmax parameter for dr). Not referenced if grade = 'N', 'L',
     *                 'H', 'S', or 'E'.
     * @param  moder   input int This specifies how the diagonal array dr is to be computed, just as mode specifies how
     *                 D is to be computed.
     * @param  condr   input double While moder is not zero, this specifies the condition number of the computed dr.
     * @param  pivtng  input char On entry specifies the pivoting permutations as follows:
     *                 'N' or ' ' => none 
     *                 'L' => left or row pivoting (matrix must be nonsymmetric). 
     *                 'R' => right or column pivoting (matrix must be nonsymmetric). 
     *                 'B' or 'F' => both or full pivoting, i.e., on both sides. In this case, m must equal n.]
     *                 
     *                 If two calls to dlatmr both have full bandwidth (kl = m-1 and ku = n-1), and differ only
     *                 in the pivtng and pack parameters, then the matrices generated will differ only in the order of
     *                 the rows and/or the columns, and otherwise contain the same data. This consistency cannot be
     *                 maintained with less than full bandwidth.
     * @param  ipivot  input int[] of dimension m or n. This array specifies the permutation used. After the basic
     *                 matrix is generated, the rows, columns, or both are permuted. If, say, row pivoting is selected,
     *                 dlatmr starts with the *last* row and interchanges the m-th and ipivot(m)-th rows, then moves to
     *                 the next-to-last row, interchanging the (m-1)-th and the ipivot(m-1)-th rows, and so on. In terms
     *                 of "2-cycles", the permutation is (1 ipivot[0]) (2 ipivot[1]) ... (m ipivot[m-1]) where the
     *                 rightmost cycle is applied first. This is the *inverse* of the effect of pivoting in LINPACK. The
     *                 idea is that factoring (with pivoting) an identity matrix which has been inverse-pivoted in this
     *                 way should result in a pivot vector identical to ipivot. Not referenced if pivtng = 'N'.
     * @param  kl      input int On entry, specifies the lower bandwidth of the matrix. For example, kl = 0 implies
     *                 upper triangular, kl = 1 implies upper Hessenberg, and kl at least m-1 implies the matrix is
     *                 not banded. Must equal ku if matrix is symmetric.
     * @param  ku      input int On entry specifies the upper bandwidth of the matrix. For example, ku = 0 implies lower
     *                 triangular, ku = 1 implies lower Hessenberg, and ku at least n-1 implies the matrix is not
     *                 banded. Must equal kl if the matrix is symmetric.
     * @param  sparse  input double On entry specifies the sparsity of the matrix if a sparse matrix is to be generated.
     *                 sparse should lie between 0 and 1. To generate a sparse matrix, for each matrix entry a uniform
     *                 (0,1) random number x is generated and compared to sparse; if x is larger the matrix entry is
     *                 unchanged and if x is smaller the entry is set to zero. Thus on average a fraction sparse of the
     *                 entries will be set to zero.
     * @param  anorm   input double On entry specifies the maximum entry of output matrix (output matrix will be
     *                 multiplied by a constant so that its largest absolute entry equals anorm) if anorm is
     *                 nonnegative. If anorm is negative, no scaling is done.
     * @param  pack    input char On entry specifies packing of matrix as follows: 
     *                 'N' => no packing 
     *                 'U' => zero out all subdiagonal entries (if symmetric) 
     *                 'L' => zero out all superdiagonal entries (if symmetric) 
     *                 'C' => store the upper triangle columnwise (only if matrix symmetric or square upper triangular) 
     *                 'R' => store the lower triangle columnwise (only if matrix symmetric or square lower triangular)
     *                       (same as upper half rowwise if symmetric)
     *                 'B' => store the lower triangle in band storage scheme (only if matrix symmetric)
     *                 'Q' => store the upper triangle in band storage scheme (only if matrix symmetric) 
     *                 'Z' => store the entire matrix in band storage scheme (pivoting can be provided for by
     *                        using this option to store A in the trailing rows of the allocated storage)
     *                        
     *                 Using these options, the various LAPACK packed and banded storage schemes can be obtained: 
     *                 GB - use 'Z' 
     *                 PB, SB, or TB - use 'B' or 'Q' 
     *                 PP, SP, or TP - use 'C' or 'R' 
     *                 
     *                 If two calls to dlatmr differ only in the pack parameter, they will generate mathematically
     *                 equivalent matrices.
     * @param  A       output double[][] of dimension (lda, n) On exit A is the desired test matrix. Only those entries
     *                 of A which are significant on output will be referenced (even if A is in packed or band storage
     *                 format). The 'unoccupied corners' of A in band format will be zeroed out.
     * @param  lda     input int On entry lda specifies the first dimension of A as declared in the calling program. 
     *                 If pack = 'N', 'U', or 'L', lda must be at least max(1,m). 
     *                 If pack = 'C' or 'R', lda must be at least 1. 
     *                 If pack = 'B' or 'Q', lda must be at least min (ku+1,n).
     *                 If pack = 'Z', lda must be at least kuu+kll+1, where kuu = min(ku,n-1) and kll = min(kl,n-1).
     * @param  iwork   workspace int[] of dimension m or n Not referenced if pivtng = 'N'.
     * @param  info    output int[] Error parameter on exit: 
     *                 0 => normal return 
     *                 -1 => m negative or unequal to n and sym = 'S' or 'H' 
     *                 -2 => n negative 
     *                 -3 => dist illegal string 
     *                 -5 => sym illegal string 
     *                 -7 => mode not in range -6 to 6 
     *                 -8 => cond less than 1.0, and mode neither -6, 0, nor 6 
     *                 -10 => mode neither -6, 0, nor 6 and rsign illegal string 
     *                 -11 => grade illegal string, or grade = 'E' and m not equal to
     *                        n, or grade = 'L', 'R', 'B', or 'E', and sym = 'S' or 'H'
     *                 -12 => grade = 'E' and dl contains zero
     *                 -13 => model not in range -6 to 6 and grade = 'L', 'B', 'H', 'S', or 'E'
     *                 -14 => condl less than 1.0, grade = 'L', 'B', 'H', 'S', or 'E', and model neither -6, 0, nor 6. 
     *                 -16 => moder not in range -6 to 6 and grade = 'R' or 'B' 
     *                 -17 => condr less than 1.0, grade = 'R' or 'B', and moder neither -6, 0, nor 6. 
     *                 -18 => pivtng illegal string, or pivtng = 'B' or 'F' and m not equal to n, or
     *                        pivtng = 'L' or 'R' and sym = 'S' or 'H'. 
     *                 -19 => ipivot contains out of range number and pivtng not equal to 'N' 
     *                 -20 => kl negative 
     *                 -21 => ku negative, or sym = 'S' or 'H' and ku not equal to kl 
     *                 -22 => sparse not in range 0 to 1. 
     *                 -24 => pack illegal string, or pack = 'U', 'L', 'B', or 'Q' and sym = 'N', 
     *                        or pack = 'C' and sym = 'N' and either kl not equal to 0 or n not equal to m, or
     *                        pack = 'R' and sym = 'N', and either ku not equal to 0 or n not equal to m. 
     *                 -26 => lda too small
     *                 1 => Error return from dlatm1 (computing D) 
     *                 2 => Cannot scale diagonal to dmax (max. entry is 0)
     *                 3 => Error return from dlatm1 (computing dl) 
     *                 4 => Error return form dlatm1 (computing dr) 
     *                 5 => anorm is positive, but matrix, constructed prior to attempting to scale it to have
     *                      norm anorm, is zero.
     */
    private void dlatmr(int m, int n, char dist, int[] iseed, char sym, double[] D, int mode, double cond, double dmax,
                        char rsign, char grade, double[] dl, int model, double condl, double[] dr, int moder,
                        double condr, char pivtng, int[] ipivot, int kl, int ku, double sparse, double anorm, char pack,
                        double[][] A, int lda, int[] iwork, int[] info) {
        boolean badpvt;
        boolean dzero;
        boolean fulbnd;
        int i;
        int idist;
        int igrade;
        int iisub;
        int ipack;
        int ipvtng;
        int irsign;
        int[] isub = new int[1];
        int isym;
        int j;
        int jjsub;
        int[] jsub = new int[1];
        int k;
        int kll;
        int kuu;
        int mnmin;
        int mnsub;
        int mxsub;
        int npvts = 0;
        double alpha;
        double onorm = 0.0;
        double temp;
        double[] tempa = new double[1];
        double[] ap = null;

        // Decode and test the input parameters.  Initialize flags & seed.
        info[0] = 0;

        // Quick return if possible
        if ((m == 0) || (n == 0)) {
            return;
        }

        // Decode dist
        if ((dist == 'U') || (dist == 'u')) {
            idist = 1;
        } else if ((dist == 'S') || (dist == 's')) {
            idist = 2;
        } else if ((dist == 'N') || (dist == 'n')) {
            idist = 3;
        } else {
            idist = -1;
        }

        // Decode sym
        if ((sym == 'S') || (sym == 's')) {
            isym = 0;
        } else if ((sym == 'N') || (sym == 'n')) {
            isym = 1;
        } else if ((sym == 'H') || (sym == 'h')) {
            isym = 0;
        } else {
            isym = -1;
        }

        // Decode rsign
        if ((rsign == 'F') || (rsign == 'f')) {
            irsign = 0;
        } else if ((rsign == 'T') || (rsign == 't')) {
            irsign = 1;
        } else {
            irsign = -1;
        }

        // Decode pivtng
        if ((pivtng == 'N') || (pivtng == 'n')) {
            ipvtng = 0;
        } else if (pivtng == ' ') {
            ipvtng = 0;
        } else if ((pivtng == 'L') || (pivtng == 'l')) {
            ipvtng = 1;
            npvts = m;
        } else if ((pivtng == 'R') || (pivtng == 'r')) {
            ipvtng = 2;
            npvts = n;
        } else if ((pivtng == 'B') || (pivtng == 'b')) {
            ipvtng = 3;
            npvts = Math.min(n, m);
        } else if ((pivtng == 'F') || (pivtng == 'f')) {
            ipvtng = 3;
            npvts = Math.min(n, m);
        } else {
            ipvtng = -1;
        }

        // Decode grade
        if ((grade == 'N') || (grade == 'n')) {
            igrade = 0;
        } else if ((grade == 'L') || (grade == 'l')) {
            igrade = 1;
        } else if ((grade == 'R') || (grade == 'r')) {
            igrade = 2;
        } else if ((grade == 'B') || (grade == 'b')) {
            igrade = 3;
        } else if ((grade == 'E') || (grade == 'e')) {
            igrade = 4;
        } else if ((grade == 'H') || (grade == 'h') || (grade == 'S') || (grade == 's')) {
            igrade = 5;
        } else {
            igrade = -1;
        }

        // Decode pack
        if ((pack == 'N') || (pack == 'n')) {
            ipack = 0;
        } else if ((pack == 'U') || (pack == 'u')) {
            ipack = 1;
        } else if ((pack == 'L') || (pack == 'l')) {
            ipack = 2;
        } else if ((pack == 'C') || (pack == 'c')) {
            ipack = 3;
        } else if ((pack == 'R') || (pack == 'r')) {
            ipack = 4;
        } else if ((pack == 'B') || (pack == 'b')) {
            ipack = 5;
        } else if ((pack == 'Q') || (pack == 'q')) {
            ipack = 6;
        } else if ((pack == 'Z') || (pack == 'z')) {
            ipack = 7;
        } else {
            ipack = -1;
        }

        // Set certain internal parameters
        mnmin = Math.min(m, n);
        kll = Math.min(kl, m - 1);
        kuu = Math.min(ku, n - 1);

        // If inv(dl) is used, check to see if dl has a zero entry.
        dzero = false;

        if ((igrade == 4) && (model == 0)) {

            for (i = 0; i < m; i++) {

                if (dl[i] == 0.0) {
                    dzero = true;
                }
            }
        } // if ((igrade == 4) && (model == 0))

        // Check values in ipivot
        badpvt = false;

        if (ipvtng > 0) {

            for (j = 0; j < npvts; j++) {

                if ((ipivot[j] <= 0) || (ipivot[j] > npvts)) {
                    badpvt = true;
                }
            }
        } // if (ipvtng > 0)

        // Set info if an error
        if (m < 0) {
            info[0] = -1;
        } else if ((m != n) && (isym == 0)) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (idist == -1) {
            info[0] = -3;
        } else if (isym == -1) {
            info[0] = -5;
        } else if ((mode < -6) || (mode > 6)) {
            info[0] = -7;
        } else if ((mode != -6) && (mode != 0) && (mode != 6) && (cond < 1.0)) {
            info[0] = -8;
        } else if ((mode != -6) && (mode != 0) && (mode != 6) && (irsign == -1)) {
            info[0] = -10;
        } else if ((igrade == -1) || ((igrade == 4) && (m != n)) || (((igrade >= 1) && (igrade <= 4)) && (isym == 0))) {
            info[0] = -11;
        } else if ((igrade == 4) && dzero) {
            info[0] = -12;
        } else if (((igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5)) &&
                       ((model < -6) || (model > 6))) {
            info[0] = -13;
        } else if (((igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5)) && (model != -6) &&
                       (model != 0) && (model != 6) && (condl < 1.0)) {
            info[0] = -14;
        } else if (((igrade == 2) || (igrade == 3)) && ((moder < -6) || (moder > 6))) {
            info[0] = -16;
        } else if (((igrade == 2) || (igrade == 3)) &&
                       ((moder != -6) && (moder != 0) && (moder != 6) && (condr < 1.0))) {
            info[0] = -17;
        } else if ((ipvtng == -1) || ((ipvtng == 3) && (m != n)) || (((ipvtng == 1) || (ipvtng == 2)) && (isym == 0))) {
            info[0] = -18;
        } else if ((ipvtng != 0) && badpvt) {
            info[0] = -19;
        } else if (kl < 0) {
            info[0] = -20;
        } else if ((ku < 0) || ((isym == 0) && (kl != ku))) {
            info[0] = -21;
        } else if ((sparse < 0.0) || (sparse > 1.0)) {
            info[0] = -22;
        } else if ((ipack == -1) || (((ipack == 1) || (ipack == 2) || (ipack == 5) || (ipack == 6)) && (isym == 1)) ||
                       ((ipack == 3) && (isym == 1) && ((kl != 0) || (m != n))) ||
                       ((ipack == 4) && (isym == 1) && ((ku != 0) || (m != n)))) {
            info[0] = -24;
        } else if ((((ipack == 0) || (ipack == 1) || (ipack == 2)) && (lda < Math.max(1, m))) ||
                       (((ipack == 3) || (ipack == 4)) && (lda < 1)) ||
                       (((ipack == 5) || (ipack == 6)) && (lda < (kuu + 1))) ||
                       ((ipack == 7) && (lda < (kll + kuu + 1)))) {
            info[0] = -26;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dlamtr had info[0] = " + info[0]);

            return;
        }

        // Decide if we can pivot consistently
        fulbnd = false;

        if ((kuu == (n - 1)) && (kll == (m - 1))) {
            fulbnd = true;
        }

        // Initialize random number generator
        for (i = 0; i < 4; i++) {
            iseed[i] = Math.abs(iseed[i]) % 4096;
        }

        iseed[3] = (2 * (iseed[3] / 2)) + 1;

        // Set up D, dl, and dr, if indicated
        // Compute D according to cond and mode
        dlatm1(mode, cond, irsign, idist, iseed, D, mnmin, info);

        if (info[0] != 0) {
            info[0] = 1;

            return;
        }

        if ((mode != 0) && (mode != -6) && (mode != 6)) {

            // Scale by dmax
            temp = Math.abs(D[0]);

            for (i = 1; i < mnmin; i++) {
                temp = Math.max(temp, Math.abs(D[i]));
            }

            if ((temp == 0.0) && (dmax != 0.0)) {
                info[0] = 2;

                return;
            }

            if (temp != 0.0) {
                alpha = dmax / temp;
            } else {
                alpha = 1.0;
            }

            for (i = 0; i < mnmin; i++) {
                D[i] = alpha * D[i];
            }
        } // if ((mode != 0) && (mode != -6) && (mode != 6))

        // Compute dl if grading set
        if ((igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5)) {
            dlatm1(model, condl, 0, idist, iseed, dl, m, info);

            if (info[0] != 0) {
                info[0] = 3;

                return;
            }
        } // if ((igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5))

        // Compute dr if grading set
        if ((igrade == 2) || (igrade == 3)) {
            dlatm1(moder, condr, 0, idist, iseed, dr, n, info);

            if (info[0] != 0) {
                info[0] = 4;

                return;
            }
        } // if ((igrade == 2) || (igrade == 3))

        // Generate iwork if pivoting
        if (ipvtng > 0) {

            for (i = 1; i <= npvts; i++) {
                iwork[i - 1] = i;
            }

            if (fulbnd) {

                for (i = 1; i <= npvts; i++) {
                    k = ipivot[i - 1];
                    j = iwork[i - 1];
                    iwork[i - 1] = iwork[k - 1];
                    iwork[k - 1] = j;
                }
            } else {

                for (i = npvts; i >= 1; i--) {
                    k = ipivot[i - 1];
                    j = iwork[i - 1];
                    iwork[i - 1] = iwork[k - 1];
                    iwork[k - 1] = j;
                }
            }
        } // if (ipvtng > 0)

        // Generate matrices for each kind of packing.  Always sweep matrix
        // columnwise (if symmetric, upper half only) so that matrix generated
        // does not depend on pack.

        if (fulbnd) {

            // Use dlatm3 so matrices generated with differing pivoting only
            // differ only in the order of their rows and/or columns
            if (ipack == 0) {

                if (isym == 0) {

                    for (j = 1; j <= n; j++) {

                        for (i = 1; i <= j; i++) {
                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                          iwork, sparse);
                            A[isub[0] - 1][jsub[0] - 1] = temp;
                            A[jsub[0] - 1][isub[0] - 1] = temp;
                        }
                    }
                } // if (isym == 0)
                else if (isym == 1) {

                    for (j = 1; j <= n; j++) {

                        for (i = 1; i <= m; i++) {
                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                          iwork, sparse);
                            A[isub[0] - 1][jsub[0] - 1] = temp;
                        }
                    }
                } // else if (isym == 1)
            } // if (ipack == 0)
            else if (ipack == 1) {

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                      sparse);
                        mnsub = Math.min(isub[0], jsub[0]);
                        mxsub = Math.max(isub[0], jsub[0]);
                        A[mnsub - 1][mxsub - 1] = temp;

                        if (mnsub != mxsub) {
                            A[mxsub - 1][mnsub - 1] = 0.0;
                        }
                    }
                }
            } // else if (ipack == 1)
            else if (ipack == 2) {

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                      sparse);
                        mnsub = Math.min(isub[0], jsub[0]);
                        mxsub = Math.max(isub[0], jsub[0]);
                        A[mxsub - 1][mnsub - 1] = temp;

                        if (mnsub != mxsub) {
                            A[mnsub - 1][mxsub - 1] = 0.0;
                        }
                    }
                }
            } // else if (ipack == 2)
            else if (ipack == 3) {
                ap = new double[n * (n + 1) / 2];

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                      sparse);

                        // Compute k = location of (isub,jsub) entry in
                        // packed array
                        mnsub = Math.min(isub[0], jsub[0]);
                        mxsub = Math.max(isub[0], jsub[0]);
                        k = (mxsub * (mxsub - 1) / 2) + mnsub;

                        // Convert k to (iisub,jjsub) location
                        jjsub = ((k - 1) / lda) + 1;
                        iisub = k - (lda * (jjsub - 1));
                        A[iisub - 1][jjsub - 1] = temp;
                        ap[k - 1] = temp;
                    }
                }
            } // else if (ipack == 3)
            else if (ipack == 4) {
                ap = new double[n * (n + 1) / 2];

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                      sparse);

                        // Compute k = location of (isub,jsub) entry in
                        // packed array
                        mnsub = Math.min(isub[0], jsub[0]);
                        mxsub = Math.max(isub[0], jsub[0]);

                        if (mnsub == 1) {
                            k = mxsub;
                        } else {
                            k = (n * (n + 1) / 2) - ((n - mnsub + 1) * (n - mnsub + 2) / 2) + mxsub - mnsub + 1;
                        }

                        // Convert k to (iisub,jjsub) location
                        jjsub = ((k - 1) / lda) + 1;
                        iisub = k - (lda * (jjsub - 1));
                        A[iisub - 1][jjsub - 1] = temp;
                        ap[k - 1] = temp;
                    }
                }
            } // else if (ipack == 4)
            else if (ipack == 5) {

                for (j = 1; j <= n; j++) {

                    for (i = j - kuu; i <= j; i++) {

                        if (i < 1) {
                            A[j - i][i + n - 1] = 0.0;
                        } else {
                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                          iwork, sparse);
                            mnsub = Math.min(isub[0], jsub[0]);
                            mxsub = Math.max(isub[0], jsub[0]);
                            A[mxsub - mnsub][mnsub - 1] = temp;
                        }
                    }
                }
            } // else if (ipack == 5)
            else if (ipack == 6) {

                for (j = 1; j <= n; j++) {

                    for (i = j - kuu; i <= j; i++) {
                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                      sparse);
                        mnsub = Math.min(isub[0], jsub[0]);
                        mxsub = Math.max(isub[0], jsub[0]);
                        A[mnsub - mxsub + kuu][mxsub - 1] = temp;
                    }
                }
            } // else if (ipack == 6)
            else if (ipack == 7) {

                if (isym == 0) {

                    for (j = 1; j <= n; j++) {

                        for (i = j - kuu; i <= j; i++) {
                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                          iwork, sparse);
                            mnsub = Math.min(isub[0], jsub[0]);
                            mxsub = Math.max(isub[0], jsub[0]);
                            A[mnsub - mxsub + kuu][mxsub - 1] = temp;

                            if (i < 1) {
                                A[j - i + kuu][i + n - 1] = 0.0;
                            }

                            if ((i >= 1) && (mnsub != mxsub)) {
                                A[mxsub - mnsub + kuu][mnsub - 1] = temp;
                            }
                        }
                    }
                } // if (isym == 0)
                else if (isym == 1) {

                    for (j = 1; j <= n; j++) {

                        for (i = j - kuu; i <= (j + kll); i++) {
                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                          iwork, sparse);
                            A[isub[0] - jsub[0] + kuu][jsub[0] - 1] = temp;
                        }
                    }
                } // else if (isym == 1)
            } // else if (ipack == 7)
        } // if (fulbnd)
        else { // not fulbnd

            // Use dlatm2
            if (ipack == 0) {

                if (isym == 0) {

                    for (j = 1; j <= n; j++) {

                        for (i = 1; i <= j; i++) {
                            A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                                     sparse);
                            A[j - 1][i - 1] = A[i - 1][j - 1];
                        }
                    }
                } // if (isym == 0)
                else if (isym == 1) {

                    for (j = 1; j <= n; j++) {

                        for (i = 1; i <= m; i++) {
                            A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                                     sparse);
                        }
                    }
                } // else if (isym == 1)
            } // if (ipack == 0)
            else if (ipack == 1) {

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                                 sparse);

                        if (i != j) {
                            A[j - 1][i - 1] = 0.0;
                        }
                    }
                }
            } // else if (ipack == 1)
            else if (ipack == 2) {

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        A[j - 1][i - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                                 sparse);

                        if (i != j) {
                            A[i - 1][j - 1] = 0.0;
                        }
                    }
                }
            } // else if (ipack == 2)
            else if (ipack == 3) {
                ap = new double[n * (n + 1) / 2];
                isub[0] = 0;
                jsub[0] = 1;

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {
                        isub[0] = isub[0] + 1;

                        if (isub[0] > lda) {
                            isub[0] = 1;
                            jsub[0] = jsub[0] + 1;
                        }

                        A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
                                                             ipvtng, iwork, sparse);
                        k = isub[0] + (lda * (jsub[0] - 1));
                        ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
                    }
                }
            } // else if (ipack == 3)
            else if (ipack == 4) {
                ap = new double[n * (n + 1) / 2];

                if (isym == 0) {

                    for (j = 1; j <= n; j++) {

                        for (i = 1; i <= j; i++) {

                            // Compute k = location of (i,j) entry in packed
                            // array
                            if (i == 1) {
                                k = j;
                            } else {
                                k = (n * (n + 1) / 2) - ((n - i + 1) * (n - i + 2) / 2) + j - i + 1;
                            }

                            // Convert k to (isub,jsub) location
                            jsub[0] = ((k - 1) / lda) + 1;
                            isub[0] = k - (lda * (jsub[0] - 1));
                            A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
                                                                 ipvtng, iwork, sparse);
                            ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
                        }
                    }
                } // if (isym == 0)
                else { // isym != 0
                    isub[0] = 0;
                    jsub[0] = 1;

                    for (j = 1; j <= n; j++) {

                        for (i = j; i <= m; i++) {
                            isub[0] = isub[0] + 1;

                            if (isub[0] > lda) {
                                isub[0] = 1;
                                jsub[0] = jsub[0] + 1;
                            }

                            A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
                                                                 ipvtng, iwork, sparse);
                            k = isub[0] + (lda * (jsub[0] - 1));
                            ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
                        }
                    }
                } // else isym != 0
            } // else if (ipack == 4)
            else if (ipack == 5) {

                for (j = 1; j <= n; j++) {

                    for (i = j - kuu; i <= j; i++) {

                        if (i < 1) {
                            A[j - i][i + n - 1] = 0.0;
                        } else {
                            A[j - i][i - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
                                                     sparse);
                        }
                    }
                }
            } // else if (ipack == 5)
            else if (ipack == 6) {

                for (j = 1; j <= n; j++) {

                    for (i = j - kuu; i <= j; i++) {
                        A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                                       iwork, sparse);
                    }
                }
            } // else if (ipack == 6)
            else if (ipack == 7) {

                if (isym == 0) {

                    for (j = 1; j <= n; j++) {

                        for (i = j - kuu; i <= j; i++) {
                            A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                                           iwork, sparse);

                            if (i < 1) {
                                A[j - i + kuu][i + n - 1] = 0.0;
                            }

                            if ((i >= 1) && (i != j)) {
                                A[j - i + kuu][i - 1] = A[i - j + kuu][j - 1];
                            }
                        }
                    }
                } // if (isym == 0)
                else if (isym == 1) {

                    for (j = 1; j <= n; j++) {

                        for (i = j - kuu; i <= (j + kll); i++) {
                            A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
                                                           iwork, sparse);
                        }
                    }
                } // else if (isym == 1)
            } // else if (ipack == 7)
        } // else not fulbnd

        // Scaling the norm
        if (ipack == 0) {
            onorm = dlange('M', m, n, A, lda, tempa);
        } else if (ipack == 1) {
            onorm = dlansy('M', 'U', n, A, lda, tempa);
        } else if (ipack == 2) {
            onorm = dlansy('M', 'L', n, A, lda, tempa);
        } else if (ipack == 3) {
            onorm = dlansp('M', 'U', n, ap, tempa);
        } // else if (ipack == 3)
        else if (ipack == 4) {
            onorm = dlansp('M', 'L', n, ap, tempa);
        } // else if (ipack == 4)
        else if (ipack == 5) {
            onorm = dlansb('M', 'L', n, kll, A, lda, tempa);
        } // else if (ipack == 5)
        else if (ipack == 6) {
            onorm = dlansb('M', 'U', n, kuu, A, lda, tempa);
        } // else if (ipack == 6)
        else if (ipack == 7) {
            onorm = dlangb('M', n, kll, kuu, A, lda, tempa);
        } // else if (ipack == 7)

        if (anorm >= 0.0) {

            if ((anorm > 0.0) && (onorm == 0.0)) {

                // Desired scaling impossible
                info[0] = 5;

                return;
            } else if (((anorm > 1.0) && (onorm < 1.0)) || ((anorm < 1.0) && (onorm > 1.0))) {

                // Scale carefully to avoid over / underflow
                if (ipack <= 2) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < m; i++) {
                            A[i][j] = (1.0 / onorm) * A[i][j];
                            A[i][j] = anorm * A[i][j];
                        }
                    }
                } // if (ipack <= 2)
                else if ((ipack == 3) || (ipack == 4)) {

                    for (i = 0; i < (n * (n + 1) / 2); i++) {
                        ap[i] = (1.0 / onorm) * ap[i];
                        ap[i] = anorm * ap[i];
                    }
                } // else if ((ipack == 3) || (ipack == 4))
                else if (ipack >= 5) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < (kll + kuu + 1); i++) {
                            A[i][j] = (1.0 / onorm) * A[i][j];
                            A[i][j] = anorm * A[i][j];
                        }
                    }
                } // else if (ipack >= 5)
            } // else if (((anorm > 1.0) && (onorm < 1.0)) || ((anorm < 1.0) &&
            else {

                // Scale straightforwardly
                if (ipack <= 2) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < m; i++) {
                            A[i][j] = (anorm / onorm) * A[i][j];
                        }
                    }
                } // if (ipack <= 2)
                else if ((ipack == 3) || (ipack == 4)) {

                    for (i = 0; i < (n * (n + 1) / 2); i++) {
                        ap[i] = (anorm / onorm) * ap[i];
                    }
                } // else if ((ipack == 3) || (ipack == 4))
                else if (ipack >= 5) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < (kll + kuu + 1); i++) {
                            A[i][j] = (anorm / onorm) * A[i][j];
                        }
                    }
                } // else if (ipack >= 5)
            } // else
        } // if (anorm >= 0.0)

        if (ipack == 3) {
            isub[0] = 0;
            jsub[0] = 1;

            for (j = 1; j <= n; j++) {

                for (i = 1; i <= j; i++) {
                    isub[0] = isub[0] + 1;

                    if (isub[0] > lda) {
                        isub[0] = 1;
                        jsub[0] = jsub[0] + 1;
                    }

                    k = isub[0] + (lda * (jsub[0] - 1));
                    A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
                }
            }
        } // else if (ipack == 3)
        else if (ipack == 4) {

            if (isym == 0) {

                for (j = 1; j <= n; j++) {

                    for (i = 1; i <= j; i++) {

                        // Compute k = location of (i,j) entry in packed
                        // array
                        if (i == 1) {
                            k = j;
                        } else {
                            k = (n * (n + 1) / 2) - ((n - i + 1) * (n - i + 2) / 2) + j - i + 1;
                        }

                        // Convert k to (isub,jsub) location
                        jsub[0] = ((k - 1) / lda) + 1;
                        isub[0] = k - (lda * (jsub[0] - 1));
                        A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
                    }
                }
            } // if (isym == 0)
            else { // isym != 0
                isub[0] = 0;
                jsub[0] = 1;

                for (j = 1; j <= n; j++) {

                    for (i = j; i <= m; i++) {
                        isub[0] = isub[0] + 1;

                        if (isub[0] > lda) {
                            isub[0] = 1;
                            jsub[0] = jsub[0] + 1;
                        }

                        k = isub[0] + (lda * (jsub[0] - 1));
                        A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
                    }
                }
            } // else isym != 0
        } // else if (ipack == 4)
        return;
    } // dlatmr

    /**
     * This is a port of version 3.1 LAPACK test routine DLATMS Original DLATMS created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dlatms generates random matrices with specified singular values (or symmetric/hermitian with specified
     * eigenvalues) for testing LAPACK programs.
     *
     * <p>dlatms operates by applying the following sequence of operations:</p>
     *
     * <p>Set the diagonal to D, where D may be input or computed according to mode, cond, dmax, and sym as described
     * below.</p>
     *
     * <p>Generate a matrix with appropriate band structure, by one of two methods:</p>
     *
     * <p>Method A: Generate a dense m by n matrix by multiplying D on the left and the right by random unitary
     * matrices, then:</p>
     *
     * <p>Reduce the bandwidth according to kl and ku, using Householder transformations.</p>
     *
     * <p>Method B: Convert the bandwidth-0 (i.e., diagonal) matrix to a bandwidth-1 matrix using Givens rotations,
     * "chasing" out-of-band elements back, much as in QR; then convert the bandwidth-1 to a bandwidth-2 matrix, etc.
     * Note that for reasonably samll bandwidths (relative to m and n) this requires less storage, as a dense matrix is
     * not generated. Also, for symmetric matrices, only, one triangle is generated.</p>
     *
     * <p>Method A is chosen if the bandwidth is a large fraction of the order of the matrix, and lda is at least m (so
     * a dense matrix can be stored.) Method B is chosen if the bandwidth is small ( < 1/2 n for symmetric, < .3 n+m for
     * non-symmetric), or lda is less than m and not less than the bandwidth.</p>
     *
     * <p>Pack the matrix if desired. Options specified by pack are: no packing, zero out upper half (if symmetric), zero
     * out lower half (if symmetric), store the upper half columnwise (if symmetric or upper triangular), store the lower
     * half columnwise (if symmetric or lower triangular), store the lower triangle in banded format (if symmetric or
     * lower triangular), store the upper triangle in banded format (if symmetric or upper triangular), and store the entire
     * matrix in banded format If method B is chosen, and band format is specified, then the matrix will be generated in
     * the band format, so no repacking will be necessary.</p>
     *
     * @param  m      input int The number of rows of A.
     * @param  n      input int The number of columns of A.
     * @param  dist   input char On entry, dist specifies the type of distribution to be used to generate the random
     *                eigen-/singular values. 
     *                'U' => uniform(0,1) ('U' for uniform) 
     *                'S' => uniform(-1,1) ('S' for symmetric) 
     *                'N' => normal(0,1) ('N' for normal)
     * @param  iseed  input/output int[] of dimension 4 On entry iseed specifies the seed of the random number
     *                generator. They should lie between 0 and 4095 inclusive, and iseed[3] should be odd. The random
     *                number generator uses a linear congruential sequence limited to small integers, and so should
     *                produce machine independent random numbers. The values of iseed are changed on exit, and can be
     *                used in the next call to dlatms to continue the same random number sequence. Changed on exit.
     * @param  sym    input char 
     *                If sym = 'S' or 'H', the generated matrix is symmetric, with eigenvalues specified by
     *                D, cond, mode, and dmax; they may be positive, negative, or zero. 
     *                If sym = 'P', the generated matrix is symmetric, with eigenvalues (= singular values) specified
     *                by D, cond, mode, and dmax; they will not be negative. 
     *                If sym = 'N', the generated matrix is nonsymmetric, with singular values specified by D, cond,
     *                mode, and dmax; they will not be negative.
     * @param  D      input/output double[] of dimension (min(m,n)) This array is used to specify the singular values or
     *                eigenvalues of A (see sym, above.) If mode = 0, then D is assumed to contain the
     *                singular/eigenvalues, otherwise they will be computed according to mode, cond, and dmax, and
     *                placed in D. Modified if mode is nonzero.
     * @param  mode   input int On entry this describes how the singular/ eigenvalues are to be specified: 
     *                = 0 means use D as input 
     *                = 1 sets D[0] = 1 and D[1:n-1] = 1.0/cond 
     *                = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond 
     *                = 3 sets D[i] = cond**(-(i)/(n-1)) 
     *                = 4 sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) 
     *                = 5 sets D to random numbers in the range (1/cond, 1) such that their logarithms are
     *                    uniformly distributed 
     *                = 6 sets D to random numbers from same distribution as the rest of the matrix mode 
     *                < 0 has the same meaning as abs(mode), except that the order of the elements of D is reversed.
     *                    Thus, if mode is positive, D has entries ranging from 1 to 1/cond, if negative,
     *                    from 1/cond to 1.
     *                If sym = 'S' or 'H', and mode is neither 0, 6, nor -6, then the elements of D will also be
     *                multiplied by a random sign (1.e., +1 or -1).
     * @param  cond   input double On entry, this is used as described under mode above. If used, it must be >= 1.
     * @param  dmax   input double If mode is neither -6, 0, nor 6, the contents of D, as computed according to mode and
     *                cond, will be scaled by dmax/max(abs(D[i])); thus the maximum absolute eigen- or singular value
     *                (which is to say the norm) will be abs(dmax). Note that dmax need not be positive: if dmax is
     *                negative (or zero), D will be scaled by a negative number (or zero).
     * @param  kl     input int This specifies the lower bandwidth of the matrix. For example, kl = 0 implies upper
     *                triangular, kl = 1 implies upper Hessenberg, and kl being at least m-1 means that the matrix has
     *                full lower bandwidth. kl must equal ku if the matrix is symmetric.
     * @param  ku     input int This specifies the upper bandwidth of the matrix. For example, ku = 0 implies lower
     *                triangular, ku = 1 implies lower Hessenberg, and ku being at least n-1 means that the matrix has
     *                full upper bandwidth. kl must equal ku if the matrix is symmetric.
     * @param  pack   input char This specifies packing of the matrix as follows: 
     *                'N' => no packing 
     *                'U' => zero out all subdiagonal entries (if symmetric) 
     *                'L' => zero out all superdiagonal entries (if symmetric) 
     *                'C' => store the upper triangle columnwise (only if the matrix is symmetric or upper triangular) 
     *                'R' => store the lower triangle columnwise (only if the matrix is symmetric or lower triangular)
     *                'B' => store the lower triangle in band storage scheme (only if matrix symmetric or lower triangular) 
     *                'Q' => store the upper triangle in band storage scheme (only if matrix symmetric or upper triangular)
     *                'Z' => store the entire matrix in band storage scheme (pivoting can be provided for by using this
     *                option to store A in the trailing rows of the allocated storage) 
     *                
     *                Using these options, the various LAPACK packed and banded storage schemes can be obtained: 
     *                GB - use 'Z' 
     *                PB, SB, or TB - use 'B' or 'Q' 
     *                PP, SP, or TP - use 'C' or 'R' 
     *                If two calls to dlatms differ only in the pack parameter, they will generate mathematically
     *                equivalent matrices
     * @param  A      input/output double[][] of dimension (lda,n) On exit A is the desired test matrix. A is first
     *                generated in full (unpacked) form, and then packed, if so specified by pack. Thus, the first m
     *                elements of the first n columns will always be modified. If pack specifies a packed or banded
     *                storage scheme, all lda elements of the first n columns will be modified; the elements of the
     *                array which do not correspond to elements of the generated matrix are set to zero.
     * @param  lda    input int lda specifies the first dimension of A as declared in the calling program. If pack =
     *                'N', 'U', 'L', 'C', or 'R', then lda must be at least m. If pack = 'B' or 'Q', then lda must be at
     *                least min(kl,m-1) (which is equal to min(ku,n-1)). If pack = 'Z', lda must be large enough to hold
     *                the packed array: min(ku,n-1) + min(kl,m-1) + 1.
     * @param  work   workspace double[] of dimension (3*max(n,m))
     * @param  info   output int[] Error code.  On exit, info[0] will be set to one of the following values:
     *                0 => normal return 
     *                -1 => m negative or unequal to n and sym = 'S', 'H', or 'P' 
     *                -2 => n negative 
     *                -3 => dist illegal string
     *                -5 => sym illegal string 
     *                -7 => mode not in range -6 to 6 
     *                -8 => cond less than 1.0, and mode neither -6, 0, nor 6 
     *                -10 => kl negative 
     *                -11 => ku negative, or sym = 'S' or 'H' and ku not equal to kl 
     *                -12 => pack illegal string, or pack = 'U' or 'L', and sym = 'N'; or pack = 'C' or 'Q' and
     *                sym = 'N' and kl is not zero; or pack = 'R' or 'B' and sym = 'N' and ku is not zero; or pack =
     *                'U', 'L', 'C', 'R', 'B', or 'Q' and m != n. 
     *                -14 => lda is less than m, or pack = 'Z' and lda is less than min(ku,n-1) + min(kl,m-1) + 1. 
     *                1 => Error return from dlatm1 
     *                2 => Cannot scale to dmax (maximum singular value is 0) 
     *                3 => Error return from dlagge or dlagsy
     */
    private void dlatms(int m, int n, char dist, int[] iseed, char sym, double[] D, int mode, double cond, double dmax,
                        int kl, int ku, char pack, double[][] A, int lda, double[] work, int[] info) {
        boolean givens;
        boolean ilextr;
        boolean iltemp;
        boolean topdwn;
        int i;
        int ic;
        int icol = 0;
        int idist;
        int iendch;
        int[] iinfo = new int[1];
        int il;
        int ilda;
        int ioffg;
        int ioffst;
        int ipack;
        int ipackg;
        int ir;
        int ir1;
        int ir2;
        int irow = 0;
        int irsign = 0;
        int iskew;
        int isym;
        int isympk = 1;
        int j;
        int jc;
        int jch;
        int jkl;
        int jku;
        int jr;
        int k;
        int llb;
        int minlda;
        int mnmin;
        int mr;
        int nc;
        int uub;
        double alpha;
        double angle;
        double[] c = new double[1];
        double[] dummy = new double[1];
        double[] extra = new double[1];
        double[] s = new double[1];
        double[] temp = new double[1];
        int length;
        double[] ap;
        int index;

        // Decode and test the input parameters.  Initialize flags & seed.
        info[0] = 0;

        // Quick return if possible
        if ((m == 0) || (n == 0)) {
            return;
        }

        // Decode dist
        if ((dist == 'U') || (dist == 'u')) {
            idist = 1;
        } else if ((dist == 'S') || (dist == 's')) {
            idist = 2;
        } else if ((dist == 'N') || (dist == 'n')) {
            idist = 3;
        } else {
            idist = -1;
        }

        // Decode sym
        if ((sym == 'N') || (sym == 'n')) {
            isym = 1;
            irsign = 0;
        } else if ((sym == 'P') || (sym == 'p')) {
            isym = 2;
            irsign = 0;
        } else if ((sym == 'S') || (sym == 's')) {
            isym = 2;
            irsign = 1;
        } else if ((sym == 'H') || (sym == 'h')) {
            isym = 2;
            irsign = 1;
        } else {
            isym = -1;
        }

        // Decode pack
        if ((pack == 'N') || (pack == 'n')) {
            ipack = 0;
        } else if ((pack == 'U') || (pack == 'u')) {
            ipack = 1;
            isympk = 1;
        } else if ((pack == 'L') || (pack == 'l')) {
            ipack = 2;
            isympk = 1;
        } else if ((pack == 'C') || (pack == 'c')) {
            ipack = 3;
            isympk = 2;
        } else if ((pack == 'R') || (pack == 'r')) {
            ipack = 4;
            isympk = 3;
        } else if ((pack == 'B') || (pack == 'b')) {
            ipack = 5;
            isympk = 3;
        } else if ((pack == 'Q') || (pack == 'q')) {
            ipack = 6;
            isympk = 2;
        } else if ((pack == 'Z') || (pack == 'z')) {
            ipack = 7;
        } else {
            ipack = -1;
        }

        // Set certain internal parameters
        mnmin = Math.min(m, n);
        llb = Math.min(kl, m - 1);
        uub = Math.min(ku, n - 1);
        mr = Math.min(m, n + llb);
        nc = Math.min(n, m + uub);

        if ((ipack == 5) || (ipack == 6)) {
            minlda = uub + 1;
        } else if (ipack == 7) {
            minlda = llb + uub + 1;
        } else {
            minlda = m;
        }

        // Use Givens rotation method if bandwidth small enough, or if lda is
        // too small to store the matrix unpacked.

        givens = false;

        if (isym == 1) {

            if ((llb + uub) < (0.3 * Math.max(1, mr + nc))) {
                givens = true;
            }
        } // if (isym == 1)
        else if ((2 * llb) < m) {
            givens = true;
        }

        if ((lda < m) && (lda >= minlda)) {
            givens = true;
        }

        // Set info if an error
        if (m < 0) {
            info[0] = -1;
        } else if ((m != n) && (isym != 1)) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (idist == -1) {
            info[0] = -3;
        } else if (isym == -1) {
            info[0] = -5;
        } else if (Math.abs(mode) > 6) {
            info[0] = -7;
        } else if ((mode != 0) && (Math.abs(mode) != 6) && (cond < 1.0)) {
            info[0] = -8;
        } else if (kl < 0) {
            info[0] = -10;
        } else if ((ku < 0) || ((isym != 1) && (kl != ku))) {
            info[0] = -11;
        } else if ((ipack == -1) || ((isympk == 1) && (isym == 1)) || ((isympk == 2) && (isym == 1) && (kl > 0)) ||
                       ((isympk == 3) && (isym == 1) && (ku > 0)) || ((isympk != 0) && (m != n))) {
            info[0] = -12;
        } else if (lda < Math.max(1, minlda)) {
            info[0] = -14;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dlatms had info[0] = " + info[0]);

            return;
        }

        // Initialize random number generator
        for (i = 0; i < 4; i++) {
            iseed[i] = Math.abs(iseed[i]) % 4096;
        }

        if ((iseed[3] % 2) != 1) {
            iseed[3] = iseed[3] + 1;
        }

        // Setup D if indicated
        // Compute D according to cond and mode
        dlatm1(mode, cond, irsign, idist, iseed, D, mnmin, iinfo);

        if (iinfo[0] != 0) {
            info[0] = 1;

            return;
        }

        // Choose Top-Down if D is (apparently) increasing,
        // Bottom-Up if D is (apparently) decreasing
        if (Math.abs(D[0]) <= Math.abs(D[mnmin - 1])) {
            topdwn = true;
        } else {
            topdwn = false;
        }

        if ((mode != 0) && (Math.abs(mode) != 6)) {

            // Scale by dmax
            temp[0] = Math.abs(D[0]);

            for (i = 1; i < mnmin; i++) {
                temp[0] = Math.max(temp[0], Math.abs(D[i]));
            }

            if (temp[0] > 0.0) {
                alpha = dmax / temp[0];
            } else {
                info[0] = 2;

                return;
            }

            for (i = 0; i < mnmin; i++) {
                D[i] = alpha * D[i];
            }
        } // if ((mode != 0) && (Math.abs(mode) != 6))

        // Generate Banded Matrix using Givens rotations.
        // Also the special case of uub = llb = 0

        // Compute Addressing constants to cover all storage formats.  Whether
        // GE, SY, GB, or SB, upper or lower triangle or both, the (i,j)-th
        // element is in A[i - iskew*j + ioffst - 1][j - 1];

        if (ipack > 4) {
            ilda = lda - 1;
            iskew = 1;

            if (ipack > 5) {
                ioffst = uub + 1;
            } else {
                ioffst = 1;
            }
        } // if (ipack > 4)
        else { // ipack <= 4
            ilda = lda;
            iskew = 0;
            ioffst = 0;
        } // else ipack <= 4

        // ipackg is the format that the matrix is generated in.  If this is
        // different from ipack, then the matrix must be repacked at the end.
        // It also signals how to compute the norm, for scaling.
        ipackg = 0;
        dlaset('F', lda, n, 0.0, 0.0, A, lda);

        // Diagonal Matrix -- We are done, unless it is to be stored SP/PP/TP
        // (pack = 'R' or 'C')
        if ((llb == 0) && (uub == 0)) {

            if (ipack > 4) {

                for (i = 0; i < mnmin; i++) {
                    A[-iskew + ioffst][i] = D[i];
                }
            } // if (ipack > 4)
            else { // ipack <= 4

                for (i = 0; i < mnmin; i++) {
                    A[i - iskew + ioffst][i] = D[i];
                }
            } // else ipack <= 4

            if ((ipack <= 2) || (ipack >= 5)) {
                ipackg = ipack;
            }
        } // if ((llb == 0) && (uub == 0))
        else if (givens) {

            // Check whether to use Givens rotations, Householder
            // transformations, or nothing
            if (isym == 1) {

                // Non-symmetric -- A = U D V
                if (ipack > 4) {
                    ipackg = ipack;
                } else {
                    ipackg = 0;
                }

                if (ipack > 4) {

                    for (i = 0; i < mnmin; i++) {
                        A[-iskew + ioffst][i] = D[i];
                    }
                } // if (ipack > 4)
                else { // ipack <= 4

                    for (i = 0; i < mnmin; i++) {
                        A[i - iskew + ioffst][i] = D[i];
                    }
                } // else ipack <= 4

                if (topdwn) {
                    jkl = 0;

                    for (jku = 1; jku <= uub; jku++) {
                        // Transform from bandwidth jkl, jku-1 to jkl, jku
                        // Last row actually rotated is m-1
                        // Last column actually rotated is min(m+jku,n)-1

                        for (jr = 1; jr <= (Math.min(m + jku, n) + jkl - 1); jr++) {
                            extra[0] = 0.0;
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = Math.sin(angle);
                            icol = Math.max(1, jr - jkl);

                            if (jr < m) {
                                il = Math.min(n, jr + jku) + 1 - icol;
                                length = lda - (jr - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                ap = new double[length];
                                index = 0;

                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][icol - 1];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, jr > jkl, false, il, c[0], s[0], ap, ilda, extra, dummy);
                                index = 0;

                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    A[i][icol - 1] = ap[index++];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }
                            } // if (jr < m)

                            // Chase "extra" back up
                            ir = jr;
                            ic = icol;

                            for (jch = jr - jkl; jch >= 1; jch -= (jkl + jku)) {

                                if (ir < m) {
                                    dlartg(A[ir - (iskew * (ic + 1)) + ioffst][ic], extra[0], c, s, dummy);
                                } // if (ir < m)

                                irow = Math.max(1, jch - jku);
                                il = ir + 2 - irow;
                                temp[0] = 0.0;
                                iltemp = jch > jku;
                                length = lda - (irow - (iskew * ic) + ioffst) + 1 + (lda * (n - ic));
                                ap = new double[length];
                                index = 0;

                                for (i = irow - (iskew * ic) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][ic - 1];
                                }

                                for (j = ic; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, iltemp, true, il, c[0], -s[0], ap, ilda, temp, extra);
                                index = 0;

                                for (i = irow - (iskew * ic) + ioffst - 1; i < lda; i++) {
                                    A[i][ic - 1] = ap[index++];
                                }

                                for (j = ic; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                if (iltemp) {
                                    dlartg(A[irow - (iskew * (ic + 1)) + ioffst][ic], temp[0], c, s, dummy);
                                    icol = Math.max(1, jch - jku - jkl);
                                    il = ic + 2 - icol;
                                    extra[0] = 0.0;
                                    length = lda - (irow - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                    ap = new double[length];
                                    index = 0;

                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        ap[index++] = A[i][icol - 1];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            ap[index++] = A[i][j];
                                        }
                                    }

                                    dlarot(true, jch > (jku + jkl), true, il, c[0], -s[0], ap, ilda, extra, temp);
                                    index = 0;

                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        A[i][icol - 1] = ap[index++];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            A[i][j] = ap[index++];
                                        }
                                    }

                                    ic = icol;
                                    ir = irow;
                                } // if (iltemp)
                            } // for (jch = jr - jkl; jch >= 1; jch -= (jkl+jku))
                        } // for (jr = 1; jr <= Math.min(m+jku,n) + jkl - 1; jr++)
                    } // for (jku = 1; jku <= uub; jku++)

                    jku = uub;

                    for (jkl = 1; jkl <= llb; jkl++) {

                        // Transform from bandwidth jkl-1, jku to jkl, jku
                        for (jc = 1; jc <= (Math.min(n + jkl, m) + jku - 1); jc++) {
                            extra[0] = 0.0;
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = Math.sin(angle);
                            irow = Math.max(1, jc - jku);

                            if (jc < n) {
                                il = Math.min(m, jc + jkl) + 1 - irow;
                                length = lda - (irow - (iskew * jc) + ioffst) + 1 + (lda * (n - jc));
                                ap = new double[length];
                                index = 0;

                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][jc - 1];
                                }

                                for (j = jc; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, jc > jku, false, il, c[0], s[0], ap, ilda, extra, dummy);
                                index = 0;

                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
                                    A[i][jc - 1] = ap[index++];
                                }

                                for (j = jc; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }
                            } // if (jc < n)

                            // Chase "extra" back up
                            ic = jc;
                            ir = irow;

                            for (jch = jc - jku; jch >= 1; jch -= (jkl + jku)) {

                                if (ic < n) {
                                    dlartg(A[ir - (iskew * (ic + 1)) + ioffst][ic], extra[0], c, s, dummy);
                                } // if (ic < n)

                                icol = Math.max(1, jch - jkl);
                                il = ic + 2 - icol;
                                temp[0] = 0.0;
                                iltemp = jch > jkl;
                                length = lda - (ir - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                ap = new double[length];
                                index = 0;

                                for (i = ir - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][icol - 1];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, iltemp, true, il, c[0], -s[0], ap, ilda, temp, extra);
                                index = 0;

                                for (i = ir - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    A[i][icol - 1] = ap[index++];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                if (iltemp) {
                                    dlartg(A[ir - (iskew * (icol + 1)) + ioffst][icol], temp[0], c, s, dummy);
                                    irow = Math.max(1, jch - jkl - jku);
                                    il = ir + 2 - irow;
                                    extra[0] = 0.0;
                                    length = lda - (irow - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                    ap = new double[length];
                                    index = 0;

                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        ap[index++] = A[i][icol - 1];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            ap[index++] = A[i][j];
                                        }
                                    }

                                    dlarot(false, jch > (jkl + jku), true, il, c[0], -s[0], ap, ilda, extra, temp);
                                    index = 0;

                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        A[i][icol - 1] = ap[index++];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            A[i][j] = ap[index++];
                                        }
                                    }

                                    ic = icol;
                                    ir = irow;
                                } // if (iltemp)
                            } // for (jch = jc - jku; jch >= 1; jch -= (jkl+jku))
                        } // for (jc = 1; jc <= Math.min(n+jkl,m)+jku-1; jc++)
                    } // for (jkl = 1; jkl <= llb; jkl++)
                } // if (topdwn)
                else { // !topdwn

                    // Bottom-Up -- Start at the bottom right.
                    jkl = 0;

                    for (jku = 1; jku <= uub; jku++) {

                        // Transform from bandwidth jkl, jku-1 to jkl, jku
                        // First row actually rotated is m-1
                        // First column actually rotated is min(m+jku,n)-1
                        iendch = Math.min(m, n + jkl) - 1;

                        for (jc = Math.min(m + jku, n) - 1; jc >= (1 - jkl); jc--) {
                            extra[0] = 0.0;
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = Math.sin(angle);
                            irow = Math.max(1, jc - jku + 1);

                            if (jc > 0) {
                                il = Math.min(m, jc + jkl + 1) + 1 - irow;
                                length = lda - (irow - (iskew * jc) + ioffst) + 1 + (lda * (n - jc));
                                ap = new double[length];
                                index = 0;

                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][jc - 1];
                                }

                                for (j = jc; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, false, (jc + jkl) < m, il, c[0], s[0], ap, ilda, dummy, extra);
                                index = 0;

                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
                                    A[i][jc - 1] = ap[index++];
                                }

                                for (j = jc; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }
                            } // if (jc > 0)

                            // Chase "extra" back down
                            ic = jc;

                            for (jch = jc + jkl; jch <= iendch; jch += (jkl + jku)) {
                                ilextr = ic > 0;

                                if (ilextr) {
                                    dlartg(A[jch - (iskew * ic) + ioffst - 1][ic - 1], extra[0], c, s, dummy);
                                } // if (ilextr)

                                ic = Math.max(1, ic);
                                icol = Math.min(n - 1, jch + jku);
                                iltemp = (jch + jku) < n;
                                temp[0] = 0.0;
                                length = lda - (jch - (iskew * ic) + ioffst) + 1 + (lda * (n - ic));
                                ap = new double[length];
                                index = 0;

                                for (i = jch - (iskew * ic) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][ic - 1];
                                }

                                for (j = ic; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, ilextr, iltemp, icol + 2 - ic, c[0], s[0], ap, ilda, extra, temp);
                                index = 0;

                                for (i = jch - (iskew * ic) + ioffst - 1; i < lda; i++) {
                                    A[i][ic - 1] = ap[index++];
                                }

                                for (j = ic; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                if (iltemp) {
                                    dlartg(A[jch - (iskew * icol) + ioffst - 1][icol - 1], temp[0], c, s, dummy);
                                    il = Math.min(iendch, jch + jkl + jku) + 2 - jch;
                                    extra[0] = 0.0;
                                    length = lda - (jch - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                    ap = new double[length];
                                    index = 0;

                                    for (i = jch - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        ap[index++] = A[i][icol - 1];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            ap[index++] = A[i][j];
                                        }
                                    }

                                    dlarot(false, true, (jch + jkl + jku) <= iendch, il, c[0], s[0], ap, ilda, temp,
                                           extra);
                                    index = 0;

                                    for (i = jch - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                        A[i][icol - 1] = ap[index++];
                                    }

                                    for (j = icol; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            A[i][j] = ap[index++];
                                        }
                                    }

                                    ic = icol;
                                } // if (iltemp)
                            } // for (jch = jc+jkl; jch <= iendch; jch += (jkl+jku))
                        } // for (jc = Math.min(m+jku,n)-1; jc >= 1 - jkl; jc--)
                    } // for (jku = 1; jku <= uub; jku++)

                    jku = uub;

                    for (jkl = 1; jkl <= llb; jkl++) {

                        // Transform from bandwidth jkl-1, jku to jkl, jku
                        // First row actually rotated is min(n+jkl,m)-1
                        // First column actually rotated is n-1
                        iendch = Math.min(n, m + jku) - 1;

                        for (jr = Math.min(n + jkl, m) - 1; jr >= (1 - jku); jr--) {
                            extra[0] = 0.0;
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = Math.sin(angle);
                            icol = Math.max(1, jr - jkl + 1);

                            if (jr > 0) {
                                il = Math.min(n, jr + jku + 1) + 1 - icol;
                                length = lda - (jr - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
                                ap = new double[length];
                                index = 0;

                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][icol - 1];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, false, (jr + jku) < n, il, c[0], s[0], ap, ilda, dummy, extra);
                                index = 0;

                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
                                    A[i][icol - 1] = ap[index++];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }
                            } // if (jr > 0)

                            // Chase "extra" back down
                            ir = jr;

                            for (jch = jr + jku; jch <= iendch; jch += (jkl + jku)) {
                                ilextr = ir > 0;

                                if (ilextr) {
                                    dlartg(A[ir - (iskew * jch) + ioffst - 1][jch - 1], extra[0], c, s, dummy);
                                } // if (ilextr)

                                ir = Math.max(1, ir);
                                irow = Math.min(m - 1, jch + jkl);
                                iltemp = (jch + jkl) < m;
                                temp[0] = 0.0;
                                length = lda - (ir - (iskew * jch) + ioffst) + 1 + (lda * (n - jch));
                                ap = new double[length];
                                index = 0;

                                for (i = ir - (iskew * jch) + ioffst - 1; i < lda; i++) {
                                    ap[index++] = A[i][jch - 1];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, ilextr, iltemp, irow + 2 - ir, c[0], s[0], ap, ilda, extra, temp);
                                index = 0;

                                for (i = ir - (iskew * jch) + ioffst - 1; i < lda; i++) {
                                    A[i][jch - 1] = ap[index++];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                if (iltemp) {
                                    dlartg(A[irow - (iskew * jch) + ioffst - 1][jch - 1], temp[0], c, s, dummy);
                                    il = Math.min(iendch, jch + jkl + jku) + 2 - jch;
                                    extra[0] = 0.0;
                                    length = lda - (irow - (iskew * jch) + ioffst) + 1 + (lda * (n - jch));
                                    ap = new double[length];
                                    index = 0;

                                    for (i = irow - (iskew * jch) + ioffst - 1; i < lda; i++) {
                                        ap[index++] = A[i][jch - 1];
                                    }

                                    for (j = jch; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            ap[index++] = A[i][j];
                                        }
                                    }

                                    dlarot(true, true, (jch + jkl + jku) <= iendch, il, c[0], s[0], ap, ilda, temp,
                                           extra);
                                    index = 0;

                                    for (i = irow - (iskew * jch) + ioffst - 1; i < lda; i++) {
                                        A[i][jch - 1] = ap[index++];
                                    }

                                    for (j = jch; j < n; j++) {

                                        for (i = 0; i < lda; i++) {
                                            A[i][j] = ap[index++];
                                        }
                                    }

                                    ir = irow;
                                } // if (iltemp)
                            } // for (jch = jr + jku; jch <= iendch; jch += (jkl+jku))
                        } // for (jr = Math.min(n+jkl,m)-1; jr >= 1 - jku; jr--)
                    } // for (jkl = 1; jkl <= llb; jkl++)
                } // else !topdwn
            } // if (isym == 1)
            else { // isym != 1

                // Symmetric -- A = U D U'
                ipackg = ipack;
                ioffg = ioffst;

                if (topdwn) {

                    // Top-Down -- Generate Upper triangle only
                    if (ipack >= 5) {
                        ipackg = 6;
                        ioffg = uub + 1;
                    } else {
                        ipackg = 1;
                    }

                    if (ipack > 4) {

                        for (i = 0; i < mnmin; i++) {
                            A[-iskew + ioffg][i] = D[i];
                        }
                    } // if (ipack > 4)
                    else { // ipack <= 4

                        for (i = 0; i < mnmin; i++) {
                            A[i - iskew + ioffg][i] = D[i];
                        }
                    } // else ipack <= 4

                    for (k = 1; k <= uub; k++) {

                        for (jc = 1; jc <= (n - 1); jc++) {
                            irow = Math.max(1, jc - k);
                            il = Math.min(jc + 1, k + 2);
                            extra[0] = 0.0;
                            temp[0] = A[jc - (iskew * (jc + 1)) + ioffg - 1][jc];
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = Math.sin(angle);
                            length = lda - (irow - (iskew * jc) + ioffg) + 1 + (lda * (n - jc));
                            ap = new double[length];
                            index = 0;

                            for (i = irow - (iskew * jc) + ioffg - 1; i < lda; i++) {
                                ap[index++] = A[i][jc - 1];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    ap[index++] = A[i][j];
                                }
                            }

                            dlarot(false, jc > k, true, il, c[0], s[0], ap, ilda, extra, temp);
                            index = 0;

                            for (i = irow - (iskew * jc) + ioffg - 1; i < lda; i++) {
                                A[i][jc - 1] = ap[index++];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    A[i][j] = ap[index++];
                                }
                            }

                            length = lda - (((1 - iskew) * jc) + ioffg) + 1 + (lda * (n - jc));
                            ap = new double[length];
                            index = 0;

                            for (i = ((1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
                                ap[index++] = A[i][jc - 1];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    ap[index++] = A[i][j];
                                }
                            }

                            dlarot(true, true, false, Math.min(k, n - jc) + 1, c[0], s[0], ap, ilda, temp, dummy);
                            index = 0;

                            for (i = ((1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
                                A[i][jc - 1] = ap[index++];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    A[i][j] = ap[index++];
                                }
                            }

                            // Chase extra back up the matrix
                            icol = jc;

                            for (jch = jc - k; jch >= 1; jch -= k) {
                                dlartg(A[jch - (iskew * (icol + 1)) + ioffg][icol], extra[0], c, s, dummy);
                                temp[0] = A[jch - (iskew * (jch + 1)) + ioffg - 1][jch];
                                length = lda - (((1 - iskew) * jch) + ioffg) + 1 + (lda * (n - jch));
                                ap = new double[length];
                                index = 0;

                                for (i = ((1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
                                    ap[index++] = A[i][jch - 1];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, true, true, k + 2, c[0], -s[0], ap, ilda, temp, extra);
                                index = 0;

                                for (i = ((1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
                                    A[i][jch - 1] = ap[index++];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                irow = Math.max(1, jch - k);
                                il = Math.min(jch + 1, k + 2);
                                extra[0] = 0.0;
                                length = lda - (irow - (iskew * jch) + ioffg) + 1 + (lda * (n - jch));
                                ap = new double[length];
                                index = 0;

                                for (i = irow - (iskew * jch) + ioffg - 1; i < lda; i++) {
                                    ap[index++] = A[i][jch - 1];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, jch > k, true, il, c[0], -s[0], ap, ilda, extra, temp);
                                index = 0;

                                for (i = irow - (iskew * jch) + ioffg - 1; i < lda; i++) {
                                    A[i][jch - 1] = ap[index++];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                icol = jch;
                            } // for (jch = jc-k; jch >= 1; jch -= k)
                        } // for (jc = 1; jc <= n-1; jc++)
                    } // for (k = 1; k <= uub; k++)

                    // If we need lower triangle, copy from upper.  Note that
                    // the order of copying is chosen to work for 'q' -> 'b'
                    if ((ipack != ipackg) && (ipack != 3)) {

                        for (jc = 1; jc <= n; jc++) {
                            irow = ioffst - (iskew * jc);

                            for (jr = jc; jr <= Math.min(n, jc + uub); jr++) {
                                A[jr + irow - 1][jc - 1] = A[jc - (iskew * jr) + ioffg - 1][jr - 1];
                            }
                        } // for (jc = 1; jc <= n; jc++)

                        if (ipack == 5) {

                            for (jc = n - uub + 1; jc <= n; jc++) {

                                for (jr = n + 2 - jc; jr <= (uub + 1); jr++) {
                                    A[jr - 1][jc - 1] = 0.0;
                                }
                            }
                        } // if (ipack == 5)

                        if (ipackg == 6) {
                            ipackg = ipack;
                        } else {
                            ipackg = 0;
                        }
                    } // if ((ipack != ipackg) && (ipack != 3))
                } // if (topdwn)
                else { // !topdwn

                    // Bottom-Up -- Generate Lower triangle only
                    if (ipack >= 5) {
                        ipackg = 5;

                        if (ipack == 6) {
                            ioffg = 1;
                        }
                    } // if (ipack >= 5)
                    else { // ipack < 5
                        ipackg = 2;
                    } // else ipack < 5

                    if (ipack > 4) {

                        for (i = 0; i < mnmin; i++) {
                            A[-iskew + ioffg][i] = D[i];
                        }
                    } // if (ipack > 4)
                    else { // ipack <= 4

                        for (i = 0; i < mnmin; i++) {
                            A[i - iskew + ioffg][i] = D[i];
                        }
                    } // else ipack <= 4

                    for (k = 1; k <= uub; k++) {

                        for (jc = n - 1; jc >= 1; jc--) {
                            il = Math.min(n + 1 - jc, k + 2);
                            extra[0] = 0.0;
                            temp[0] = A[((1 - iskew) * jc) + ioffg][jc - 1];
                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
                            c[0] = Math.cos(angle);
                            s[0] = -Math.sin(angle);
                            length = lda - (((1 - iskew) * jc) + ioffg) + 1 + (lda * (n - jc));
                            ap = new double[length];
                            index = 0;

                            for (i = ((1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
                                ap[index++] = A[i][jc - 1];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    ap[index++] = A[i][j];
                                }
                            }

                            dlarot(false, true, (n - jc) > k, il, c[0], s[0], ap, ilda, temp, extra);
                            index = 0;

                            for (i = ((1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
                                A[i][jc - 1] = ap[index++];
                            }

                            for (j = jc; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    A[i][j] = ap[index++];
                                }
                            }

                            icol = Math.max(1, jc - k + 1);
                            length = lda - (jc - (iskew * icol) + ioffg) + 1 + (lda * (n - icol));
                            ap = new double[length];
                            index = 0;

                            for (i = jc - (iskew * icol) + ioffg - 1; i < lda; i++) {
                                ap[index++] = A[i][icol - 1];
                            }

                            for (j = icol; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    ap[index++] = A[i][j];
                                }
                            }

                            dlarot(true, false, true, jc + 2 - icol, c[0], s[0], ap, ilda, dummy, temp);
                            index = 0;

                            for (i = jc - (iskew * icol) + ioffg - 1; i < lda; i++) {
                                A[i][icol - 1] = ap[index++];
                            }

                            for (j = icol; j < n; j++) {

                                for (i = 0; i < lda; i++) {
                                    A[i][j] = ap[index++];
                                }
                            }

                            // Chase extra back down the matrix
                            icol = jc;

                            for (jch = jc + k; jch <= (n - 1); jch += k) {
                                dlartg(A[jch - (iskew * icol) + ioffg - 1][icol - 1], extra[0], c, s, dummy);
                                temp[0] = A[((1 - iskew) * jch) + ioffg][jch - 1];
                                length = lda - (jch - (iskew * icol) + ioffg) + 1 + (lda * (n - icol));
                                ap = new double[length];
                                index = 0;

                                for (i = jch - (iskew * icol) + ioffg - 1; i < lda; i++) {
                                    ap[index++] = A[i][icol - 1];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(true, true, true, k + 2, c[0], s[0], ap, ilda, extra, temp);
                                index = 0;

                                for (i = jch - (iskew * icol) + ioffg - 1; i < lda; i++) {
                                    A[i][icol - 1] = ap[index++];
                                }

                                for (j = icol; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                il = Math.min(n + 1 - jch, k + 2);
                                extra[0] = 0.0;
                                length = lda - (((1 - iskew) * jch) + ioffg) + 1 + (lda * (n - jch));
                                ap = new double[length];
                                index = 0;

                                for (i = ((1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
                                    ap[index++] = A[i][jch - 1];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        ap[index++] = A[i][j];
                                    }
                                }

                                dlarot(false, true, (n - jch) > k, il, c[0], s[0], ap, ilda, temp, extra);
                                index = 0;

                                for (i = ((1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
                                    A[i][jch - 1] = ap[index++];
                                }

                                for (j = jch; j < n; j++) {

                                    for (i = 0; i < lda; i++) {
                                        A[i][j] = ap[index++];
                                    }
                                }

                                icol = jch;
                            } // for (jch = jc+k; jch <= n-1; jch += k)
                        } // for (jc = n-1; jc >= 1; jc--)
                    } // for (k = 1; k <= uub; k++)

                    // If we need upper triangle, copy from lower.  Note that the
                    // order of copying is chosen to work for 'b' -> 'q'
                    if ((ipack != ipackg) && (ipack != 4)) {

                        for (jc = n; jc >= 1; jc--) {
                            irow = ioffst - (iskew * jc);

                            for (jr = jc; jr >= Math.max(1, jc - uub); jr--) {
                                A[jr + irow - 1][jc - 1] = A[jc - (iskew * jr) + ioffg - 1][jr - 1];
                            }
                        } // for (jc = n; jc >= 1; jc--)

                        if (ipack == 6) {

                            for (jc = 1; jc <= uub; jc++) {

                                for (jr = 1; jr <= (uub + 1 - jc); jr++) {
                                    A[jr - 1][jc - 1] = 0.0;
                                }
                            }
                        } // if (ipack == 6)

                        if (ipackg == 5) {
                            ipackg = ipack;
                        } // if (ipackg == 5)
                        else { // ipackg != 5
                            ipackg = 0;
                        } // else ipackg != 5
                    } // if ((ipack != ipackg) && (ipack != 4))
                } // else !topdwn
            } // else isym != 1
        } // else if (givens)
        else {

            // Generate Banded Matrix by first rotating by random Unitary
            // matrices, then reducing the bandwidth using Householder
            // transformations.
            // Note: We should only get here if lda >= n.
            if (isym == 1) {

                // Non-symmetric -- A = U D V
                dlagge(mr, nc, llb, uub, D, A, lda, iseed, work, iinfo);
            } // if (isym == 1)
            else { // isym != 1

                // Symmetric -- A = U D U'
                dlagsy(m, llb, D, A, lda, iseed, work, iinfo);
            } // else isym != 1

            if (iinfo[0] != 0) {
                info[0] = 3;

                return;
            } // if (iinfo[0] != 0)
        } // else

        // Pack the matrix
        if (ipack != ipackg) {

            if (ipack == 1) {

                // 'U' -- Upper triangular, not packed
                for (j = 0; j < m; j++) {

                    for (i = j + 1; i < m; i++) {
                        A[i][j] = 0.0;
                    }
                }
            } // if (ipack == 1)
            else if (ipack == 2) {

                // 'L' -- Lower triangular, not packed
                for (j = 1; j < m; j++) {

                    for (i = 0; i <= (j - 1); i++) {
                        A[i][j] = 0.0;
                    }
                }
            } // else if (ipack == 2)
            else if (ipack == 3) {

                // 'C' -- Upper triangle packed Columnwise.
                icol = 1;
                irow = 0;

                for (j = 0; j < m; j++) {

                    for (i = 0; i <= j; i++) {
                        irow = irow + 1;

                        if (irow > lda) {
                            irow = 1;
                            icol = icol + 1;
                        }

                        A[irow - 1][icol - 1] = A[i][j];
                    }
                }
            } // else if (ipack == 3)
            else if (ipack == 4) {

                // 'R' -- Lower triangle packed columnwise.
                icol = 1;
                irow = 0;

                for (j = 0; j < m; j++) {

                    for (i = j; i < m; i++) {
                        irow = irow + 1;

                        if (irow > lda) {
                            irow = 1;
                            icol = icol + 1;
                        }

                        A[irow - 1][icol - 1] = A[i][j];
                    }
                }
            } // else if (ipack == 4)
            else if (ipack >= 5) {
                // 'B' -- The lower triangle is packed as a band matrix.
                // 'Q' -- The upper triangle is packed as a band matrix.
                // 'Z' -- The whole matrix is packed as a band matrix.

                if (ipack == 5) {
                    uub = 0;
                } // if (ipack == 5)

                if (ipack == 6) {
                    llb = 0;
                } // if (ipack == 6)

                for (j = 1; j <= uub; j++) {

                    for (i = Math.min(j + llb, m); i >= 1; i--) {
                        A[i - j + uub][j - 1] = A[i - 1][j - 1];
                    }
                }

                for (j = uub + 2; j <= n; j++) {

                    for (i = j - uub; i <= Math.min(j + llb, m); i++) {
                        A[i - j + uub][j - 1] = A[i - 1][j - 1];
                    }
                }
            } // else if (ipack >= 5)

            // If packed, zero out extraneous elements

            // Symmetric/Triangular Packed
            // zero out everything after A[irow-1][icol-1]

            if ((ipack == 3) || (ipack == 4)) {

                for (jc = icol - 1; jc < m; jc++) {

                    for (jr = irow; jr < lda; jr++) {
                        A[jr][jc] = 0.0;
                    }

                    irow = 0;
                }
            } // if ((ipack == 3) || (ipack == 4))
            else if (ipack >= 5) {

                // Packed Band
                // 1st row is now in A[uub+1-j][j-1], zero above it
                // m-th row is now in A[m-1+uub-j][j-1], zero below it
                // last non-zero diagonal is now in A[uub+llb][j-1],
                // zero below it, too.
                ir1 = uub + llb + 2;
                ir2 = uub + m + 2;

                for (jc = 1; jc <= n; jc++) {

                    for (jr = 1; jr <= (uub + 1 - jc); jr++) {
                        A[jr - 1][jc - 1] = 0.0;
                    }

                    for (jr = Math.max(1, Math.min(ir1, ir2 - jc)); jr <= lda; jr++) {
                        A[jr - 1][jc - 1] = 0.0;
                    }
                } // for (jc = 1; jc <= n; jc++)
            } // else if (ipack >= 5)
        } // if (ipack != ipackg)

        return;
    } // dlatms

    /**
     * This is a port of version 3.1 LAPACK auxiliary routine DLATRD Original DLATRD created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dlatrd reduces nb rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal
     * similarity transformation Q'*A*Q, and returns the matrices V and W which are needed to apply the transformation
     * to the unreduced part of A. If uplo = 'U', dlatrd reduces the last nb rows and columns of a matrix, of which the
     * upper triangle is supplied. If uplo = 'L'. dlatrd reduces the first nb rows and columns of a matrix, of which the
     * lower triangle is supplied. This is an auxiliary routine called by dsytrd.
     *
     * @param  uplo  input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
     *               stored: 
     *               = 'U': Upper triangular 
     *               = 'L': Lower triangular
     * @param  n     input int The order of the matrix A.
     * @param  nb    input int The number of rows and columns to be reduced.
     * @param  A     input/output double[][] of dimension lda by n. On entry, the symmetric matrix A. If uplo == 'U',
     *               the leading n-by-n upper triangular part of A contains the upper triangular part of matrix A, and
     *               the strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
     *               triangular part of A contains the lower triangular part of the matrix A, and the strictly uper
     *               triangular part of A is not referenced. 
     *               On exit: If uplo = 'U', the last nb columns have been reduced to tridiagonal form, with the
     *               diagonal elements overwriting the diagonal elements of A; the elements above the diagonal with the
     *               array tau represent the orthogonal matrix Q as a product of elementary reflectors. 
     *               If uplo = 'L', the first nb columns have been reduced to tridiagonal form, with the diagonal
     *               elements overwriting the diagonal elements of A; the elements below the diagonal with the array
     *               tau represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.
     * @param  lda   input int The leading dimension of the array A. lda >= max(1,n).
     * @param  e     output double[] of dimension n-1. If uplo = 'U', e(n-nb-1:n-2) contains the superdiagonal elements
     *               of the last nb columns of the reduced matrix. If uplo = 'L', e(0:nb-1) contains the subdiagonal
     *               elements of the first nb columns of the reduced matrix.
     * @param  tau   output double[] of dimension n-1 The scalar factors of the elementary reflectors, stored in
     *               tau(n-nb-1:n-2) if uplo = 'U', and in tau(0:nb-1) if uplo = 'L'. See Further Details.
     * @param  W     output double[][] of dimension ldw by nb. The n-by-nb matrix W required to update the unreduced
     *               part of A.
     * @param  ldw   input int The leading dimension of the array W. ldw >= max(1,n).
     *
     *               <p>Further Details: If uplo = 'U', the matrix Q is represented as a product of elementary
     *               reflectors Q = H[n-1] H[n-2] ... H[n-nb]. Each H[i] has the form H[i] = I - tau * v * v' where tau
     *               is a real scalar, and v is a real vector with v(i-1:n-1) = 0 and v(i-2) = 1; v(0:i-2) is stored on
     *               exit in A(0:i-2,i-1), and tau in tau(i-2). If uplo = 'L', the matrix Q is represented as a product
     *               of elementary reflectors Q = H[0] H[1] ... H[nb-1]. Each H[i] has the form H[i] = I - tau * v * v'
     *               where tau is a real scalar, and v is a real vector with v(0:i-1) = 0 and v(i) = 1; v(i:n-1) is
     *               stored on exit in A(i:n-1,i-1),and tau in tau[i-1].</p>
     *
     *               <p>The elements of the vectors v together form the n-by-nb matrix V which is needed, with W, to apply
     *               the transformation to the unreduced part of the matrix using a symmetric rank-2k update of the
     *               form: A = A - V*W' - W*V'</p>
     *
     *               <p>The contents of A on exit are illustrated by the following examples with n = 5 and nb = 2: If
     *               uplo = 'U':
     *               ( a a a v4 v5)
     *               (   a a v4 v5) 
     *               (     a  1 v5)
     *               (        d  1)
     *               (           d)
     *               if uplo = 'L': 
     *               ( d          )
     *               ( 1  d       )
     *               (v1  1 a     ) 
     *               (v1 v2 a  a  )
     *               (v1 v2 a  a a)
     *               where d denotes a diagonal element of the reduced matrix, a denotes an element of the original
     *               matrix that is unchanged, and vi denotes an element of the vector defining H(i).</p>
     */
    private void dlatrd(char uplo, int n, int nb, double[][] A, int lda, double[] e, double[] tau, double[][] W,
                        int ldw) {
        int i;
        int iw;
        double alpha;
        double[][] array1;
        double[] vector1;
        double[] vector2;
        double[] vector3;
        int j;
        int k;

        // Quick return if possible
        if (n <= 0) {
            return;
        }

        if ((uplo == 'U') || (uplo == 'u')) {

            // Reduce last nb columns of upper triangle
            for (i = n; i >= (n - nb + 1); i--) {
                iw = i - n + nb;

                if (i < n) {

                    // Update A(0:i-1,i-1)
                    array1 = new double[i][n - i];

                    for (j = 0; j < i; j++) {

                        for (k = 0; k < (n - i); k++) {
                            array1[j][k] = A[j][k + i];
                        }
                    }

                    vector1 = new double[n - i];

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = W[i - 1][iw + j];
                    }

                    vector2 = new double[i];

                    for (j = 0; j < i; j++) {
                        vector2[j] = A[j][i - 1];
                    }

                    dgemv('N', i, n - i, -1.0, array1, i, vector1, 1, 1.0, vector2, 1);

                    for (j = 0; j < i; j++) {
                        A[j][i - 1] = vector2[j];
                    }

                    for (j = 0; j < i; j++) {

                        for (k = 0; k < (n - i); k++) {
                            array1[j][k] = W[j][k + iw];
                        }
                    }

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = A[i - 1][j + i];
                    }

                    for (j = 0; j < i; j++) {
                        vector2[j] = A[j][i - 1];
                    }

                    dgemv('N', i, n - i, -1.0, array1, i, vector1, 1, 1.0, vector2, 1);

                    for (j = 0; j < i; j++) {
                        A[j][i - 1] = vector2[j];
                    }
                } // if (i < n)

                if (i > 1) {

                    // Generate elementary reflector H[i-1] to annihilate A(0:i-3;,i-1)
                    vector1 = new double[1];
                    vector1[0] = A[i - 2][i - 1];
                    vector2 = new double[i - 2];

                    for (j = 0; j < (i - 2); j++) {
                        vector2[j] = A[j][i - 1];
                    }

                    vector3 = new double[1];
                    dlarfg(i - 1, vector1, vector2, 1, vector3);
                    A[i - 2][i - 1] = vector1[0];

                    for (j = 0; j < (i - 2); j++) {
                        A[j][i - 1] = vector2[j];
                    }

                    tau[i - 2] = vector3[0];
                    e[i - 2] = A[i - 2][i - 1];
                    A[i - 2][i - 1] = 1.0;

                    // Compute W(0:i-2,i-1)
                    vector1 = new double[i - 1];
                    vector2 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector1[j] = A[j][i - 1];
                        vector2[j] = W[j][iw - 1];
                    }

                    dsymv('U', i - 1, 1.0, A, lda, vector1, 1, 0.0, vector2, 1);

                    for (j = 0; j < (i - 1); j++) {
                        W[j][iw - 1] = vector2[j];
                    }

                    if (i < n) {
                        array1 = new double[i - 1][n - i];

                        for (j = 0; j < (i - 1); j++) {

                            for (k = 0; k < (n - i); k++) {
                                array1[j][k] = W[j][k + iw];
                            }
                        }

                        vector1 = new double[i - 1];

                        for (j = 0; j < (i - 1); j++) {
                            vector1[j] = A[j][i - 1];
                        }

                        vector2 = new double[n - i];

                        for (j = 0; j < (n - i); j++) {
                            vector2[j] = W[j + i][iw - 1];
                        }

                        dgemv('T', i - 1, n - i, 1.0, array1, i - 1, vector1, 1, 0.0, vector2, 1);

                        for (j = 0; j < (n - i); j++) {
                            W[j + i][iw - 1] = vector2[j];
                        }

                        for (j = 0; j < (i - 1); j++) {

                            for (k = 0; k < (n - i); k++) {
                                array1[j][k] = A[j][k + i];
                            }
                        }

                        for (j = 0; j < (i - 1); j++) {
                            vector1[j] = W[j][iw - 1];
                        }

                        dgemv('N', i - 1, n - i, -1.0, array1, i - 1, vector2, 1, 1.0, vector1, 1);

                        for (j = 0; j < (i - 1); j++) {
                            W[j][iw - 1] = vector1[j];
                            vector1[j] = A[j][i - 1];
                        }

                        for (j = 0; j < (n - i); j++) {
                            vector2[j] = W[j + i][iw - 1];
                        }

                        dgemv('T', i - 1, n - i, 1.0, array1, i - 1, vector1, 1, 0.0, vector2, 1);

                        for (j = 0; j < (n - i); j++) {
                            W[j + i][iw - 1] = vector2[j];
                        }

                        for (j = 0; j < (i - 1); j++) {

                            for (k = 0; k < (n - i); k++) {
                                array1[j][k] = W[j][k + iw];
                            }
                        }

                        for (j = 0; j < (i - 1); j++) {
                            vector1[j] = W[j][iw - 1];
                        }

                        dgemv('N', i - 1, n - i, -1.0, array1, i - 1, vector2, 1, 1.0, vector1, 1);

                        for (j = 0; j < (i - 1); j++) {
                            W[j][iw - 1] = vector1[j];
                        }
                    } // if (i < n)

                    vector1 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector1[j] = W[j][iw - 1];
                    }

                    dscal(i - 1, tau[i - 2], vector1, 1);

                    for (j = 0; j < (i - 1); j++) {
                        W[j][iw - 1] = vector1[j];
                    }

                    vector2 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector2[j] = A[j][i - 1];
                    }

                    alpha = -0.5 * tau[i - 2] * ddot(i - 1, vector1, 1, vector2, 1);
                    daxpy(i - 1, alpha, vector2, 1, vector1, 1);

                    for (j = 0; j < (i - 1); j++) {
                        W[j][iw - 1] = vector1[j];
                    }
                } // if (i > 1)
            } // for (i = n; i >= n-nb+1; i--)
        } // if ((uplo == 'U') || (uplo == 'u'))
        else { // ((uplo != 'U') && (uplo != 'u'))

            // Reduce first nb columns of lower triangle
            for (i = 1; i <= nb; i++) {

                // Update A(i-1:n-1,i-1)
                if (i != 1) {
                    array1 = new double[n - i + 1][i - 1];

                    for (j = 0; j < (n - i + 1); j++) {

                        for (k = 0; k < (i - 1); k++) {
                            array1[j][k] = A[j + i - 1][k];
                        }
                    }

                    vector1 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector1[j] = W[i - 1][j];
                    }

                    vector2 = new double[n - i + 1];

                    for (j = 0; j < (n - i + 1); j++) {
                        vector2[j] = A[j + i - 1][i - 1];
                    }

                    dgemv('N', n - i + 1, i - 1, -1.0, array1, n - i + 1, vector1, 1, 1.0, vector2, 1);

                    for (j = 0; j < (n - i + 1); j++) {
                        A[j + i - 1][i - 1] = vector2[j];
                    }

                    for (j = 0; j < (n - i + 1); j++) {

                        for (k = 0; k < (i - 1); k++) {
                            array1[j][k] = W[j + i - 1][k];
                        }
                    }

                    for (j = 0; j < (i - 1); j++) {
                        vector1[j] = A[i - 1][j];
                    }

                    for (j = 0; j < (n - i + 1); j++) {
                        vector2[j] = A[j + i - 1][i - 1];
                    }

                    dgemv('N', n - i + 1, i - 1, -1.0, array1, n - i + 1, vector1, 1, 1.0, vector2, 1);

                    for (j = 0; j < (n - i + 1); j++) {
                        A[j + i - 1][i - 1] = vector2[j];
                    }
                } // if (i != 1)

                if (i < n) {

                    // Generate elementary reflector H[i-1] to annihilate A(i+1:n-1,i-1)
                    vector1 = new double[1];
                    vector1[0] = A[i][i - 1];
                    vector2 = new double[n - i - 1];

                    for (j = 0; j < (n - i - 1); j++) {
                        vector2[j] = A[j + Math.min(i + 1, n - 1)][i - 1];
                    }

                    vector3 = new double[1];
                    dlarfg(n - i, vector1, vector2, 1, vector3);
                    A[i][i - 1] = vector1[0];

                    for (j = 0; j < (n - i - 1); j++) {
                        A[j + Math.min(i + 1, n - 1)][i - 1] = vector2[j];
                    }

                    tau[i - 1] = vector3[0];
                    e[i - 1] = A[i][i - 1];
                    A[i][i - 1] = 1.0;

                    // Compute W(i:n-1,i-1)
                    array1 = new double[n - i][n - i];

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (n - i); k++) {
                            array1[j][k] = A[j + i][k + i];
                        }
                    }

                    vector1 = new double[n - i];
                    vector2 = new double[n - i];

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = A[j + i][i - 1];
                        vector2[j] = W[j + i][i - 1];
                    }

                    dsymv('L', n - i, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

                    for (j = 0; j < (n - i); j++) {
                        W[j + i][i - 1] = vector2[j];
                    }

                    array1 = new double[n - i][i - 1];

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (i - 1); k++) {
                            array1[j][k] = W[j + i][k];
                        }
                    }

                    vector2 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector2[j] = W[j][i - 1];
                    }

                    dgemv('T', n - i, i - 1, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

                    for (j = 0; j < (i - 1); j++) {
                        W[j][i - 1] = vector2[j];
                    }

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (i - 1); k++) {
                            array1[j][k] = A[j + i][k];
                        }
                    }

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = W[j + i][i - 1];
                    }

                    dgemv('N', n - i, i - 1, -1.0, array1, n - i, vector2, 1, 1.0, vector1, 1);

                    for (j = 0; j < (n - i); j++) {
                        W[j + i][i - 1] = vector1[j];
                        vector1[j] = A[j + i][i - 1];
                    }

                    for (j = 0; j < (i - 1); j++) {
                        vector2[j] = W[j][i - 1];
                    }

                    dgemv('T', n - i, i - 1, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

                    for (j = 0; j < (i - 1); j++) {
                        W[j][i - 1] = vector2[j];
                    }

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (i - 1); k++) {
                            array1[j][k] = W[j + i][k];
                        }
                    }

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = W[j + i][i - 1];
                    }

                    dgemv('N', n - i, i - 1, -1.0, array1, n - i, vector2, 1, 1.0, vector1, 1);
                    dscal(n - i, tau[i - 1], vector1, 1);
                    vector2 = new double[n - i];

                    for (j = 0; j < (n - i); j++) {
                        vector2[j] = A[j + i][i - 1];
                    }

                    alpha = -0.5 * tau[i - 1] * ddot(n - i, vector1, 1, vector2, 1);
                    daxpy(n - i, alpha, vector2, 1, vector1, 1);

                    for (j = 0; j < (n - i); j++) {
                        W[j + i][i - 1] = vector1[j];
                    }
                } // if (i < n)
            } // for (i = 1; i <= nb; i++)
        } // else ((uplo != 'U') && (uplo != 'u'))

        return;
    } // dlatrd

    /**
     * This is a port of the 10/14/93 DNRM2 function Original code written by Sven Hammarling, Nag Ltd. dnrm2 returns
     * the euclidean norm of a vector via the function sqrt(x'*x)
     *
     * @param   n     int
     * @param   x     double[]
     * @param   incx  int
     *
     * @return  double
     */
    private double dnrm2(int n, double[] x, int incx) {
        int ix;
        double absxi;
        double norm;
        double scale;
        double ssq;
        double ratio;

        if ((n < 1) || (incx < 1)) {
            norm = 0.0;
        } else if (n == 1) {
            norm = Math.abs(x[0]);
        } else {
            scale = 0.0;
            ssq = 1.0;

            for (ix = 0; ix <= ((n - 1) * incx); ix += incx) {

                if (x[ix] != 0.0) {
                    absxi = Math.abs(x[ix]);

                    if (scale < absxi) {
                        ratio = scale / absxi;
                        ssq = 1.0 + (ssq * ratio * ratio);
                        scale = absxi;
                    } else {
                        ratio = absxi / scale;
                        ssq = ssq + (ratio * ratio);
                    }
                } // if (x[ix] != 0.0)
            } // for (ix = 0; ix <= (n-1)*incx; ix += incx)

            norm = scale * Math.sqrt(ssq);
        }

        return norm;
    } // dnrm2

    /**
     * This is a port of version 3.1 LAPACK routine DORG2L Original DORG2L created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorg2l generates an m by n real matrix Q with orthonormal columns, which is defined as the last n columns of a product
     * of k elementary reflectors of order m
     *  Q = H[k-1] ... H[1] H[0] as returned by dgeqlf
     *
     * @param  m     input int The number of rows of the matrix Q. m >= 0.
     * @param  n     input int The number of columns of the matrix Q. m >= n >= 0.
     * @param  k     input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
     * @param  A     input/output double[][] of dimension lda by n On entry, the (n-k+i)-th column must the the vector
     *               which defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqlf in the
     *               last k columns of its array argument A. On exit, the m by n matrix Q.
     * @param  lda   input int The first dimension of the array A. lda >= max(1,m).
     * @param  tau   input double[] of dimension k tau[i] must contain the scalar factor of the elementary reflector H[i],
     *               as returned by dgeqlf.
     * @param  work  workspace double[] of dimension n.
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info = -i, the i-th argument has an illegal value
     */
    private void dorg2l(int m, int n, int k, double[][] A, int lda, double[] tau, double[] work, int[] info) {
        int i;
        int ii;
        int j;
        int L;
        double[] vector1;
        int p;

        // Test the input arguments
        info[0] = 0;

        if (m < 0) {
            info[0] = -1;
        } else if ((n < 0) || (n > m)) {
            info[0] = -2;
        } else if ((k < 0) || (k > n)) {
            info[0] = -3;
        } else if (lda < Math.max(1, m)) {
            info[0] = -5;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorg2l had info = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n <= 0) {
            return;
        }

        // Initialize columns 0:n-k-1 to columns of the unit matrix
        for (j = 0; j < (n - k); j++) {

            for (L = 0; L < m; L++) {
                A[L][j] = 0.0;
            }

            A[m - n + j][j] = 1.0;
        } // for (j = 0; j < n-k; j++)

        for (i = 1; i <= k; i++) {
            ii = n - k + i;

            // Apply H[i-1] to A(0:m-k+i-1,0:n-k+i-1) from the left
            A[m - n + ii - 1][ii - 1] = 1.0;
            vector1 = new double[m - n + ii];

            for (p = 0; p < (m - n + ii); p++) {
                vector1[p] = A[p][ii - 1];
            }

            dlarf('L', m - n + ii, ii - 1, vector1, 1, tau[i - 1], A, lda, work);
            vector1 = new double[m - n + ii - 1];

            for (p = 0; p < (m - n + ii - 1); p++) {
                vector1[p] = A[p][ii - 1];
            }

            dscal(m - n + ii - 1, -tau[i - 1], vector1, 1);

            for (p = 0; p < (m - n + ii - 1); p++) {
                A[p][ii - 1] = vector1[p];
            }

            A[m - n + ii - 1][ii - 1] = 1.0 - tau[i - 1];

            // Set A(m-k+i:m-1,n-k+i-1) to zero
            for (L = m - n + ii; L < m; L++) {
                A[L][ii - 1] = 0.0;
            }
        } // for (i = 1; i <= k; i++)

        return;
    } // dorg2l

    /**
     * This is a port of version 3.1 LAPACK routine DORG2R Original DORG2R created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorg2r generates an m by n real matrix Q with orthonormal columns, which is defined as the first n columns of a
     * product of k elementary reflectors of order m
     *  Q = H[0] H[1] ... H[k-1] as returned by dgeqrf.
     *
     * @param  m     input int The number of rows of the matrix Q. m >= 0.
     * @param  n     input int The number of columns of the matrix Q. m >= n >= 0.
     * @param  k     input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
     * @param  A     input/output double[][] of dimension lda by n. On entry, the i-th column must contain the vector
     *               which defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqrf in the
     *               first k columns of its array argument A. On exit, the m-by-n matrix Q.
     * @param  lda   input int The first dimension of the array A. lda >= max(1,m).
     * @param  tau   input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector
     *               H[i], as returned by dgeqrf.
     * @param  work  workspace double[] of dimension n.
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info = -i, the i-th argument has an illegal value.
     */
    private void dorg2r(int m, int n, int k, double[][] A, int lda, double[] tau, double[] work, int[] info) {
        int i;
        int j;
        int L;
        double[] vector1;
        double[][] array1;
        int p;
        int q;

        // Test the input arguments
        info[0] = 0;

        if (m < 0) {
            info[0] = -1;
        } else if ((n < 0) || (n > m)) {
            info[0] = -2;
        } else if ((k < 0) || (k > n)) {
            info[0] = -3;
        } else if (lda < Math.max(1, m)) {
            info[0] = -5;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorg2r had info = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n <= 0) {
            return;
        }

        // Initialize columns k:n-1 to columns of the unit matrix
        for (j = k; j < n; j++) {

            for (L = 0; L < m; L++) {
                A[L][j] = 0.0;
            }

            A[j][j] = 1.0;
        } // for (j = k; j < n; j++)

        for (i = k; i >= 1; i--) {

            // Apply H[i-1] to A(i-1:m-1,i-1:n-1) from the left
            if (i < n) {
                A[i - 1][i - 1] = 1.0;
                vector1 = new double[m - i + 1];

                for (p = 0; p < (m - i + 1); p++) {
                    vector1[p] = A[p + i - 1][i - 1];
                }

                array1 = new double[m - i + 1][n - i];

                for (p = 0; p < (m - i + 1); p++) {

                    for (q = 0; q < (n - i); q++) {
                        array1[p][q] = A[p + i - 1][q + i];
                    }
                }

                dlarf('L', m - i + 1, n - i, vector1, 1, tau[i - 1], array1, m - i + 1, work);

                for (p = 0; p < (m - i + 1); p++) {

                    for (q = 0; q < (n - i); q++) {
                        A[p + i - 1][q + i] = array1[p][q];
                    }
                }
            } // if (i < n)

            if (i < m) {
                vector1 = new double[m - i];

                for (p = 0; p < (m - i); p++) {
                    vector1[p] = A[p + i][i - 1];
                }

                dscal(m - i, -tau[i - 1], vector1, 1);

                for (p = 0; p < (m - i); p++) {
                    A[p + i][i - 1] = vector1[p];
                }
            } // if (i < m)

            A[i - 1][i - 1] = 1.0 - tau[i - 1];

            // Set A(0:i-2, i-1) to zero
            for (L = 1; L <= (i - 1); L++) {
                A[L - 1][i - 1] = 0.0;
            }

        } // for (i = k; i >= 1; i--)

        return;
    } // dorg2r

    /**
     * This is a port of the version 3.1 LAPACK routine DORGQL Original DORGQL created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 
     * dorgql generates the m-by-n real matrix Q with orthonormal columns, which is defined as the last n columns of
     * a product of k elementary reflectors of order m 
     *  Q = H[k-1] ... H[1] H[0] as returned by dgeqlf.
     *
     * @param  m      input int The number of rows of the matrix Q. m >= 0.
     * @param  n      input int The number of columns of the matrix Q. m >= n >= 0.
     * @param  k      input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
     * @param  A      input/output double[][] of dimension lda by n. On entry, the (n-k+i)-th column must contain the
     *                vector which defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqlf
     *                in the last k columns of its array argument A. On exit, the m-by-n matrix Q.
     * @param  lda    input int The first dimension of the array A. lda >= max(1,m).
     * @param  tau    input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector
     *                H[i], as returned by dgeqlf.
     * @param  work   workspace/output double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns
     *                the optimal lwork.
     * @param  lwork  input int The dimension of the array work. lwork >= max(1,n). For optimum performance lwork >=
     *                n*nb, where nb is optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine
     *                only calculates the optimal size of the work array, returns this value as the first entry of the
     *                work array, and no error message related to lwork is issued.
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument has an illegal value
     */
    private void dorgql(int m, int n, int k, double[][] A, int lda, double[] tau, double[] work, int lwork,
                        int[] info) {
        boolean lquery;
        int i;
        int ib;
        int[] iinfo = new int[1];
        int iws;
        int j;
        int kk;
        int L;
        int ldwork = n;
        int lwkopt;
        int nb = 1;
        int nbmin;
        int nx;
        double[][] array1;
        int row1;
        double[][] array2;
        double[][] array3;
        double[] vector1;
        int p;
        int q;

        // Test the input arguments
        info[0] = 0;
        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }
        if (m < 0) {
            info[0] = -1;
        } else if ((n < 0) || (n > m)) {
            info[0] = -2;
        } else if ((k < 0) || (k > n)) {
            info[0] = -3;
        } else if (lda < Math.max(1, m)) {
            info[0] = -5;
        }
        
        if (info[0] == 0) {
            if (n == 0) {
                lwkopt = 1;
            }
            else {
                nb = ilaenv(1, "DORGQL", " ", m, n, k, -1);
                lwkopt = n * nb;    
            }
            work[0] = lwkopt;
            if ((lwork < Math.max(1, n)) && (!lquery)) {
                info[0] = -8;
            }
        }
        
        if (info[0] != 0) {
            MipavUtil.displayError("Error dorgql had info = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n <= 0) {
            return;
        }

        nbmin = 2;
        nx = 0;
        iws = n;

        if ((nb > 1) && (nb < k)) {

            // Determine when to cross over from blocked to unblocked code
            nx = Math.max(0, ilaenv(3, "DORGQL", " ", m, n, k, -1));

            if (nx < k) {

                // Determine if workspace is large enough for blocked code.
                ldwork = n;
                iws = ldwork * nb;

                if (lwork < iws) {

                    // Not enough workspace to use optimal nb: reduce nb and determine
                    // the minimum value of nb.
                    nb = lwork / ldwork;
                    nbmin = Math.max(2, ilaenv(2, "DORGQL", " ", m, n, k, -1));
                } // if (lwork < iws)
            } // if (nx < k)
        } // if ((nb > 1) && (nb < k))

        if ((nb >= nbmin) && (nb < k) && (nx < k)) {

            // Use blocked code after the first block.
            // The last kk columns are handled by the block method
            kk = Math.min(k, ((k - nx + nb - 1) / nb) * nb);

            // Set A(m-kk:m-1,0:n-kk-1) to zero.
            for (j = 0; j < (n - kk); j++) {

                for (i = m - kk; i < m; i++) {
                    A[i][j] = 0.0;
                }
            }
        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
        else {
            kk = 0;
        }

        // Use unblocked code for the first or only block
        dorg2l(m - kk, n - kk, k - kk, A, lda, tau, work, iinfo);

        if (kk > 0) {

            // Use blocked code
            for (i = k - kk + 1; i <= k; i += nb) {
                ib = Math.min(nb, k - i + 1);

                if (((n - k + i) > 1) && ((m - k + i + ib - 1) > 0)) {

                    // Form the triangular factor of the block reflector
                    // H = H[i+ib-2] ... H[i] H[i-1]
                    array1 = new double[m - k + i + ib - 1][ib];

                    for (p = 0; p < (m - k + i + ib - 1); p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[p][q + n - k + i - 1];
                        }
                    }

                    vector1 = new double[ib];

                    for (p = 0; p < ib; p++) {
                        vector1[p] = tau[p + i - 1];
                    }

                    array2 = new double[ib][ib];
                    dlarft('B', 'C', m - k + i + ib - 1, ib, array1, m - k + i + ib - 1, vector1, array2, ib);

                    for (p = 0; p < (m - k + i + ib - 1); p++) {

                        for (q = 0; q < ib; q++) {
                            A[p][q + n - k + i - 1] = array1[p][q];
                        }
                    }

                    array3 = new double[n - k + i - 1][ib];
                    dlarfb('L', 'N', 'B', 'C', m - k + i + ib - 1, n - k + i - 1, ib, array1, m - k + i + ib - 1,
                           array2, ib, A, lda, array3, n - k + i - 1);
                } // if ((n-k+i > 1) && (m-k+i+ib-1 > 0))

                // Apply H to rows 0:m-k+i+ib-2 of current block
                row1 = Math.max(1, m - k + i + ib - 1);
                array1 = new double[row1][ib];

                for (p = 0; p < row1; p++) {

                    for (q = 0; q < ib; q++) {
                        array1[p][q] = A[p][q + n - k + i - 1];
                    }
                }

                vector1 = new double[ib];

                for (p = 0; p < ib; p++) {
                    vector1[p] = tau[p + i - 1];
                }

                dorg2l(m - k + i + ib - 1, ib, ib, array1, row1, vector1, work, iinfo);

                for (p = 0; p < row1; p++) {

                    for (q = 0; q < ib; q++) {
                        A[p][q + n - k + i - 1] = array1[p][q];
                    }
                }

                // Set rows m-k+i+ib-1:m-1 of current block to zero
                for (j = n - k + i - 1; j < (n - k + i + ib - 1); j++) {

                    for (L = m - k + i + ib - 1; L < m; L++) {
                        A[L][j] = 0.0;
                    }
                }
            } // for (i = k - kk + 1; i <= k; i+= nb)
        } // if (kk > 0)

        work[0] = iws;

        return;
    } // dorgql

    /**
     * This is a port of version 3.1 LAPACK routine DORGQR Original DORGQR created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorgqr generates an m-by-n real matrix Q with orthonormal columns, which is defined as the first n columns
     * of a product of k elementary reflectors of order m 
     *  Q = H[0] H[1] ... H[k-1] as returned by dgeqrf.
     *
     * @param  m      input int The number of rows of the matrix Q. m >= 0.
     * @param  n      input int The number of columns of the matrix Q. m >= n >= 0.
     * @param  k      input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
     * @param  A      input/output double[][] of dimensions lda by n. On entry, the i-th column must contain the vector
     *                which defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqrf in the
     *                first k columns of its array argument A. On exit, the m-by-n matrix Q.
     * @param  lda    input int The first dimension of the array A. lda >= max(1,m).
     * @param  tau    input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector
     *                H[i], as returned by dgeqrf.
     * @param  work   (worksplace/output) double[] of dimension max(1,lwork). 
     *                On exit, if info[0] = 0, work[0] returns the optimal lwork.
     * @param  lwork  input int The dimension of the array work. lwork >= max(1,n). For optimum performance lwork >=
     *                n*nb, where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the
     *                routine only calculates the optimal size of the work array, returns this value as the first entry
     *                of the work array, and no error message related to lwork is issued.
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info = -i, the i-th argument has an illegal value
     */
    private void dorgqr(int m, int n, int k, double[][] A, int lda, double[] tau, double[] work, int lwork,
                        int[] info) {
        boolean lquery;
        int i;
        int ib;
        int[] iinfo = new int[1];
        int iws;
        int j;
        int ki = 1;
        int kk;
        int L;
        int ldwork;
        int lwkopt;
        int nb;
        int nbmin;
        int nx;
        double[][] array1;
        double[][] array2;
        double[][] array3;
        double[][] array4;
        double[] vector1;
        int p;
        int q;
        int row1;

        // Test the input arguments
        info[0] = 0;
        nb = ilaenv(1, "DORGQR", " ", m, n, k, -1);
        lwkopt = Math.max(1, n) * nb;
        work[0] = lwkopt;

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        if (m < 0) {
            info[0] = -1;
        } else if ((n < 0) || (n > m)) {
            info[0] = -2;
        } else if ((k < 0) || (k > n)) {
            info[0] = -3;
        } else if (lda < Math.max(1, m)) {
            info[0] = -5;
        } else if ((lwork < Math.max(1, n)) && (!lquery)) {
            info[0] = -8;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorgqr had info = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n <= 0) {
            work[0] = 1;

            return;
        }

        nbmin = 2;
        nx = 0;
        iws = n;

        if ((nb > 1) && (nb < k)) {

            // Determine when to cross over from blocked to unblocked code
            nx = Math.max(0, ilaenv(3, "DORGQR", " ", m, n, k, -1));

            if (nx < k) {

                // Determine if workspace is large enough for blocked code.
                ldwork = n;
                iws = ldwork * nb;

                if (lwork < iws) {

                    // Not enough workspace to use optimal nb: reduce nb and determine
                    // the minimum value of nb.
                    nb = lwork / ldwork;
                    nbmin = Math.max(2, ilaenv(2, "DORGQR", " ", m, n, k, -1));
                } // if (lwork < iws)
            } // if (nx < k)
        } // if ((nb > 1) && (nb < k))

        if ((nb >= nbmin) && (nb < k) && (nx < k)) {

            // Use blocked code after the last block.
            // The first kk columns are handled by the block method
            ki = ((k - nx - 1) / nb) * nb;
            kk = Math.min(k, ki + nb);

            // Set A(0:kk-1,kk:n-1) to zero.

            for (j = kk; j < n; j++) {

                for (i = 0; i < kk; i++) {
                    A[i][j] = 0.0;
                }
            }
        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
        else {
            kk = 0;
        }

        // Use unblocked code for the last or only block
        if (kk < n) {
            row1 = Math.max(1, m - kk);
            array1 = new double[row1][n - kk];

            for (p = 0; p < row1; p++) {

                for (q = 0; q < (n - kk); q++) {
                    array1[p][q] = A[p + kk][q + kk];
                }
            }

            vector1 = new double[k - kk];

            for (p = 0; p < (k - kk); p++) {
                vector1[p] = tau[p + kk];
            }

            dorg2r(m - kk, n - kk, k - kk, array1, row1, vector1, work, iinfo);

            for (p = 0; p < row1; p++) {

                for (q = 0; q < (n - kk); q++) {
                    A[p + kk][q + kk] = array1[p][q];
                }
            }
        } // if (kk < n)

        if (kk > 0) {

            // Use blocked code
            for (i = ki + 1; i >= 1; i -= nb) {
                ib = Math.min(nb, k - i + 1);

                if ((i + ib) <= n) {

                    // Form the triangular factor of the block reflector
                    // H = H[i-1] H[i] ... H[i+ib-2]
                    array1 = new double[m - i + 1][ib];

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[p + i - 1][q + i - 1];
                        }
                    }

                    vector1 = new double[ib];

                    for (p = 0; p < ib; p++) {
                        vector1[p] = tau[p + i - 1];
                    }

                    array2 = new double[ib][ib];
                    dlarft('F', 'C', m - i + 1, ib, array1, m - i + 1, vector1, array2, ib);

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < ib; q++) {
                            A[p + i - 1][q + i - 1] = array1[p][q];
                        }
                    }

                    // Apply H to A(i-1:m-1, i+ib-1:n-1) from the left
                    array3 = new double[m - i + 1][n - i - ib + 1];

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < (n - i - ib + 1); q++) {
                            array3[p][q] = A[p + i - 1][q + i + ib - 1];
                        }
                    }

                    array4 = new double[n - i - ib + 1][ib];
                    dlarfb('L', 'N', 'F', 'C', m - i + 1, n - i - ib + 1, ib, array1, m - i + 1, array2, ib, array3,
                           m - i + 1, array4, n - i - ib + 1);

                    for (p = 0; p < (m - i + 1); p++) {

                        for (q = 0; q < (n - i - ib + 1); q++) {
                            A[p + i - 1][q + i + ib - 1] = array3[p][q];
                        }
                    }
                } // if ((i+ib) <= n)

                // Apply H to rows i-1:m-1 of current block
                array1 = new double[m - i + 1][ib];

                for (p = 0; p < (m - i + 1); p++) {

                    for (q = 0; q < ib; q++) {
                        array1[p][q] = A[p + i - 1][q + i - 1];
                    }
                }

                vector1 = new double[ib];

                for (p = 0; p < ib; p++) {
                    vector1[p] = tau[p + i - 1];
                }

                dorg2r(m - i + 1, ib, ib, array1, m - i + 1, vector1, work, iinfo);

                for (p = 0; p < (m - i + 1); p++) {

                    for (q = 0; q < ib; q++) {
                        A[p + i - 1][q + i - 1] = array1[p][q];
                    }
                }

                // Set rows 0:i-2 of current block to zero
                for (j = i; j <= (i + ib - 1); j++) {

                    for (L = 1; L <= (i - 1); L++) {
                        A[L - 1][j - 1] = 0.0;
                    }
                }
            } // for (i = ki+1; i >= 1; i -= nb)
        } // if (kk > 0)

        work[0] = iws;

        return;
    } // dorgqr

    /**
     * This is a port of version 3.1 LAPACK routine DORGTR Original DORGTR created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorgtr generates a real orthogonal matrix Q which is defined as the product of n-1 elementary reflectors
     * of order N, as returned by dsytrd: 
     * If uplo = 'U', Q = H[n-2] ... H[1] H[0] 
     * If uplo = 'L', Q = H[0] H[1] ... H[n-2]
     *
     * @param  uplo   input char \
     *                = 'U': Upper triangle of A contains elementary reflectors from dsytrd 
     *                = 'L': Lower triangle of A contains elementary reflectors from dsytrd
     * @param  n      input int The order of the matrix Q. n >= 0.
     * @param  A      input/output double[][] of dimension lda by n On entry, the vectors which define the elementary
     *                reflectors, as returned by dsytrd. On exit, the n-by-n orthogonal matrix Q.
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,n).
     * @param  tau    input double[] of dimension n-1. tau[i] must contain the scalar factor of the elementary reflector
     *                H[i], as returned by dsytrd.
     * @param  work   workspace/output double[] of dimension max(1, lwork). 
     *                On exit, if info[0] = 0, work[0] returns the optimal lwork.
     * @param  lwork  input int The dimension of the array work. lwork >= max(1,n-1). For optimum performance, lwork >=
     *                (n-1)*nb, where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the
     *                routine only caclulates the optimal size of the work array, returns this value as the first entry
     *                of the work array, and no error message related to lwork is issued.
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info = -i, the i-th argument had an illegal value
     */
    private void dorgtr(char uplo, int n, double[][] A, int lda, double[] tau, double[] work, int lwork, int[] info) {
        boolean lquery;
        boolean upper;
        int i;
        int[] iinfo = new int[1];
        int j;
        int lwkopt = 1;
        int nb;
        double[][] array1;

        // Test the input arguments
        info[0] = 0;

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -4;
        } else if ((lwork < Math.max(1, n - 1)) && (!lquery)) {
            info[0] = -7;
        }

        if (info[0] == 0) {

            if (upper) {
                nb = ilaenv(1, "DORGQL", " ", n - 1, n - 1, n - 1, -1);
            } else {
                nb = ilaenv(1, "DORGQR", " ", n - 1, n - 1, n - 1, -1);
            }

            lwkopt = Math.max(1, n - 1) * nb;
            work[0] = lwkopt;
        } // if (info[0] == 0)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorgtr had info = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n == 0) {
            work[0] = 1;

            return;
        }

        if (upper) {
            // Q was determined by a call to dsytrd with uplo == 'U'

            // Shift the vectors which define the elementary reflectors one column
            // to the left, and set the last row and column of Q to those of the
            // unit matrix

            for (j = 0; j < (n - 1); j++) {

                for (i = 0; i <= (j - 1); i++) {
                    A[i][j] = A[i][j + 1];
                }

                A[n - 1][j] = 0.0;
            } // for (j = 0; j < n-1; j++)

            for (i = 0; i < (n - 1); i++) {
                A[i][n - 1] = 0.0;
            }

            A[n - 1][n - 1] = 1.0;

            // Generate Q(0:n-2,0:n-2)
            dorgql(n - 1, n - 1, n - 1, A, lda, tau, work, lwork, iinfo);
        } // if (upper)
        else { // lower

            // Q was determined by a call to dsytrd with uplo == 'L'

            // Shift the vectors which define the elementary reflectors one column
            // to the right, and set the first row and column of Q to those of the
            // unit matrix

            for (j = n - 1; j >= 1; j--) {
                A[0][j] = 0.0;

                for (i = j + 1; i < n; i++) {
                    A[i][j] = A[i][j - 1];
                }
            } // for (j = n-1; j >=1; j--)

            A[0][0] = 1.0;

            for (i = 1; i < n; i++) {
                A[i][0] = 0.0;
            }

            if (n > 1) {

                // Generate Q(1:n-1,1:n-1)
                array1 = new double[n - 1][n - 1];

                for (i = 0; i < (n - 1); i++) {

                    for (j = 0; j < (n - 1); j++) {
                        array1[i][j] = A[i + 1][j + 1];
                    }
                }

                dorgqr(n - 1, n - 1, n - 1, array1, n - 1, tau, work, lwork, iinfo);

                for (i = 0; i < (n - 1); i++) {

                    for (j = 0; j < (n - 1); j++) {
                        A[i + 1][j + 1] = array1[i][j];
                    }
                }
            } // if (n > 1)
        } // else lower

        work[0] = lwkopt;

        return;
    } // dorgtr

    /**
     * This is a port of the version 3.1 LAPACK routine DORM2L Original DORM2L created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorm2l overwrites the general real m by n matrix C with 
     *     Q * C if side == 'L' and trans == 'N', or
     *     Q' * C if side == 'L' and trans == 'T', or
     *     C * Q if side == 'R' and trans == 'N', or
     *     C * Q' if side == 'R' and trans == 'T'
     * where Q is a real orthogonal matrix defined as a product of k elementary reflectors Q = H[k-1] ... H[1] H[0] as
     * retunred by dgeqlf. Q is of order m if side == 'L' and of order n if side == 'R'.
     *
     * @param  side   (input) char 
     *                = 'L': Apply Q or Q' from the left 
     *                = 'R': Apply Q or Q' from the right
     * @param  trans  (input) char 
     *                = 'N': apply Q (no transpose) 
     *                = 'T': apply Q' (Transpose)
     * @param  m      (input) int The number of rows of the matrix C. m >= 0.
     * @param  n      (input) int The number of columns of the matrix C. n >= 0.
     * @param  k      (input) int The number of elementary reflectors whose product defines the matrix Q. 
     *                If side == 'L', m >= k >= 0. 
     *                If side == 'R', n >= k >= 0.
     * @param  A      (input) double[][] of dimension (lda,k) The i-th column must contain the vector which defines the
     *                elementary reflector H(i), for i = 0, 1,...,k-1, as returned by dgeqlf in the last k column of its
     *                array argument A. A is modified by the routine but restored on exit.
     * @param  lda    (input) int The leading dimension of the array A. 
     *                If side == 'L', lda >= max(1,m). 
     *                If side == 'R', lda >= max(1,n).
     * @param  tau    (input) double[] of dimension (k) tau[i] must contain the scalar factor of the elementary
     *                reflector H[i], as returned by dgeqlf.
     * @param  C      (input/output) double[][]of dimension (ldc, n) On entry, the m by n matrix C. On exit, C is
     *                overwritten by Q*C or Q'*C or C*Q' or C*Q.
     * @param  ldc    (input) int The leading dimension of the array C. ldc >= max(1,m).
     * @param  work   (workspace) double[] of dimension 
     *                (n) if side == 'L', 
     *                (m) if side == 'R'.
     * @param  info   (output) int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument had an illegal value.
     */
    private void dorm2l(char side, char trans, int m, int n, int k, double[][] A, int lda, double[] tau, double[][] C,
                        int ldc, double[] work, int[] info) {
        boolean left;
        boolean notran;
        int i;
        int i1;
        int i2;
        int i3;
        int mi = 0;
        int ni = 0;
        int nq;
        double aii;
        double[] v;
        int j;

        // Test the input arguments
        info[0] = 0;
        left = ((side == 'L') || (side == 'l'));
        notran = ((trans == 'N') || (trans == 'n'));

        // nq is the order of Q
        if (left) {
            nq = m;
        } else {
            nq = n;
        }

        if ((!left) && (side != 'R') && (side != 'r')) {
            info[0] = -1;
        } else if ((!notran) && (trans != 'T') && (trans != 't')) {
            info[0] = -2;
        } else if (m < 0) {
            info[0] = -3;
        } else if (n < 0) {
            info[0] = -4;
        } else if ((k < 0) || (k > nq)) {
            info[0] = -5;
        } else if (lda < Math.max(1, nq)) {
            info[0] = -7;
        } else if (ldc < Math.max(1, m)) {
            info[0] = -10;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorm2l had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0) || (k == 0)) {
            return;
        }

        if ((left && notran) || ((!left) && (!notran))) {
            i1 = 1;
            i2 = k;
            i3 = 1;
        } else {
            i1 = k;
            i2 = 1;
            i3 = -1;
        }

        if (left) {
            ni = n;
        } else {
            mi = m;
        }

        if (i3 == 1) {

            for (i = i1; i <= i2; i++) {

                if (left) {

                    // H[i-1] is applied to C(0:m-k+i-1,0:n-1)
                    mi = m - k + i;
                    v = new double[mi];
                } // if (left)
                else { // !left

                    // H[i-1] is applied to C(0:m-1,0:n-k+i-1)
                    ni = n - k + i;
                    v = new double[ni];
                } // else !left

                // Apply H[i-1]
                aii = A[nq - k + i - 1][i - 1];
                A[nq - k + i - 1][i - 1] = 1.0;

                if (left) {

                    for (j = 0; j < mi; j++) {
                        v[j] = A[j][i - 1];
                    }
                } else {

                    for (j = 0; j < ni; j++) {
                        v[j] = A[j][i - 1];
                    }
                }

                dlarf(side, mi, ni, v, 1, tau[i - 1], C, ldc, work);
                A[nq - k + i - 1][i - 1] = aii;
            } // for (i = i1; i <= i2; i++)
        } // if (i3 == 1)
        else { // i3 == -1

            for (i = i1; i >= i2; i--) {

                if (left) {

                    // H[i-1] is applied to C(0:m-k+i-1,0:n-1)
                    mi = m - k + i;
                    v = new double[mi];
                } // if (left)
                else { // !left

                    // H[i-1] is applied to C(0:m-1,0:n-k+i-1)
                    ni = n - k + i;
                    v = new double[ni];
                } // else !left

                // Apply H[i-1]
                aii = A[nq - k + i - 1][i - 1];
                A[nq - k + i - 1][i - 1] = 1.0;

                if (left) {

                    for (j = 0; j < mi; j++) {
                        v[j] = A[j][i - 1];
                    }
                } else {

                    for (j = 0; j < ni; j++) {
                        v[j] = A[j][i - 1];
                    }
                }

                dlarf(side, mi, ni, v, 1, tau[i - 1], C, ldc, work);
                A[nq - k + i - 1][i - 1] = aii;
            } // for (i = i1; i >= i2; i--)
        } // else i3 == -1

        return;
    } // dorm2l

    /**
     * This is a port of the version 3.1 LAPACK routine DORM2R Original DORM2R created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dorm2r overwrites the general real m by n matrix C with 
     *     Q * C if side = 'L' and trans = 'N', or 
     *     Q'* C if side = 'L' and trans = 'T', or 
     *     C * Q if side = 'R' and trans = 'N', or 
     *     C * Q' if side = 'R' and trans = 'T',
     * where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(0) H(1) . . . H(k-1)
     * as returned by dgeqrf. Q is of order m if side = 'L' and of order n if side = 'R'.
     *
     * @param  side   input char 
     *                = 'L': apply Q or Q' from the left 
     *                = 'R': apply Q or Q' from the right
     * @param  trans  input char 
     *                = 'N': apply Q (no transpose) 
     *                = 'T': apply Q' (transpose)
     * @param  m      input int The number of rows of the matrix C. m >= 0.
     * @param  n      input int The number of columns of the matrix C. n >= 0.
     * @param  k      input int The number of elementary reflectors whose product defines the matrix Q. 
     *                If side = 'L', m >= k >= 0 
     *                If side = 'R', n >= k >= 0
     * @param  A      input double[][] of dimension (lda, k) The i-th column must contain the vector which defines the
     *                elementary reflector H(i), for i = 0,1,...,k-1, as returned by dgeqrf in the first k columns of
     *                its array argument A. A is modified by the routine but restored on exit.
     * @param  lda    input int The leading dimension of the array A. 
     *                If side = 'L', lda >= max(1,m) 
     *                If side = 'R', lda >= max(1,n)
     * @param  tau    input double[] of dimension (k) tau[i-1] must contain the scalar factor of the elementary
     *                reflector H(i), as returned by dgeqrf.
     * @param  C      (input/output) double[][] of dimension (ldc,n) On entry, the m by n matrix C. On exit, C is
     *                overwritten by Q*C or Q'*C or C*Q' or C*Q.
     * @param  ldc    input int The leading dimension of the array C. ldc >= max(1,m).
     * @param  work   (workspace) double[] of dimension 
     *                (n) if side = 'L' 
     *                (m) if side = 'R'
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument had an illegal value.
     */
    private void dorm2r(char side, char trans, int m, int n, int k, double[][] A, int lda, double[] tau, double[][] C,
                        int ldc, double[] work, int[] info) {
        boolean left;
        boolean notran;
        int i;
        int i1;
        int i2;
        int i3;
        int ic = 1;
        int jc = 1;
        int mi = 1;
        int ni = 1;
        int nq;
        double aii;
        int j;
        int p;
        double[] x;
        double[][] array1;
        int row1;

        // Test the input arguments
        info[0] = 0;

        if ((side == 'L') || (side == 'l')) {
            left = true;
        } else {
            left = false;
        }

        if ((trans == 'N') || (trans == 'n')) {
            notran = true;
        } else {
            notran = false;
        }

        // nq is the order of Q
        if (left) {
            nq = m;
        } else {
            nq = n;
        }

        if ((!left) && (side != 'R') && (side != 'r')) {
            info[0] = -1;
        } else if ((!notran) && (trans != 'T') && (trans != 't')) {
            info[0] = -2;
        } else if (m < 0) {
            info[0] = -3;
        } else if (n < 0) {
            info[0] = -4;
        } else if ((k < 0) || (k > nq)) {
            info[0] = -5;
        } else if (lda < Math.max(1, nq)) {
            info[0] = -7;
        } else if (ldc < Math.max(1, m)) {
            info[0] = -10;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dorm2r had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0) || (k == 0)) {
            return;
        }

        if ((left && (!notran)) || ((!left) && notran)) {
            i1 = 1;
            i2 = k;
            i3 = 1;
        } else {
            i1 = k;
            i2 = 1;
            i3 = -1;
        }

        if (left) {
            ni = n;
            jc = 1;
        } else {
            mi = m;
            ic = 1;
        }

        if (i3 == 1) {

            for (i = i1; i <= i2; i++) {

                if (left) {

                    // H(i-1) is applied to C(i-1:m-1,0:n-1)
                    mi = m - i + 1;
                    ic = i;
                } else {

                    // H(i-1) is applied to C(0:m-1,i-1:n-1)
                    ni = n - i + 1;
                    jc = i;
                }

                // Apply H(i-1)
                aii = A[i - 1][i - 1];
                A[i - 1][i - 1] = 1.0;

                if (left) {
                    x = new double[mi];

                    for (j = 0; j < mi; j++) {
                        x[j] = A[i - 1 + j][i - 1];
                    }
                } // if (left)
                else {
                    x = new double[ni];

                    for (j = 0; j < ni; j++) {
                        x[j] = A[i - 1 + j][i - 1];
                    }
                }

                row1 = Math.max(1, mi);
                array1 = new double[row1][ni];

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < ni; p++) {
                        array1[j][p] = C[ic - 1 + j][jc - 1 + p];
                    }
                }

                dlarf(side, mi, ni, x, 1, tau[i - 1], array1, row1, work);

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < ni; p++) {
                        C[ic - 1 + j][jc - 1 + p] = array1[j][p];
                    }
                }

                A[i - 1][i - 1] = aii;
            } // for (i = i1; i <= i2; i++)
        } // if (i3 == 1)
        else { // i3 == -1

            for (i = i1; i >= i2; i--) {

                if (left) {

                    // H(i-1) is applied to C(i-1:m-1,0:n-1)
                    mi = m - i + 1;
                    ic = i;
                } else {

                    // H(i-1) is applied to C(0:m-1,i-1:n-1)
                    ni = n - i + 1;
                    jc = i;
                }

                // Apply H(i-1)
                aii = A[i - 1][i - 1];
                A[i - 1][i - 1] = 1.0;

                if (left) {
                    x = new double[mi];

                    for (j = 0; j < mi; j++) {
                        x[j] = A[i - 1 + j][i - 1];
                    }
                } // if (left)
                else {
                    x = new double[ni];

                    for (j = 0; j < ni; j++) {
                        x[j] = A[i - 1 + j][i - 1];
                    }
                }

                row1 = Math.max(1, mi);
                array1 = new double[row1][ni];

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < ni; p++) {
                        array1[j][p] = C[ic - 1 + j][jc - 1 + p];
                    }
                }

                dlarf(side, mi, ni, x, 1, tau[i - 1], array1, row1, work);

                for (j = 0; j < row1; j++) {

                    for (p = 0; p < ni; p++) {
                        C[ic - 1 + j][jc - 1 + p] = array1[j][p];
                    }
                }

                A[i - 1][i - 1] = aii;
            } // for (i = i1; i >= i2; i--)
        } // else i3 == -1

        return;
    } // dorm2r

    /**
     * This is a port of version 3.1 LAPACK routine DORMQR Original DORMQR created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006 
     * dormqr overwrites the general real m by n matrix C with 
     *                           side = 'L'          side = 'R' 
     *           trans = 'N':      Q * C               C * Q 
     *           trans = 'T':      Q**T * C            C * Q**T 
     * where Q is a real orthogonal matrix defined as the product of k elementary reflectors 
     *                    Q = H(1) H(1) . . . H(k-1)
     * as returned by dgeqrf. Q is of order m if side = 'L' and of order n if side = 'R'.
     *
     * @param  side   input char 
     *                = 'L': apply Q or Q**T from the left 
     *                = 'R': apply Q or Q**T from the right
     * @param  trans  trans char 
     *                = 'N': No transpose, apply Q 
     *                = 'T': Transpose, apply Q**T
     * @param  m      input int The number of rows of matrix C. m >= 0.
     * @param  n      input int The number of columns of matrix C. n >= 0.
     * @param  k      input int The number of elementary reflectors whose product defines the matrix Q. 
     *                If side = 'L', m >= k >= 0 
     *                If side = 'R', n >= k >= 0
     * @param  A      input double[][] of dimension (lda,k) The i-th column must contain the vector which defines the
     *                elementary reflector H(i), for i = 0,1,...,k-1, as returned by dgeqrf in the first k columns of its
     *                array argument A. A is modified by the routine but restored on exit.
     * @param  lda    input int The leading dimension of the array A. 
     *                If side = 'L', lda >= max(1,m) 
     *                If side = 'R', lda >= max(1,n)
     * @param  tau    input double[] of dimension k tau[i-1] must contain the scalar factor of the elementary reflector
     *                H(i), as returned by dgeqrf
     * @param  C      (input/output) double[][] of dimension (ldc,n) 
     *                On entry, the m by n matrix C. 
     *                On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
     * @param  ldc    input int The leading dimension of the array C. ldc >= max(1,m).
     * @param  work   (workspace/output) double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns the
     *                optimal lwork.
     * @param  lwork  input int The dimension of the array work. 
     *                If side = 'L', work >= max(1,n). 
     *                If side = 'R', work >= max(1,m). 
     *                For optimum performance lwork >= n*nb if side = 'L', and lwork >= m*nb if side = 'R',
     *                where nb is optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine only
     *                calculates the optimal size of the work array, returns this value as the first entry of the work
     *                array, and no error message related to lwork is output.
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument had an illegal value
     */
    private void dormqr(char side, char trans, int m, int n, int k, double[][] A, int lda, double[] tau, double[][] C,
                        int ldc, double[] work, int lwork, int[] info) {
        int nbmax = 64;
        int ldt = nbmax + 1;
        boolean left;
        boolean lquery;
        boolean notran;
        int i;
        int i1;
        int i2;
        int i3;
        int ib;
        int ic = 1;
        int[] iinfo = new int[1];
        int iws;
        int jc = 1;
        int ldwork;
        int lwkopt = 1;
        int mi = 1;
        int nb = 1;
        int nbmin;
        int ni = 1;
        int nq;
        int nw;
        double[][] T = new double[ldt][nbmax];
        String name = null;
        String opts = null;
        char[] optsC = new char[2];
        double[][] array1;
        int p;
        int q;
        int row1;
        int row2;
        double[] x;
        double[][] array2;
        double[][] work2d;

        // Test the input arguments
        info[0] = 0;

        if ((side == 'L') || (side == 'l')) {
            left = true;
        } else {
            left = false;
        }

        if ((trans == 'N') || (trans == 'n')) {
            notran = true;
        } else {
            notran = false;
        }

        lquery = (lwork == -1);

        // nq is the order of Q and nw is the minimum dimension of work
        if (left) {
            nq = m;
            nw = n;
        } else {
            nq = n;
            nw = m;
        }

        if ((!left) && (side != 'R') && (side != 'r')) {
            info[0] = -1;
        } else if ((!notran) && (trans != 'T') && (trans != 't')) {
            info[0] = -2;
        } else if (m < 0) {
            info[0] = -3;
        } else if (n < 0) {
            info[0] = -4;
        } else if ((k < 0) || (k > nq)) {
            info[0] = -5;
        } else if (lda < Math.max(1, nq)) {
            info[0] = -7;
        } else if (ldc < Math.max(1, m)) {
            info[0] = -10;
        } else if ((lwork < Math.max(1, nw)) && (!lquery)) {
            info[0] = -12;
        }

        if (info[0] == 0) {

            // Determine the block size.  nb may be at most nbmax, where nbmax
            // is used to define the local array T.
            name = new String("DORMQR");
            optsC[0] = side;
            optsC[1] = trans;
            opts = new String(optsC);
            nb = Math.min(nbmax, ilaenv(1, name, opts, m, n, k, -1));
            lwkopt = Math.max(1, nw) * nb;
            work[0] = lwkopt;
        } // if (info[0] == 0)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dormqr had info[0] = " + info[0]);

            return;
        } else if (lquery) {
            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0) || (k == 0)) {
            work[0] = 1;

            return;
        }

        nbmin = 2;
        ldwork = nw;

        if ((nb > 1) && (nb < k)) {
            iws = nw * nb;

            if (lwork < iws) {
                nb = lwork / ldwork;
                nbmin = Math.max(2, ilaenv(2, name, opts, m, n, k, -1));
            } // if (lwork < iws)
        } // if ((nb > 1) && (nb < k))
        else {
            iws = nw;
        }

        if ((nb < nbmin) || (nb >= k)) {

            // use unblocked code
            dorm2r(side, trans, m, n, k, A, lda, tau, C, ldc, work, iinfo);
        } // if ((nb < nbmin) || (nb >= k))
        else {

            // Use blocked code
            if ((left && (!notran)) || ((!left) && notran)) {
                i1 = 1;
                i2 = k;
                i3 = nb;
            } else {
                i1 = (((k - 1) / nb) * nb) + 1;
                i2 = 1;
                i3 = -nb;
            }

            if (left) {
                ni = n;
                jc = 1;
            } else {
                mi = m;
                ic = 1;
            }

            if (i3 == nb) {

                for (i = i1; i <= i2; i += nb) {
                    ib = Math.min(nb, k - i + 1);

                    // Form the triangular factor of the block reflector
                    // H = H(i-1) H(i) .  .  .  H(i+ib-2)
                    row1 = Math.max(1, nq - i + 1);
                    array1 = new double[row1][ib];

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[i - 1 + p][i - 1 + q];
                        }
                    }

                    x = new double[ib];

                    for (p = 0; p < ib; p++) {
                        x[p] = tau[i - 1 + p];
                    }

                    dlarft('F', 'C', nq - i + 1, ib, array1, row1, x, T, ldt);

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            A[i - 1 + p][i - 1 + q] = array1[p][q];
                        }
                    }

                    if (left) {

                        // H or H' is applied to C(i-1:m-1,0:n-1)
                        mi = m - i + 1;
                        ic = i;
                    } else {

                        // H or H' is applied to C(0:m-1,i-1:n-1)
                        ni = n - i + 1;
                        jc = i;
                    }

                    // Apply H or H'
                    if (left) {
                        row1 = Math.max(1, mi);
                    } else {
                        row1 = Math.max(1, ni);
                    }

                    array1 = new double[row1][ib];

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[i - 1 + p][i - 1 + q];
                        }
                    }

                    row2 = Math.max(1, mi);
                    array2 = new double[row2][ni];

                    for (p = 0; p < row2; p++) {

                        for (q = 0; q < ni; q++) {
                            array2[p][q] = C[ic - 1 + p][jc - 1 + q];
                        }
                    }

                    work2d = new double[ldwork][ib];
                    dlarfb(side, trans, 'F', 'C', mi, ni, ib, array1, row1, T, ldt, array2, row2, work2d, ldwork);

                    for (p = 0; p < row2; p++) {

                        for (q = 0; q < ni; q++) {
                            C[ic - 1 + p][jc - 1 + q] = array2[p][q];
                        }
                    }
                } // for (i = i1; i <= i2; i += nb)
            } // if (i3 == nb)
            else { // i3 == -nb

                for (i = i1; i >= i2; i -= nb) {
                    ib = Math.min(nb, k - i + 1);

                    // Form the triangular factor of the block reflector
                    // H = H(i-1) H(i) .  .  .  H(i+ib-2)
                    row1 = Math.max(1, nq - i + 1);
                    array1 = new double[row1][ib];

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[i - 1 + p][i - 1 + q];
                        }
                    }

                    x = new double[ib];

                    for (p = 0; p < ib; p++) {
                        x[p] = tau[i - 1 + p];
                    }

                    dlarft('F', 'C', nq - i + 1, ib, array1, row1, x, T, ldt);

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            A[i - 1 + p][i - 1 + q] = array1[p][q];
                        }
                    }

                    if (left) {

                        // H or H' is applied to C(i-1:m-1,0:n-1)
                        mi = m - i + 1;
                        ic = i;
                    } else {

                        // H or H' is applied to C(0:m-1,i-1:n-1)
                        ni = n - i + 1;
                        jc = i;
                    }

                    // Apply H or H'
                    if (left) {
                        row1 = Math.max(1, mi);
                    } else {
                        row1 = Math.max(1, ni);
                    }

                    array1 = new double[row1][ib];

                    for (p = 0; p < row1; p++) {

                        for (q = 0; q < ib; q++) {
                            array1[p][q] = A[i - 1 + p][i - 1 + q];
                        }
                    }

                    row2 = Math.max(1, mi);
                    array2 = new double[row2][ni];

                    for (p = 0; p < row2; p++) {

                        for (q = 0; q < ni; q++) {
                            array2[p][q] = C[ic - 1 + p][jc - 1 + q];
                        }
                    }

                    work2d = new double[ldwork][ib];
                    dlarfb(side, trans, 'F', 'C', mi, ni, ib, array1, row1, T, ldt, array2, row2, work2d, ldwork);

                    for (p = 0; p < row2; p++) {

                        for (q = 0; q < ni; q++) {
                            C[ic - 1 + p][jc - 1 + q] = array2[p][q];
                        }
                    }
                } // for (i = i1; i >= i2; i -= nb)
            } // else i3 == -nb
        }

        work[0] = lwkopt;

        return;
    } // dormqr

    /**
     * This is a port of the version 3.1 LAPACK routine DPOTF2 Original DPOTF2 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dpotf2 computes the Cholesky factorization of a real symmetric positive definite matrix A.
     *
     * <p>The factorization has the form 
     *     A = U' * U, if UPLO = 'U', or
     *     A = L * L', if UPLO = 'L',
     * where U is an upper triangular matrix and L is lower triangular</p>
     *
     * <p>This is the unblocked version of the algorithm, calling Level 2 BLAS.</p>
     *
     * @param  uplo  input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
     *               stored. 
     *               = 'U': Upper triangular 
     *               = 'L': Lower triangular
     * @param  n     input int The order of the matrix A. n >= 0.
     * @param  A     input/output double[][] dimension lda by n On entry, the symmetric matrix A. If UPLO = 'U', the
     *               leading n by n upper triangular part of A contains the upper triangular part of the matrix A, and
     *               the strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n by n lower
     *               triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
     *               triangular part of A is not referenced.
     *
     *               <p>On exit, if info[0] = 0, the factor U or L from the Cholesky factorization A = U'*U or A = L*L'.
     *               </p>
     * @param  lda   input int The leading dimension of the array A. lda >= max(1,n).
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info[0] = -k, the k-th argument had an illegal value 
     *               > 0: If info[0] = k, the leading minor of order k is not positive definite,
     *                    and the factorization could not be completed.
     */
    private void dpotf2(char uplo, int n, double[][] A, int lda, int[] info) {
        boolean upper;
        int j;
        double[] dx;
        double ajj;
        int i;
        double[] x;
        double[] y;
        double[][] array1;
        int m;
        int p;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -4;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error in dpotf2 with info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (upper) {

            // Compute the Cholesky factorization A = U'*U
            for (j = 1; j <= n; j++) {

                // Compute U(j-1,j-1) and test for non-positive-definiteness.
                if (j != 1) {
                    dx = new double[j - 1];

                    for (i = 0; i < (j - 1); i++) {
                        dx[i] = A[i][j - 1];
                    }

                    ajj = A[j - 1][j - 1] - ddot(j - 1, dx, 1, dx, 1);
                } // if (j != 1)
                else {
                    ajj = A[0][0];
                }

                if (ajj <= 0.0) {
                    A[j - 1][j - 1] = ajj;
                    info[0] = j;

                    return;
                } // if (ajj <= 0.0)

                ajj = Math.sqrt(ajj);
                A[j - 1][j - 1] = ajj;

                // Compute elements j:n-1 of row j-1
                if (j < n) {
                    y = new double[n - j];

                    for (i = 0; i < (n - j); i++) {
                        y[i] = A[j - 1][j + i];
                    }

                    if (j != 1) {
                        array1 = new double[j - 1][n - j];

                        for (m = 0; m < (j - 1); m++) {

                            for (p = 0; p < (n - j); p++) {
                                array1[m][p] = A[m][p + j];
                            }
                        }

                        x = new double[j - 1];

                        for (i = 0; i < (j - 1); i++) {
                            x[i] = A[i][j - 1];
                        }

                        dgemv('T', j - 1, n - j, -1.0, array1, j - 1, x, 1, 1.0, y, 1);
                    } // if (j != 1)

                    dscal(n - j, 1.0 / ajj, y, 1);

                    for (i = 0; i < (n - j); i++) {
                        A[j - 1][j + i] = y[i];
                    }
                } // if (j < n)
            } // for (j = 1; j <= n; j++)
        } // if (upper)
        else { // lower

            // Compute the Cholesky factorization A = L*L'
            for (j = 1; j <= n; j++) {

                // Compute L(j-1,j-1) and test for non-positive-definiteness
                if (j != 1) {
                    dx = new double[j - 1];

                    for (i = 0; i < (j - 1); i++) {
                        dx[i] = A[j - 1][i];
                    }

                    ajj = A[j - 1][j - 1] - ddot(j - 1, dx, 1, dx, 1);
                } // if (j != 1)
                else {
                    ajj = A[0][0];
                }

                if (ajj <= 0.0) {
                    A[j - 1][j - 1] = ajj;
                    info[0] = j;

                    return;
                } // if (ajj <= 0.0)

                ajj = Math.sqrt(ajj);
                A[j - 1][j - 1] = ajj;

                // Compute elements j:n-1 of column j-1
                if (j < n) {
                    y = new double[n - j];

                    for (i = 0; i < (n - j); i++) {
                        y[i] = A[j + i][j - 1];
                    }

                    if (j != 1) {
                        array1 = new double[n - j][j - 1];

                        for (m = 0; m < (n - j); m++) {

                            for (p = 0; p < (j - 1); p++) {
                                array1[m][p] = A[m + j][p];
                            }
                        }

                        x = new double[j - 1];

                        for (i = 0; i < (j - 1); i++) {
                            x[i] = A[j - 1][i];
                        }

                        dgemv('N', n - j, j - 1, -1.0, array1, n - j, x, 1, 1.0, y, 1);
                    } // if (j != 1)

                    dscal(n - j, 1.0 / ajj, y, 1);

                    for (i = 0; i < (n - j); i++) {
                        A[j + i][j - 1] = y[i];
                    }
                } // if (j < n)
            } // for (j = 1; j <= n; j++)
        } // else lower

        return;
    } // dpotf2

    /**
     * This is a port of the DPOTRF version 3.1 LAPACK routine Original DPOTRF created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dpotrf computes the Cholesky factorization of a real symmetric positive definite matrix A
     *
     * <p>The factorization has the form 
     *        A = U'*U, if uplo = 'U', or 
     *        A = L * L', if uplo = 'L', 
     * where U is an upper triangular matrix and L is lower triangular</p>
     *
     * <p>This is the block version of the algorithm, calling Level 3 BLAS.</p>
     *
     * @param  uplo  input char 
     *         = 'U': Upper triangle of A is stored. 
     *         = 'L': Lower triangle of A is stored.
     * @param  n     input int The order of the matrix A. n >= 0.
     * @param  A     (input/output) double[][] dimension (lda, n) On entry, the symmetric matrix A. If uplo == 'U', the
     *               leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and
     *               the strictly lower triangular part of A is not referenced. If uplo == 'L', the leading n-by-n lower
     *               triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
     *               triangular part of A is not referenced.
     *
     *               <p>On exit, if info[0] = 0, the factor U or L from the Cholesky factorization A = U'*U or A = L*L'.
     *               </p>
     * @param  lda   input int The leading dimension of array A. lda >= max(1,n)
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info[0] = -i, the i-th argument had an illegal value 
     *               > 0: If info[0] = i, the leading minor of order i is not positive definite, and the
     *                    factorization could not be completed.
     */
    private void dpotrf(char uplo, int n, double[][] A, int lda, int[] info) {
        boolean upper;
        String name;
        int nb;
        char[] chArray = new char[1];
        String opts;
        int j;
        int jb;
        int m, p;
        double[][] array1;
        double[][] array2;
        double[][] array3;
        int row1;
        int row2;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } // if ((uplo == 'U') || (uplo == 'u'))
        else {
            upper = false;
        }

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -1;
        } // if ((!upper) && (uplo != 'L') && (uplo != 'l'))
        else if (n < 0) {
            info[0] = -2;
        } // else if (n < 0)
        else if (lda < Math.max(1, n)) {
            info[0] = -4;
        } // else if (lda < Math.max(1,n))

        if (info[0] != 0) {
            MipavUtil.displayError("Error in dpotrf with info[0] = " + info[0]);

            return;
        } // if (info[0] != 0)

        // Quick return if possible
        if (n == 0) {
            return;
        } // if (n == 0)

        name = new String("DPOTRF");
        chArray[0] = uplo;
        opts = new String(chArray);

        // Determine the block size for this environment
        nb = ilaenv(1, name, opts, n, -1, -1, -1);

        if ((nb <= 1) || (nb >= n)) {

            // Use unblocked code
            dpotf2(uplo, n, A, lda, info);
        } // if ((nb <= 1) || (nb >= n))
        else { // Use blocked code

            if (upper) {

                // Compute the Cholesky factorization A = U' * U.
                for (j = 1; j <= n; j += nb) {

                    // Update and factorize the current diagonal block and test for
                    // non-positive-definiteness.
                    jb = Math.min(nb, n - j + 1);
                    row1 = Math.max(1, j - 1);
                    array1 = new double[row1][jb];

                    for (m = 0; m < row1; m++) {

                        for (p = 0; p < jb; p++) {
                            array1[m][p] = A[m][p + j - 1];
                        }
                    }

                    array2 = new double[jb][jb];

                    for (m = 0; m < jb; m++) {

                        for (p = 0; p < jb; p++) {
                            array2[m][p] = A[m + j - 1][p + j - 1];
                        }
                    }

                    dsyrk('U', 'T', jb, j - 1, -1.0, array1, row1, 1.0, array2, jb);
                    dpotf2('U', jb, array2, jb, info);

                    for (m = 0; m < jb; m++) {

                        for (p = 0; p < jb; p++) {
                            A[m + j - 1][p + j - 1] = array2[m][p];
                        }
                    }

                    if (info[0] != 0) {
                        info[0] = info[0] + j - 1;

                        return;
                    }

                    if ((j + jb) <= n) {

                        // Compute the current row block
                        for (m = 0; m < row1; m++) {

                            for (p = 0; p < jb; p++) {
                                array1[m][p] = A[m][p + j - 1];
                            }
                        }

                        row2 = Math.max(1, j - 1);
                        array2 = new double[row2][n - j - jb + 1];

                        for (m = 0; m < row2; m++) {

                            for (p = 0; p < (n - j - jb + 1); p++) {
                                array2[m][p] = A[m][p + j + jb - 1];
                            }
                        }

                        array3 = new double[jb][n - j - jb + 1];

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < (n - j - jb + 1); p++) {
                                array3[m][p] = A[m + j - 1][p + j + jb - 1];
                            }
                        }

                        dgemm('T', 'N', jb, n - j - jb + 1, j - 1, -1.0, array1, row1, array2, row2, 1.0, array3, jb);

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < (n - j - jb + 1); p++) {
                                A[m + j - 1][p + j + jb - 1] = array3[m][p];
                            }
                        }

                        array1 = new double[jb][jb];

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < jb; p++) {
                                array1[m][p] = A[m + j - 1][p + j - 1];
                            }
                        }

                        dtrsm('L', 'U', 'T', 'N', jb, n - j - jb + 1, 1.0, array1, jb, array3, jb);

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < (n - j - jb + 1); p++) {
                                A[m + j - 1][p + j + jb - 1] = array3[m][p];
                            }
                        }
                    } // if ((j + jb) <= n)
                } // for (j = 1; j <= n; j+= nb);
            } // if (upper)
            else { // lower

                // Compute the Cholesky factorization A = L*L'
                for (j = 1; j <= n; j += nb) {

                    // Update and factorize the current diagonal block and test for
                    // non-positive-definiteness.
                    jb = Math.min(nb, n - j + 1);
                    array2 = new double[jb][jb];

                    for (m = 0; m < jb; m++) {

                        for (p = 0; p < jb; p++) {
                            array2[m][p] = A[m + j - 1][p + j - 1];
                        }
                    }

                    if (j != 1) {
                        array1 = new double[jb][j - 1];

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < (j - 1); p++) {
                                array1[m][p] = A[m + j - 1][p];
                            }
                        }

                        dsyrk('L', 'N', jb, j - 1, -1.0, array1, jb, 1.0, array2, jb);
                    } // if (j != 1)

                    dpotf2('L', jb, array2, jb, info);

                    for (m = 0; m < jb; m++) {

                        for (p = 0; p < jb; p++) {
                            A[m + j - 1][p + j - 1] = array2[m][p];
                        }
                    }

                    if (info[0] != 0) {
                        info[0] = info[0] + j - 1;

                        return;
                    } // if (info[0] != 0)

                    if ((j + jb) <= n) {

                        // Compute the current block column
                        array3 = new double[n - j - jb + 1][jb];

                        for (m = 0; m < (n - j - jb + 1); m++) {

                            for (p = 0; p < jb; p++) {
                                array3[m][p] = A[m + j + jb - 1][p + j - 1];
                            }
                        }

                        if (j != 1) {
                            array1 = new double[n - j - jb + 1][j - 1];

                            for (m = 0; m < (n - j - jb + 1); m++) {

                                for (p = 0; p < (j - 1); p++) {
                                    array1[m][p] = A[m + j + jb - 1][p];
                                }
                            }

                            array2 = new double[jb][j - 1];

                            for (m = 0; m < jb; m++) {

                                for (p = 0; p < (j - 1); p++) {
                                    array2[m][p] = A[m + j - 1][p];
                                }
                            }

                            dgemm('N', 'T', n - j - jb + 1, jb, j - 1, -1.0, array1, n - j - jb + 1, array2, jb, 1.0,
                                  array3, n - j - jb + 1);

                            for (m = 0; m < (n - j - jb + 1); m++) {

                                for (p = 0; p < jb; p++) {
                                    A[m + j + jb - 1][p + j - 1] = array3[m][p];
                                }
                            }
                        } // if (j != 1)

                        array1 = new double[jb][jb];

                        for (m = 0; m < jb; m++) {

                            for (p = 0; p < jb; p++) {
                                array1[m][p] = A[m + j - 1][p + j - 1];
                            }
                        }

                        dtrsm('R', 'L', 'T', 'N', n - j - jb + 1, jb, 1.0, array1, jb, array3, n - j - jb + 1);

                        for (m = 0; m < (n - j - jb + 1); m++) {

                            for (p = 0; p < jb; p++) {
                                A[m + j + jb - 1][p + j - 1] = array3[m][p];
                            }
                        }
                    } // if ((j + jb) <= n)
                } // for (j = 1; j <= n; j+= nb)
            } // else lower
        } // else use blocked code

        return;
    } // dpotrf

    /**
     * This is a port of the 3/11/78 linpack routine drot Original code written by Jack Dongarra.
     *
     * @param  n     int
     * @param  dx    double[]
     * @param  incx  int
     * @param  dy    double[]
     * @param  incy  int
     * @param  c     double
     * @param  s     double
     */
    private void drot(int n, double[] dx, int incx, double[] dy, int incy, double c, double s) {
        double dtemp;
        int i;
        int ix;
        int iy;

        if (n <= 0) {
            return;
        }

        if ((incx != 1) || (incy != 1)) {

            // Code for unequal increments or equal increments not equal to 1
            ix = 0;
            iy = 0;

            if (incx < 0) {
                ix = (-n + 1) * incx;
            }

            if (incy < 0) {
                iy = (-n + 1) * incy;
            }

            for (i = 1; i <= n; i++) {
                dtemp = (c * dx[ix]) + (s * dy[iy]);
                dy[iy] = (c * dy[iy]) - (s * dx[ix]);
                dx[ix] = dtemp;
                ix = ix + incx;
                iy = iy + incy;
            } // for (i = 1; i <= n; i++)

            return;
        } // if ((incx != 1) || (incy != 1))

        // Code for both increments equal to 1
        for (i = 0; i < n; i++) {
            dtemp = (c * dx[i]) + (s * dy[i]);
            dy[i] = (c * dy[i]) - (s * dx[i]);
            dx[i] = dtemp;
        } // for (i = 0; i < n; i++)

        return;
    } // drot

    /**
     * Routine ported from 12/3/93 linpack dscal Original version written by Jack Dongarra Scales a vector by a
     * constant.
     *
     * @param  n     int
     * @param  da    double
     * @param  dx    double[]
     * @param  incx  int
     */
    private void dscal(int n, double da, double[] dx, int incx) {
        int nincx;
        int i;
        int m;
        int mp1;

        if ((n <= 0) || (incx <= 0)) {
            return;
        }

        if (incx != 1) {

            // Code for increment not equal to 1
            nincx = n * incx;

            for (i = 0; i < nincx; i += incx) {
                dx[i] = da * dx[i];
            } // for (i = 0; i < nincx; i += incx)

            return;
        } // if (incx != 1)

        // Code for increment equal to 1
        m = n % 5;

        if (m != 0) {

            for (i = 0; i < m; i++) {
                dx[i] = da * dx[i];
            }

            if (n < 5) {
                return;
            }
        } // if (m != 0)

        mp1 = m + 1;

        for (i = mp1; i <= n; i += 5) {
            dx[i - 1] = da * dx[i - 1];
            dx[i] = da * dx[i];
            dx[i + 1] = da * dx[i + 1];
            dx[i + 2] = da * dx[i + 2];
            dx[i + 3] = da * dx[i + 3];
        } // for (i = mp1; i <= n; i+= 5)

        return;
    } // dscal

    /**
     * This is a port of the version 3.1 LAPACK test routine DSGT01 Original DSGT01 created by Univ. of Tennessee, Univ.
     * of California Berkeley, and NAG Ltd., November, 2006
     * dsgt01 checks a decomposition of the form A Z = B Z D or A B Z = Z D or B A Z = Z D where A is a symmetric
     * matrix, B is symmetric positive definite, Z is orthogonal, and D is diagonal. One of the following test ratios is
     * computed:
     * itype = 1: result[0] = | A Z - B Z D | / ( |A| |Z| n ulp )
     * itype = 2: result[0] = | A B Z - Z D | / ( |A| |Z| n ulp )
     * itype = 3: result[0] = | B A Z - Z D | / ( |A| |Z| n ulp )
     *
     * @param  itype   input int The form of the symmetric generalized eigenproblem.
     *                 = 1: A*Z = (lambda)*B*Z 
     *                 = 2: A*B*Z = (lambda)*Z
     *                 = 3: B*A*Z = (lambda)*Z
     * @param  uplo    input char Specifies whether the upper or lower triangular part of the symmetric matrices A and B
     *                 is stored. 
     *                 = 'U': Upper triangular
     *                 = 'L': Lower triangular
     * @param  n       input int The order of the matrix A. n >= 0.
     * @param  m       input int The number of eigenvalues found. 0 <= m <= n.
     * @param  A       input double[][] of dimension (lda,n). The original symmetric matrix A.
     * @param  lda     input int The leading dimension of the array A. lda >= max(1,n).
     * @param  B       input double[][] of dimension (ldb,n). The original symmetric positive definite matrix B.
     * @param  ldb     input int The leading dimension of the array B. ldb >= max(1,n).
     * @param  Z       input double[][] of dimension (ldz,m). The computed eigenvectors of the generalized eigenproblem.
     * @param  ldz     input int The leading dimension of the array Z. ldz >= max(1,n).
     * @param  D       input double[] of dimension m. The computed eigenvalues of the generalized eigenproblem.
     * @param  work    workspace double[] of dimension n*n.
     * @param  result  output double[] of dimension 1. The test ratio as described above.
     */
    private void dsgt01(int itype, char uplo, int n, int m, double[][] A, int lda, double[][] B, int ldb, double[][] Z,
                        int ldz, double[] D, double[] work, double[] result) {
        int i;
        int j;
        double anorm;
        double ulp;
        double[][] work2D = new double[n][n];

        result[0] = 0.0;

        if (n <= 0) {
            return;
        }

        ulp = dlamch('E');

        // Compute product of 1-norms of A and Z.
        anorm = dlansy('1', uplo, n, A, lda, work) * dlange('1', n, m, Z, ldz, work);

        if (anorm == 0.0) {
            anorm = 1.0;
        }

        if (itype == 1) {

            // Norm of AZ - BZD
            dsymm('L', uplo, n, m, 1.0, A, lda, Z, ldz, 0.0, work2D, n);

            for (i = 0; i < m; i++) {

                for (j = 0; j < n; j++) {
                    Z[j][i] = D[i] * Z[j][i];
                }
            }

            dsymm('L', uplo, n, m, 1.0, B, ldb, Z, ldz, -1.0, work2D, n);

            for (i = 0; i < n; i++) {

                for (j = 0; j < n; j++) {
                    work[i + (n * j)] = work2D[i][j];
                }
            }

            result[0] = (dlange('1', n, m, work2D, n, work) / anorm) / (n * ulp);
        } // if (itype == 1)
        else if (itype == 2) {

            // Norm of ABZ - ZD
            dsymm('L', uplo, n, m, 1.0, B, ldb, Z, ldz, 0.0, work2D, n);

            for (i = 0; i < m; i++) {

                for (j = 0; j < n; j++) {
                    Z[j][i] = D[i] * Z[j][i];
                }
            }

            dsymm('L', uplo, n, m, 1.0, A, lda, work2D, n, -1.0, Z, ldz);

            for (i = 0; i < n; i++) {

                for (j = 0; j < n; j++) {
                    work[i + (n * j)] = work2D[i][j];
                }
            }

            result[0] = (dlange('1', n, m, Z, ldz, work) / anorm) / (n * ulp);
        } // else if (itype == 2)
        else { // itype == 3

            // Norm of BAZ - ZD
            dsymm('L', uplo, n, m, 1.0, A, lda, Z, ldz, 0.0, work2D, n);

            for (i = 0; i < m; i++) {

                for (j = 0; j < n; j++) {
                    Z[j][i] = D[i] * Z[j][i];
                }
            }

            dsymm('L', uplo, n, m, 1.0, B, ldb, work2D, n, -1.0, Z, ldz);

            for (i = 0; i < n; i++) {

                for (j = 0; j < n; j++) {
                    work[i + (n * j)] = work2D[i][j];
                }
            }

            result[0] = (dlange('1', n, m, Z, ldz, work) / anorm) / (n * ulp);
        } // else itype == 3

        return;
    } // dsgt01

    /**
     * This is a port of version 3.1 LAPACK test routine DSTECH Original DSTECH created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * Let T be the tridiagonal matrix with diagonal entries A[0] ,..., A[n-1] and offdiagonal entries B[0] ,..., B[n-2]).
     * dstech checks to see if eig[0], ..., eig[n-1] are indeed accurate eigenvalues of T. It does this by expanding
     * each eig[i] into an interval [svd[i] - eps, svd[i] + eps], merging overlapping intervals if any, and using Sturm
     * sequences to count and verify whether each resulting interval has the correct number of eigenvalues (using
     * dstect). Here eps = tol * mazheps * maxeig, where macheps is the machine precision and maxeig is the absolute
     * value of the largest eigenvalue. If each interval contains the correct number of eigenvalues, info[0] = 0 is
     * returned, otherwise info is the index of the first eigenvalue in the first bad interval.
     *
     * @param  n     (input) int The dimension of the tridiagonal matrix T.
     * @param  A     (input) double[] of dimension (n) The diagonal entries of the tridiagonal matrix T.
     * @param  B     (input) double[] of dimension (n-1) The offdiagonal entries of the tridiagonal matrix T.
     * @param  eig   (input) double[] of dimension (n) The purported eigenvalues to be checked.
     * @param  tol   double Error tolerance for checking, a multiple of the machine precision.
     * @param  work  (workspace) double[] of dimension (n)
     * @param  info  (output) int[] 
     *               0 if the eigenvalues are all correct (to within 1 +- tol*mazheps*maxeig 
     *               >0 if the interval containing the info-th eigenvalue contains the incorrect
     *                  number of eigenvalues.
     */
    private void dstech(int n, double[] A, double[] B, double[] eig, double tol, double[] work, int[] info) {
        int bpnt;
        int count;
        int i;
        int isub;
        int j;
        int[] numl = new int[1];
        int[] numu = new int[1];
        int tpnt;
        double emin;
        double eps;
        double lower;
        double mx;
        double tuppr;
        double unflep;
        double upper;

        // Check input parameters
        info[0] = 0;

        if (n == 0) {
            return;
        }

        if (n < 0) {
            info[0] = -1;

            return;
        }

        if (tol < 0) {
            info[0] = -5;

            return;
        }

        // Get machine constants
        eps = dlamch('E') * dlamch('B');
        unflep = dlamch('S') / eps;
        eps = tol * eps;

        // Compute maximum absolute eigenvalue, error tolerance
        mx = Math.abs(eig[0]);

        for (i = 1; i < n; i++) {
            mx = Math.max(mx, Math.abs(eig[i]));
        }

        eps = Math.max(eps * mx, unflep);

        // Sort eigenvalues from eig into work
        for (i = 0; i < n; i++) {
            work[i] = eig[i];
        }

        for (i = 1; i <= (n - 1); i++) {
            isub = 1;
            emin = work[0];

            for (j = 2; j <= (n + 1 - i); j++) {

                if (work[j - 1] < emin) {
                    isub = j;
                    emin = work[j - 1];
                } // if (work[j-1] < emin)
            } // for (j = 2; j <= n+1-i; j++)

            if (isub != (n + 1 - i)) {
                work[isub - 1] = work[n - i];
                work[n - i] = emin;
            } // if (isub != (n+1-i))
        } // for (i = 1; i <= n-1; i++)

        // tpnt points to singular value at right endpoint of interval
        // bpnt points to singular value at left endpoint of interval
        tpnt = 1;
        bpnt = 1;

        // Begin loop over all intervals
        do {
            upper = work[tpnt - 1] + eps;
            lower = work[bpnt - 1] - eps;

            // Begin loop merging overlapping intervals
            do {

                if (bpnt == n) {
                    break;
                }

                tuppr = work[bpnt] + eps;

                if (tuppr < lower) {
                    break;
                }

                // Merge
                bpnt = bpnt + 1;
                lower = work[bpnt - 1] - eps;
            } while (true);

            // Count singular values in interval [lower, upper]
            dstect(n, A, B, lower, numl);
            dstect(n, A, B, upper, numu);
            count = numu[0] - numl[0];

            if (count != (bpnt - tpnt + 1)) {

                // Wrong number of singular values in interval
                info[0] = tpnt;

                return;
            } // if (count != (bpnt - tpnt + 1))

            tpnt = bpnt + 1;
            bpnt = tpnt;
        } while (tpnt <= n);

        return;
    } // dstech

    /**
     * This is a port of version 3.1 LAPACK test routine DSTECT Original DSTECT created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dstect counts the number num of eigenvalues of a tridiagonal matrix T which are less than or equal to shift. T
     * has diagonal entries A[0], ... , A[n-1], and offdiagonal entries B[0], ..., B[n-1]. See W. Kahan "Accurate
     * Eigenvalues of a Symmetric TriDiagonal Matrix", Report CS41, Computer Science Department, Stanford University,
     * July 21, 1966
     *
     * @param  n      (input) int The dimension of the tridiagonal matrix T.
     * @param  A      (input) double[] of dimension (n) The diagonal entries of the tridiagonal matrix T.
     * @param  B      (input) double[] of dimension (n-1) The offdiagonal entries of the tridiagonal matrix T.
     * @param  shift  (input) double The shift used.
     * @param  num    (output) int[] The number of eigenvalues of T less than or equal to shift.
     */
    private void dstect(int n, double[] A, double[] B, double shift, int[] num) {
        int i;
        double m1;
        double m2;
        double mx;
        double ovfl;
        double sov;
        double sshift;
        double ssun;
        double sun;
        double tmp;
        double tom;
        double u;
        double unfl;

        // Get machine constants
        unfl = dlamch('S');
        ovfl = dlamch('O');

        // Find largest entry
        mx = Math.abs(A[0]);

        for (i = 0; i < (n - 1); i++) {
            mx = Math.max(mx, Math.abs(A[i + 1]));
            mx = Math.max(mx, Math.abs(B[i]));
        } // for (i = 0; i < n-1; i++)

        // Handle easy cases, including zero matrix
        if (shift >= (3.0 * mx)) {
            num[0] = n;

            return;
        }

        if (shift < (-3.0 * mx)) {
            num[0] = 0;

            return;
        }

        // Compute scale factors as in Kahan's report
        // At this point, mx != 0 so we can divide by it
        sun = Math.sqrt(unfl);
        ssun = Math.sqrt(sun);
        sov = Math.sqrt(ovfl);
        tom = ssun * sov;

        if (mx <= 1.0) {
            m1 = 1.0 / mx;
            m2 = tom;
        } else {
            m1 = 1.0;
            m2 = tom / mx;
        }

        // Begin counting
        num[0] = 0;
        sshift = (shift * m1) * m2;
        u = ((A[0] * m1) * m2) - sshift;

        if (u <= sun) {

            if (u <= 0.0) {
                num[0] = num[0] + 1;

                if (u > -sun) {
                    u = -sun;
                }
            } // if (u <= 0.0)
            else { // u  > 0.0
                u = sun;
            } // else u > 0.0
        } // if (u <= sun)

        for (i = 1; i < n; i++) {
            tmp = (B[i - 1] * m1) * m2;
            u = (((A[i] * m1) * m2) - (tmp * (tmp / u))) - sshift;

            if (u <= sun) {

                if (u <= 0.0) {
                    num[0] = num[0] + 1;

                    if (u > -sun) {
                        u = -sun;
                    }
                } // if (u <= 0.0)
                else { // u > 0.0
                    u = sun;
                } // else u > 0.0
            } // if (u <= sun)
        } // for (i = 1; i < n; i++)

        return;
    } // dstect

    /**
     * This is a port of version 3.1 LAPACK routine DSTEQR Original DSTEQR created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsteqr computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the
     * implicit QL or QR method. The eigenvectors of a full or band symmetric matrix can also be found if dsytrd or
     * dsptrd or dsbtrd has been used to reduce this matrix to tridiagonal form.
     *
     * @param  compz  input char 
     *                = 'N': Compute eigenvalues only. 
     *                = 'V': Compute eigenvalues and eigenvectors of the original symmetric matrix. 
     *                       On entry, Z must contain the orthogonal matrix used to reduce the original matrix to
     *                       tridiagonal form. 
     *                = 'I': Compute eigenvalues and eigenvectors of the tridiagonal matrix. 
     *                       Z is initialized to the identity matrix.
     * @param  n      input int The order of the matrix. n >= 0.
     * @param  d      input/output double[] of dimension n. On entry, the diagonal elements of the tridiagonal matrix.
     *                On exit, if info = 0, the eigenvalues in ascending order.
     * @param  e      input/output double[] of dimension n-1 On entry, the (n-1) subdiagonal elements of the tridiagonal
     *                matrix. On exit, e has been destroyed.
     * @param  Z      input/output double[][] of dimension ldz by n. On entry, if compz = 'V', then Z contains the
     *                orthogonal matrix used in reduction to tridiagonal form. On exit, if info[0] = 0, then if compz =
     *                'V', Z contains the orthonormal eigenvectors of the original symmetric matrix. and if compz = 'I',
     *                Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix. If compz = 'N', then
     *                Z is not referenced.
     * @param  ldz    input int The leading dimension of the array Z. ldz >= 1, and if eigenvectors are desired, then
     *                ldz >= max(1,n).
     * @param  work   workspace double[] of dimension max(1,2*n-2). If compz = 'N', then work is not referenced.
     * @param  info   output int[] 
     *                = 0: successful exit. 
     *                < 0: If info[0] = -i, then the i-th argument had an illegal value 
     *                > 0: The algorithm failed to find all the eigenvalues in a total of 30*n iterations; if
     *                     info[0]= i, then i elements of e have not converged to zero; on exit, d and e contain
     *                     the elements of a symmetric tridiagonal matrix which is orthogonally similar to the
     *                     original matrix.
     */
    private void dsteqr(char compz, int n, double[] d, double[] e, double[][] Z, int ldz, double[] work, int[] info) {
        int maxit = 30;
        int i;
        int icompz;
        int ii;
        int iscale;
        int j;
        int jtot;
        int k;
        int L;
        int L1;
        int lend;
        int lendm1;
        int lendp1;
        int lendsv;
        int lm1;
        int lsv;
        int m;
        int mm;
        int mm1;
        int nm1;
        int nmaxit;
        int ptr1;
        int ptr2;
        double anorm;
        double b;
        double[] c = new double[1];
        double eps;
        double eps2;
        double f;
        double g;
        double p;
        double[] r = new double[1];
        double[] rt1 = new double[1];
        ;

        double[] rt2 = new double[1];
        double[] s = new double[1];
        double safmax;
        double safmin;
        double ssfmax;
        double ssfmin;
        double tst;
        double[] vector1;
        double[] vector2;
        double[][] array1;
        double val;

        // Test the input parameters
        info[0] = 0;

        if ((compz == 'N') || (compz == 'n')) {
            icompz = 0;
        } else if ((compz == 'V') || (compz == 'v')) {
            icompz = 1;
        } else if ((compz == 'I') || (compz == 'i')) {
            icompz = 2;
        } else {
            icompz = -1;
        }

        if (icompz < 0) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if ((ldz < 1) || ((icompz > 0) && (ldz < Math.max(1, n)))) {
            info[0] = -6;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsteqr had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (n == 1) {

            if (icompz == 2) {
                Z[0][0] = 1.0;
            }

            return;
        } // if (n == 1)

        // Determine the unit roundoff and over/underflow thresholds.
        eps = dlamch('E');
        eps2 = eps * eps;
        safmin = dlamch('S');
        safmax = 1.0 / safmin;
        ssfmax = Math.sqrt(safmax) / 3.0;
        ssfmin = Math.sqrt(safmin) / eps2;

        // Compute the eigenvalues and eigenvectors of the tridiagonal matrix.
        if (icompz == 2) {
            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
        }

        nmaxit = n * maxit;
        jtot = 0;

        // Determine where the matrix splits and choose QL or QR iteration for
        // each block, according to whether top or bottom diagonal element is
        // smaller.
        L1 = 1;
        nm1 = n - 1;

primary:  {

//loop1:
            do {

//loop2:
                do {

//loop3:
                    do {

                        if (L1 > n) {
                            break primary;
                        } // if (L1 > n)

                        if (L1 > 1) {
                            e[L1 - 2] = 0.0;
                        } // if (L1 > 1)

set4:                    {

                            if (L1 <= nm1) {

                                for (m = L1; m <= nm1; m++) {
                                    tst = Math.abs(e[m - 1]);

                                    if (tst == 0.0) {
                                        break set4;
                                    } // if (test == 0.0)

                                    if (tst <= (Math.sqrt(Math.abs(d[m - 1])) * Math.sqrt(Math.abs(d[m])) * eps)) {
                                        e[m - 1] = 0.0;

                                        break set4;
                                    } // if (tst <= (Math.sqrt(Math.abs(d[m-1])) *
                                } // for (m = L1; m <= nm1; m++)
                            } // if (L1 <= nm1)

                            m = n;
                        } // set4

                        L = L1;
                        lsv = L;
                        lend = m;
                        lendsv = lend;
                        L1 = m + 1;
                    } // loop3
                    while (lend == L);

                    // Scale submatrix in rows and columns L-1 to lend-1.
                    vector1 = new double[lend - L + 1];

                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
                        vector1[ptr1] = d[ptr1 + L - 1];
                    }

                    vector2 = new double[lend - L];

                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
                        vector2[ptr1] = e[ptr1 + L - 1];
                    }

                    anorm = dlanst('I', lend - L + 1, vector1, vector2);
                    iscale = 0;
                } // loop2
                while (anorm == 0.0);

                if (anorm > ssfmax) {
                    iscale = 1;
                    array1 = new double[lend - L + 1][1];

                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
                        array1[ptr1][0] = d[ptr1 + L - 1];
                    }

                    dlascl('G', 0, 0, anorm, ssfmax, lend - L + 1, 1, array1, lend - L + 1, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #1 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
                        d[ptr1 + L - 1] = array1[ptr1][0];
                    }

                    array1 = new double[lend - L][1];

                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
                        array1[ptr1][0] = e[ptr1 + L - 1];
                    }

                    dlascl('G', 0, 0, anorm, ssfmax, lend - L, 1, array1, lend - L, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #2 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
                        e[ptr1 + L - 1] = array1[ptr1][0];
                    }
                } // if (anorm > ssfmax)
                else if (anorm < ssfmin) {
                    iscale = 2;
                    array1 = new double[lend - L + 1][1];

                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
                        array1[ptr1][0] = d[ptr1 + L - 1];
                    }

                    dlascl('G', 0, 0, anorm, ssfmin, lend - L + 1, 1, array1, lend - L + 1, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #3 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
                        d[ptr1 + L - 1] = array1[ptr1][0];
                    }

                    array1 = new double[lend - L][1];

                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
                        array1[ptr1][0] = e[ptr1 + L - 1];
                    }

                    dlascl('G', 0, 0, anorm, ssfmin, lend - L, 1, array1, lend - L, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #4 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
                        e[ptr1 + L - 1] = array1[ptr1][0];
                    }
                } // else if (anorm < ssfmin)

                // Choose between QL and QR iteration
                if (Math.abs(d[lend - 1]) < Math.abs(d[L - 1])) {
                    lend = lsv;
                    L = lendsv;
                } // if (Math.abs(d[lend-1]) < Math.abs(d[L-1]))

set5:            {

                    if (lend > L) {

// QL iteration
// Look for small subdiagonal element
//loop6:
                        do {

loop7:
                            do {

set8:                            {

                                    if (L != lend) {
                                        lendm1 = lend - 1;

                                        for (m = L; m <= lendm1; m++) {
                                            tst = e[m - 1] * e[m - 1];

                                            if (tst <= ((eps2 * Math.abs(d[m - 1]) * Math.abs(d[m])) + safmin)) {
                                                break set8;
                                            } // if (tst <= (eps2 * Math.abs(d[m-1]) *
                                        } // for (m = L; m <= lendm1; m++)
                                    } // if (L != lend)

                                    m = lend;
                                } // set8

                                if (m < lend) {
                                    e[m - 1] = 0.0;
                                } // if (m < lend)

                                p = d[L - 1];

                                if (m == L) {
                                    break loop7;
                                } // if (m == L)

                                // If the remaining matrix is 2-by-2, use dlae2 or dlaev2
                                // to compute its eigensystem.
                                if (m == (L + 1)) {

                                    if (icompz > 0) {
                                        dlaev2(d[L - 1], e[L - 1], d[L], rt1, rt2, c, s);
                                        array1 = new double[n][2];

                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
                                                array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 1];
                                            }
                                        }

                                        dlasr('R', 'V', 'B', n, 2, c, s, array1, n);

                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
                                                Z[ptr1][ptr2 + L - 1] = array1[ptr1][ptr2];
                                            }
                                        }
                                    } // if (icompz > 0)
                                    else {
                                        dlae2(d[L - 1], e[L - 1], d[L], rt1, rt2);
                                    }

                                    d[L - 1] = rt1[0];
                                    d[L] = rt2[0];
                                    e[L - 1] = 0.0;
                                    L = L + 2;

                                    if (L <= lend) {
                                        continue loop7;
                                    }

                                    break set5;
                                } // if (m == (L+1))

                                if (jtot == nmaxit) {
                                    break set5;
                                } // if (jtot == nmaxit)

                                jtot = jtot + 1;

                                // Form shift
                                g = (d[L] - p) / (2.0 * e[L - 1]);
                                r[0] = dlapy2(g, 1.0);

                                if (g >= 0) {
                                    val = Math.abs(r[0]);
                                } else {
                                    val = -Math.abs(r[0]);
                                }

                                g = d[m - 1] - p + (e[L - 1] / (g + val));
                                s[0] = 1.0;
                                c[0] = 1.0;
                                p = 0.0;

                                // Inner loop
                                mm1 = m - 1;
                                vector1 = new double[m - L];
                                vector2 = new double[m - L];

                                for (i = mm1; i >= L; i--) {
                                    f = s[0] * e[i - 1];
                                    b = c[0] * e[i - 1];
                                    dlartg(g, f, c, s, r);

                                    if (i != (m - 1)) {
                                        e[i] = r[0];
                                    } // if (i != (m-1))

                                    g = d[i] - p;
                                    r[0] = ((d[i - 1] - g) * s[0]) + (2.0 * c[0] * b);
                                    p = s[0] * r[0];
                                    d[i] = g + p;
                                    g = (c[0] * r[0]) - b;

                                    // If eigenvectors are desired, then save rotations
                                    if (icompz > 0) {
                                        vector1[i - L] = c[0];
                                        vector2[i - L] = -s[0];
                                    } // if (icompz > 0)
                                } // for (i = mm1; i >= L; i--)

                                // If eigenvectors are desired, then apply saved rotations.
                                if (icompz > 0) {
                                    mm = m - L + 1;
                                    array1 = new double[n][mm];

                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
                                            array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 1];
                                        }
                                    }

                                    dlasr('R', 'V', 'B', n, mm, vector1, vector2, array1, n);

                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
                                            Z[ptr1][ptr2 + L - 1] = array1[ptr1][ptr2];
                                        }
                                    }
                                } // if (icompz > 0)

                                d[L - 1] = d[L - 1] - p;
                                e[L - 1] = g;
                            } // loop7
                            while (true);

                            // Eigenvalue found
                            d[L - 1] = p;
                            L = L + 1;
                        } // loop6
                        while (L <= lend);
                    } // if (lend > L)
                    else {

// QR iteration
// Look for small superdiagonal element
//loop9:
                        do {

loop10:
                            do {

set11:                           {

                                    if (L != lend) {
                                        lendp1 = lend + 1;

                                        for (m = L; m >= lendp1; m--) {
                                            tst = e[m - 2] * e[m - 2];

                                            if (tst <= ((eps2 * Math.abs(d[m - 1]) * Math.abs(d[m - 2])) + safmin)) {
                                                break set11;
                                            } // if (tst <= (eps2 * Math.abs(d[m-1]) *
                                        } // for (m = L; m >= lendp1; m--)
                                    } // if (L != lend)

                                    m = lend;
                                } // set11

                                if (m > lend) {
                                    e[m - 2] = 0.0;
                                } // if (m > lend)

                                p = d[L - 1];

                                if (m == L) {
                                    break loop10;
                                } // if (m == L)

                                // If the remaining matrix is 2-by-2, use dlae2 or dlaev2
                                // to compute its eigensystem.
                                if (m == (L - 1)) {

                                    if (icompz > 0) {
                                        dlaev2(d[L - 2], e[L - 2], d[L - 1], rt1, rt2, c, s);
                                        array1 = new double[n][2];

                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
                                                array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 2];
                                            }
                                        }

                                        dlasr('R', 'V', 'F', n, 2, c, s, array1, n);

                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
                                                Z[ptr1][ptr2 + L - 2] = array1[ptr1][ptr2];
                                            }
                                        }
                                    } // if (icompz > 0)
                                    else {
                                        dlae2(d[L - 2], e[L - 2], d[L - 1], rt1, rt2);
                                    }

                                    d[L - 2] = rt1[0];
                                    d[L - 1] = rt2[0];
                                    e[L - 2] = 0.0;
                                    L = L - 2;

                                    if (L >= lend) {
                                        continue loop10;
                                    } // if (L >= lend)

                                    break set5;
                                } // if (m == (L-1))

                                if (jtot == nmaxit) {
                                    break set5;
                                } // if (jtot == nmaxit)

                                jtot = jtot + 1;

                                // Form shift.
                                g = (d[L - 2] - p) / (2.0 * e[L - 2]);
                                r[0] = dlapy2(g, 1.0);

                                if (g >= 0.0) {
                                    val = Math.abs(r[0]);
                                } else {
                                    val = -Math.abs(r[0]);
                                }

                                g = d[m - 1] - p + (e[L - 2] / (g + val));

                                s[0] = 1.0;
                                c[0] = 1.0;
                                p = 0.0;

                                // Inner loop
                                lm1 = L - 1;
                                vector1 = new double[L - m];
                                vector2 = new double[L - m];

                                for (i = m; i <= lm1; i++) {
                                    f = s[0] * e[i - 1];
                                    b = c[0] * e[i - 1];
                                    dlartg(g, f, c, s, r);

                                    if (i != m) {
                                        e[i - 2] = r[0];
                                    } // if (i != m)

                                    g = d[i - 1] - p;
                                    r[0] = ((d[i] - g) * s[0]) + (2.0 * c[0] * b);
                                    p = s[0] * r[0];
                                    d[i - 1] = g + p;
                                    g = (c[0] * r[0]) - b;

                                    // If eigenvalues are desired, then save rotations
                                    if (icompz > 0) {
                                        vector1[i - m] = c[0];
                                        vector2[i - m] = s[0];
                                    } // if (icompz > 0)
                                } // for (i = m; i <= lm1; i++)

                                // If eigenvectors are desired, then apply saved rotations
                                if (icompz > 0) {
                                    mm = L - m + 1;
                                    array1 = new double[n][mm];

                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
                                            array1[ptr1][ptr2] = Z[ptr1][ptr2 + m - 1];
                                        }
                                    }

                                    dlasr('R', 'V', 'F', n, mm, vector1, vector2, array1, n);

                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
                                            Z[ptr1][ptr2 + m - 1] = array1[ptr1][ptr2];
                                        }
                                    }
                                } // if (icompz > 0)

                                d[L - 1] = d[L - 1] - p;
                                e[lm1 - 1] = g;
                            } // loop10
                            while (true);

                            // Eigenvalue found.
                            d[L - 1] = p;
                            L = L - 1;
                        } // loop9
                        while (L >= lend);
                    } // else QR iteration
                } // set5

                // Undo scaling if necessary
                if (iscale == 1) {
                    array1 = new double[lendsv - lsv + 1][1];

                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
                        array1[ptr1][0] = d[ptr1 + lsv - 1];
                    }

                    dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #5 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
                        d[ptr1 + lsv - 1] = array1[ptr1][0];
                    }

                    array1 = new double[lendsv - lsv][1];

                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
                        array1[ptr1][0] = e[ptr1 + lsv - 1];
                    }

                    dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv, 1, array1, lendsv - lsv, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #6 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
                        e[ptr1 + lsv - 1] = array1[ptr1][0];
                    }
                } // if (iscale == 1)
                else if (iscale == 2) {
                    array1 = new double[lendsv - lsv + 1][1];

                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
                        array1[ptr1][0] = d[ptr1 + lsv - 1];
                    }

                    dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #7 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
                        d[ptr1 + lsv - 1] = array1[ptr1][0];
                    }

                    array1 = new double[lendsv - lsv][1];

                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
                        array1[ptr1][0] = e[ptr1 + lsv - 1];
                    }

                    dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv, 1, array1, lendsv - lsv, info);

                    if (info[0] != 0) {
                        UI.setDataText("dsteqr call to dlascl #8 had info[0] = " + info[0] + "\n");
                    }

                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
                        e[ptr1 + lsv - 1] = array1[ptr1][0];
                    }
                } // else if (iscale == 2)

                // Check for no convergence to an eigenvalue after a total of
                // n*maxit iterations
            } // loop1
            while (jtot < nmaxit);

            for (i = 0; i < (n - 1); i++) {

                if (e[i] != 0.0) {
                    info[0] = info[0] + 1;
                }
            } // for (i = 0; i < n-1; i++)

            if (info[0] != 0) {
                UI.setDataText("dsteqr nonzero e produced info[0] = " + info[0] + "\n");
            }

            return;
        } // primary

        // Order eigenvalues and eigenvectors.
        if (icompz == 0) {

            // Use quick sort
            dlasrt('I', n, d, info);

            if (info[0] != 0) {
                UI.setDataText("dsteqr call to dlasrt produced info[0] = " + info[0] + "\n");
            }
        } // if (icompz == 0)
        else { // icompz != 0

            // Use selection sort to minimize swaps of eigenvectors
            for (ii = 2; ii <= n; ii++) {
                i = ii - 1;
                k = i;
                p = d[i - 1];

                for (j = ii; j <= n; j++) {

                    if (d[j - 1] < p) {
                        k = j;
                        p = d[j - 1];
                    } // if (d[j-1] < p)
                } // for (j == ii; j <= n; j++)

                if (k != i) {
                    d[k - 1] = d[i - 1];
                    d[i - 1] = p;

                    for (ptr1 = 0; ptr1 < n; ptr1++) {
                        val = Z[ptr1][i - 1];
                        Z[ptr1][i - 1] = Z[ptr1][k - 1];
                        Z[ptr1][k - 1] = val;
                    } // for (ptr1 = 0; ptr1 < n; ptr1++)
                } // if (k != i)
            } // for (ii = 2; ii <= n; ii++)
        } // else icompz != 0

        return;
    } // dsteqr

    /**
     * This is a port of version 3.1 LAPACK routine DSTERF Original DSTERF created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsterf computes all the eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of
     * the QL or QR algorithm.
     *
     * @param  n     input int The order of the matrix. n >= 0.
     * @param  d     input/output double[] of dimension n. On entry, the n diagonal elements of the tridiagonal matrix.
     *               On exit, if info[0] = 0, the eigenvalues in ascending order
     * @param  e     input/order double[] of dimension n-1 On entry, the (n-1) subdiagonal elements in the tridiagonal
     *               matrix. On exit, e has been destroyed.
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info[0] = -i, the i-th argument had an illegal value 
     *               > 0: The algorithm failed to find all of the eigenvalues in a total of 30*n iterations;
     *                    if info = i, then i elements of e have not converged to zero.
     */
    private void dsterf(int n, double[] d, double[] e, int[] info) {
        int maxit = 30;
        int i;
        int iscale;
        int jtot;
        int L;
        int L1;
        int lend;
        int lendsv;
        int lsv;
        int m;
        int nmaxit;
        double alpha;
        double anorm;
        double bb;
        double c;
        double eps;
        double eps2;
        double gamma;
        double oldc;
        double oldgam;
        double p;
        double r;
        double[] rt1 = new double[1];
        double[] rt2 = new double[2];
        double rte;
        double s;
        double safmax;
        double safmin;
        double sigma;
        double ssfmax;
        double ssfmin;
        double[] vector1;
        double[] vector2;
        double[][] array1;

        info[0] = 0;

        // Test the input parameters
        if (n < 0) {
            info[0] = -1;
            MipavUtil.displayError("Error dsterf had n < 0");

            return;
        }

        // Quick return if possible
        if (n <= 1) {
            return;
        }

        // Determine the unit roundoff for this environment
        eps = dlamch('E');
        eps2 = eps * eps;
        safmin = dlamch('S');
        safmax = 1.0 / safmin;
        ssfmax = Math.sqrt(safmax) / 3.0;
        ssfmin = Math.sqrt(safmin) / eps2;

        // Compute the eigenvalues of the tridiagonal matrix
        nmaxit = n * maxit;
        sigma = 0.0;
        jtot = 0;

        // Determine where the matrix splits and choose QL or QR iteration for
        // each block, according to whether top or bottom diagonal element is
        // smaller
        L1 = 1;

primary:
        do {

            if (L1 > n) {
                dlasrt('I', n, d, info);

                return;
            } // if (L1 > n)

            if (L1 > 1) {
                e[L1 - 2] = 0.0;
            } // if (L1 > 1)

loop1:       {

                for (m = L1; m <= (n - 1); m++) {

                    if (Math.abs(e[m - 1]) <= ((Math.sqrt(Math.abs(d[m - 1])) * Math.sqrt(Math.abs(d[m]))) * eps)) {
                        e[m - 1] = 0.0;

                        break loop1;
                    }
                } // for (m = L1; m <= n-1; m++)

                m = n;
            } // loop1

            L = L1;
            lsv = L;
            lend = m;
            lendsv = lend;
            L1 = m + 1;

            if (lend == L) {
                continue primary;
            }

            // Scale submatrix in rows and columns L-1 to lend - 1
            vector1 = new double[lend - L + 1];

            for (i = 0; i < (lend - L + 1); i++) {
                vector1[i] = d[i + L - 1];
            }

            vector2 = new double[lend - L];

            for (i = 0; i < (lend - L); i++) {
                vector2[i] = e[i + L - 1];
            }

            anorm = dlanst('I', lend - L + 1, vector1, vector2);
            iscale = 0;

            if (anorm > ssfmax) {
                iscale = 1;
                array1 = new double[lend - L + 1][1];

                for (i = 0; i < (lend - L + 1); i++) {
                    array1[i][0] = d[i + L - 1];
                }

                dlascl('G', 0, 0, anorm, ssfmax, lend - L + 1, 1, array1, lend - L + 1, info);

                for (i = 0; i < (lend - L + 1); i++) {
                    d[i + L - 1] = array1[i][0];
                }

                array1 = new double[lend - L][1];

                for (i = 0; i < (lend - L); i++) {
                    array1[i][0] = e[i + L - 1];
                }

                dlascl('G', 0, 0, anorm, ssfmax, lend - L, 1, array1, lend - L, info);

                for (i = 0; i < (lend - L); i++) {
                    e[i + L - 1] = array1[i][0];
                }
            } // if (anorm > ssfmax)
            else if (anorm < ssfmin) {
                iscale = 2;
                array1 = new double[lend - L + 1][1];

                for (i = 0; i < (lend - L + 1); i++) {
                    array1[i][0] = d[i + L - 1];
                }

                dlascl('G', 0, 0, anorm, ssfmin, lend - L + 1, 1, array1, lend - L + 1, info);

                for (i = 0; i < (lend - L + 1); i++) {
                    d[i + L - 1] = array1[i][0];
                }

                array1 = new double[lend - L][1];

                for (i = 0; i < (lend - L); i++) {
                    array1[i][0] = e[i + L - 1];
                }

                dlascl('G', 0, 0, anorm, ssfmin, lend - L, 1, array1, lend - L, info);

                for (i = 0; i < (lend - L); i++) {
                    e[i + L - 1] = array1[i][0];
                }
            } // else if (anorm < ssfmin)

            for (i = L - 1; i <= (lend - 2); i++) {
                e[i] = e[i] * e[i];
            }

            // Choose between QR and QL iteration
            if (Math.abs(d[lend - 1]) < Math.abs(d[L - 1])) {
                lend = lsv;
                L = lendsv;
            }

loop2:       {

                if (lend >= L) {

// QL iteration
// Look for small subdiagonal element
loop3:
                    do {

loop4:                   {

                            if (L != lend) {

                                for (m = L; m <= (lend - 1); m++) {

                                    if (Math.abs(e[m - 1]) <= (eps2 * Math.abs(d[m - 1] * d[m]))) {
                                        break loop4;
                                    }
                                } // for (m = L; m <= lend-1; m++)
                            } // if (L != lend)

                            m = lend;
                        } // loop4

                        if (m < lend) {
                            e[m - 1] = 0.0;
                        }

                        p = d[L - 1];

                        if (m != L) {

                            // If remaining matrix is 2 by 2, use dlae2 to compute its
                            // eigenvalues
                            if (m == (L + 1)) {
                                rte = Math.sqrt(e[L - 1]);
                                dlae2(d[L - 1], rte, d[L], rt1, rt2);
                                d[L - 1] = rt1[0];
                                d[L] = rt2[0];
                                e[L - 1] = 0.0;
                                L = L + 2;

                                if (L <= lend) {
                                    continue loop3;
                                } // if (L <= lend)

                                break loop2;
                            } // if (m == (L+1))

                            if (jtot == nmaxit) {
                                break loop2;
                            }

                            jtot = jtot + 1;

                            // Form shift
                            rte = Math.sqrt(e[L - 1]);
                            sigma = (d[L] - p) / (2.0 * rte);
                            r = dlapy2(sigma, 1.0);

                            if (sigma >= 0) {
                                sigma = p - (rte / (sigma + Math.abs(r)));
                            } else {
                                sigma = p - (rte / (sigma - Math.abs(r)));
                            }

                            c = 1.0;
                            s = 0.0;
                            gamma = d[m - 1] - sigma;
                            p = gamma * gamma;

                            // Inner loop
                            for (i = m - 1; i >= L; i--) {
                                bb = e[i - 1];
                                r = p + bb;

                                if (i != (m - 1)) {
                                    e[i] = s * r;
                                }

                                oldc = c;
                                c = p / r;
                                s = bb / r;
                                oldgam = gamma;
                                alpha = d[i - 1];
                                gamma = (c * (alpha - sigma)) - (s * oldgam);
                                d[i] = oldgam + (alpha - gamma);

                                if (c != 0.0) {
                                    p = (gamma * gamma) / c;
                                } else {
                                    p = oldc * bb;
                                }
                            } // for (i = m-1; i >= L; i--)

                            e[L - 1] = s * p;
                            d[L - 1] = sigma + gamma;

                            continue loop3;
                        } // if (m != L)

                        // Eigenvalue found
                        d[L - 1] = p;

                        L = L + 1;

                        if (L <= lend) {
                            continue loop3;
                        }

                        break loop2;
                    } // loop3
                    while (true);
                } // if (lend >= L)
                else { // (lend < L)

// QR integration
// Look for small superdiagonal element
loop5:
                    do {

loop6:                   {

                            for (m = L; m >= (lend + 1); m--) {

                                if (Math.abs(e[m - 2]) <= (eps2 * Math.abs(d[m - 1] * d[m - 2]))) {
                                    break loop6;
                                }
                            } // for (m = L; m >= lend+1; m--)

                            m = lend;
                        } // loop6

                        if (m > lend) {
                            e[m - 2] = 0.0;
                        }

                        p = d[L - 1];

                        if (m != L) {
                            // If remaining matrix is 2 by 2, use dlae2 to compute its
                            // eigenvalues

                            if (m == (L - 1)) {
                                rte = Math.sqrt(e[L - 2]);
                                dlae2(d[L - 1], rte, d[L - 2], rt1, rt2);
                                d[L - 1] = rt1[0];
                                d[L - 2] = rt2[0];
                                e[L - 2] = 0.0;
                                L = L - 2;

                                if (L >= lend) {
                                    continue loop5;
                                }

                                break loop2;
                            } // if (m == (L-1))

                            if (jtot == nmaxit) {
                                break loop2;
                            }

                            jtot = jtot + 1;

                            // Form shift
                            rte = Math.sqrt(e[L - 2]);
                            sigma = (d[L - 2] - p) / (2.0 * rte);
                            r = dlapy2(sigma, 1.0);

                            if (sigma >= 0) {
                                sigma = p - (rte / (sigma + Math.abs(r)));
                            } else {
                                sigma = p - (rte / (sigma - Math.abs(r)));
                            }

                            c = 1.0;
                            s = 0.0;
                            gamma = d[m - 1] - sigma;
                            p = gamma * gamma;

                            // Inner loop
                            for (i = m; i <= (L - 1); i++) {
                                bb = e[i - 1];
                                r = p + bb;

                                if (i != m) {
                                    e[i - 2] = s * r;
                                }

                                oldc = c;
                                c = p / r;
                                s = bb / r;
                                oldgam = gamma;
                                alpha = d[i];
                                gamma = (c * (alpha - sigma)) - (s * oldgam);
                                d[i - 1] = oldgam + (alpha - gamma);

                                if (c != 0.0) {
                                    p = (gamma * gamma) / c;
                                } else {
                                    p = oldc * bb;
                                }
                            } // for (i = m; i <= L-1; i++)

                            e[L - 2] = s * p;
                            d[L - 1] = sigma + gamma;

                            continue loop5;
                        } // if (m != L)

                        // Eigenvalue found
                        d[L - 1] = p;

                        L = L - 1;

                        if (L >= lend) {
                            continue loop5;
                        }

                        break loop2;
                    } // loop5
                    while (true);
                } // else (lend < L)
            } // loop2

            // Undo scaling if necessary
            if (iscale == 1) {
                array1 = new double[lendsv - lsv + 1][1];

                for (i = 0; i < (lendsv - lsv + 1); i++) {
                    array1[i][0] = d[i + lsv - 1];
                }

                dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

                for (i = 0; i < (lendsv - lsv + 1); i++) {
                    d[i + lsv - 1] = array1[i][0];
                }
            } // if (iscale == 1)

            if (iscale == 2) {
                array1 = new double[lendsv - lsv + 1][1];

                for (i = 0; i < (lendsv - lsv + 1); i++) {
                    array1[i][0] = d[i + lsv - 1];
                }

                dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

                for (i = 0; i < (lendsv - lsv + 1); i++) {
                    d[i + lsv - 1] = array1[i][0];
                }
            } // if (iscale == 2)

            // Check for no convergence to an eigenvalue after a total of n*maxit
            // iterations

            if (jtot < nmaxit) {
                continue primary;
            }

            for (i = 0; i <= (n - 2); i++) {

                if (e[i] != 0.0) {
                    info[0] = info[0] + 1;
                }
            } // for (i = 0; i <= n-2; i++)

            return;
        } while (true); // primary
    } // dsterf

    /**
     * This is a port of version 3.1 LAPACK test routine DSTT21 Original DSTT21 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dstt21 checks a decomposition of the form A = U S U' where ' means transpose, A is symmetric tridiagonal, U is
     * orthogonal, and S is diagonal (if kband == 0) or symmetric tridagonal (if kband == 1). Two tests are performed:
     * result[0] = | A - U S U' | / ( |A| n ulp )
     * result[1] = | I - UU' | / ( n ulp )
     *
     * @param  n       (input) int The size of the matrix. If it is zero, dstt21 does nothing. It must be at least zero.
     * @param  kband   (input) int The bandwidth of the matrix S. It may only be zero or one. If zero, then S is
     *                 diagonal, and SE is not referenced. If one, then S is symmetric tri-diagonal.
     * @param  AD      (input) double[] of dimension (n) The diagonal of the original (unfactored) matrix A. A is
     *                 assumed to be symmetric tridiagonal.
     * @param  AE      (input) double[] of dimension (n-1) The off-diagonal of the original (unfactored) matrix A. A is
     *                 assumed to be symmetric tridiagonal. AE[0] is the [0][1] and [1][0] element, AE[1] is the [1][2]
     *                 and [2][1] element, etc.
     * @param  SD      (input) double[] of dimension (n) The diagonal of the (symmetric tri-) diagonal matrix S.
     * @param  SE      (input) double[] of dimension (n-1) The off-diagonal of the (symmetric tri-) diagonal matrix S.
     *                 Not referenced if kband == 0. If kband == 1, then SE[0] is the [0][1] and [1][0] element, SE[1]
     *                 is the [1][2] and [2][1] element, etc.
     * @param  U       (input) double[][] of dimension (ldu, n) The orthogonal matrix in the decomposition.
     * @param  ldu     (input) int The leading dimension of U. ldu must be at least n.
     * @param  work    (workspace) double[] of dimension (n*(n+1))
     * @param  result  (output) double[] of dimension (2) The values computed by the two tests described above. The
     *                 values are currently limited to 1/ulp, to avoid overflow. result[0] is always modified.
     */
    private void dstt21(int n, int kband, double[] AD, double[] AE, double[] SD, double[] SE, double[][] U, int ldu,
                        double[] work, double[] result) {
        int j;
        double anorm;
        double temp1;
        double temp2;
        double ulp;
        double unfl;
        double wnorm;
        double[][] array1;
        int index1;
        int index2;
        double[] x;
        double[] y;
        int i;

        // Constants
        result[0] = 0.0;
        result[1] = 0.0;

        if (n <= 0) {
            return;
        }

        unfl = dlamch('S');
        ulp = dlamch('P');

        // DO Test 1
        // Copy A & Compute its 1-Norm
        array1 = new double[n][n];
        dlaset('F', n, n, 0.0, 0.0, array1, n);
        index1 = 0;
        index2 = 0;

        for (j = 0; j < (n * n); j++) {
            work[j] = array1[index1][index2];
            index1++;

            if (index1 == n) {
                index1 = 0;
                index2++;
            }
        }

        anorm = 0.0;
        temp1 = 0.0;

        for (j = 1; j <= (n - 1); j++) {
            work[(n + 1) * (j - 1)] = AD[j - 1];
            work[((n + 1) * (j - 1)) + 1] = AE[j - 1];
            temp2 = Math.abs(AE[j - 1]);
            anorm = Math.max(anorm, Math.abs(AD[j - 1]) + temp1 + temp2);
            temp1 = temp2;
        } // for (j = 1; j <= n-1; j++)

        work[(n * n) - 1] = AD[n - 1];
        anorm = Math.max(anorm, Math.abs(AD[n - 1]) + temp1);
        anorm = Math.max(anorm, unfl);

        // Norm of A - USU'
        x = new double[n];
        index1 = 0;
        index2 = 0;

        for (j = 0; j < (n * n); j++) {
            array1[index1][index2] = work[j];
            index1++;

            if (index1 == n) {
                index1 = 0;
                index2++;
            }
        }

        for (j = 0; j < n; j++) {

            for (i = 0; i < n; i++) {
                x[i] = U[i][j];
            }

            dsyr('L', n, -SD[j], x, 1, array1, n);
        } // for (j = 0; j < n; j++)

        if ((n > 1) && (kband == 1)) {
            y = new double[n];

            for (j = 0; j < (n - 1); j++) {

                for (i = 0; i < n; i++) {
                    x[i] = U[i][j];
                    y[i] = U[i][j + 1];
                }

                dsyr2('L', n, -SE[j], x, 1, y, 1, array1, n);
            }
        } // if ((n > 1) && (kband == 1))

        wnorm = dlansy('1', 'L', n, array1, n, work);

        if (anorm > wnorm) {
            result[0] = (wnorm / anorm) / (n * ulp);
        } else if (anorm < 1.0) {
            result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
        } else {
            result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
        }

        // Do Test 2
        // Compute UU' - I
        dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, array1, n);
        index1 = 0;
        index2 = 0;

        for (j = 0; j < (n * n); j++) {
            work[j] = array1[index1][index2];
            index1++;

            if (index1 == n) {
                index1 = 0;
                index2++;
            }
        }

        for (j = 1; j <= n; j++) {
            work[(n + 1) * (j - 1)] = work[(n + 1) * (j - 1)] - 1.0;
        }

        index1 = 0;
        index2 = 0;

        for (j = 0; j < (n * n); j++) {
            array1[index1][index2] = work[j];
            index1++;

            if (index1 == n) {
                index1 = 0;
                index2++;
            }
        }

        result[1] = Math.min((double) n, dlange('1', n, n, array1, n, work)) / (n * ulp);

        return;
    } // dstt21

    /**
     * This is a port of the LAPACK version 3.1 DSYGS2 routine Original DSYGS2 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * DSYGS2 reduces a real symmetric-definite generalized eigenproblem to standard form.
     *
     * <p>If itype = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
     * </p>
     *
     * <p>if itype = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U' or
     * L'*A*L.</p>
     *
     * <p>B must have been previously factorized as U'*U or L*L' by dpotrf.</p>
     *
     * @param  itype  input int 
     *         = 1: Compute inv(U')*A*inv(U) or inv(L)*A*inv(L') 
     *         = 2 or 3: Compute U*A*U' or L'*A*L
     * @param  uplo   input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
     *                stored, and how B has been factorized. 
     *                = 'U': Upper triangular 
     *                = 'L': Lower triangular
     * @param  n      input int The order of matrices A and B. n >= 0.
     * @param  A      input/output double[][] dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *                leading n by n upper triangular part of A contains the upper triangular part of the matrix A, and
     *                the strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n by n lower
     *                triangular part of A contains the lower triangular part of the matrix A and the strictly upper
     *                triangular part of A is not referenced.
     *
     *                <p>On exit, if info[0] = 0, the transformed matrix is stored in the same format as A.</p>
     * @param  lda    input int The leading dimension of array A. lda >= max(1,n).
     * @param  B      input double[][] dimension ldb by n. The triangular factor from the Cholesky factorization of B,
     *                as returned by dpotrf.
     * @param  ldb    input int The leading dimension of array B. ldb >= max(1,n).
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info[0] = -i, the i-th argument had an illegal value
     */
    private void dsygs2(int itype, char uplo, int n, double[][] A, int lda, double[][] B, int ldb, int[] info) {
        boolean upper;
        int k;
        double akk;
        double bkk;
        double ct;
        double[] vector1;
        double[] vector2;
        double[][] array1;
        int i;
        int j;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if ((itype < 1) || (itype > 3)) {
            info[0] = -1;
        } else if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (lda < Math.max(1, n)) {
            info[0] = -5;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -7;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsygs2 had info[0] = " + info[0]);

            return;
        }

        if (itype == 1) {

            if (upper) {

                // Compute inv(U')*A*inv(U)
                for (k = 1; k <= n; k++) {

                    // Update the upper triangle of A(k-1:n-1,k-1:n-1)
                    akk = A[k - 1][k - 1];
                    bkk = B[k - 1][k - 1];
                    akk = akk / (bkk * bkk);
                    A[k - 1][k - 1] = akk;

                    if (k < n) {
                        vector1 = new double[n - k];

                        for (i = 0; i < (n - k); i++) {
                            vector1[i] = A[k - 1][k + i];
                        }

                        dscal(n - k, 1.0 / bkk, vector1, 1);
                        ct = -0.5 * akk;
                        vector2 = new double[n - k];

                        for (i = 0; i < (n - k); i++) {
                            vector2[i] = B[k - 1][k + i];
                        }

                        daxpy(n - k, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (n - k); i++) {
                            A[k - 1][k + i] = vector1[i];
                        }

                        array1 = new double[n - k][n - k];

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                array1[i][j] = A[i + k][j + k];
                            }
                        }

                        dsyr2(uplo, n - k, -1.0, vector1, 1, vector2, 1, array1, n - k);

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                A[i + k][j + k] = array1[i][j];
                            }
                        }

                        for (i = 0; i < (n - k); i++) {
                            vector1[i] = A[k - 1][k + i];
                        }

                        daxpy(n - k, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                array1[i][j] = B[i + k][j + k];
                            }
                        }

                        dtrsv(uplo, 'T', 'N', n - k, array1, n - k, vector1, 1);

                        for (i = 0; i < (n - k); i++) {
                            A[k - 1][k + i] = vector1[i];
                        }
                    } // if (k < n)
                } // for (k = 1; k <= n; k++)
            } // if (upper)
            else { // lower

                // Compute inv(L)*A*inv(L')
                for (k = 1; k <= n; k++) {

                    // update the lower triangle A(k-1:n-1,k-1:n-1)
                    akk = A[k - 1][k - 1];
                    bkk = B[k - 1][k - 1];
                    akk = akk / (bkk * bkk);
                    A[k - 1][k - 1] = akk;

                    if (k < n) {
                        vector1 = new double[n - k];

                        for (i = 0; i < (n - k); i++) {
                            vector1[i] = A[k + i][k - 1];
                        }

                        dscal(n - k, 1.0 / bkk, vector1, 1);
                        ct = -0.5 * akk;
                        vector2 = new double[n - k];

                        for (i = 0; i < (n - k); i++) {
                            vector2[i] = B[k + i][k - 1];
                        }

                        daxpy(n - k, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (n - k); i++) {
                            A[k + i][k - 1] = vector1[i];
                        }

                        array1 = new double[n - k][n - k];

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                array1[i][j] = A[i + k][j + k];
                            }
                        }

                        dsyr2(uplo, n - k, -1.0, vector1, 1, vector2, 1, array1, n - k);

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                A[i + k][j + k] = array1[i][j];
                            }
                        }

                        for (i = 0; i < (n - k); i++) {
                            vector1[i] = A[k + i][k - 1];
                        }

                        daxpy(n - k, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (n - k); i++) {

                            for (j = 0; j < (n - k); j++) {
                                array1[i][j] = B[i + k][j + k];
                            }
                        }

                        dtrsv(uplo, 'N', 'N', n - k, array1, n - k, vector1, 1);

                        for (i = 0; i < (n - k); i++) {
                            A[k + i][k - 1] = vector1[i];
                        }
                    } // if (k < n)
                } // for (k = 1; k <= n; k++)
            } // else lower
        } // if (itype == 1)
        else { // itype == 2 or 3

            if (upper) {

                // Compute U*A*U'
                for (k = 1; k <= n; k++) {

                    // Update the upper triangle of A(0:k-1,0:k-1)
                    akk = A[k - 1][k - 1];
                    bkk = B[k - 1][k - 1];

                    if (k != 1) {
                        vector1 = new double[k - 1];

                        for (i = 0; i < (k - 1); i++) {
                            vector1[i] = A[i][k - 1];
                        }

                        dtrmv(uplo, 'N', 'N', k - 1, B, ldb, vector1, 1);
                        ct = 0.5 * akk;
                        vector2 = new double[k - 1];

                        for (i = 0; i < (k - 1); i++) {
                            vector2[i] = B[i][k - 1];
                        }

                        daxpy(k - 1, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (k - 1); i++) {
                            A[i][k - 1] = vector1[i];
                        }

                        dsyr2(uplo, k - 1, 1.0, vector1, 1, vector2, 1, A, lda);

                        for (i = 0; i < (k - 1); i++) {
                            vector1[i] = A[i][k - 1];
                        }

                        daxpy(k - 1, ct, vector2, 1, vector1, 1);
                        dscal(k - 1, bkk, vector1, 1);

                        for (i = 0; i < (k - 1); i++) {
                            A[i][k - 1] = vector1[i];
                        }
                    } // if (k != 1)

                    A[k - 1][k - 1] = akk * bkk * bkk;
                } // for (k = 1; k <= n; k++)
            } // if (upper)
            else { // lower

                // Compute L'*A*L
                for (k = 1; k <= n; k++) {

                    // Update the lower triangle of A(0:k-1,0:k-1)
                    akk = A[k - 1][k - 1];
                    bkk = B[k - 1][k - 1];

                    if (k != 1) {
                        vector1 = new double[k - 1];

                        for (i = 0; i < (k - 1); i++) {
                            vector1[i] = A[k - 1][i];
                        }

                        dtrmv(uplo, 'T', 'N', k - 1, B, ldb, vector1, 1);
                        ct = 0.5 * akk;
                        vector2 = new double[k - 1];

                        for (i = 0; i < (k - 1); i++) {
                            vector2[i] = B[k - 1][i];
                        }

                        daxpy(k - 1, ct, vector2, 1, vector1, 1);

                        for (i = 0; i < (k - 1); i++) {
                            A[k - 1][i] = vector1[i];
                        }

                        dsyr2(uplo, k - 1, 1.0, vector1, 1, vector2, 1, A, lda);

                        for (i = 0; i < (k - 1); i++) {
                            vector1[i] = A[k - 1][i];
                        }

                        daxpy(k - 1, ct, vector2, 1, vector1, 1);
                        dscal(k - 1, bkk, vector1, 1);

                        for (i = 0; i < (k - 1); i++) {
                            A[k - 1][i] = vector1[i];
                        }
                    } // if (k != 1)

                    A[k - 1][k - 1] = akk * bkk * bkk;
                } // for (k = 1; k <= n; k++)
            } // else lower
        } // else itype == 2 or 3

        return;
    } // dsygs2

    /**
     * This routine is a port of the version 3.1 LAPACK routine DSYGST Original DSYGST created by Univ. of Tennessee,
     * Univ. of California Berkeley, and NAG Ltd., November, 2006
     * dsygst reduces a real symmetric-definite generalized eigenproblem to standard form.
     *
     * <p>If itype = 1, the problem is A*x = lambda*B*x and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')</p>
     *
     * <p>if itype = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U' or
     * L'*A*L</p>
     *
     * <p>B must have been previously factorized as U'*U or L*L' by dpotrf</p>
     *
     * @param  itype  input int 
     *                = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L') 
     *                = 2 or 3: compute U*A*U' or L'*A*L
     * @param  uplo   input char 
     *                = 'U': Upper triangle of A is stored and B is factored as U'*U 
     *                = 'L': Lower triangle of A is stored and B is factored as L*L'
     * @param  n      input int The order of matrices A and B. n >= 0.
     * @param  A      input/output double[][] dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *                leading n-by-n upper triangular part of A contains the upper triangular part of matrix A, and the
     *                strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
     *                triangular part of A contains the lower triangular part of matrix A, and the strictly upper
     *                triangular part of A is not referenced.
     *
     *                <p>On exit, if info[0] = 0, the transformed matrix, stored in the same format as A.</p>
     * @param  lda    input int The leading dimension of array A. lda >= max(1,n).
     * @param  B      input double[][] dimension ldb by n. The triangular factor from the Cholesky factorization of B,
     *                as returned by dpotrf
     * @param  ldb    input int The leading dimension of array B. ldb >= max(1,n).
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info = -i, the i-th argument had an illegal value
     */
    private void dsygst(int itype, char uplo, int n, double[][] A, int lda, double[][] B, int ldb, int[] info) {
        boolean upper;
        int k;
        int kb;
        int nb;
        char[] ch = new char[1];
        String opts;
        int i;
        int j;
        double[][] array1;
        double[][] array2;
        double[][] array3;
        int row1;
        int row2;
        int row3;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if ((itype < 1) || (itype > 3)) {
            info[0] = -1;
        } else if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -3;
        } else if (lda < Math.max(1, n)) {
            info[0] = -5;
        } else if (ldb < Math.max(1, n)) {
            info[0] = -7;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error in dsygst with info[0] = " + info[0]);

            return;
        } // if (info[0] != 0)

        // Quick return if possible
        if (n == 0) {
            return;
        }

        // Determine the block size for this environment
        ch[0] = uplo;
        opts = new String(ch);
        nb = ilaenv(1, "DSYGST", opts, n, -1, -1, -1);

        if ((nb <= 1) || (nb >= n)) {

            // Use unblocked code
            dsygs2(itype, uplo, n, A, lda, B, ldb, info);
        } else {

            // Use blocked code
            if (itype == 1) {

                if (upper) {

                    // Compute inv(U')*A*inv(U)
                    for (k = 1; k <= n; k += nb) {
                        kb = Math.min(n - k + 1, nb);

                        // Update the upper triangle of A[k-1:n-1][k-1:n-1]
                        array1 = new double[kb][kb];
                        array2 = new double[kb][kb];

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                array1[i][j] = A[i + k - 1][j + k - 1];
                                array2[i][j] = B[i + k - 1][j + k - 1];
                            }
                        }

                        dsygs2(itype, uplo, kb, array1, kb, array2, kb, info);

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i + k - 1][j + k - 1] = array1[i][j];
                            }
                        }

                        if ((k + kb) <= n) {
                            array1 = new double[kb][n - k - kb + 1];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array1[i][j] = A[i + k - 1][j + k + kb - 1];
                                }
                            }

                            dtrsm('L', uplo, 'T', 'N', kb, n - k - kb + 1, 1.0, array2, kb, array1, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
                                }
                            }

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            array3 = new double[kb][n - k - kb + 1];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array3[i][j] = B[i + k - 1][j + k + kb - 1];
                                }
                            }

                            dsymm('L', uplo, kb, n - k - kb + 1, -0.5, array2, kb, array3, kb, 1.0, array1, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
                                }
                            }

                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array2[i][j] = A[i + k + kb - 1][j + k + kb - 1];
                                }
                            }

                            dsyr2k(uplo, 'T', n - k - kb + 1, kb, -1.0, array1, kb, array3, kb, 1.0, array2,
                                   n - k - kb + 1);

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    A[i + k + kb - 1][j + k + kb - 1] = array2[i][j];
                                }
                            }

                            array2 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array1[i][j] = A[i + k - 1][j + k + kb - 1];
                                }
                            }

                            dsymm('L', uplo, kb, n - k - kb + 1, -0.5, array2, kb, array3, kb, 1.0, array1, kb);
                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array2[i][j] = B[i + k + kb - 1][j + k + kb - 1];
                                }
                            }

                            dtrsm('R', uplo, 'N', 'N', kb, n - k - kb + 1, 1.0, array2, n - k - kb + 1, array1, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
                                }
                            }
                        } // if ((k + kb) <= n)
                    } // for (k = 1; k <= n; k += nb)
                } // if (upper)
                else { // lower

                    // Compute inv(L)*A*inv(L')
                    for (k = 1; k <= n; k += nb) {
                        kb = Math.min(n - k + 1, nb);

                        // Update the lower triangle of A(k-1:n-1,k-1:n-1
                        array1 = new double[kb][kb];
                        array2 = new double[kb][kb];

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                array1[i][j] = A[i + k - 1][j + k - 1];
                                array2[i][j] = B[i + k - 1][j + k - 1];
                            }
                        }

                        dsygs2(itype, uplo, kb, array1, kb, array2, kb, info);

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i + k - 1][j + k - 1] = array1[i][j];
                            }
                        }

                        if ((k + kb) <= n) {
                            array1 = new double[n - k - kb + 1][kb];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = A[i + k + kb - 1][j + k - 1];
                                }
                            }

                            dtrsm('R', uplo, 'T', 'N', n - k - kb + 1, kb, 1.0, array2, kb, array1, n - k - kb + 1);

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
                                }
                            }

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            array3 = new double[n - k - kb + 1][kb];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    array3[i][j] = B[i + k + kb - 1][j + k - 1];
                                }
                            }

                            dsymm('R', uplo, n - k - kb + 1, kb, -0.5, array2, kb, array3, n - k - kb + 1, 1.0, array1,
                                  n - k - kb + 1);

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
                                }
                            }

                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array2[i][j] = A[i + k + kb - 1][j + k + kb - 1];
                                }
                            }

                            dsyr2k(uplo, 'N', n - k - kb + 1, kb, -1.0, array1, n - k - kb + 1, array3, n - k - kb + 1,
                                   1.0, array2, n - k - kb + 1);

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    A[i + k + kb - 1][j + k + kb - 1] = array2[i][j];
                                }
                            }

                            array2 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = A[i + k + kb - 1][j + k - 1];
                                }
                            }

                            dsymm('R', uplo, n - k - kb + 1, kb, -0.5, array2, kb, array3, n - k - kb + 1, 1.0, array1,
                                  n - k - kb + 1);
                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < (n - k - kb + 1); j++) {
                                    array2[i][j] = B[i + k + kb - 1][j + k + kb - 1];
                                }
                            }

                            dtrsm('L', uplo, 'N', 'N', n - k - kb + 1, kb, 1.0, array2, n - k - kb + 1, array1,
                                  n - k - kb + 1);

                            for (i = 0; i < (n - k - kb + 1); i++) {

                                for (j = 0; j < kb; j++) {
                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
                                }
                            }
                        } // if ((k + kb) <= n)
                    } // for (k = 1; k <= n; k += nb)
                } // else lower
            } // if (itype == 1)
            else { // itype != 1

                if (upper) {

                    // Compute U*A*U'
                    for (k = 1; k <= n; k += nb) {
                        kb = Math.min(n - k + 1, nb);

                        // Update the upper triangle of A[0:k+kb-2][0:k+kb-2]
                        row1 = Math.max(1, k - 1);
                        array1 = new double[row1][kb];

                        for (i = 0; i < row1; i++) {

                            for (j = 0; j < kb; j++) {
                                array1[i][j] = A[i][j + k - 1];
                            }
                        }

                        dtrmm('L', uplo, 'N', 'N', k - 1, kb, 1.0, B, ldb, array1, row1);

                        for (i = 0; i < row1; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i][j + k - 1] = array1[i][j];
                            }
                        }

                        if (k != 1) {
                            array2 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            row3 = Math.max(1, k - 1);
                            array3 = new double[row3][kb];

                            for (i = 0; i < row3; i++) {

                                for (j = 0; j < kb; j++) {
                                    array3[i][j] = B[i][j + k - 1];
                                }
                            }

                            dsymm('R', uplo, k - 1, kb, 0.5, array2, kb, array3, row3, 1.0, array1, row1);

                            for (i = 0; i < row1; i++) {

                                for (j = 0; j < kb; j++) {
                                    A[i][j + k - 1] = array1[i][j];
                                }
                            }

                            dsyr2k(uplo, 'N', k - 1, kb, 1.0, array1, row1, array3, row3, 1.0, A, lda);
                            array1 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            row2 = Math.max(1, k - 1);
                            array2 = new double[row2][kb];

                            for (i = 0; i < row2; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i][j + k - 1];
                                }
                            }

                            dsymm('R', uplo, k - 1, kb, 0.5, array1, kb, array3, row3, 1.0, array2, row2);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = B[i + k - 1][j + k - 1];
                                }
                            }
                        } // if (k != 1)
                        else { // k == 1
                            array1 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = B[i + k - 1][j + k - 1];
                                }
                            }

                            row2 = Math.max(1, k - 1);
                            array2 = new double[row2][kb];

                            for (i = 0; i < row2; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i][j + k - 1];
                                }
                            }
                        } // else k == 1

                        dtrmm('R', uplo, 'T', 'N', k - 1, kb, 1.0, array1, kb, array2, row2);

                        for (i = 0; i < row2; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i][j + k - 1] = array2[i][j];
                            }
                        }

                        array2 = new double[kb][kb];

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                array2[i][j] = A[i + k - 1][j + k - 1];
                            }
                        }

                        dsygs2(itype, uplo, kb, array2, kb, array1, kb, info);

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i + k - 1][j + k - 1] = array2[i][j];
                            }
                        }
                    } // for (k = 1; k <= n; k += nb)
                } // if (upper)
                else { // lower

                    // Compute L'*A*L
                    for (k = 1; k <= n; k += nb) {
                        kb = Math.min(n - k + 1, nb);

                        // Update the lower triangle of A[0:k+kb-2][0:k+kb-2]
                        if (k != 1) {
                            array1 = new double[kb][k - 1];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    array1[i][j] = A[i + k - 1][j];
                                }
                            }

                            dtrmm('R', uplo, 'N', 'N', kb, k - 1, 1.0, B, ldb, array1, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    A[i + k - 1][j] = array1[i][j];
                                }
                            }

                            array2 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array2[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            array3 = new double[kb][k - 1];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    array3[i][j] = B[i + k - 1][j];
                                }
                            }

                            dsymm('L', uplo, kb, k - 1, 0.5, array2, kb, array3, kb, 1.0, array1, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    A[i + k - 1][j] = array1[i][j];
                                }
                            }

                            dsyr2k(uplo, 'T', k - 1, kb, 1.0, array1, kb, array3, kb, 1.0, A, lda);
                            array1 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = A[i + k - 1][j + k - 1];
                                }
                            }

                            array2 = new double[kb][k - 1];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    array2[i][j] = A[i + k - 1][j];
                                }
                            }

                            dsymm('L', uplo, kb, k - 1, 0.5, array1, kb, array3, kb, 1.0, array2, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; k++) {
                                    array1[i][j] = B[i + k - 1][j + k - 1];
                                }
                            }

                            dtrmm('L', uplo, 'T', 'N', kb, k - 1, 1.0, array1, kb, array2, kb);

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < (k - 1); j++) {
                                    A[i + k - 1][j] = array2[i][j];
                                }
                            }
                        } // if (k != 1)
                        else { // k == 1
                            array1 = new double[kb][kb];

                            for (i = 0; i < kb; i++) {

                                for (j = 0; j < kb; j++) {
                                    array1[i][j] = B[i + k - 1][j + k - 1];
                                }
                            }
                        } // else k == 1

                        array2 = new double[kb][kb];

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                array2[i][j] = A[i + k - 1][j + k - 1];
                            }
                        }

                        dsygs2(itype, uplo, kb, array2, kb, array1, kb, info);

                        for (i = 0; i < kb; i++) {

                            for (j = 0; j < kb; j++) {
                                A[i + k - 1][j + k - 1] = array2[i][j];
                            }
                        }
                    } // for (k = 1; k <= n; k += nb)
                } // else lower
            } // else itype != 1
        }

        return;
    } // dsygst

    /**
     * This is a port of the 2/8/89 Blas routine DSYMM Original version written by: Jack Dongarra, Argonne National Lab.
     * Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms
     * Group Ltd. dsymm performs one of the matrix operations C = alpha*A*B + beta*C or C = alpha*B*A + beta*C, where
     * alpha and beta are scalars, A is a symmetric matrix and B and C are m by n matrices
     *
     * @param  side   input char On entry, side specifies whether the symmetric matrix A appears on the left or right in
     *                the operation as follows: = 'L' or 'l' C = alpha*A*B + beta*C = 'R' or 'r' C + alpha*B*A + beta*C
     * @param  uplo   input char On entry, uplo specifies whether the upper or lower triangular part of the symmetric
     *                matrix A is to be referenced as follows: = 'U' or 'u' Only the upper triangular part of the
     *                symmetric matrix is to be referenced. = 'L' or 'l' Only the lower triangular part of the symmetric
     *                matrix is to be referenced.
     * @param  m      input int On entry, m specifies the number of rows of the matrix C. m must be at least zero.
     * @param  n      input int On entry, n specifies the number of columns of the matrix C. n must be at least zero.
     * @param  alpha  double Specifies scalar.
     * @param  A      input double[][] of dimension lda by ka, where ka is m when side = 'L' or 'l' and is n otherwise.
     *                Before entry with side = 'L' or 'l', the m by m part of the array A must contain the symmetric
     *                matrix, such that when uplo = 'U' or 'u', the leading m by m upper triangular part of the array A
     *                must contain the upper triangular part of the symmetric matrix and the strictly lower triangular
     *                part of A is not referenced, and when uplo = 'L' or 'l', the leading m by m lower triangular part
     *                of the array A must contain the lower triangular part of the symmetric matrix and the strictly
     *                uppper triangular part of A is not referenced. Before entry with side = 'R' or 'r', the n by n
     *                part of the array A must contain the symmetric matrix, such that when uplo = 'U' or 'u', the
     *                leading n by n upper triangular part of the array A must contain the upper triangular part of the
     *                symmetric matrix and the strictly lower triangular part of A is not referenced, and when uplo =
     *                'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower
     *                triangular part of the symmetric matrix and the strictly upper triangular part of A is not
     *                referenced.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. When side = 'L' or 'l', then lda must be at least max(1,m), otherwise lda must be at
     *                least max(1,n).
     * @param  B      input double[][] of dimension ldb by n. Before entry, the leading m by n part of the array B must
     *                contain the matrix B.
     * @param  ldb    input int On entry, ldb specifies the first dimension of B as declared in the calling (sub)
     *                program. ldb must be at least max(1,m).
     * @param  beta   beta double Specified scalar. When beta is supplied as zero, then C need not be set on input.
     * @param  C      input/output double[][] of dimension ldc by n. Before entry, the leading m by n part of the array
     *                C must contain the matrix C, except when beta is zero, in which case C need not be set on entry.
     *                On exit, the array C is overwritten by the m by n updated matrix.
     * @param  ldc    input int On entry, ldc specifies the first dimension of C as declared in the calling (sub)
     *                program. ldc must be at least max(1,m).
     */
    private void dsymm(char side, char uplo, int m, int n, double alpha, double[][] A, int lda, double[][] B, int ldb,
                       double beta, double[][] C, int ldc) {
        boolean upper;
        int i;
        int info;
        int j;
        int k;
        int nrowa;
        double temp1;
        double temp2;

        // Set nrowa as the number of rows of A.
        if ((side == 'L') || (side == 'l')) {
            nrowa = m;
        } else {
            nrowa = n;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        // Test the input parameters.
        info = 0;

        if ((side != 'L') && (side != 'l') && (side != 'R') && (side != 'r')) {
            info = 1;
        } else if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info = 2;
        } else if (m < 0) {
            info = 3;
        } else if (n < 0) {
            info = 4;
        } else if (lda < Math.max(1, nrowa)) {
            info = 7;
        } else if (ldb < Math.max(1, m)) {
            info = 9;
        } else if (ldc < Math.max(1, m)) {
            info = 12;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dymmm had info = " + info);

            return;
        }

        // Quick return if possible
        if ((m == 0) || (n == 0) || ((alpha == 0.0) && (beta == 1.0))) {
            return;
        }

        if (alpha == 0.0) {

            if (beta == 0.0) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        C[i][j] = 0.0;
                    }
                }
            } // if (beta == 0.0)
            else { // beta != 0.0

                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        C[i][j] = beta * C[i][j];
                    }
                }
            } // else beta != 0.0

            return;
        } // if (alpha == 0.0)

        if ((side == 'L') || (side == 'l')) {

            // Form C = alpha*A*B + beta*C
            if (upper) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i < m; i++) {
                        temp1 = alpha * B[i][j];
                        temp2 = 0.0;

                        for (k = 0; k <= (i - 1); k++) {
                            C[k][j] = C[k][j] + (temp1 * A[k][i]);
                            temp2 = temp2 + (B[k][j] * A[k][i]);
                        } // for (k = 0; k <= i-1; k++)

                        if (beta == 0.0) {
                            C[i][j] = (temp1 * A[i][i]) + (alpha * temp2);
                        } else {
                            C[i][j] = (beta * C[i][j]) + (temp1 * A[i][i]) + (alpha * temp2);
                        }
                    } // for (i = 0; i < m; i++)
                } // for (j = 0; j < n; j++)
            } // if (upper)
            else { // lower

                for (j = 0; j < n; j++) {

                    for (i = m - 1; i >= 0; i--) {
                        temp1 = alpha * B[i][j];
                        temp2 = 0.0;

                        for (k = i + 1; k < m; k++) {
                            C[k][j] = C[k][j] + (temp1 * A[k][i]);
                            temp2 = temp2 + (B[k][j] * A[k][i]);
                        } // for (k = i+1; k < m; k++)

                        if (beta == 0.0) {
                            C[i][j] = (temp1 * A[i][i]) + (alpha * temp2);
                        } else {
                            C[i][j] = (beta * C[i][j]) + (temp1 * A[i][i]) + (alpha * temp2);
                        }
                    } // for (i = m-1; i >= 0; i--)
                } // for (j = 0; j < n; j++)
            } // else lower
        } // if ((side == 'L') || (side == 'l'))
        else { // ((side == 'R') || (side == 'r'))

            // Form C = alpha*B*A + beta*C
            for (j = 0; j < n; j++) {
                temp1 = alpha * A[j][j];

                if (beta == 0.0) {

                    for (i = 0; i < m; i++) {
                        C[i][j] = temp1 * B[i][j];
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (i = 0; i < m; i++) {
                        C[i][j] = (beta * C[i][j]) + (temp1 * B[i][j]);
                    }
                } // else beta != 0.0

                for (k = 0; k <= (j - 1); k++) {

                    if (upper) {
                        temp1 = alpha * A[k][j];
                    } else {
                        temp1 = alpha * A[j][k];
                    }

                    for (i = 0; i < m; i++) {
                        C[i][j] = C[i][j] + (temp1 * B[i][k]);
                    }
                } // for (k = 0; k <= j-1; k++)

                for (k = j + 1; k < n; k++) {

                    if (upper) {
                        temp1 = alpha * A[j][k];
                    } else {
                        temp1 = alpha * A[k][j];
                    }

                    for (i = 0; i < m; i++) {
                        C[i][j] = C[i][j] + (temp1 * B[i][k]);
                    }
                } // for (k = j+1; k < n; k++)
            } // for (j = 0; j < n; j++)
        } // else ((side == 'R') || (side == 'r'))

        return;
    } // dsymm

    /**
     * This is a port of the 10/22/86 Blas routine DSYMV Original code written by: Jack Dongarra, Argonne Nationa Lab.
     * Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.
     * dsymv performs the matrix-vector operation y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are n
     * element vectors and A is an n by n symmetric matrix.
     *
     * @param  uplo   input char On entry, uplo specifies whether the upper or lower triangular part of the array A is
     *                to be referenced as follows: = 'U' or 'u' Only the upper triangular part of A is to be referenced.
     *                = 'L' or 'l' Only the lower triangular part of A is to be referenced.
     * @param  n      input int On entry, n specifies the order of the matrix A. n must be at least zero.
     * @param  alpha  input double Specified scalar
     * @param  A      input double[][] of dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n
     *                upper triangular part of the array A must contain the upper triagular part of the symmetric matrix
     *                and the strictly lower triangular part of A is not referenced. Before entry with uplo = 'L' or
     *                'l', the leading n by n lower triangular part of the array A must contain the lower triangular
     *                part of the symmetric matrix and the strictly upper triangular part of A is not referenced.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,n).
     * @param  x      input double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x
     *                must contain the n element vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     * @param  beta   input double On entry, beta specifies the scalar beta. When beta is supplied as zero, then y need
     *                not be set on input.
     * @param  y      input/output double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented
     *                array y must contain the n element vector y. On exit, y is overwritten by the updated vector y.
     * @param  incy   input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
     */
    private void dsymv(char uplo, int n, double alpha, double[][] A, int lda, double[] x, int incx, double beta,
                       double[] y, int incy) {
        double temp1;
        double temp2;
        int i;
        int info;
        int ix;
        int iy;
        int j;
        int jx;
        int jy;
        int kx;
        int ky;

        // Test the input parameters
        info = 0;

        if ((uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if (n < 0) {
            info = 2;
        } else if (lda < Math.max(1, n)) {
            info = 5;
        } else if (incx == 0) {
            info = 7;
        } else if (incy == 0) {
            info = 10;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dsymv had error = " + info);

            return;
        }

        // Quick return if possible
        if ((n == 0) || ((alpha == 0.0) && (beta == 1.0))) {
            return;
        }

        // Set up the start points in x and y
        if (incx > 0) {
            kx = 1;
        } else {
            kx = 1 - ((n - 1) * incx);
        }

        if (incy > 0) {
            ky = 1;
        } else {
            ky = 1 - ((n - 1) * incy);
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through the triangular part of A.

        // First form y = beta*y.

        if (beta != 1.0) {

            if (incy == 1) {

                if (beta == 0.0) {

                    for (i = 0; i < n; i++) {
                        y[i] = 0.0;
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (i = 0; i < n; i++) {
                        y[i] = beta * y[i];
                    }
                } // else beta != 0.0
            } // if (incy == 1)
            else { // incy != 1
                iy = ky - 1;

                if (beta == 0.0) {

                    for (i = 0; i < n; i++) {
                        y[iy] = 0.0;
                        iy = iy + incy;
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (i = 0; i < n; i++) {
                        y[iy] = beta * y[iy];
                        iy = iy + incy;
                    }
                } // else beta != 0.0
            } // else incy != 1
        } // if (beta != 1.0)

        if (alpha == 0.0) {
            return;
        }

        if ((uplo == 'U') || (uplo == 'u')) {

            // Form y when A is stored in upper triangle
            if ((incx == 1) && (incy == 1)) {

                for (j = 0; j < n; j++) {
                    temp1 = alpha * x[j];
                    temp2 = 0.0;

                    for (i = 0; i <= (j - 1); i++) {
                        y[i] = y[i] + (temp1 * A[i][j]);
                        temp2 = temp2 + (A[i][j] * x[i]);
                    } // for (i = 0; i <= j-1; i++)

                    y[j] = y[j] + (temp1 * A[j][j]) + (alpha * temp2);
                } // for (j = 0; j < n; j++)
            } // if ((incx == 1) && (incy == 1))
            else { // ((incx != 1) || (incy != 1))
                jx = kx - 1;
                jy = ky - 1;

                for (j = 0; j < n; j++) {
                    temp1 = alpha * x[jx];
                    temp2 = 0.0;
                    ix = kx - 1;
                    iy = ky - 1;

                    for (i = 0; i <= (j - 1); i++) {
                        y[iy] = y[iy] + (temp1 * A[i][j]);
                        temp2 = temp2 + (A[i][j] * x[ix]);
                        ix = ix + incx;
                        iy = iy + incy;
                    } // for (i = 0; i <= j-1; i++)

                    y[jy] = y[jy] + (temp1 * A[j][j]) + (alpha * temp2);
                    jx = jx + incx;
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // else ((incx != 1) || (incy != 1))
        } // if ((uplo == 'U') || (uplo == 'u'))
        else { // ((uplo == 'L') || (uplo == 'l'))

            // Form y when A is stored in lower triangle
            if ((incx == 1) && (incy == 1)) {

                for (j = 0; j < n; j++) {
                    temp1 = alpha * x[j];
                    temp2 = 0.0;
                    y[j] = y[j] + (temp1 * A[j][j]);

                    for (i = j + 1; i < n; i++) {
                        y[i] = y[i] + (temp1 * A[i][j]);
                        temp2 = temp2 + (A[i][j] * x[i]);
                    } // for (i = j+1; i < n; i++)

                    y[j] = y[j] + (alpha * temp2);
                } // for (j = 0; j < n; j++)
            } // if ((incx == 1) && (incy == 1))
            else { // ((incx != 1) || (incy != 1))
                jx = kx - 1;
                jy = ky - 1;

                for (j = 0; j < n; j++) {
                    temp1 = alpha * x[jx];
                    temp2 = 0.0;
                    y[jy] = y[jy] + (temp1 * A[j][j]);
                    ix = jx;
                    iy = jy;

                    for (i = j + 1; i < n; i++) {
                        ix = ix + incx;
                        iy = iy + incy;
                        y[iy] = y[iy] + (temp1 * A[i][j]);
                        temp2 = temp2 + (A[i][j] * x[ix]);
                    } // for (i = j+1; i < n; i++)

                    y[jy] = y[jy] + (alpha * temp2);
                    jx = jx + incx;
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // else ((incx != 1) || (incy != 1))
        } // else ((uplo == 'L') || (uplo == 'l'))

        return;
    } // dsymv

    /**
     * This is a port of level 2 Blas routine DSYR Original routine written on 22-October-1986 by Jack Dongarra, Argonne
     * National Lab. Jermey Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia
     * National Labs. dsyr performs the symmetric rank 1 operation A = alpha*x*x' + A, where alpha is a real scalar, x
     * is an n element vector and A is an n by n symmetric matrix.
     *
     * @param  uplo   (input) char On entry, uplo specifies whether the upper or lower triangular part of the array A is
     *                to be referenced as follows: uplo = 'U' or 'u' Only the upper triangular part of A is to be
     *                referenced. uplo = 'L' or 'l' Only the lower triangular part of A is to be referenced. Unchanged
     *                on exit.
     * @param  n      (input) int On entry, n specifies the order of the matrix A. n must be at least zero. Unchanged on
     *                exit.
     * @param  alpha  (input) double On entry, alpha specifies the scalar alpha. Unchanged on exit.
     * @param  x      (input) double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array
     *                x must contain the n element vector x. Unchanged on exit.
     * @param  incx   (input) int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     *                Unchanged on exit.
     * @param  A      (input/output) double[][] of dimension (lda,n). Before entry with uplo = 'U' or 'u', the leading n
     *                by n upper triangular part of the array A must contain the upper triangular part of the symmetric
     *                matrix and the strictly lower triangular part of A is not referenced. On exit, the upper
     *                triangualr part of the array A is overwritten by the upper triangular part of the updated matrix.
     *                Before entry with uplo = 'L' or 'l', the leading n by n lower triangular part of the array A must
     *                contain the lower triangular part of the symmetric matrix and the strictly upper triangular part
     *                of A is not referenced. On exit, the lower triangular part of the array A is overwritten by the
     *                lower triangular part of the updated matrix.
     * @param  lda    (input) int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,n). Unchanged on exit.
     */
    private void dsyr(char uplo, int n, double alpha, double[] x, int incx, double[][] A, int lda) {
        double temp;
        int i;
        int[] info = new int[1];
        int ix;
        int j;
        int jx;
        int kx = 0;

        info[0] = 0;

        if ((uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
            info[0] = 1;
        } else if (n < 0) {
            info[0] = 2;
        } else if (incx == 0) {
            info[0] = 5;
        } else if (lda < Math.max(1, n)) {
            info[0] = 7;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsyr had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if ((n == 0) || (alpha == 0.0)) {
            return;
        }

        // Set the start point in x if the increment is not unity
        if (incx <= 0) {
            kx = -(n - 1) * incx;
        } else if (incx != 1) {
            kx = 0;
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through the triangular part of A.
        if ((uplo == 'U') || (uplo == 'u')) {

            if (incx == 1) {

                for (j = 0; j < n; j++) {

                    if (x[j] != 0.0) {
                        temp = alpha * x[j];

                        for (i = 0; i <= j; i++) {
                            A[i][j] = A[i][j] + (x[i] * temp);
                        }
                    } // if (x[j] != 0.0)
                } // for (j = 0; j < n; j++)
            } // if (incx == 1)
            else { // incx != 1
                jx = kx;

                for (j = 0; j < n; j++) {

                    if (x[jx] != 0.0) {
                        temp = alpha * x[jx];
                        ix = kx;

                        for (i = 0; i <= j; i++) {
                            A[i][j] = A[i][j] + (x[ix] * temp);
                            ix = ix + incx;
                        }
                    } // if (x[jx] != 0.0)

                    jx = jx + incx;
                } // for (j = 0; j < n; j++)
            } // else incx != 1
        } else { // ((uplo == 'L') || (uplo == 'l'))

            // Form A when A is stored in lower triangle
            if (incx == 1) {

                for (j = 0; j < n; j++) {

                    if (x[j] != 0.0) {
                        temp = alpha * x[j];

                        for (i = j; i < n; i++) {
                            A[i][j] = A[i][j] + (x[i] * temp);
                        }
                    } // if (x[j] != 0.0)
                } // for (j = 0; j < n; j++)
            } // if (incx == 1)
            else { // incx != 1
                jx = kx;

                for (j = 0; j < n; j++) {

                    if (x[jx] != 0.0) {
                        temp = alpha * x[jx];
                        ix = jx;

                        for (i = j; i < n; i++) {
                            A[i][j] = A[i][j] + (x[ix] * temp);
                            ix = ix + incx;
                        }
                    } // if (x[jx] != 0.0)

                    jx = jx + incx;
                } // for (j = 0; j < n; j++)
            } // else incx != 1
        } // else ((uplo == 'L') || (uplo == 'l'))

        return;
    } // dsyr

    /**
     * Port of 10/22/86 Blas DSYR2 routine Original version written by: Jack Dongarra, Argonne National Lab. Jeremy Du
     * Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs. dsyr2
     * performs the symmetric rank 2 operation A = alpha*x*y' + alpha*y*x' + A, where alpha is a scalar, x and y are n
     * element vectors, and A is an n by n symmetric matrix.
     *
     * @param  uplo   input char On entry, uplo specifies whether the upper or lower triangular part of the array A is
     *                to be referenced as follows: = 'U' or 'u' Only the upper triangular part of A is to be referenced.
     *                = 'L' or 'l' Only the lower triangular part of A is to be referenced.
     * @param  n      input int On entry, n specifies the order of the matrix A. n must be at least zero.
     * @param  alpha  input double specified scalar
     * @param  x      input double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x
     *                must contain the n element vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     * @param  y      input double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented array y
     *                must contain the n element vector y.
     * @param  incy   input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
     * @param  A      input/output double[][] of dimension lda by n. Before entry with uplo = 'U' or 'u', the leading n
     *                by n upper triangular part of the array A must contain the upper triangular part of the symmetric
     *                matrix and the strictly lower triangular part of A is not referenced. On exit, the upper
     *                triangular part of the array A is overwritten by the upper triangular part of the updated matrix.
     *                Before entry with uplo = 'L' or 'l', the leading n by n lower triangular part of the array A must
     *                contain the lower triangular part of the symmetric matrix and the strictly upper triangular part
     *                of A is not referenced. On exit, the lower triangular part of the array A is overwritten by the
     *                lower triangular part of the updated matrix.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,n).
     */
    private void dsyr2(char uplo, int n, double alpha, double[] x, int incx, double[] y, int incy, double[][] A,
                       int lda) {
        double temp1;
        double temp2;
        int i;
        int info;
        int ix;
        int iy;
        int j;
        int jx = 0;
        int jy = 0;
        int kx = 1;
        int ky = 1;

        // Test the input parameters
        info = 0;

        if ((uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if (n < 0) {
            info = 2;
        } else if (incx == 0) {
            info = 5;
        } else if (incy == 0) {
            info = 7;
        } else if (lda < Math.max(1, n)) {
            info = 9;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dsyr2 had info = " + info);

            return;
        }

        // Quick return if possible
        if ((n == 0) || (alpha == 0.0)) {
            return;
        }

        // Set up the start points in x and y if the increments are not both unity.

        if ((incx != 1) || (incy != 1)) {

            if (incx > 0) {
                kx = 1;
            } else {
                kx = 1 - ((n - 1) * incx);
            }

            if (incy > 0) {
                ky = 1;
            } else {
                ky = 1 - ((n - 1) * incy);
            }

            jx = kx - 1;
            jy = ky - 1;
        } // if ((incx != 1) || (incy != 1))

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through the triangular part of A.
        if ((uplo == 'U') || (uplo == 'u')) {

            // Form A when A is stored in the upper triangle
            if ((incx == 1) && (incy == 1)) {

                for (j = 0; j < n; j++) {

                    if ((x[j] != 0.0) || (y[j] != 0.0)) {
                        temp1 = alpha * y[j];
                        temp2 = alpha * x[j];

                        for (i = 0; i <= j; i++) {
                            A[i][j] = A[i][j] + (x[i] * temp1) + (y[i] * temp2);
                        }
                    } // if (x[j] != 0.0) || (y[j] != 0.0))
                } // for (j = 0; j < n; j++)
            } // if ((incx == 1) && (incy == 1))
            else { // ((incx != 1) || (incy != 1))

                for (j = 0; j < n; j++) {

                    if ((x[jx] != 0.0) || (y[jy] != 0.0)) {
                        temp1 = alpha * y[jy];
                        temp2 = alpha * x[jx];
                        ix = kx - 1;
                        iy = ky - 1;

                        for (i = 0; i <= j; i++) {
                            A[i][j] = A[i][j] + (x[ix] * temp1) + (y[iy] * temp2);
                            ix = ix + incx;
                            iy = iy + incy;
                        } // for (i = 0; i <= j; i++)
                    } // if ((x[jx] != 0.0) || (y[jy] != 0.0))

                    jx = jx + incx;
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // else ((incx != 1) || (incy != 1))
        } // if ((uplo == 'U') || (uplo == 'u'))
        else { // ((uplo == 'L') || (uplo == 'l'))

            // Form A when A is stored in the lower triangle
            if ((incx == 1) && (incy == 1)) {

                for (j = 0; j < n; j++) {

                    if ((x[j] != 0.0) || (y[j] != 0.0)) {
                        temp1 = alpha * y[j];
                        temp2 = alpha * x[j];

                        for (i = j; i < n; i++) {
                            A[i][j] = A[i][j] + (x[i] * temp1) + (y[i] * temp2);
                        }
                    } // if ((x[j] != 0.0) || (y[j] != 0.0))
                } // for (j = 0; j < n; j++)
            } // if ((incx == 1) && (incy == 1))
            else { // ((incx != 1) || (incy != 1))

                for (j = 0; j < n; j++) {

                    if ((x[jx] != 0.0) || (y[jy] != 0.0)) {
                        temp1 = alpha * y[jy];
                        temp2 = alpha * x[jx];
                        ix = jx;
                        iy = jy;

                        for (i = j; i < n; i++) {
                            A[i][j] = A[i][j] + (x[ix] * temp1) + (y[iy] * temp2);
                            ix = ix + incx;
                            iy = iy + incy;
                        } // for (i = j; i < n; i++)
                    } // if ((x[jx] != 0.0) || (y[jy] != 0.0))

                    jx = jx + incx;
                    jy = jy + incy;
                } // for (j = 0; j < n; j++)
            } // else ((incx != 1) || (incy != 1))
        } // else ((uplo == 'L') || (uplo == 'l'))

        return;
    } // dsyr2

    /**
     * This is a port of the 2/8/89 Blas routine DSYR2K Original version written by: Jack Dongarra, Argonne National
     * Lab. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
     * Algorithms Group Ltd. dsyr2k performs one of the symmeric rank 2k operations C = alpha*A*B' + alpha*B*A' +
     * beta*C, or C = alpha*A'*B + alpha*B'*A + beta*C, where alpha and beta are scalars, C is an n by n symmetric
     * matrix and A and B are n by k matrices in the first case and k by n matrices in the second case.
     *
     * @param  uplo   input char On entry, uplo specifies whether the upper or lower triangular part of the array C is
     *                to be referenced as follows: = 'U' or 'u' Only the upper triangular part of C is to be referenced.
     *                = 'L' or 'l' Only the lower triangular part of C is to be referenced
     * @param  trans  input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' C =
     *                alpha*A*B' + alpha*B*A' + beta*C = 'T' or 't' C = alpha*A'*B + alpha*B'*A + beta*C = 'C' or 'c' C
     *                = alpha*A'*B + alpha*B'*A + beta*C
     * @param  n      input int On entry, n specifies the order of the matrix C. n must be at least zero.
     * @param  k      input int On entry with trans = 'N' or 'n', k specifies the number of columns of the matrices A
     *                and B, and on entry with trans = 'T' or 't' or 'C' or 'c', k specifies the number of rows of the
     *                matrices A and B. k must be at least zero.
     * @param  alpha  input double Specifies scalar.
     * @param  A      input double[][] of dimension lda by ka, where ka is k when trans = 'N' or 'n', and is n
     *                otherwise. Before entry with trans = 'N' or 'n', the leading n by k part of the array A must
     *                contain the matrix A, otherwise the leading k by n part of the array A must contain the matrix A.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. When trans = 'N' or 'n' then lda must be at least max(1,n), otherwise lda must be at
     *                least max(1,k).
     * @param  B      input double[][] of dimension ldb by kb, where kb is k when trans = 'N' or 'n', and is n
     *                otherwise. Before entry with trans = 'N' or 'n', the leading n by k part of the array B must
     *                contain the matrix B, otherwise the leading k by n part of the array B must contain the matrix B.
     * @param  ldb    input int On entry, ldb specifies the first dimension of B as declared in the calling (sub)
     *                program. When trans = 'N' or 'n', then ldb must be at least max(1,n), otherwise ldb must be at
     *                least max(1,k).
     * @param  beta   input double Specified scalar
     * @param  C      input/output double[][] of dimension ldc by n Before entry with uplo = 'U' or 'u', the leading n
     *                by n upper triangular part of the array C must contain the upper triangular part of the symmetric
     *                matrix and the strictly lower triangular part of C is not referenced. On exit, the upper
     *                triangular part of the array C is overwritten by the upper triangular part of the updated matrix.
     *                Before entry with uplo = 'L' or 'l', the leading n by n lower triangular part of the array C must
     *                contain the lower triangular part of the symmetric matrix and the strictly upper triangular part
     *                of C is not referenced. On exit, the lower triangular part of the array C is overwritten by the
     *                lower triangular part of the updated matrix.
     * @param  ldc    input int On entry, ldc specifies the first dimension of C as declared in the calling (sub)
     *                program. ldc must be at least max(1,n).
     */
    private void dsyr2k(char uplo, char trans, int n, int k, double alpha, double[][] A, int lda, double[][] B, int ldb,
                        double beta, double[][] C, int ldc) {
        boolean upper;
        int i;
        int info;
        int j;
        int L;
        int nrowa;
        double temp1;
        double temp2;

        // Test the input parameters.

        if ((trans == 'N') || (trans == 'n')) {
            nrowa = n;
        } else {
            nrowa = k;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        info = 0;

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if ((trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') &&
                       (trans != 'c')) {
            info = 2;
        } else if (n < 0) {
            info = 3;
        } else if (k < 0) {
            info = 4;
        } else if (lda < Math.max(1, nrowa)) {
            info = 7;
        } else if (ldb < Math.max(1, nrowa)) {
            info = 9;
        } else if (ldc < Math.max(1, n)) {
            info = 12;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dsyr2k had info = " + info);

            return;
        }

        // Quick return if possible
        if ((n == 0) || (((alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
            return;
        }

        if (alpha == 0.0) {

            if (upper) {

                if (beta == 0.0) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = 0.0;
                        }
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (j = 0; j < n; j++) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    }
                } // else beta != 0.0
            } // if (upper)
            else { // lower

                if (beta == 0.0) {

                    for (j = 0; j < n; j++) {

                        for (i = j; i < n; i++) {
                            C[i][j] = 0.0;
                        }
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (j = 0; j < n; j++) {

                        for (i = j; i < n; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    }
                } // else beta != 0.0
            } // else lower

            return;
        } // if (alpha == 0.0)

        if ((trans == 'N') || (trans == 'n')) {

            // Form C = alpha*A*B' + alpha*B*A' + beta*C.
            if (upper) {

                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if ((A[j][L] != 0.0) || (B[j][L] != 0.0)) {
                            temp1 = alpha * B[j][L];
                            temp2 = alpha * A[j][L];

                            for (i = 0; i <= j; i++) {
                                C[i][j] = C[i][j] + (A[i][L] * temp1) + (B[i][L] * temp2);
                            }
                        } // if ((A[j][L] != 0.0) || (B[j][L] != 0.0))
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // if (upper)
            else { // lower

                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = j; i < n; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = j; i < n; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if ((A[j][L] != 0.0) || (B[j][L] != 0.0)) {
                            temp1 = alpha * B[j][L];
                            temp2 = alpha * A[j][L];

                            for (i = j; i < n; i++) {
                                C[i][j] = C[i][j] + (A[i][L] * temp1) + (B[i][L] * temp2);
                            }
                        } // if ((A[j][L] != 0.0) || (B[j][L] != 0.0))
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // else lower
        } // if ((trans == 'N') || (trans == 'n'))
        else { // ((trans != 'N') && (trans != 'n'))

            // Form C = alpha*A'*B + alpha*B'*A + beta*C.
            if (upper) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i <= j; i++) {
                        temp1 = 0.0;
                        temp2 = 0.0;

                        for (L = 0; L < k; L++) {
                            temp1 = temp1 + (A[L][i] * B[L][j]);
                            temp2 = temp2 + (B[L][i] * A[L][j]);
                        } // for (L = 0; L < k; L++)

                        if (beta == 0.0) {
                            C[i][j] = (alpha * temp1) + (alpha * temp2);
                        } else {
                            C[i][j] = (beta * C[i][j]) + (alpha * temp1) + (alpha * temp2);
                        }
                    } // for (i = 0; i <= j; i++)
                } // for (j = 0; j < n; j++)
            } // if (upper)
            else { // lower

                for (j = 0; j < n; j++) {

                    for (i = j; i < n; i++) {
                        temp1 = 0.0;
                        temp2 = 0.0;

                        for (L = 0; L < k; L++) {
                            temp1 = temp1 + (A[L][i] * B[L][j]);
                            temp2 = temp2 + (B[L][i] * A[L][j]);
                        } // for (L = 0; L < k; L++)

                        if (beta == 0.0) {
                            C[i][j] = (alpha * temp1) + (alpha * temp2);
                        } else {
                            C[i][j] = (beta * C[i][j]) + (alpha * temp1) + (alpha * temp2);
                        }
                    } // for (i = j; i < n; i++)
                } // for (j = 0; j < n; j++)
            } // else lower
        } // else ((trans != 'N') && (trans != 'n'))

        return;
    } // dsyr2k

    /**
     * dsyrk is the port of the 2/8/89 blas DSYRK routine. Original version written by: Jack Dongarra, Argonne National
     * Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
     * Algorithms Group Ltd. dsyrk performs one of the symmetric rank k operations C = alpha*A*A' + beta*C, or C =
     * alpha*A'*A + beta*c where alpha and beta are scalars, C is an n by n symmetric matrix and A is an n by k matrix
     * in the frist case and a k by n matrix in the second case.
     *
     * @param  uplo   input char On entry, uplo specifies whether the upper or lower triangular part of the array C is
     *                to be referenced as follows: = 'U' or 'u' Only the upper triangular part of C is to be referenced.
     *                = 'L' or 'l' Only the lower triangular part of C is to be referenced.
     * @param  trans  input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' C =
     *                alpha*A*A' + beta*C. = 'T' or 't' C = alpha*A'*A + beta*C. = 'C' or 'c' C = alpha*A'*A + beta*C.
     * @param  n      input int On entry, n specifies the order of the matrix C. n must be at least zero.
     * @param  k      input int On entry with trans = 'N' or 'n', k specifies the number of columns of the matrix A, and
     *                on entry with trans = 'T' or 't' or 'C' or 'c', k specifies the number of rows of the matrix A. k
     *                must be at least zero.
     * @param  alpha  input double specified scalar
     * @param  A      input double[][] array of dimension lda by ka, where ka is k when trans = 'N' or 'n', and is n
     *                otherwise. Before entry with trans = 'N' or 'n', the leading n by k part of the array A must
     *                contain the matrix A, otherwise the leading k by n part of the array A must contain the matrix A.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. When trans = 'N' or 'n' then lda must be at least max(1,n), otherwise lda must be at
     *                least max(1,k).
     * @param  beta   input double specified scalar
     * @param  C      input/output double[][] array of dimension ldc by n Before entry with uplo = 'U' or 'u', the
     *                leading n by n upper triangular part of the array C must contain the upper triangular part of the
     *                symmetric matrix and the strictly lower triangular part of C is not referenced. On exit, the upper
     *                triangular part of the array C, is overwritten by the upper triangular part of the updated matrix.
     *                Before entry with uplo = 'L' or 'l', the leading n by n lower triangular part of the array C must
     *                contain the lower triangular part of the symmetric matrix and the strictly upper triangular part
     *                of C is not referenced. On exit, the lower triangular part of the array C is overwritten by the
     *                lower triangular part of the updated matrix.
     * @param  ldc    input int On entry, ldc specifies the first dimension of C as declared in the calling (sub)
     *                program. ldc must be at least max(1,n).
     */
    private void dsyrk(char uplo, char trans, int n, int k, double alpha, double[][] A, int lda, double beta,
                       double[][] C, int ldc) {
        int nrowa;
        boolean upper;
        int info;
        int i;
        int j;
        int L;
        double temp;

        // Test the input parameters
        if ((trans == 'N') || (trans == 'n')) {
            nrowa = n;
        } else {
            nrowa = k;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        info = 0;

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if ((trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') &&
                       (trans != 'c')) {
            info = 2;
        } else if (n < 0) {
            info = 3;
        } else if (k < 0) {
            info = 4;
        } else if (lda < Math.max(1, nrowa)) {
            info = 7;
        } else if (ldc < Math.max(1, n)) {
            info = 10;
        }

        if (info != 0) {
            MipavUtil.displayError("Error in dsyrk with info = " + info);

            return;
        } // if (info != 0)

        // Quick return if possible
        if ((n == 0) || (((alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
            return;
        }

        if (alpha == 0.0) {

            if (upper) {

                if (beta == 0.0) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = 0.0;
                        }
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (j = 0; j < n; j++) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    }
                } // else beta != 0.0
            } // if (upper)
            else { // lower

                if (beta == 0.0) {

                    for (j = 0; j < n; j++) {

                        for (i = j; i < n; i++) {
                            C[i][j] = 0.0;
                        }
                    }
                } // if (beta == 0.0)
                else { // beta != 0.0

                    for (j = 0; j < n; j++) {

                        for (i = j; i < n; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    }
                } // else beta != 0.0
            } // else lower
        } // if (alpha == 0.0)

        if ((trans == 'N') || (trans == 'n')) {

            // Form C = alpha*A*A' + beta*C
            if (upper) {

                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = 0; i <= j; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if (A[j][L] != 0.0) {
                            temp = alpha * A[j][L];

                            for (i = 0; i <= j; i++) {
                                C[i][j] = C[i][j] + (temp * A[i][L]);
                            }
                        } // if (A[j][L] != 0.0)
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // if (upper)
            else { // lower

                for (j = 0; j < n; j++) {

                    if (beta == 0.0) {

                        for (i = j; i < n; i++) {
                            C[i][j] = 0.0;
                        }
                    } // if (beta == 0.0)
                    else if (beta != 1.0) {

                        for (i = j; i < n; i++) {
                            C[i][j] = beta * C[i][j];
                        }
                    } // else if (beta != 1.0)

                    for (L = 0; L < k; L++) {

                        if (A[j][L] != 0.0) {
                            temp = alpha * A[j][L];

                            for (i = j; i < n; i++) {
                                C[i][j] = C[i][j] + (temp * A[i][L]);
                            }
                        } // if (A[j][L] != 0.0)
                    } // for (L = 0; L < k; L++)
                } // for (j = 0; j < n; j++)
            } // else lower
        } // if ((trans == 'N') || (trans == 'n'))
        else { // trans != 'N' && trans != 'n'

            // Form C = alpha*A'*A + beta*C.
            if (upper) {

                for (j = 0; j < n; j++) {

                    for (i = 0; i <= j; i++) {
                        temp = 0.0;

                        for (L = 0; L < k; L++) {
                            temp = temp + (A[L][i] * A[L][j]);
                        }

                        if (beta == 0.0) {
                            C[i][j] = alpha * temp;
                        } else {
                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
                        }
                    } // for (i = 0; i <= j; i++)
                } // for (j = 0; j < n; j++)
            } // if (upper)
            else { // lower

                for (j = 0; j < n; j++) {

                    for (i = j; i < n; i++) {
                        temp = 0.0;

                        for (L = 0; L < k; L++) {
                            temp = temp + (A[L][i] * A[L][j]);
                        }

                        if (beta == 0.0) {
                            C[i][j] = alpha * temp;
                        } else {
                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
                        }
                    } // for (i = j; i < n; i++)
                } // for (j = 0; j < n; j++)
            } // else lower
        } // else trans != 'N' && trans != 'n'

        return;
    } // dsyrk

    /**
     * This is a port of version 3.1 LAPACK test routine DSYT21 Original DSYT21 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsyt21 generally checks a decomposition of the form A = U S U' where ' means transpose, A is symmetric, U is
     * orthogonal, and S is diagonal (if kband == 0) or symmetric tridiagonal (if kband == 1).
     *
     * <p>If itype == 1, then U is represented as a dense matrix; otherwise U is expressed as a product of Householder
     * transformations, whose vectors are stored in the array "V" and whose scaling constants are in "tau". We shall use
     * the letter "V" to refer to the product of Householder transformations (which should be equal to U).</p>
     *
     * <p>Specifically, if itype == 1, then: result[0] = | A - U S U' | / ( |A| n ulp ) *and* 
     *                                       result[1] = | I - UU' | / (n ulp )</p>
     *
     * <p>If itype == 2, then: result[0] = | A - V S V' | / ( |A| n ulp )</p>
     *
     * <p>If itype == 3, then: result[0] = | I - VU' | / ( n ulp )</p>
     *
     * <p>For itype > 1, the transformation U is expressed as a product V = H(0)...H(n-1), where H(j) = I - tau(j) v(j) v(j)'
     *         and each vector v(j) has its first j elements 0 and the remaining n-j elements stored in V(j:n-1,j-1).</p>
     *
     * @param  itype   (input) int Specifies the type of tests to be performed. 
     *                 1: U expressed as a dense orthogonal matrix: 
     *                 result[0] = | A - U S U' | / ( |A| n ulp ) *and* 
     *                 result[1] = | I - UU' | / ( n ulp ) 
     *                 2: U expressed as a product V of Householder transformations:
     *                 result[0] = | A - V S V' | / ( |A| n ulp )
     *                 3: U expressed both as a dense orthogonal matrix and as a product of Householder
     *                 transformations: 
     *                 result[0] = | I - VU' | / ( n ulp )
     * @param  uplo    (input) char If uplo == 'U', the upper triangle of A and V will be used and the (strictly) lower
     *                 triangle will not be referenced. If uplo == 'L', the lower triangle of A and V will be used and
     *                 the (strictly) upper triangle will not be referenced.
     * @param  n       (input) int The size of the matrix. If it is zero, dsyt21 does nothing. It must be at least zero.
     * @param  kband   (input) int The bandwidth of the matrix. It may only be zero or one. If zero, then S is diagonal,
     *                 and E is not referenced. If one, then S is symmetric tri-diagonal.
     * @param  A       (input) double[][] of dimension (lda,n) The original (unfactored) matrix. It is assumed to be
     *                 symmetric, and only the upper (uplo == 'U') or only the lower (uplo == 'L') will be referenced.
     * @param  lda     (input) int The leading dimension of A. It must be at least 1 and at least n.
     * @param  D       (input) double[] of dimension (n) The diagonal of the (symmetric tri-) diagonal matrix.
     * @param  E       (input) double[] of dimension (n-1) The off-diagonal of the (symmetric tri-) diagonal matrix.
     *                 E[0] is the [0][1] and [1][0] element, E[1] is the [1][2] and [2][1] element, etc. Not
     *                 referenced if kband == 0.
     * @param  U       (input) double[][] of dimension (ldu,n) If itype == 1 or 3, this contains the orthogonal matrix
     *                 in the decomposition, expressed as a dense matrix. If itype == 2, then it is not referenced.
     * @param  ldu     (input) int The leading dimension of U. ldu must be at least n and at least 1.
     * @param  V       (input) double[][] of dimension (ldv,n) If itype == 2 or 3, the columns of this array contain the
     *                 Householder vectors used to describe the orthogonal matrix in the decomposition. If uplo == 'L',
     *                 then the vectors are in the lower triangle, if uplo == 'U', then in the upper triangle. *Note* If
     *                 itype == 2 or 3, V is modified and restored. The subdiagonal (if uplo == 'L') or the
     *                 superdiagonal (if uplo == 'U') is set to one, and later reset to its original value, during the
     *                 course of the calculation. If itype == 1, then it is neither referenced nor modified.
     * @param  ldv     (input) int The leading dimension of V. ldv must be at least n and at least 1.
     * @param  tau     (input) double[] of dimension (n) If itype >= 2, then tau[j] is the scalar factor of v(j) v(j)'
     *                 in the Householder transformation H(j) of the product U = H(0)...H(n-3) If itype < 2, then tau is
     *                 not referenced.
     * @param  work    (workspace) double[] of dimension (2*n**2)
     * @param  result  (output) double[] of dimension (2) The values computed by the two tests are described above. The
     *                 values are currently limited to 1/ulp, to avoid overflow. result[0] is always modified. result[1]
     *                 is modified only if itype == 1.
     */
    private void dsyt21(int itype, char uplo, int n, int kband, double[][] A, int lda, double[] D, double[] E,
                        double[][] U, int ldu, double[][] V, int ldv, double[] tau, double[] work, double[] result) {
        boolean lower;
        char cuplo;
        int[] iinfo = new int[1];
        int j;
        int jcol;
        int jr;
        int jrow;
        double anorm;
        double ulp;
        double unfl;
        double vsave;
        double wnorm = 0.0;
        double[] x;
        double[] y;
        int i;
        double[][] array1;
        double[][] array2;
        int index1;
        int index2;
        int index3;
        int index4;

        result[0] = 0.0;

        if (itype == 1) {
            result[1] = 0.0;
        }

        if (n <= 0) {
            return;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            lower = false;
            cuplo = 'U';
        } else {
            lower = true;
            cuplo = 'L';
        }

        unfl = dlamch('S');
        ulp = dlamch('E') * dlamch('B');

        // Some Error Checks
        if ((itype < 1) || (itype > 3)) {
            result[0] = 10.0 / ulp;

            return;
        }

        x = new double[n];
        y = new double[n];

        // Do Test 1

        // Norm of A:
        if (itype == 3) {
            anorm = 1.0;
        } else {
            anorm = Math.max(dlansy('1', cuplo, n, A, lda, work), unfl);
        }

        // Compute error matrix:
        if (itype == 1) {

            // itype == 1: error = A - U S U'
            array1 = new double[n][n];
            dlaset('F', n, n, 0.0, 0.0, array1, n);
            dlacpy(cuplo, n, n, A, lda, array1, n);

            for (j = 0; j < n; j++) {

                for (i = 0; i < n; i++) {
                    x[i] = U[i][j];
                }

                dsyr(cuplo, n, -D[j], x, 1, array1, n);
            } // for (j = 0; j < n; j++)

            if ((n > 1) && (kband == 1)) {

                for (j = 0; j < (n - 1); j++) {

                    for (i = 0; i < n; i++) {
                        x[i] = U[i][j];
                        y[i] = U[i][j + 1];
                        dsyr2(cuplo, n, -E[j], x, 1, y, 1, array1, n);
                    }
                } // for (j = 0; j < n-1; j++)
            } // if ((n > 1) && (kband == 1))

            wnorm = dlansy('1', cuplo, n, array1, n, work);
        } // if (itype == 1)
        else if (itype == 2) {

            // itype == 2: error = V S V' - A
            array1 = new double[n][n];
            dlaset('F', n, n, 0.0, 0.0, array1, n);
            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                work[i] = array1[index1][index2];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            if (lower) {
                work[(n * n) - 1] = D[n - 1];

                for (j = n - 1; j >= 1; j--) {

                    if (kband == 1) {
                        work[((n + 1) * (j - 1)) + 1] = (1.0 - tau[j - 1]) * E[j - 1];

                        for (jr = j + 2; jr <= n; jr++) {
                            work[((j - 1) * n) + jr - 1] = -tau[j - 1] * E[j - 1] * V[jr - 1][j - 1];
                        }
                    } // if (kband == 1)

                    vsave = V[j][j - 1];
                    V[j][j - 1] = 1.0;

                    for (i = 0; i < (n - j); i++) {
                        x[i] = V[j + i][j - 1];
                    }

                    array1 = new double[n][n - j];
                    index1 = 0;
                    index2 = 0;

                    for (i = 0; i < (n * (n - j)); i++) {
                        array1[index1][index2] = work[((n + 1) * j) + i];
                        index1++;

                        if (index1 == n) {
                            index1 = 0;
                            index2++;
                        }
                    }

                    dlarfy('L', n - j, x, 1, tau[j - 1], array1, n, y);
                    index1 = 0;
                    index2 = 0;

                    for (i = 0; i < (n * (n - j)); i++) {
                        work[((n + 1) * j) + i] = array1[index1][index2];
                        index1++;

                        if (index1 == n) {
                            index1 = 0;
                            index2++;
                        }
                    }

                    V[j][j - 1] = vsave;
                    work[(n + 1) * (j - 1)] = D[j - 1];
                } // for (j = n-1; j >= 1; j--)
            } // if (lower)
            else { // upper
                work[0] = D[0];

                for (j = 1; j <= (n - 1); j++) {

                    if (kband == 1) {
                        work[((n + 1) * j) - 1] = (1.0 - tau[j - 1]) * E[j - 1];

                        for (jr = 1; jr <= (j - 1); jr++) {
                            work[(j * n) + jr - 1] = -tau[j - 1] * E[j - 1] * V[jr - 1][j];
                        }
                    } // if (kband == 1)

                    vsave = V[j - 1][j];
                    V[j - 1][j] = 1.0;

                    for (i = 0; i < j; i++) {
                        x[i] = V[i][j];
                    }

                    array1 = new double[n][j];
                    index1 = 0;
                    index2 = 0;

                    for (i = 0; i < (n * j); i++) {
                        array1[index1][index2] = work[i];
                        index1++;

                        if (index1 == n) {
                            index1 = 0;
                            index2++;
                        }
                    }

                    dlarfy('U', j, x, 1, tau[j - 1], array1, n, y);
                    index1 = 0;
                    index2 = 0;

                    for (i = 0; i < (n * j); i++) {
                        work[i] = array1[index1][index2];
                        index1++;

                        if (index1 == n) {
                            index1 = 0;
                            index2++;
                        }
                    }

                    V[j - 1][j] = vsave;
                    work[(n + 1) * j] = D[j];
                } // for (j = 1; j <= n-1; j++)
            } // else upper

            for (jcol = 1; jcol <= n; jcol++) {

                if (lower) {

                    for (jrow = jcol; jrow <= n; jrow++) {
                        work[jrow + (n * (jcol - 1)) - 1] = work[jrow + (n * (jcol - 1)) - 1] - A[jrow - 1][jcol - 1];
                    } // for (jrow = jcol; jrow <= n; jrow++)
                } // if (lower)
                else { // upper

                    for (jrow = 1; jrow <= jcol; jrow++) {
                        work[jrow + (n * (jcol - 1)) - 1] = work[jrow + (n * (jcol - 1)) - 1] - A[jrow - 1][jcol - 1];
                    } // for (jrow = 1; jrow <= jcol; jrow++)
                } // else upper
            } // for (jcol = 1; jcol <= n; jcol++)

            index1 = 0;
            index2 = 0;
            array1 = new double[n][n];

            for (i = 0; i < (n * n); i++) {
                array1[index1][index2] = work[i];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            wnorm = dlansy('1', cuplo, n, array1, n, work);
        } // else if (itype == 2)
        else if (itype == 3) {

            // itype == 3: error = U V' - I
            if (n < 2) {
                return;
            }

            array1 = new double[n][n];
            dlacpy(' ', n, n, U, ldu, array1, n);
            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                work[i] = array1[index1][index2];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            array1 = new double[ldv][n - 1];
            array2 = new double[n][n - 1];

            if (lower) {
                index1 = 1;
                index2 = 0;
                index3 = 0;
                index4 = 0;

                for (i = 0; i < (ldv * (n - 1)); i++) {
                    array1[index3][index4] = V[index1][index2];
                    index1++;

                    if (index1 == ldv) {
                        index1 = 0;
                        index2++;
                    }

                    index3++;

                    if (index3 == ldv) {
                        index3 = 0;
                        index4++;
                    }
                }

                index1 = 0;
                index2 = 0;

                for (i = 0; i < (n * (n - 1)); i++) {
                    array2[index1][index2] = work[n + i];
                    index1++;

                    if (index1 == n) {
                        index1 = 0;
                        index2++;
                    }
                }

                dorm2r('R', 'T', n, n - 1, n - 1, array1, ldv, tau, array2, n, x, iinfo);
                index1 = 0;
                index2 = 0;

                for (i = 0; i < (n * (n - 1)); i++) {
                    work[n + i] = array2[index1][index2];
                    index1++;

                    if (index1 == n) {
                        index1 = 0;
                        index2++;
                    }
                }
            } // if (lower)
            else { // upper
                index1 = 0;
                index2 = 1;
                index3 = 0;
                index4 = 0;

                for (i = 0; i < (ldv * (n - 1)); i++) {
                    array1[index3][index4] = V[index1][index2];
                    index1++;

                    if (index1 == ldv) {
                        index1 = 0;
                        index2++;
                    }

                    index3++;

                    if (index3 == ldv) {
                        index3 = 0;
                        index4++;
                    }
                }

                index1 = 0;
                index2 = 0;

                for (i = 0; i < (n * (n - 1)); i++) {
                    array2[index1][index2] = work[i];
                    index1++;

                    if (index1 == n) {
                        index1 = 0;
                        index2++;
                    }
                }

                dorm2l('R', 'T', n, n - 1, n - 1, array1, ldv, tau, array2, n, x, iinfo);
                index1 = 0;
                index2 = 0;

                for (i = 0; i < (n * (n - 1)); i++) {
                    work[i] = array2[index1][index2];
                    index1++;

                    if (index1 == n) {
                        index1 = 0;
                        index2++;
                    }
                }
            } // else upper

            if (iinfo[0] != 0) {
                result[0] = 10.0 / ulp;

                return;
            } // if (iinfo[0] != 0)

            for (j = 1; j <= n; j++) {
                work[(n + 1) * (j - 1)] = work[(n + 1) * (j - 1)] - 1.0;
            }

            array1 = new double[n][n];
            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                array1[index1][index2] = work[i];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            wnorm = dlange('1', n, n, array1, n, x);
        } // else if (itype == 3)

        if (anorm > wnorm) {
            result[0] = (wnorm / anorm) / (n * ulp);
        } else if (anorm < 1.0) {
            result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
        } else {
            result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
        }

        // Do test 2
        // Compute UU' - I
        if (itype == 1) {
            array1 = new double[n][n];
            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                array1[index1][index2] = work[i];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, array1, n);
            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                work[i] = array1[index1][index2];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            for (j = 1; j <= n; j++) {
                work[(n + 1) * (j - 1)] = work[(n + 1) * (j - 1)] - 1.0;
            }

            index1 = 0;
            index2 = 0;

            for (i = 0; i < (n * n); i++) {
                array1[index1][index2] = work[i];
                index1++;

                if (index1 == n) {
                    index1 = 0;
                    index2++;
                }
            }

            result[1] = Math.min(dlange('1', n, n, array1, n, x), (double) n) / (n * ulp);
        } // if (itype == 1)

        return;
    } // dsyt21

    /**
     * This is a port of the version 3.1 LAPACK routine DSYTD2 Original DSYTD2 created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsytd2 reduces a real symmetric matrix A to symmetric tridiagonal form T by an orthogonal similarity
     * transformation: Q' * A * Q = T.
     *
     * @param  uplo  input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
     *               stored: 
     *               = 'U': Upper triangular 
     *               = 'L': Lower triangular
     * @param  n     input int The order of the matrix A. n >= 0.
     * @param  A     input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *               leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and
     *               the strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
     *               triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
     *               triangular part of A is not referenced. On exit, if uplo = 'U', the diagonal and first
     *               superdiagonal of A are overwritten by the corresponding elements of the tridiagonal matrix T, and
     *               the elements above the first superdiagonal, with the array tau, represent the orthogonal matrix Q
     *               as a product of elementary reflectors; if uplo = 'L', the diagonal and first subdiagonal of A are
     *               overwritten by the corresponding elements of the tridiagonal matrix T, and the elements below the
     *               first subdiagonal, with the array tau, represent the orthogonal matrix Q as a product of elementary
     *               reflectors. See Further Details.
     * @param  lda   input int The leading dimension of the array A. lda >= max(1,n).
     * @param  d     output double[] of dimension n. The diagonal elements of the tridiagonal matrix T: D[i] = A[i][i].
     * @param  e     output double[] of dimension n-1. The off-diagonal elements of the tridiagonal matrix T: e[i] =
     *               A[i][i+1] if uplo = 'U', e[i] = A[i+1][i] if uplo = 'L'
     * @param  tau   output double[] of dimension n-1. The scalar factors of the elementary reflectors (see Furtehr
     *               Details).
     * @param  info  output int[] 
     *               = 0: successful exit 
     *               < 0: If info = -i, the i-th argument had an illegal value
     *
     *               <p>Further Details: If uplo = 'U', the matrix Q is represented as a product of elementary
     *               reflectors Q = H[n-2] ... H[1] H[0] Each H[i] has the form H[i] = I - tau * v * v' where tau is a
     *               real scalar, and v is a real vector with v(i:n-1) = 0 and v(i-1) = 1; v(0:i-2) is stored on exit in
     *               A(0:i-2,i), and tau in tau[i-1]. If uplo = 'L', the matrix Q is represented as a product of
     *               elementary refelectors Q = H[0] H[1] ... H[n-2] Each H[i] has the form H[i] = I - tau * v * v'
     *               where tau is a real scalar, and v is a real vector with v(0:i-1) = 0 and v(i) = 1; v(i+1:n-1) is
     *               stored on exit in A(i+1:n-1,i-1), and tau in tau[i-1].</p>
     *
     *               <p>The contents of A on exit are illustrated by the following examples with n = 5: If uplo = 'U':
     *               (d e v2 v3 v4 ) 
     *               (  d  e v3 v4 ) 
     *               (     d  e v4 ) 
     *               (        d  e ) 
     *               (           d )
     *                If Uplo = 'L': 
     *                (d            ) 
     *                (e   d        )
     *                (v1  e  d     )
     *                (v1 v2  e d   )
     *                (v1 v2 v3 e d ) 
     *                where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of the
     *                vector defining H[i].</p>
     */
    private void dsytd2(char uplo, int n, double[][] A, int lda, double[] d, double[] e, double[] tau, int[] info) {
        boolean upper;
        int i;
        int j;
        int k;
        double alpha;
        double[] taui = new double[1];
        double[] vector1;
        double[] vector2;
        double[][] array1;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -4;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsytd2 had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        if (n <= 0) {
            return;
        }

        if (upper) {

            // Reduce the upper triangle of A
            for (i = n - 1; i >= 1; i--) {

                // Generate elementary reflector H[i-1] = I - tau * v * v' to
                // annihilate A(0:i-2,i)
                if (i == 1) {
                    taui[0] = 0.0;
                } else {
                    vector1 = new double[1];
                    vector1[0] = A[i - 1][i];
                    vector2 = new double[i - 1];

                    for (j = 0; j < (i - 1); j++) {
                        vector2[j] = A[j][i];
                    }

                    dlarfg(i, vector1, vector2, 1, taui);
                    A[i - 1][i] = vector1[0];

                    for (j = 0; j < (i - 1); j++) {
                        A[j][i] = vector2[j];
                    }
                }

                e[i - 1] = A[i - 1][i];

                if (taui[0] != 0.0) {

                    // Apply H[i-1] from both sides to A(0:i-1,0:i-1)
                    A[i - 1][i] = 1.0;

                    // Compute x = tau * A * v storing x in tau(0:i-1)
                    vector1 = new double[i];

                    for (j = 0; j < i; j++) {
                        vector1[j] = A[j][i];
                    }

                    dsymv(uplo, i, taui[0], A, lda, vector1, 1, 0.0, tau, 1);


                    // Compute w = x - 1/2 * tau * (x'*v) * v
                    alpha = -0.5 * taui[0] * ddot(i, tau, 1, vector1, 1);
                    daxpy(i, alpha, vector1, 1, tau, 1);

                    // Apply the transformation as a rank-2 update:
                    // A = A - v * w' - w * v'
                    dsyr2(uplo, i, -1.0, vector1, 1, tau, 1, A, lda);
                    A[i - 1][i] = e[i - 1];
                } // if (taui[0] != 0.0)

                d[i] = A[i][i];
                tau[i - 1] = taui[0];
            } // for (i = n-1; i >= 1; i--)

            d[0] = A[0][0];
        } // if (upper)
        else { // lower

            // Reduce the lower triangle of A
            for (i = 1; i <= (n - 1); i++) {

                // Generate elementary reflector H[i-1] = I - tau * v * v'
                // to annihilate A(i+1:n-1,i-1)
                if (i == (n - 1)) {
                    taui[0] = 0.0;
                } else {
                    vector1 = new double[1];
                    vector1[0] = A[i][i - 1];
                    vector2 = new double[n - i - 1];

                    for (j = 0; j < (n - i - 1); j++) {
                        vector2[j] = A[j + Math.min(i + 1, n - 1)][i - 1];
                    }

                    dlarfg(n - i, vector1, vector2, 1, taui);
                    A[i][i - 1] = vector1[0];

                    for (j = 0; j < (n - i - 1); j++) {
                        A[j + Math.min(i + 1, n - 1)][i - 1] = vector2[j];
                    }
                }

                e[i - 1] = A[i][i - 1];

                if (taui[0] != 0.0) {

                    // Apply H[i-1] from both sides to A(i:n-1,i:n-1)
                    A[i][i - 1] = 1.0;

                    // Compute x = tau * A * v storing y in tau(i-1:n-2)
                    array1 = new double[n - i][n - i];

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (n - i); k++) {
                            array1[j][k] = A[j + i][k + i];
                        }
                    }

                    vector1 = new double[n - i];
                    vector2 = new double[n - i];

                    for (j = 0; j < (n - i); j++) {
                        vector1[j] = A[j + i][i - 1];
                        vector2[j] = tau[j + i - 1];
                    }

                    dsymv(uplo, n - i, taui[0], array1, n - i, vector1, 1, 0.0, vector2, 1);

                    // Compute w = x - 1/2 * tau * (x'*v) * v
                    alpha = -0.5 * taui[0] * ddot(n - i, vector2, 1, vector1, 1);
                    daxpy(n - i, alpha, vector1, 1, vector2, 1);

                    // Apply the transformation as a rank-2 update:
                    // A = A - v * w' - w * v'
                    dsyr2(uplo, n - i, -1.0, vector1, 1, vector2, 1, array1, n - i);

                    for (j = 0; j < (n - i); j++) {
                        tau[j + i - 1] = vector2[j];
                    }

                    for (j = 0; j < (n - i); j++) {

                        for (k = 0; k < (n - i); k++) {
                            A[j + i][k + i] = array1[j][k];
                        }
                    }

                    A[i][i - 1] = e[i - 1];
                } // if (taui[0] != 0.0)

                d[i - 1] = A[i - 1][i - 1];
                tau[i - 1] = taui[0];
            } // for (i = 1; i <= n-1; i++)

            d[n - 1] = A[n - 1][n - 1];
        } // else lower

        return;
    } // dsytd2

    /**
     * This is a port of the version 3.1 LAPACK routine DSYTRD Original DSYTRD created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dsytrd reduces a real symmetric matrix A to a real symmetric tridiagonal form T by an orthogonal similarity
     * transformation. Q'*A*Q = T.
     *
     * @param  uplo   input char 
     *                = 'U': Upper triangle of A is stored. 
     *                = 'L': Lower triangle of A is stored.
     * @param  n      input int The order of the matrix A. n >= 0.
     * @param  A      input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
     *                leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and
     *                the strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
     *                triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
     *                triangular part of A is not referenced. On exit, if uplo = 'U', the diagonal and first
     *                superdiagonal of A are overwritten by the corresponding elements of the tridiagonal matrix T, and
     *                the elements above the first superdiagonal, with the array tau, represent the orthogonal matrix Q
     *                as a product of elementary reflectors; if uplo = 'L', the diagonal and first subdiagonal of A are
     *                overwritten by the corresponding elements of the tridiagonal matrix T, and the elements below the
     *                first subdiagonal, with the array tau, represent the orthogonal matrix Q as a product of
     *                elementary reflectors. See further details.
     * @param  lda    input int The leading dimension of the array A. lda >= max(1,n).
     * @param  d      output double[] of dimension n The diagonal elements of the tridiagonal matrix T: d[i] = A[i][i].
     * @param  e      output double[] of dimension n-1. The off-diagonal elements of the tridiagonal matrix T: e[i] =
     *                A[i][i+1] if uplo = 'U', e[i] = A[i+1][i], if uplo = 'L'.
     * @param  tau    output double[] of dimension n-1. The scalar factors of the elementary reflectors (see Further
     *                Details).
     * @param  work   (workspace/output) double[] of dimension max(1, lwork). 
     *                On exit, if info[0] = 0, work[0] returns the optimal lwork.
     * @param  lwork  input int The dimension of the array work. lwork >= 1. For optimum performance lwork >= n*nb,
     *                where nb is the optimal blocksize. if lwork = -1, then a workspace query is assumed; the routine
     *                only calculates the optimal size of the work array, returns this value as the first entry of the
     *                work array, and no error message related to lwork is issued.
     * @param  info   output int[] 
     *                = 0: successful exit 
     *                < 0: If info = -i, the i-th argument had an illegal value
     *
     *                <p>Further details: If uplo = 'U', the matrix Q is represented as a product of elementary
     *                reflectors Q = H[n-2]...H[1] H[0]. Each H[i] has the form H[i] = I - tau * v * v' where tau is a
     *                real scalar, and v is a real vector with v(i:n-1) = 0 and v[i-1] = 1; v(0:i-2) is stored on exit
     *                in A(0:i-2,i), and tau in tau[i-1]. If uplo = 'L', the matrix Q is represented as a product of
     *                elementary reflectors Q = H[0] H[1] ... H[n-2] Each H[i] has the form H[i] = I - tau * v * v'
     *                where tau is a real scalar, and v is a real vector with v(0:i-1) = 0 and v(i) = 0; v(i+1:n-1) is
     *                stored on exit in A(i+1:n-1,i-1), and tau in tau[i-1].</p>
     *
     *                <p>The contents of A on exit are illustrated by the following examples with n = 5:
     *                If uplo = 'U':
     *                (d e v2 v3 v4)
     *                (  d  e v3 v4)
     *                (     d  e v4)
     *                (        d  e)
     *                (           d)
     *                If uplo = 'L':
     *                (d           )
     *                (e   d       )
     *                (v1  e  d    )
     *                (v1 v2  e d  )
     *                (v1 v2 v3 e d) 
     *                where d and e denote diagonal and off-diagonal elements of T, 
     *                and vi denotes an element of the vector defining H[i].</p>
     */
    private void dsytrd(char uplo, int n, double[][] A, int lda, double[] d, double[] e, double[] tau, double[] work,
                        int lwork, int[] info) {
        boolean lquery;
        boolean upper;
        int i;
        int[] iinfo = new int[1];
        int iws;
        int j;
        int kk;
        int ldwork = n;
        int lwkopt = 1;
        int nb = 1;
        int nbmin;
        int nx;
        char[] ch = new char[1];
        String opts = null;
        double[][] array1;
        double[][] array2;
        int p;
        int q;
        double[][] work2d;
        double[] vector1;
        double[] vector2;
        double[] vector3;
        double[][] work2da;

        // Test the input parameters
        info[0] = 0;

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        if (lwork == -1) {
            lquery = true;
        } else {
            lquery = false;
        }

        if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info[0] = -1;
        } else if (n < 0) {
            info[0] = -2;
        } else if (lda < Math.max(1, n)) {
            info[0] = -4;
        } else if ((lwork < 1) && (!lquery)) {
            info[0] = -9;
        }

        if (info[0] == 0) {

            // Determine the block size
            ch[0] = uplo;
            opts = new String(ch);
            nb = ilaenv(1, "DSYTRD", opts, n, -1, -1, -1);
            lwkopt = n * nb;
            work[0] = lwkopt;
        } // if (info[0] == 0)

        if (info[0] != 0) {
            MipavUtil.displayError("Error dsytrd had info[0] = " + info[0]);

            return;
        } // if (info[0] != 0)
        else if (lquery) {
            return;
        }

        // Quick return if possible
        if (n == 0) {
            work[0] = 1;

            return;
        } // if (n == 0)

        nx = n;
        iws = 1;

        if ((nb > 1) && (nb < n)) {

            // Determine when to cross over from blocked to unblocked code (last
            // block is always handled by unblocked code).
            nx = Math.max(nb, ilaenv(3, "DSYTRD", opts, n, -1, -1, -1));

            if (nx < n) {

                // Determine if workspace is large enough for blocked code
                ldwork = n;
                iws = ldwork * nb;

                if (lwork < iws) {

                    // Not enough workspace to use optimal nb: determine the minimum
                    // value of nb, and reduce nb or force use of unblocked code by
                    // setting nx = n
                    nb = Math.max(lwork / ldwork, 1);
                    nbmin = ilaenv(2, "DSYTRD", opts, n, -1, -1, -1);

                    if (nb < nbmin) {
                        nx = n;
                    }
                } // if (lwork < iws)
            } // if (nx < n)
            else {
                nx = n;
            }
        } // if ((nb > 1) && (nb < n))
        else {
            nb = 1;
        }

        if (upper) {
            // Reduce the upper triangle of A.
            // Columns 0:kk-1 are handled by the unblocked method.

            kk = n - (((n - nx + nb - 1) / nb) * nb);

            for (i = n - nb + 1; i >= (kk + 1); i -= nb) {

                // Reduce columns i-1:i+nb-2 to tridiagonal form and form the matrix
                // W which is needed to update the unreduced part of the matrix
                work2d = new double[ldwork][nb];
                dlatrd(uplo, i + nb - 1, nb, A, lda, e, tau, work2d, ldwork);

                // Update the unreduced submatrix A(0:i-2,0:i-2), using an update of
                // the form: A = A - V*W' - W*V'
                if (i != 1) {
                    array1 = new double[i - 1][nb];

                    for (p = 0; p < (i - 1); p++) {

                        for (q = 0; q < nb; q++) {
                            array1[p][q] = A[p][q + i - 1];
                        }
                    }

                    dsyr2k(uplo, 'N', i - 1, nb, -1.0, array1, i - 1, work2d, ldwork, 1.0, A, lda);
                } // if (i != 1)

                // Copy the superdiagonal elements back into A, and diagonal elements
                // into d
                for (j = i; j <= (i + nb - 1); j++) {
                    A[j - 2][j - 1] = e[j - 2];
                    d[j - 1] = A[j - 1][j - 1];
                }
            } // for (i = n-nb+1; i >= kk+1; i-= nb)

            // Use unblocked code to reduce the last or only block
            dsytd2(uplo, kk, A, lda, d, e, tau, iinfo);
        } // if (upper)
        else { // lower

            // Reduce lower triangle of A
            for (i = 1; i <= (n - nx); i += nb) {

                // Reduce columns i-1:i+nb-2 to tridiagonal form and form the matrix W
                // which is needed to update the unreduced part of the matrix
                array1 = new double[n - i + 1][n - i + 1];

                for (p = 0; p < (n - i + 1); p++) {

                    for (q = 0; q < (n - i + 1); q++) {
                        array1[p][q] = A[p + i - 1][q + i - 1];
                    }
                }

                vector1 = new double[n - i];
                vector2 = new double[n - i];
                work2d = new double[n - i + 1][nb];
                dlatrd(uplo, n - i + 1, nb, array1, n - i + 1, vector1, vector2, work2d, n - i + 1);

                for (p = 0; p < (n - i + 1); p++) {

                    for (q = 0; q < (n - i + 1); q++) {
                        A[p + i - 1][q + i - 1] = array1[p][q];
                    }
                }

                for (p = 0; p < (n - i); p++) {
                    e[p + i - 1] = vector1[p];
                    tau[p + i - 1] = vector2[p];
                }

                // Update the unreduced submatrix A(i+ib-1:n-1,i+ib-1:n-1), using
                // an update of the form: A = A - V*W' - W*V'
                array1 = new double[n - i - nb + 1][nb];

                for (p = 0; p < (n - i - nb + 1); p++) {

                    for (q = 0; q < nb; q++) {
                        array1[p][q] = A[p + i + nb - 1][q + i - 1];
                    }
                }

                work2da = new double[n - i - nb + 1][nb];

                for (p = 0; p < (n - i - nb + 1); p++) {

                    for (q = 0; q < nb; q++) {
                        work2da[p][q] = work2d[p + nb][q];
                    }
                }

                array2 = new double[n - i - nb + 1][n - i - nb + 1];

                for (p = 0; p < (n - i - nb + 1); p++) {

                    for (q = 0; q < (n - i - nb + 1); q++) {
                        array2[p][q] = A[p + i + nb - 1][q + i + nb - 1];
                    }
                }

                dsyr2k(uplo, 'N', n - i - nb + 1, nb, -1.0, array1, n - i - nb + 1, work2da, n - i - nb + 1, 1.0,
                       array2, n - i - nb + 1);

                for (p = 0; p < (n - i - nb + 1); p++) {

                    for (q = 0; q < (n - i - nb + 1); q++) {
                        A[p + i + nb - 1][q + i + nb - 1] = array2[p][q];
                    }
                }

                // Copy subdiagonal elements back into A, and diagonal elements
                // into D.
                for (j = i; j <= (i + nb - 1); j++) {
                    A[j][j - 1] = e[j - 1];
                    d[j - 1] = A[j - 1][j - 1];
                }
            } // for (i = 1; i <= n-nx; i += nb)

            // Use unblocked code to reduce the last or only block
            array1 = new double[n - i + 1][n - i + 1];

            for (p = 0; p < (n - i + 1); p++) {

                for (q = 0; q < (n - i + 1); q++) {
                    array1[p][q] = A[p + i - 1][q + i - 1];
                }
            }

            vector1 = new double[n - i + 1];
            vector2 = new double[n - i];
            vector3 = new double[n - i];
            dsytd2(uplo, n - i + 1, array1, n - i + 1, vector1, vector2, vector3, iinfo);

            for (p = 0; p < (n - i + 1); p++) {

                for (q = 0; q < (n - i + 1); q++) {
                    A[p + i - i][q + i - 1] = array1[p][q];
                }
            }

            for (p = 0; p < (n - i + 1); p++) {
                d[p + i - 1] = vector1[p];
            }

            for (p = 0; p < (n - i); p++) {
                e[p + i - 1] = vector2[p];
                tau[p + i - 1] = vector3[p];
            }
        } // else lower

        work[0] = lwkopt;

        return;
    } // dsytrd

    /**
     * This is a port of version 3.1 LAPACK routine DTGEVC Original DTGEVC created by Univ. of Tennessee, Univ. of
     * California Berkeley, and NAG Ltd., November, 2006
     * dtgevc computes some or all of the right and/or left eigenvectors of a pair of real eigenvectors of
     * a pair of real matrices (S,P), where S is a quasi-triangular matrix and P is upper triangular.  Matrix 
     * pairs of this type are produced by the generalized Schur factorization of a matrix pair (A,B):
     *      A = Q*S*Z**T,    B = Q*P*Z**T
     * as computed by dgghrd + dhgeqz
     * 
     * The right eigenvector x and the left eigenvector y of (S, P) corresponding to an eigenvalue w are
     * defined by:
     *     S*x = w*P*x,    (y**H)*S = w*(y**H)*P,
     *     
     * where y**H denotes the conjugate transpose of y.  The eigenvalues are not input to this routine,
     * but are computed directly from the diagonal blocks of S and P.
     * 
     * This routine returns the matrices X and/or Y of right and left eigenvectors of (S,P), or the products
     * Z*X and/or Q*Y, where Z and Q are input matrices.  If Q and Z are the orthogonal factors from the generalized
     * Schur factorization of a matrix pair (A,B), then Z*X and Q*Y are the matrices of right and left
     * eigenvectors of (A, B).
     *
     * @param  side    input char 
     *                 = 'R': compute right eigenvectors only 
     *                 = 'L': compute left eigenvectors only 
     *                 = 'B': compute both right and left eigenvectors
     * @param  howmny  input char 
     *                 = 'A': compute all right and/or left eigenvectors 
     *                 = 'B': compute all right and/or left eigenvectors, 
     *                        backtransformed by the matrices in vr and/or vl 
     *                 = 'S': Compute selected right and/or left eigenvectors, specified by the boolean array select
     * @param  select  input boolean[] of dimension (n) If howmny = 'S', select specifies the eigenvectors to be
     *                 computed. If w[j] is a real eigenvalue, the corresponding real eigenvector is computed if
     *                 select[j] is true.  If w[j] and w[j+1] are real and imaginary parts of a complex 
     *                 eigenvalue, the corresponding complex eigenvector is computed if either select[j] or
     *                 select[j+1] is true, and on exit select[j] is set to true and select[j+1] is set to
     *                 false.
     *                 Not referenced if howmny == 'A' or 'B'.
     * @param  n       input int The order of the matrices S and P. n >= 0.
     * @param  S       input double[][] of dimension (lds,n) The upper quasi-triangular matrix S from a generalized 
     *                 Schur factorization, as computd by dhgeqz,
     * @param  lds     input int The leading dimension of array S. lds >= max(1,n).
     * @param  P       input double[][] of dimension (ldp,n) The upper triangular matrix P from a generalized
     *                 Schur factorization, as computed by dhgeqz.
     *                 2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S must be in positive
     *                 diagonal form.
     * @param  ldp     input int The leading dimension of the array P. ldp >= max(1,n).
     * @param  vl      (input/output) double[][] of dimension (ldvl,mm) On entry, if side = 'L' or 'B' and howmny = 'B',
     *                 vl must contain an n-by-n matrix Q (usually the orthogonal matrix Q of left Schur vectors
     *                 returned by dhgeqz). On exit, if side = 'L' or 'B', vl contains: 
     *                 if howmny = 'A', the matrix Y of left eigenvectors of (S,P) 
     *                 if howmny = 'B', the matrix Q*Y 
     *                 if howmny = 'S', the left eigenvectors of (S,P) specified by select, stored consecutively
     *                    in the columns of vl, in the same order as their eigenvalues.
     *
     *                 <p>A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive
     *                 columns, the first holding the real part, and the second the imaginary part.
     *                 
     *                 Not referenced if side == 'R'.</p>
     * @param  ldvl    input int The leading dimension of the array vl. ldvl >= 1, and if side == 'L' or 'B',
     *                 ldvl >= n.
     * @param  vr      (input/output) double[][] of dimension (ldvr,mm) On entry, if side = 'R' or 'B' and howmny = 'B',
     *                 vr must contain an n-by-n matrix Z (usually the orthogonal matrix Z of right Schur vectors
     *                 returned by dhgeqz). 
     *                 
     *                 On exit, if side = 'R' or 'B', vr contains: 
     *                 if howmny = 'A', the matrix X of right eigenvectors of (S,P) 
     *                 if howmny = 'B' or 'b', the matrix Z*X 
     *                 if howmny = 'S' or 's', the right eigenvectors of (S,P) specified by select, stored consecutively
     *                 in the columns of vr, in the same order as their eigenvalues.
     *
     *                 <p>A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive
     *                 columns, the first holding the real part and the second holding the imaginary part.
     *                 
     *                 Not referenced if side = 'L'.</p>
     * @param  ldvr    input int The leading dimension of the array vr. ldvr >= 1, and if side == 'R' or 'B',
     *                 ldvr >= n.
     * @param  mm      input int The number of columns in the arrays vl and/or vr. mm >= m.
     * @param  m       output int[] The number of columns in the arrys vl and/or vr actually used to store the
     *                 eigenvectors. If howmny = 'A' or 'B', m is set to n. Each selected real eigenvector occupies one
     *                 column and each selected complex eigenvector occupies two columns.
     * @param  work    workspace double[] of dimension (6*n)
     * @param  info    output int[] 
     *                 = 0: successful exit 
     *                 < 0: if info[0] = -i, the i-th argument had an illegal value. 
     *                 > 0: the 2-by-2 block (info-1:info) does not have a complex eigenvalue.
     *                 
     * Further details: 
     * Allocation of workspace: 
     *     work[j] = 1-norm of j-th column of A, above the diagonal. 
     *     work[n+j] = 1-norm of j-th column of B, above the diagonal. 
     *     work[2*n:3*n-1] = real part of eigenvector 
     *     work[3*n:4*n-1] = imaginary part of eigenvector 
     *     work[4*n:5*n-1] = real part of back-transformed eigenvector
     *     work[5*n:6*n-1] = imaginary part of back-transformed eigenvector 
     *     
     * Rowwise vs. columnwise solution methods: 
     * 
     * Finding a generalized eigenvector consists basically of solving the singular triangular system 
     * (A - wB) x = 0 (for right) or: (A- wB)**H y = 0 (for left)
     *
     * <p>Consider finding the i-th right eigenvector (assume all eigenvalues are real). The equation to
     * be solved is: 
     *  0 = sum from k=j to k=n-1 of C[j][k] v[k] = sum from k=j to k=i of C[j][k] v[k] for
     *  j = i,...,0 where C = (A - w B) (The components v(i+1:n-1) are 0.)</p>
     *
     * <p>The "rowwise" method is: 
     *    (1) v(i) := 1 
     *    for j = i-1,...,0: 
     *    (2) compute s = -sum from k=j+1 to k=i of C[j][k] v[k] and 
     *    (3) v[j] := s / C[j][j]</p>
     *
     * <p>Step 2 is sometimes called the "dot product" step, since it is an inner product between the
     * j-th row and the portion of the eigenvector that has been computed so far.</p>
     *
     * <p>The "columnwise" method consists basically in doing the sums for all the rows in parallel. As
     * each v[j] is computed, the contribution of v[j] times the j-th column of C is added to the
     * partial sums.</p>
     *
     * <p>When finding left eigenvectors, the matrix in question is the transpose of the one in storage,
     * so the rowwise method then actually accesses columns of A and B at each step.</p>
     */
    private void dtgevc(char side, char howmny, boolean[] select, int n, double[][] S, int lds, double[][] P, int ldp,
                        double[][] vl, int ldvl, double[][] vr, int ldvr, int mm, int[] m, double[] work, int[] info) {
        double safety = 100.0;
        boolean compl;
        boolean compr;
        boolean il2by2;
        boolean ilabad;
        boolean ilall;
        boolean ilback;
        boolean ilbbad;
        boolean ilcomp;
        boolean ilcplx;
        boolean lsa;
        boolean lsb;
        int i;
        int ibeg;
        int ieig;
        int iend;
        int ihwmny;
        int[] iinfo = new int[1];
        int im;
        int iside;
        int j;
        int ja;
        int jc;
        int je;
        int jr;
        int jw;
        int na;
        int nw;
        double[] acoef = new double[1];
        double acoefa;
        double anorm;
        double ascale;
        double bcoefa;
        double[] bcoefi = new double[1];
        double[] bcoefr = new double[1];
        double[] big = new double[1];
        double bignum;
        double bnorm;
        double bscale;
        double cim2a;
        double cim2b;
        double cimaga;
        double cimagb;
        double cre2a;
        double cre2b;
        double creala;
        double crealb;
        double dmin;
        double[] safmin = new double[1];
        double salfar;
        double sbeta;
        double[] scale = new double[1];
        double small;
        double[] temp = new double[1];
        double[] temp2 = new double[1];
        double temp2i;
        double temp2r;
        double ulp;
        double xmax;
        double xscale;
        double[] bdiag = new double[2];
        double[][] sum = new double[2][2];
        double[][] sums = new double[2][2];
        double[][] sump = new double[2][2];
        double[][] array1;
        double[][] array2;
        double[] x;
        double[] y;
        int p;
        int q;
        int r;
        int row1;

        // Decode and test the input parameters
        if ((howmny == 'A') || (howmny == 'a')) {
            ihwmny = 1;
            ilall = true;
            ilback = false;
        } else if ((howmny == 'S') || (howmny == 's')) {
            ihwmny = 2;
            ilall = false;
            ilback = false;
        } else if ((howmny == 'B') || (howmny == 'b')) {
            ihwmny = 3;
            ilall = true;
            ilback = true;
        } else {
            ihwmny = -1;
            ilall = true;
            ilback = false;
        }

        if ((side == 'R') || (side == 'r')) {
            iside = 1;
            compl = false;
            compr = true;
        } else if ((side == 'L') || (side == 'l')) {
            iside = 2;
            compl = true;
            compr = false;
        } else if ((side == 'B') || (side == 'b')) {
            iside = 3;
            compl = true;
            compr = true;
        } else {
            iside = -1;
            compl = false;
            compr = false;
        }

        info[0] = 0;

        if (iside < 0) {
            info[0] = -1;
        } else if (ihwmny < 0) {
            info[0] = -2;
        } else if (n < 0) {
            info[0] = -4;
        } else if (lds < Math.max(1, n)) {
            info[0] = -6;
        } else if (ldp < Math.max(1, n)) {
            info[0] = -8;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dtgevc had info[0] = " + info[0]);

            return;
        }

        // Count the number of eigenvectors to be computed
        if (!ilall) {
            im = 0;
            ilcplx = false;

            for (j = 0; j < n; j++) {

                if (ilcplx) {
                    ilcplx = false;

                    continue;
                } // if (ilcplx)

                if (j < (n - 1)) {

                    if (S[j + 1][j] != 0.0) {
                        ilcplx = true;
                    }
                } // if (j < (n-1))

                if (ilcplx) {

                    if (select[j] || (select[j + 1])) {
                        im = im + 2;
                    }
                } // if (ilcplx)
                else if (select[j]) {
                    im = im + 1;
                } // else if (select[j])
            } // for (j = 0; j < n; j++)
        } // if (!ilall)
        else { // ilall
            im = n;
        } // else ilall

        // Check 2-by-2 diagonal blocks of S, P
        ilabad = false;
        ilbbad = false;

        for (j = 0; j < (n - 1); j++) {

            if (S[j + 1][j] != 0.0) {

                if ((P[j][j] == 0.0) || (P[j + 1][j + 1] == 0.0) || (P[j][j + 1] != 0.0)) {
                    ilbbad = true;
                }

                if (j < (n - 2)) {

                    if (S[j + 2][j + 1] != 0.0) {
                        ilabad = true;
                    }
                } // if (j < n-2)
            } // if (S[j+1][j] != 0.0)
        } // for (j = 0; j < n-1; j++)

        if (ilabad) {
            info[0] = -5;
        } else if (ilbbad) {
            info[0] = -7;
        } else if ((compl && (ldvl < n)) || (ldvl < 1)) {
            info[0] = -10;
        } else if ((compr && (ldvr < n)) || (ldvr < 1)) {
            info[0] = -12;
        } else if (mm < im) {
            info[0] = -13;
        }

        if (info[0] != 0) {
            MipavUtil.displayError("Error dtgevc had info[0] = " + info[0]);

            return;
        }

        // Quick return if possible
        m[0] = im;

        if (n == 0) {
            return;
        }

        // Machine constants
        safmin[0] = dlamch('S');
        big[0] = 1.0 / safmin[0];
        dlabad(safmin, big);
        ulp = dlamch('E') * dlamch('B');
        small = safmin[0] * n / ulp;
        big[0] = 1.0 / small;
        bignum = 1.0 / (safmin[0] * n);

        // Compute the 1-norm of each column of the strictly upper triangular
        // part (i.e., excluding all elements belonging to the diagonal blocks)
        // of S and P to check for possible overflow in the triangular solver.
        anorm = Math.abs(S[0][0]);

        if (n > 1) {
            anorm = anorm + Math.abs(S[1][0]);
        }

        bnorm = Math.abs(P[0][0]);
        work[0] = 0.0;
        work[n] = 0.0;

        for (j = 2; j <= n; j++) {
            temp[0] = 0.0;
            temp2[0] = 0.0;

            if (S[j - 1][j - 2] == 0.0) {
                iend = j - 1;
            } else {
                iend = j - 2;
            }

            for (i = 1; i <= iend; i++) {
                temp[0] = temp[0] + Math.abs(S[i - 1][j - 1]);
                temp2[0] = temp2[0] + Math.abs(P[i - 1][j - 1]);
            }

            work[j - 1] = temp[0];
            work[n - 1 + j] = temp2[0];

            for (i = iend + 1; i <= Math.min(j + 1, n); i++) {
                temp[0] = temp[0] + Math.abs(S[i - 1][j - 1]);
                temp2[0] = temp2[0] + Math.abs(P[i - 1][j - 1]);
            }

            anorm = Math.max(anorm, temp[0]);
            bnorm = Math.max(bnorm, temp2[0]);
        } // for (j = 2; j <= n; j++)

        ascale = 1.0 / Math.max(anorm, safmin[0]);
        bscale = 1.0 / Math.max(bnorm, safmin[0]);

        // Left eigenvectors
        if (compl) {
            ieig = 0;

            // Main loop over eigenvalues
            ilcplx = false;

            for (je = 1; je <= n; je++) {

                // Skip this iteration if (a) howmny = 'S' and select = false, or
                // (b) this would be the second of a complex pair.
                // Check for complex eigenvalue, so as to be sure of which
                // entry(-ies) of select to look at.
                if (ilcplx) {
                    ilcplx = false;

                    continue;
                } // if (ilcplx)

                nw = 1;

                if (je < n) {

                    if (S[je][je - 1] != 0.0) {
                        ilcplx = true;
                        nw = 2;
                    } // if (S[je][je-1] != 0.0)
                } // if (je < n)

                if (ilall) {
                    ilcomp = true;
                } else if (ilcplx) {
                    ilcomp = select[je - 1] || select[je];
                } else {
                    ilcomp = select[je - 1];
                } // else

                if (!ilcomp) {
                    continue;
                } // if (!ilcomp)

                // Decide if (a) singular pencil, (b) real eigenvalue, or
                // (c) complex eigenvalue
                if (!ilcplx) {

                    if ((Math.abs(S[je - 1][je - 1]) <= safmin[0]) && (Math.abs(P[je - 1][je - 1]) <= safmin[0])) {

                        // Singular matrix pencil -- return unit eigenvector
                        ieig = ieig + 1;

                        for (jr = 1; jr <= n; jr++) {
                            vl[jr - 1][ieig - 1] = 0.0;
                        }

                        vl[ieig - 1][ieig - 1] = 1.0;

                        continue;
                    } // if ((Math.abs(S[je-1][je-1]) <= safmin[0]) &&
                } // if (!ilcplx)

                // Clear vector
                for (jr = 0; jr < (nw * n); jr++) {
                    work[(2 * n) + jr] = 0.0;
                }

                // Compute coefficients in (a S - b B)transpose y  = 0
                // a is acoef
                // b is coefr + i*bcoefi
                if (!ilcplx) {

                    // Real eigenvalue
                    temp[0] = Math.max(Math.abs(S[je - 1][je - 1]) * ascale, Math.abs(P[je - 1][je - 1]) * bscale);
                    temp[0] = Math.max(temp[0], safmin[0]);
                    temp[0] = 1.0 / temp[0];
                    salfar = (temp[0] * S[je - 1][je - 1]) * ascale;
                    sbeta = (temp[0] * P[je - 1][je - 1]) * bscale;
                    acoef[0] = sbeta * ascale;
                    bcoefr[0] = salfar * bscale;
                    bcoefi[0] = 0.0;

                    // Scale to avoid underflow
                    scale[0] = 1.0;
                    lsa = ((Math.abs(sbeta) >= safmin[0]) && (Math.abs(acoef[0]) < small));
                    lsb = ((Math.abs(salfar) >= safmin[0]) && (Math.abs(bcoefr[0]) < small));

                    if (lsa) {
                        scale[0] = (small / Math.abs(sbeta)) * Math.min(anorm, big[0]);
                    }

                    if (lsb) {
                        scale[0] = Math.max(scale[0], (small / Math.abs(salfar)) * Math.min(bnorm, big[0]));
                    }

                    if (lsa || lsb) {
                        temp[0] = Math.max(1.0, Math.abs(acoef[0]));
                        temp[0] = Math.max(temp[0], Math.abs(bcoefr[0]));
                        scale[0] = Math.min(scale[0], 1.0 / (safmin[0] * temp[0]));

                        if (lsa) {
                            acoef[0] = ascale * (scale[0] * sbeta);
                        } else {
                            acoef[0] = scale[0] * acoef[0];
                        }

                        if (lsb) {
                            bcoefr[0] = bscale * (scale[0] * salfar);
                        } else {
                            bcoefr[0] = scale[0] * bcoefr[0];
                        }
                    } // if (lsa || lsb)

                    acoefa = Math.abs(acoef[0]);
                    bcoefa = Math.abs(bcoefr[0]);

                    // First component is 1
                    work[(2 * n) + je - 1] = 1.0;
                    xmax = 1.0;
                } // if (!ilcplx)
                else { // complex eigenvalue
                    array1 = new double[2][2];
                    array2 = new double[2][2];

                    for (p = 0; p < 2; p++) {

                        for (q = 0; q < 2; q++) {
                            array1[p][q] = S[je - 1 + p][je - 1 + q];
                            array2[p][q] = P[je - 1 + p][je - 1 + q];
                        }
                    }

                    dlag2(array1, 2, array2, 2, safmin[0] * safety, acoef, temp, bcoefr, temp2, bcoefi);
                    bcoefi[0] = -bcoefi[0];

                    if (bcoefi[0] == 0.0) {
                        info[0] = je;

                        return;
                    } // if (bcoefi[0] == 0.0)

                    // Scale to avoid over/underflow
                    acoefa = Math.abs(acoef[0]);
                    bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
                    scale[0] = 1.0;

                    if (((acoefa * ulp) < safmin[0]) && (acoefa >= safmin[0])) {
                        scale[0] = (safmin[0] / ulp) / acoefa;
                    }

                    if (((bcoefa * ulp) < safmin[0]) && (bcoefa >= safmin[0])) {
                        scale[0] = Math.max(scale[0], (safmin[0] / ulp) / bcoefa);
                    }

                    if ((safmin[0] * acoefa) > ascale) {
                        scale[0] = ascale / (safmin[0] * acoefa);
                    }

                    if ((safmin[0] * bcoefa) > bscale) {
                        scale[0] = Math.min(scale[0], bscale / (safmin[0] * bcoefa));
                    }

                    if (scale[0] != 1.0) {
                        acoef[0] = scale[0] * acoef[0];
                        acoefa = Math.abs(acoef[0]);
                        bcoefr[0] = scale[0] * bcoefr[0];
                        bcoefi[0] = scale[0] * bcoefi[0];
                        bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
                    } // if (scale != 1.0)

                    // Compute first two components of eigenvector
                    temp[0] = acoef[0] * S[je][je - 1];
                    temp2r = (acoef[0] * S[je - 1][je - 1]) - (bcoefr[0] * P[je - 1][je - 1]);
                    temp2i = -bcoefi[0] * P[je - 1][je - 1];

                    if (Math.abs(temp[0]) > (Math.abs(temp2r) + Math.abs(temp2i))) {
                        work[(2 * n) + je - 1] = 1.0;
                        work[(3 * n) + je - 1] = 0.0;
                        work[(2 * n) + je] = -temp2r / temp[0];
                        work[(3 * n) + je] = -temp2i / temp[0];
                    } else {
                        work[(2 * n) + je] = 1.0;
                        work[(3 * n) + je] = 0.0;
                        temp[0] = acoef[0] * S[je - 1][je];
                        work[(2 * n) + je - 1] = ((bcoefr[0] * P[je][je]) - (acoef[0] * S[je][je])) / temp[0];
                        work[(3 * n) + je - 1] = bcoefi[0] * P[je][je] / temp[0];
                    }

                    xmax = Math.max(Math.abs(work[(2 * n) + je - 1]) + Math.abs(work[(3 * n) + je - 1]),
                                    Math.abs(work[(2 * n) + je]) + Math.abs(work[(3 * n) + je]));
                } // else complex eigenvalue

                dmin = Math.max(ulp * acoefa * anorm, ulp * bcoefa * bnorm);
                dmin = Math.max(dmin, safmin[0]);

                // Triangular solve of (a S - b P)transpose y = 0
                // (rowwise in (a S - b P )transpose,
                // or columnwise in (a S - b P))
                il2by2 = false;

                for (j = je + nw; j <= n; j++) {

                    if (il2by2) {
                        il2by2 = false;

                        continue;
                    } // if (il2by2)

                    na = 1;
                    bdiag[0] = P[j - 1][j - 1];

                    if (j < n) {

                        if (S[j][j - 1] != 0.0) {
                            il2by2 = true;
                            bdiag[1] = P[j][j];
                            na = 2;
                        } // if (S[j][j-1] != 0.0)
                    } // if (j < n)

                    // Check whether scaling is necessary for dot products
                    xscale = 1.0 / Math.max(1.0, xmax);
                    temp[0] = Math.max(work[j - 1], work[n + j - 1]);
                    temp[0] = Math.max(temp[0], (acoefa * work[j - 1]) + (bcoefa * work[n + j - 1]));

                    if (il2by2) {
                        temp[0] = Math.max(temp[0], work[j]);
                        temp[0] = Math.max(temp[0], work[n + j]);
                        temp[0] = Math.max(temp[0], (acoefa * work[j]) + (bcoefa * work[n + j]));
                    } // if (il2by2)

                    if (temp[0] > (bignum * xscale)) {

                        for (jw = 0; jw <= (nw - 1); jw++) {

                            for (jr = je; jr <= (j - 1); jr++) {
                                work[((jw + 2) * n) + jr - 1] = xscale * work[((jw + 2) * n) + jr - 1];
                            } // for (jr = je; jr <= j - 1; jr++)
                        } // for (jw = 0; jw <= nw-1; jw++)

                        xmax = xmax * xscale;
                    } // if (temp[0] > bignum * xscale)

                    // Compute dot products
                    // SUM = sum from k = je to k = j-1 of
                    // conjg(a * S[k-1][j-1] - b*P[k-1][j-1]) * x[k-1]
                    // To reduce the op count, this is done as
                    // aconjg*conjg(sum from k=je to k=j-1 of S[k-1][j-1]*x[k-1])
                    // - bonjg*conjg(sum from k=je to k=j-1 of P[k-1][j-1]*x[k-1])
                    // which may cause underflow problems if S or P are close to
                    // underflow.  (e.g., less than small.)
                    for (jw = 1; jw <= nw; jw++) {

                        for (ja = 1; ja <= na; ja++) {
                            sums[ja - 1][jw - 1] = 0.0;
                            sump[ja - 1][jw - 1] = 0.0;

                            for (jr = je; jr <= (j - 1); jr++) {
                                sums[ja - 1][jw - 1] = sums[ja - 1][jw - 1] +
                                                       (S[jr - 1][j + ja - 2] * work[((jw + 1) * n) + jr - 1]);
                                sump[ja - 1][jw - 1] = sump[ja - 1][jw - 1] +
                                                       (P[jr - 1][j + ja - 2] * work[((jw + 1) * n) + jr - 1]);
                            } // for (jr = je; jr <= j-1; jr++)
                        } // for (ja = 1; ja <= na; ja++)
                    } // for (jw = 1; jw <= nw; jw++)

                    for (ja = 0; ja < na; ja++) {

                        if (ilcplx) {
                            sum[ja][0] = (-acoef[0] * sums[ja][0]) + (bcoefr[0] * sump[ja][0]) -
                                         (bcoefi[0] * sump[ja][1]);
                            sum[ja][1] = (-acoef[0] * sums[ja][1]) + (bcoefr[0] * sump[ja][1]) +
                                         (bcoefi[0] * sump[ja][0]);
                        } else { // if (ilcplx),  !ilcplx
                            sum[ja][0] = (-acoef[0] * sums[ja][0]) + (bcoefr[0] * sump[ja][0]);
                        } // else !ilcplx
                    } // for (ja = 0; ja < na; ja++)

                    // Solve (a S - b B)transpose y = SUM(,)
                    // with scaling and perturbation of the denominator
                    array1 = new double[na][na];

                    for (p = 0; p < na; p++) {

                        for (q = 0; q < na; q++) {
                            array1[p][q] = S[j - 1 + p][j - 1 + q];
                        }
                    }

                    array2 = new double[na][nw];
                    dlaln2(true, na, nw, dmin, acoef[0], array1, na, bdiag[0], bdiag[1], sum, 2, bcoefr[0], bcoefi[0],
                           array2, na, scale, temp, iinfo);
                    work[(2 * n) + j - 1] = array2[0][0];

                    if (na == 2) {
                        work[(2 * n) + j] = array2[1][0];
                    }

                    if (nw == 2) {
                        work[(3 * n) + j - 1] = array2[0][1];

                        if (na == 2) {
                            work[(3 * n) + j] = array2[1][1];
                        }
                    }

                    if (scale[0] < 1.0) {

                        for (jw = 0; jw <= (nw - 1); jw++) {

                            for (jr = je; jr <= (j - 1); jr++) {
                                work[((jw + 2) * n) + jr - 1] = scale[0] * work[((jw + 2) * n) + jr - 1];
                            } // for (jr = je; jr <= j-1; jr++)
                        } // for (jw = 0; jw <= nw - 1; jw++)

                        xmax = scale[0] * xmax;
                    } // if (scale[0] < 1.0)

                    xmax = Math.max(xmax, temp[0]);
                } // for (j = je + nw; j <= n; j++)

                // Copy eigenvector to vl, back transforming if howmny == 'B'
                ieig = ieig + 1;

                if (ilback) {

                    for (jw = 0; jw <= (nw - 1); jw++) {
                        row1 = Math.max(1, n);
                        array1 = new double[row1][n + 1 - je];

                        for (p = 0; p < row1; p++) {

                            for (q = 0; q < (n + 1 - je); q++) {
                                array1[p][q] = vl[p][je - 1 + q];
                            }
                        }

                        x = new double[n + 1 - je];

                        for (p = 0; p < (n + 1 - je); p++) {
                            x[p] = work[((jw + 2) * n) + je - 1 + p];
                        }

                        y = new double[n];

                        for (p = 0; p < n; p++) {
                            y[p] = work[((jw + 4) * n) + p];
                        }

                        dgemv('N', n, n + 1 - je, 1.0, array1, row1, x, 1, 0.0, y, 1);

                        for (p = 0; p < n; p++) {
                            work[((jw + 4) * n) + p] = y[p];
                        }
                    } // for (jw = 0; jw <= nw - 1; jw++)

                    array1 = new double[n][nw];
                    r = 0;

                    for (q = 0; q < nw; q++) {

                        for (p = 0; p < n; p++) {
                            array1[p][q] = work[(4 * n) + r];
                            r++;
                        }
                    }

                    array2 = new double[n][nw];
                    dlacpy(' ', n, nw, array1, n, array2, n);

                    for (p = 0; p < n; p++) {

                        for (q = 0; q < nw; q++) {
                            vl[p][je - 1 + q] = array2[p][q];
                        }
                    }

                    ibeg = 1;
                } // if (ilback)
                else { // !ilback
                    array1 = new double[n][nw];
                    r = 0;

                    for (q = 0; q < nw; q++) {

                        for (p = 0; p < n; p++) {
                            array1[p][q] = work[(2 * n) + r];
                            r++;
                        }
                    }

                    array2 = new double[n][nw];
                    dlacpy(' ', n, nw, array1, n, array2, n);

                    for (p = 0; p < n; p++) {

                        for (q = 0; q < nw; q++) {
                            vl[p][ieig - 1 + q] = array2[p][q];
                        }
                    }

                    ibeg = je;
                } // else !ilback

                // Scale eigenvector
                xmax = 0.0;

                if (ilcplx) {

                    for (j = ibeg - 1; j < n; j++) {
                        xmax = Math.max(xmax, Math.abs(vl[j][ieig - 1]) + Math.abs(vl[j][ieig]));
                    }
                } // if (ilcplx)
                else { // !ilcplx

                    for (j = ibeg - 1; j < n; j++) {
                        xmax = Math.max(xmax, Math.abs(vl[j][ieig - 1]));
                    }
                } // else !ilcplx

                if (xmax > safmin[0]) {
                    xscale = 1.0 / xmax;

                    for (jw = 0; jw <= (nw - 1); jw++) {

                        for (jr = ibeg; jr <= n; jr++) {
                            vl[jr - 1][ieig + jw - 1] = xscale * vl[jr - 1][ieig + jw - 1];
                        }
                    }
                } // if (xmax > safmin[0])

                ieig = ieig + nw - 1;
            } // for (je = 1; je <= n; je++)
        } // if (compl)

        // Right eigenvectors
        if (compr) {
            ieig = im + 1;

            // Main loop over eigenvalues
            ilcplx = false;

            for (je = n; je >= 1; je--) {

                // Skip this iteration if (a) howmny = 'S' and select = false, or
                // (b) this would be the second of a complex pair.
                // Check for complex eigenvalue, so as to be sure of which
                // entry(-ies) of select to look at -- if complex, select[je-1]
                // or select[je-2]
                // If this is a complex pair, the 2-by-2 diagonal block
                // corresponding to the eigenvalue is i0n rows/columns je-2:je-1
                if (ilcplx) {
                    ilcplx = false;

                    continue;
                } // if (ilcplx)

                nw = 1;

                if (je > 1) {

                    if (S[je - 1][je - 2] != 0.0) {
                        ilcplx = true;
                        nw = 2;
                    } // if (S[je-1][je-2] != 0.0)
                } // if (je > 1)

                if (ilall) {
                    ilcomp = true;
                } // if (ilall)
                else if (ilcplx) {
                    ilcomp = select[je - 1] || select[je - 2];
                } // else if (ilcplx)
                else {
                    ilcomp = select[je - 1];
                }

                if (!ilcomp) {
                    continue;
                } // if (!ilcomp)

                // Decide if (a) singular pencil, (b) real eigenvalue, or
                // (c) complex eigenvalue.
                if (!ilcplx) {

                    if ((Math.abs(S[je - 1][je - 1]) <= safmin[0]) && (Math.abs(P[je - 1][je - 1]) <= safmin[0])) {

                        // Singular matrix pencil -- unit eigenvector
                        ieig = ieig - 1;

                        for (jr = 0; jr < n; jr++) {
                            vr[jr][ieig - 1] = 0.0;
                        }

                        vr[ieig - 1][ieig - 1] = 1.0;

                        continue;
                    } // if ((Math.abs(S[je-1][je-1]) <= safmin[0]) &&
                } // if (!ilcplx)

                // Clear vector
                for (jw = 0; jw <= (nw - 1); jw++) {

                    for (jr = 1; jr <= n; jr++) {
                        work[((jw + 2) * n) + jr - 1] = 0.0;
                    }
                }

                // Compute coefficients in (a S - b B) x = 0
                // a is acoef[0]
                // b is bcoefr + i*bcoefi[0]
                if (!ilcplx) {

                    // Real eigenvalue
                    temp[0] = Math.max(Math.abs(S[je - 1][je - 1]) * ascale, Math.abs(P[je - 1][je - 1]) * bscale);
                    temp[0] = Math.max(temp[0], safmin[0]);
                    temp[0] = 1.0 / temp[0];
                    salfar = (temp[0] * S[je - 1][je - 1]) * ascale;
                    sbeta = (temp[0] * P[je - 1][je - 1]) * bscale;
                    acoef[0] = sbeta * ascale;
                    bcoefr[0] = salfar * bscale;
                    bcoefi[0] = 0.0;

                    // Scale to avoid underflow
                    scale[0] = 1.0;
                    lsa = ((Math.abs(sbeta) >= safmin[0]) && (Math.abs(acoef[0]) < small));
                    lsb = ((Math.abs(salfar) >= safmin[0]) && (Math.abs(bcoefr[0]) < small));

                    if (lsa) {
                        scale[0] = (small / Math.abs(sbeta)) * Math.min(anorm, big[0]);
                    } // if (lsa)

                    if (lsb) {
                        scale[0] = Math.max(scale[0], (small / Math.abs(salfar)) * Math.min(bnorm, big[0]));
                    } // if (lsb)

                    if (lsa || lsb) {
                        temp[0] = Math.max(1.0, Math.abs(acoef[0]));
                        temp[0] = Math.max(temp[0], Math.abs(bcoefr[0]));
                        scale[0] = Math.min(scale[0], 1.0 / (safmin[0] * temp[0]));

                        if (lsa) {
                            acoef[0] = ascale * (scale[0] * sbeta);
                        } else {
                            acoef[0] = scale[0] * acoef[0];
                        }

                        if (lsb) {
                            bcoefr[0] = bscale * (scale[0] * salfar);
                        } else {
                            bcoefr[0] = scale[0] * bcoefr[0];
                        }
                    } // if (lsa || lsb)

                    acoefa = Math.abs(acoef[0]);
                    bcoefa = Math.abs(bcoefr[0]);

                    // First component is 1
                    work[(2 * n) + je - 1] = 1.0;
                    xmax = 1.0;

                    // Compute contribution from column je-1 of S and P to sum
                    // (See "Further Details" above.)
                    for (jr = 1; jr <= (je - 1); jr++) {
                        work[(2 * n) + jr - 1] = (bcoefr[0] * P[jr - 1][je - 1]) - (acoef[0] * S[jr - 1][je - 1]);
                    } // for (jr = 1; jr <= je-1; jr++)
                } // if (!ilcplx)
                else { // ilcplx

                    // Complex eigenvalue
                    array1 = new double[2][2];
                    array2 = new double[2][2];

                    for (p = 0; p < 2; p++) {

                        for (q = 0; q < 2; q++) {
                            array1[p][q] = S[je - 2 + p][je - 2 + q];
                            array2[p][q] = P[je - 2 + p][je - 2 + q];
                        }
                    }

                    dlag2(array1, 2, array2, 2, safmin[0] * safety, acoef, temp, bcoefr, temp2, bcoefi);

                    if (bcoefi[0] == 0.0) {
                        info[0] = je - 1;

                        return;
                    } // if (bcoefi[0] == 0.0)

                    // Scale to avoid over/underflow
                    acoefa = Math.abs(acoef[0]);
                    bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
                    scale[0] = 1.0;

                    if (((acoefa * ulp) < safmin[0]) && (acoefa >= safmin[0])) {
                        scale[0] = (safmin[0] / ulp) / acoefa;
                    }

                    if (((bcoefa * ulp) < safmin[0]) && (bcoefa >= safmin[0])) {
                        scale[0] = Math.max(scale[0], (safmin[0] / ulp) / bcoefa);
                    }

                    if ((safmin[0] * acoefa) > ascale) {
                        scale[0] = ascale / (safmin[0] * acoefa);
                    }

                    if ((safmin[0] * bcoefa) > bscale) {
                        scale[0] = Math.min(scale[0], bscale / (safmin[0] * bcoefa));
                    }

                    if (scale[0] != 1.0) {
                        acoef[0] = scale[0] * acoef[0];
                        acoefa = Math.abs(acoef[0]);
                        bcoefr[0] = scale[0] * bcoefr[0];
                        bcoefi[0] = scale[0] * bcoefi[0];
                        bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
                    } // if (scale[0] != 1.0)

                    // Compute first two components of eigenvector
                    // and contribution to sums
                    temp[0] = acoef[0] * S[je - 1][je - 2];
                    temp2r = (acoef[0] * S[je - 1][je - 1]) - (bcoefr[0] * P[je - 1][je - 1]);
                    temp2i = -bcoefi[0] * P[je - 1][je - 1];

                    if (Math.abs(temp[0]) >= (Math.abs(temp2r) + Math.abs(temp2i))) {
                        work[(2 * n) + je - 1] = 1.0;
                        work[(3 * n) + je - 1] = 0.0;
                        work[(2 * n) + je - 2] = -temp2r / temp[0];
                        work[(3 * n) + je - 2] = -temp2i / temp[0];
                    } // if (Math.abs(temp[0]) >= Math.abs(temp2r) +
                    else {
                        work[(2 * n) + je - 2] = 1.0;
                        work[(3 * n) + je - 2] = 0.0;
                        temp[0] = acoef[0] * S[je - 2][je - 1];
                        work[(2 * n) + je - 1] = ((bcoefr[0] * P[je - 2][je - 2]) - (acoef[0] * S[je - 2][je - 2])) /
                                                     temp[0];
                        work[(3 * n) + je - 1] = bcoefi[0] * P[je - 2][je - 2] / temp[0];
                    } // else

                    xmax = Math.max(Math.abs(work[(2 * n) + je - 1]) + Math.abs(work[(3 * n) + je - 1]),
                                    Math.abs(work[(2 * n) + je - 2]) + Math.abs(work[(3 * n) + je - 2]));

                    // Compute contribution from columns je-1 and je-2
                    // of A and B to the sums
                    creala = acoef[0] * work[(2 * n) + je - 2];
                    cimaga = acoef[0] * work[(3 * n) + je - 2];
                    crealb = (bcoefr[0] * work[(2 * n) + je - 2]) - (bcoefi[0] * work[(3 * n) + je - 2]);
                    cimagb = (bcoefi[0] * work[(2 * n) + je - 2]) + (bcoefr[0] * work[(3 * n) + je - 2]);
                    cre2a = acoef[0] * work[(2 * n) + je - 1];
                    cim2a = acoef[0] * work[(3 * n) + je - 1];
                    cre2b = (bcoefr[0] * work[(2 * n) + je - 1]) - (bcoefi[0] * work[(3 * n) + je - 1]);
                    cim2b = (bcoefi[0] * work[(2 * n) + je - 1]) + (bcoefr[0] * work[(3 * n) + je - 1]);

                    for (jr = 1; jr <= (je - 2); jr++) {
                        work[(2 * n) + jr - 1] = (-creala * S[jr - 1][je - 2]) + (crealb * P[jr - 1][je - 2]) -
                                                 (cre2a * S[jr - 1][je - 1]) + (cre2b * P[jr - 1][je - 1]);
                        work[(3 * n) + jr - 1] = (-cimaga * S[jr - 1][je - 2]) + (cimagb * P[jr - 1][je - 2]) -
                                                 (cim2a * S[jr - 1][je - 1]) + (cim2b * P[jr - 1][je - 1]);
                    } // for (jr = 1; jr <= je-2; jr++)
                } // else ilcplx

                dmin = Math.max(ulp * acoefa * anorm, ulp * bcoefa * bnorm);
                dmin = Math.max(dmin, safmin[0]);

                // Columnwise triangular solve of (a S - b P) x = 0
                il2by2 = false;

                for (j = je - nw; j >= 1; j--) {

                    // If a 2-by-2 block is in position j-2:j-1, wait until
                    // next iteration to process it (when it will be j-1:j)
                    if ((!il2by2) && (j > 1)) {

                        if (S[j - 1][j - 2] != 0.0) {
                            il2by2 = true;

                            continue;
                        }
                    } // if ((!il2by2) && (j > 1))

                    bdiag[0] = P[j - 1][j - 1];

                    if (il2by2) {
                        na = 2;
                        bdiag[1] = P[j][j];
                    } else {
                        na = 1;
                    }

                    // Compute x[j-1] (and x[j], if 2-by-2 block)
                    array1 = new double[na][na];

                    for (p = 0; p < na; p++) {

                        for (q = 0; q < na; q++) {
                            array1[p][q] = S[j - 1 + p][j - 1 + q];
                        }
                    }

                    array2 = new double[n][nw];
                    r = 0;

                    for (q = 0; q < nw; q++) {

                        for (p = 0; p < n; p++) {
                            array2[p][q] = work[(2 * n) + j - 1 + r];
                            r++;
                        }
                    }

                    dlaln2(false, na, nw, dmin, acoef[0], array1, na, bdiag[0], bdiag[1], array2, n, bcoefr[0],
                           bcoefi[0], sum, 2, scale, temp, iinfo);

                    if (scale[0] < 1.0) {

                        for (jw = 0; jw <= (nw - 1); jw++) {

                            for (jr = 1; jr <= je; jr++) {
                                work[((jw + 2) * n) + jr - 1] = scale[0] * work[((jw + 2) * n) + jr - 1];
                            }
                        }
                    } // if (scale[0] < 1.0)

                    xmax = Math.max(scale[0] * xmax, temp[0]);

                    for (jw = 1; jw <= nw; jw++) {

                        for (ja = 1; ja <= na; ja++) {
                            work[((jw + 1) * n) + j + ja - 2] = sum[ja - 1][jw - 1];
                        }
                    }

                    // w = w + x[j-1]*(a S(*,j-1) - b P(*,j-1) with scaling
                    if (j > 1) {

                        // Check whether scaling is necessary for sum
                        xscale = 1.0 / Math.max(1.0, xmax);
                        temp[0] = (acoefa * work[j - 1]) + (bcoefa * work[n + j - 1]);

                        if (il2by2) {
                            temp[0] = Math.max(temp[0], (acoefa * work[j]) + (bcoefa * work[n + j]));
                        } // if (il2by2)

                        temp[0] = Math.max(temp[0], acoefa);
                        temp[0] = Math.max(temp[0], bcoefa);

                        if (temp[0] > (bignum * xscale)) {

                            for (jw = 0; jw <= (nw - 1); jw++) {

                                for (jr = 1; jr <= je; jr++) {
                                    work[((jw + 2) * n) + jr - 1] = xscale * work[((jw + 2) * n) + jr - 1];
                                }
                            }

                            xmax = xmax * xscale;
                        } // if (temp[0] > bignum*xscale)

                        // Compute the contributions of the off-diagonals of
                        // column j-1 (and j, if 2-by-2 block) of S and P to the
                        // sums.

                        for (ja = 1; ja <= na; ja++) {

                            if (ilcplx) {
                                creala = acoef[0] * work[(2 * n) + j + ja - 2];
                                cimaga = acoef[0] * work[(3 * n) + j + ja - 2];
                                crealb = (bcoefr[0] * work[(2 * n) + j + ja - 2]) -
                                         (bcoefi[0] * work[(3 * n) + j + ja - 2]);
                                cimagb = (bcoefi[0] * work[(2 * n) + j + ja - 2]) +
                                         (bcoefr[0] * work[(3 * n) + j + ja - 2]);

                                for (jr = 1; jr <= (j - 1); jr++) {
                                    work[(2 * n) + jr - 1] = work[(2 * n) + jr - 1] - (creala * S[jr - 1][j + ja - 2]) +
                                                             (crealb * P[jr - 1][j + ja - 2]);
                                    work[(3 * n) + jr - 1] = work[(3 * n) + jr - 1] - (cimaga * S[jr - 1][j + ja - 2]) +
                                                             (cimagb * P[jr - 1][j + ja - 2]);
                                } // for (jr = 1; jr <= j-1; jr++)
                            } // if (ilcplx)
                            else { // !ilcplx
                                creala = acoef[0] * work[(2 * n) + j + ja - 2];
                                crealb = bcoefr[0] * work[(2 * n) + j + ja - 2];

                                for (jr = 1; jr <= (j - 1); jr++) {
                                    work[(2 * n) + jr - 1] = work[(2 * n) + jr - 1] - (creala * S[jr - 1][j + ja - 2]) +
                                                             (crealb * P[jr - 1][j + ja - 2]);
                                } // for (jr = 1; jr <= j-1; jr++)
                            } // else !ilcplx
                        } // for (ja = 1; ja <= na; ja++)
                    } // if (j > 1)

                    il2by2 = false;
                } // for (j = je - nw; j >= 1; j--)

                // Copy eigenvector to vr, back transforming if howmny == 'B'
                ieig = ieig - nw;

                if (ilback) {

                    for (jw = 0; jw <= (nw - 1); jw++) {

                        for (jr = 1; jr <= n; jr++) {
                            work[((jw + 4) * n) + jr - 1] = work[(jw + 2) * n] * vr[jr - 1][0];
                        }

                        for (jc = 2; jc <= je; jc++) {

                            for (jr = 1; jr <= n; jr++) {
                                work[((jw + 4) * n) + jr - 1] = work[((jw + 4) * n) + jr - 1] +
                                                                (work[((jw + 2) * n) + jc - 1] * vr[jr - 1][jc - 1]);
                            }
                        }
                    } // for (jw = 0; jw <= nw-1; jw++)

                    for (jw = 0; jw <= (nw - 1); jw++) {

                        for (jr = 1; jr <= n; jr++) {
                            vr[jr - 1][ieig + jw - 1] = work[((jw + 4) * n) + jr - 1];
                        }
                    }

                    iend = n;
                } // if (ilback)
                else { // !ilback

                    for (jw = 0; jw <= (nw - 1); jw++) {

                        for (jr = 1; jr <= n; jr++) {
                            vr[jr - 1][ieig + jw - 1] = work[((jw + 2) * n) + jr - 1];
                        }
                    }

                    iend = je;
                } // else !ilback

                // Scale eigenvector
                xmax = 0.0;

                if (ilcplx) {

                    for (j = 1; j <= iend; j++) {
                        xmax = Math.max(xmax, Math.abs(vr[j - 1][ieig - 1]) + Math.abs(vr[j - 1][ieig]));
                    }
                } // if (ilcplx)
                else {

                    for (j = 1; j <= iend; j++) {
                        xmax = Math.max(xmax, Math.abs(vr[j - 1][ieig - 1]));
                    }
                } // else

                if (xmax > safmin[0]) {
                    xscale = 1.0 / xmax;

                    for (jw = 0; jw <= (nw - 1); jw++) {

                        for (jr = 1; jr <= iend; jr++) {
                            vr[jr - 1][ieig + jw - 1] = xscale * vr[jr - 1][ieig + jw - 1];
                        }
                    }
                } // if (xmax > safmin[0])
            } // for (je = n; je >= 1; je--)
        } // if (compr)

        return;
    } // dtgevc

    /**
     * This is a port of the 2/8/89 Blas routine DTRMM Original code written by: Jack Dongarra, Argonne National
     * Laboratory Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
     * Algorithms Group Ltd. dtrmm performs one of the matrix-matrix operations B = alpha*op(A)*B or B = alpha*B*op(A),
     * where alpha is scalar, B is an m by n matrix, A is a unit, or non-unit, upper or lower tringular matrix and op(A)
     * is one of op(A) = A or op(A) = A'.
     *
     * @param  side    input char On entry, side specifies whether op(A) multiplies B from the left or right as follows:
     *                 = 'L' or 'l' B = alpha*op(A)*B = 'R' or 'r' B = alpha*B*op(A)
     * @param  uplo    input char On entry, uplo specifies whether matrix A is an upper or lower triangular matrix as
     *                 follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular matrix
     * @param  transa  input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication
     *                 as follows: = 'N' or 'n' op(A) = A = 'T' or 't' op(A) = A' = 'C' or 'c' op(A) = A'
     * @param  diag    input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u'
     *                 A is assumed to be unit triangular = 'N' or 'n' A is not assumed to be unit triangular
     * @param  m       input int On entry, m specifies the number of rows of B. m must be at least zero.
     * @param  n       input int On entry, n specifies the number of columns of B. n must be at least zero.
     * @param  alpha   input double Specified scalar. When alpha is zero then A is not referenced and B need not be set
     *                 before entry.
     * @param  A       input double[][] of dimension lda by k, where k is m when side = 'L' or 'l' and is n when side =
     *                 'R' or 'r'. Before entry with uplo = 'U' or 'u', the leading k by k upper triangular part of the
     *                 array A must contain the upper triangular matrix and the strictly lower triangular part of A is
     *                 not referenced. Before entry with uplo = 'L' or 'l', the leading k by k lower triangular part of
     *                 the array A must contain the lower triangular matrix and the strictly upper triangular part of A
     *                 is not referenced. Note that when diag = 'U' or 'u', the diagonal elements of A are not
     *                 referenced either, but are assumed to be unity.
     * @param  lda     input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                 program. When side = 'L' or 'l' then lda must be at least max(1,m), when side = 'R' or 'r' then
     *                 lda must be at least max(1,n).
     * @param  B       input/output double[][] of dimension ldb by n Before entry, the leading m by n part of the array
     *                 B must contain the matrix B, and on exit is overwritten by the transformed matrix.
     * @param  ldb     input int On entry, ldb specifies the first dimension of B as declared in the calling (sub)
     *                 program. ldb must be at least max(1,m).
     */
    private void dtrmm(char side, char uplo, char transa, char diag, int m, int n, double alpha, double[][] A, int lda,
                       double[][] B, int ldb) {
        boolean lside;
        boolean nounit;
        boolean upper;
        int i;
        int info;
        int j;
        int k;
        int nrowa;
        double temp;

        // Test the input parameters
        if ((side == 'L') || (side == 'l')) {
            lside = true;
        } else {
            lside = false;
        }

        if (lside) {
            nrowa = m;
        } else {
            nrowa = n;
        }

        if ((diag == 'N') || (diag == 'n')) {
            nounit = true;
        } else {
            nounit = false;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        info = 0;

        if ((!lside) && (side != 'R') && (side != 'r')) {
            info = 1;
        } else if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info = 2;
        } else if ((transa != 'N') && (transa != 'n') && (transa != 'T') && (transa != 't') && (transa != 'C') &&
                       (transa != 'c')) {
            info = 3;
        } else if ((diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
            info = 4;
        } else if (m < 0) {
            info = 5;
        } else if (n < 0) {
            info = 6;
        } else if (lda < Math.max(1, nrowa)) {
            info = 9;
        } else if (ldb < Math.max(1, m)) {
            info = 11;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dtrmm had info = " + info);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (alpha == 0.0) {

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    B[i][j] = 0.0;
                }
            }

            return;
        } // if (alpha == 0.0)

        if (lside) {

            if ((transa == 'N') || (transa == 'n')) {

                // Form B = alpha*A*B
                if (upper) {

                    for (j = 0; j < n; j++) {

                        for (k = 0; k < m; k++) {

                            if (B[k][j] != 0.0) {
                                temp = alpha * B[k][j];

                                for (i = 0; i <= (k - 1); i++) {
                                    B[i][j] = B[i][j] + (temp * A[i][k]);
                                }

                                if (nounit) {
                                    temp = temp * A[k][k];
                                }

                                B[k][j] = temp;
                            } // if (B[k][j] != 0.0)
                        } // for (k = 0; k < m; k++)
                    } // for (j = 0; j < n; j++)
                } // if (upper)
                else { // lower

                    for (j = 0; j < n; j++) {

                        for (k = m - 1; k >= 0; k--) {

                            if (B[k][j] != 0.0) {
                                temp = alpha * B[k][j];
                                B[k][j] = temp;

                                if (nounit) {
                                    B[k][j] = B[k][j] * A[k][k];
                                }

                                for (i = k + 1; i < m; i++) {
                                    B[i][j] = B[i][j] + (temp * A[i][k]);
                                }
                            } // if (B[k][j] != 0.0)
                        } // for (k = m-1; k >= 0; k--)
                    } // for (j = 0; j < n; j++)
                } // lower
            } // if (transa == 'N') || (transa == 'n'))
            else { // ((transa != 'N') && (transa != 'n'))

                // Form B = alpha*A'*B
                if (upper) {

                    for (j = 0; j < n; j++) {

                        for (i = m - 1; i >= 0; i--) {
                            temp = B[i][j];

                            if (nounit) {
                                temp = temp * A[i][i];
                            }

                            for (k = 0; k <= (i - 1); k++) {
                                temp = temp + (A[k][i] * B[k][j]);
                            }

                            B[i][j] = alpha * temp;
                        } // for (i = m-1; i >= 0; i--)
                    } // for (j = 0; j < n; j++)
                } // if (upper)
                else { // lower

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < m; i++) {
                            temp = B[i][j];

                            if (nounit) {
                                temp = temp * A[i][i];
                            }

                            for (k = i + 1; k < m; k++) {
                                temp = temp + (A[k][i] * B[k][j]);
                            }

                            B[i][j] = alpha * temp;
                        } // for (i = 0; i < m; i++)
                    } // for (j = 0; j < n; j++)
                } // lower
            } // else ((transa != 'N') && (transa != 'n'))
        } // if (lside)
        else { // !lside

            if ((transa == 'N') || (transa == 'n')) {

                // Form B = alpha*B*A
                if (upper) {

                    for (j = n - 1; j >= 0; j--) {
                        temp = alpha;

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = 0; i < m; i++) {
                            B[i][j] = temp * B[i][j];
                        }

                        for (k = 0; k <= (j - 1); k++) {

                            if (A[k][j] != 0.0) {
                                temp = alpha * A[k][j];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] + (temp * B[i][k]);
                                }
                            } // if (A[k][j] != 0.0)
                        } // for (k = 0; k <= j-1; k++)
                    } // for (j = n-1; j >= 0; j--)
                } // if (upper)
                else { // lower

                    for (j = 0; j < n; j++) {
                        temp = alpha;

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = 0; i < m; i++) {
                            B[i][j] = temp * B[i][j];
                        }

                        for (k = j + 1; k < n; k++) {

                            if (A[k][j] != 0.0) {
                                temp = alpha * A[k][j];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] + (temp * B[i][k]);
                                }
                            } // if (A[k][j] != 0.0)
                        } // for (k = j+1; k < n; k++)
                    } // for (j = 0; j < n; j++)
                } // lower
            } // if (transa == 'N') || (transa == 'n'))
            else { // ((transa != 'N') && (transa != 'n'))

                // Form B = alpha*B*A'
                if (upper) {

                    for (k = 0; k < n; k++) {

                        for (j = 0; j <= (k - 1); j++) {

                            if (A[j][k] != 0.0) {
                                temp = alpha * A[j][k];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] + (temp * B[i][k]);
                                }
                            } // if (A[j][k] != 0.0)
                        } // for (j = 0; j <= k-1; j++)

                        temp = alpha;

                        if (nounit) {
                            temp = temp * A[k][k];
                        }

                        if (temp != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][k] = temp * B[i][k];
                            }
                        } // if (temp != 1.0)
                    } // for (k = 0; k < n; k++)
                } // if (upper)
                else { // lower

                    for (k = n - 1; k >= 0; k--) {

                        for (j = k + 1; j < n; j++) {

                            if (A[j][k] != 0.0) {
                                temp = alpha * A[j][k];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] + (temp * B[i][k]);
                                }
                            } // if (A[j][k] != 0.0)
                        } // for (j = k+1; j < n; j++)

                        temp = alpha;

                        if (nounit) {
                            temp = temp * A[k][k];
                        }

                        if (temp != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][k] = temp * B[i][k];
                            } // for (i = 0; i < m; i++)
                        } // if (temp != 1.0)
                    } // for (k = n-1; k >= 0; k--)
                } // lower
            } // else ((transa != 'N') && (transa != 'n'))
        } // else !lside

        return;
    } // dtrmm

    /**
     * This is a port of the 10/22/86 blas routine DTRMV Original version written by: Jack Dongarra, Argonne National
     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office Richard Hanson, Sandia National Labs.
     * dtrmv performs one of the matrix-vector operations x = A*x or x = A'*x where x is an n element vector and A is an
     * n by n unit, or non-unit, upper or lower triangular matrix
     *
     * @param  uplo   input char On entry, uplo specifies whether the matrix is an upper or lower triangular matrix as
     *                follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular matrix
     * @param  trans  input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n', x =
     *                A*x = 'T' or 't', x = A'*x = 'C' or 'c', x = A'*x
     * @param  diag   input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A
     *                is assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
     * @param  n      input int On entry, n specifies the order of the matrix A. n must be at least zero.
     * @param  A      input double[][] dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n upper
     *                triangular part of the array A must contain the upper triangular matrix and the strictly lower
     *                triangular part of A is not referenced. Before entry with uplo = 'L' or 'l', the leading n by n
     *                lower triangular part of the array A must contain the lower triangular matrix and the strictly
     *                upper triangular part of A is not referenced. Note that when diag = 'U' or 'u', the diagonal
     *                elements of A are not referenced either, but are assumed to be unity.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,n).
     * @param  x      input/output double[] of dimension at least (1 + (n-1)*abs(incx)) Before entry, the incremented
     *                array x must contain the n element vector x. On exit, array x is is overwritten with the
     *                transformed vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     */
    private void dtrmv(char uplo, char trans, char diag, int n, double[][] A, int lda, double[] x, int incx) {
        double temp;
        int i;
        int info;
        int ix;
        int j;
        int jx;
        int kx = 0;
        boolean nounit;

        // Test the input parameters
        info = 0;

        if ((uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if ((trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') &&
                       (trans != 'c')) {
            info = 2;
        } else if ((diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
            info = 3;
        } else if (n < 0) {
            info = 4;
        } else if (lda < Math.max(1, n)) {
            info = 6;
        } else if (incx == 0) {
            info = 8;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dtrmv had info = " + info);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if ((diag == 'N') || (diag == 'n')) {
            nounit = true;
        } else {
            nounit = false;
        }

        // Set up the start point in x if the increment is not unity.  This will
        // be (n-1)*incx too small for descending loops.

        if (incx <= 0) {
            kx = 1 - ((n - 1) * incx);
        } else if (incx != 1) {
            kx = 1;
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through A.
        if ((trans == 'N') || (trans == 'n')) {

            // Form x = A*x
            if ((uplo == 'U') || (uplo == 'u')) {

                if (incx == 1) {

                    for (j = 0; j < n; j++) {

                        if (x[j] != 0.0) {
                            temp = x[j];

                            for (i = 0; i <= (j - 1); i++) {
                                x[i] = x[i] + (temp * A[i][j]);
                            }

                            if (nounit) {
                                x[j] = x[j] * A[j][j];
                            }
                        } // if (x[j] != 0.0)
                    } // for (j = 0; j < n; j++)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx - 1;

                    for (j = 0; j < n; j++) {

                        if (x[jx] != 0.0) {
                            temp = x[jx];
                            ix = kx - 1;

                            for (i = 0; i <= (j - 1); i++) {
                                x[ix] = x[ix] + (temp * A[i][j]);
                                ix = ix + incx;
                            } // for (i = 0; i <= j-1; i++)

                            if (nounit) {
                                x[jx] = x[jx] * A[j][j];
                            }
                        } // if (x[jx] != 0.0)

                        jx = jx + incx;
                    } // for (j = 0; j < n; j++)
                } // else incx != 1
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // uplo == 'L' || uplo == 'l'

                if (incx == 1) {

                    for (j = n - 1; j >= 0; j--) {

                        if (x[j] != 0.0) {
                            temp = x[j];

                            for (i = n - 1; i >= (j + 1); i--) {
                                x[i] = x[i] + (temp * A[i][j]);
                            } // for (i = n-1; i >= j+1; i--)

                            if (nounit) {
                                x[j] = x[j] * A[j][j];
                            }
                        } // if (x[j] != 0.0)
                    } // for (j = n-1; j >= 0; j--)
                } // if (incx == 1)
                else { // incx != 1
                    kx = kx + ((n - 1) * incx);
                    jx = kx - 1;

                    for (j = n - 1; j >= 0; j--) {

                        if (x[jx] != 0.0) {
                            temp = x[jx];
                            ix = kx - 1;

                            for (i = n - 1; i >= (j + 1); i--) {
                                x[ix] = x[ix] + (temp * A[i][j]);
                                ix = ix - incx;
                            } // for (i = n-1; i >= j+1; i--)

                            if (nounit) {
                                x[jx] = x[jx] * A[j][j];
                            }
                        } // if (x[jx] != 0.0)

                        jx = jx - incx;
                    } // for (j = n-1; j >= 0; j--)
                } // else incx != 1
            } // else uplo == 'L' || uplo == 'l'
        } // if ((trans == 'N') || (trans == 'n'))
        else { // trans != 'N' && trans != 'n'

            // Form x = A'*x
            if ((uplo == 'U') || (uplo == 'u')) {

                if (incx == 1) {

                    for (j = n - 1; j >= 0; j--) {
                        temp = x[j];

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = j - 1; i >= 0; i--) {
                            temp = temp + (A[i][j] * x[i]);
                        } // for (i = j-1; i >= 0; i--)

                        x[j] = temp;
                    } // for (j = n-1; j >= 0; j--)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx + ((n - 1) * incx) - 1;

                    for (j = n - 1; j >= 0; j--) {
                        temp = x[jx];
                        ix = jx;

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = j - 1; i >= 0; i--) {
                            ix = ix - incx;
                            temp = temp + (A[i][j] * x[ix]);
                        } // for (i = j-1; i >= 0; i--)

                        x[jx] = temp;
                        jx = jx - incx;
                    } // for (j = n-1; j >= 0; j--)
                } // else incx != 1
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l')) {

                if (incx == 1) {

                    for (j = 0; j < n; j++) {
                        temp = x[j];

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = j + 1; i < n; i++) {
                            temp = temp + (A[i][j] * x[i]);
                        } // for (i = j+1; i < n; i++)

                        x[j] = temp;
                    } // for (j = 0; j < n; j++)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx - 1;

                    for (j = 0; j < n; j++) {
                        temp = x[jx];
                        ix = jx;

                        if (nounit) {
                            temp = temp * A[j][j];
                        }

                        for (i = j + 1; i < n; i++) {
                            ix = ix + incx;
                            temp = temp + (A[i][j] * x[ix]);
                        } // for (i = j+1; i < n; i++)

                        x[jx] = temp;
                        jx = jx + incx;
                    } // for (j = 0; j < n; j++)
                } // else incx != 1
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else trans != 'N' && trans != 'n'

        return;
    } // dtrmv

    /**
     * This is a port of the 2/8/89 Blas routine DTRSM Original code written by: Jack Dongarra, Argonne National
     * Laboratory Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
     * Algorithms Group Ltd. dtrsm solves one of the matrix equations op(A)*X = alpha*B or X*op(A) = alpha*B, where
     * alpha is a scalar, X and B are m by n matrices, A is a unit, or non-unit, upper or lower triangular matrix and
     * op(A) is one of op(A) = A or op(A) = A'. The matrix X is overwritten on B.
     *
     * @param  side    input char On entry, side specifies whether op(A) appears on the left or right or X as follows: =
     *                 'L' or 'l' op(A)*X = alpha*B = 'R' or 'r' X*op(A) = alpha*B
     * @param  uplo    input char On entry, uplo specifies whether the matrix A is an upper or lower triangular matrix
     *                 as follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular
     *                 matrix
     * @param  transa  input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication
     *                 as follows: = 'N' or 'n' op(A) = A = 'T' or 't' op(A) = A' = 'C' or 'c' op(A) = A'
     * @param  diag    input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u'
     *                 A is assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
     * @param  m       input int On entry, m specifies the number of rows of B. m must be at least zero.
     * @param  n       input int On entry, n specifies the number of columns of B. n must be at least zero.
     * @param  alpha   input double Specified scalar. When alpha is zero then A is not referenced and B need not be set
     *                 before entry.
     * @param  A       input double[][] of dimension lda by k, where k is m when side = 'L' or 'l' and is n when side =
     *                 'R' or 'r'. Before entry with uplo = 'U' or 'u', the leading k by k upper triangular part of the
     *                 array A must contain the upper triangular matrix and the strictly lower part of A is not
     *                 referenced. Before entry with uplo = 'L' or 'l', the leading k by k lower triangular part of the
     *                 array A must contain the lower triangular matrix and the strictly upper triangular part of A is
     *                 not referenced. Note that when diag = 'U' or 'u', the diagonal elements of A are not referenced
     *                 either, but are assumed to be unity.
     * @param  lda     input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                 program. When side = 'L' or 'l', then lda must be at least max(1,m). When side = 'R' or 'r', then
     *                 lda must be at least max(1,n).
     * @param  B       input/output double[][] of dimension ldb by n. Before entry, the leading m by n part of the array
     *                 B must contain the right-hand side matrix B, and on exit is overwritten by the solution matrix X.
     * @param  ldb     input int On entry, ldb specifies the first dimension of B as declared in the calling (sub)
     *                 program. ldb must be at least max(1,m).
     */
    private void dtrsm(char side, char uplo, char transa, char diag, int m, int n, double alpha, double[][] A, int lda,
                       double[][] B, int ldb) {
        boolean lside;
        boolean nounit;
        boolean upper;
        int i;
        int info;
        int j;
        int k;
        int nrowa;
        double temp;

        // Test the input parameters
        if ((side == 'L') || (side == 'l')) {
            lside = true;
        } else {
            lside = false;
        }

        if (lside) {
            nrowa = m;
        } else {
            nrowa = n;
        }

        if ((diag == 'N') || (diag == 'n')) {
            nounit = true;
        } else {
            nounit = false;
        }

        if ((uplo == 'U') || (uplo == 'u')) {
            upper = true;
        } else {
            upper = false;
        }

        info = 0;

        if ((!lside) && (side != 'R') && (side != 'r')) {
            info = 1;
        } else if ((!upper) && (uplo != 'L') && (uplo != 'l')) {
            info = 2;
        } else if ((transa != 'N') && (transa != 'n') && (transa != 'T') && (transa != 't') && (transa != 'C') &&
                       (transa != 'c')) {
            info = 3;
        } else if ((diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
            info = 4;
        } else if (m < 0) {
            info = 5;
        } else if (n < 0) {
            info = 6;
        } else if (lda < Math.max(1, nrowa)) {
            info = 9;
        } else if (ldb < Math.max(1, m)) {
            info = 11;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dtrsm had info = " + info);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if (alpha == 0.0) {

            for (j = 0; j < n; j++) {

                for (i = 0; i < m; i++) {
                    B[i][j] = 0.0;
                }
            }

            return;
        } // if (alpha == 0.0)

        if (lside) {

            if ((transa == 'N') || (transa == 'n')) {

                // Form B = alpha*inv(A)*B
                if (upper) {

                    for (j = 0; j < n; j++) {

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][j] = alpha * B[i][j];
                            }
                        } // if (alpha != 1.0)

                        for (k = m - 1; k >= 0; k--) {

                            if (B[k][j] != 0.0) {

                                if (nounit) {
                                    B[k][j] = B[k][j] / A[k][k];
                                }

                                for (i = 0; i <= (k - 1); i++) {
                                    B[i][j] = B[i][j] - (B[k][j] * A[i][k]);
                                }
                            } // if (B[k][j] != 0.0)
                        } // for (k = m-1; k >= 0; k--)
                    } // for (j = 0; j < n; j++)
                } // if (upper)
                else { // lower

                    for (j = 0; j < n; j++) {

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][j] = alpha * B[i][j];
                            }
                        } // if (alpha != 1.0)

                        for (k = 0; k < m; k++) {

                            if (B[k][j] != 0.0) {

                                if (nounit) {
                                    B[k][j] = B[k][j] / A[k][k];
                                }

                                for (i = k + 1; i < m; i++) {
                                    B[i][j] = B[i][j] - (B[k][j] * A[i][k]);
                                }
                            } // if (B[k][j] != 0.0)
                        } // for (k = 0; k < m; k++)
                    } // for (j = 0; j < n; j++)
                } // else lower
            } // if ((transa == 'N') || (transa == 'n')
            else { // ((transa != 'N') && (transa != 'n'))

                // Form B = alpha*inv(A')*B
                if (upper) {

                    for (j = 0; j < n; j++) {

                        for (i = 0; i < m; i++) {
                            temp = alpha * B[i][j];

                            for (k = 0; k <= (i - 1); k++) {
                                temp = temp - (A[k][i] * B[k][j]);
                            }

                            if (nounit) {
                                temp = temp / A[i][i];
                            }

                            B[i][j] = temp;
                        } // for (i = 0; i < m; i++)
                    } // for (j = 0; j < n; j++)
                } // if (upper)
                else { // lower

                    for (j = 0; j < n; j++) {

                        for (i = m - 1; i >= 0; i--) {
                            temp = alpha * B[i][j];

                            for (k = i + 1; k < m; k++) {
                                temp = temp - (A[k][i] * B[k][j]);
                            }

                            if (nounit) {
                                temp = temp / A[i][i];
                            }

                            B[i][j] = temp;
                        } // for (i = m-1; i >= 0; i--)
                    } // for (j = 0; j < n; j++)
                } // else lower
            } // else ((transa != 'N') && (transa != 'n'))
        } // if (lside)
        else { // !lside

            if ((transa == 'N') || (transa == 'n')) {

                // Form B = alpha*B*inv(A)
                if (upper) {

                    for (j = 0; j < n; j++) {

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][j] = alpha * B[i][j];
                            }
                        } // if (alpha != 1.0)

                        for (k = 0; k <= (j - 1); k++) {

                            if (A[k][j] != 0.0) {

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] - (A[k][j] * B[i][k]);
                                }
                            } // if (A[k][j] != 0.0)
                        } // for (k = 0; k <= j-1; k++)

                        if (nounit) {
                            temp = 1.0 / A[j][j];

                            for (i = 0; i < m; i++) {
                                B[i][j] = temp * B[i][j];
                            }
                        } // if (nounit)
                    } // for (j = 0; j < n; j++)
                } // if (upper)
                else { // lower

                    for (j = n - 1; j >= 0; j--) {

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][j] = alpha * B[i][j];
                            }
                        } // if (alpha != 1.0)

                        for (k = j + 1; k < n; k++) {

                            if (A[k][j] != 0.0) {

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] - (A[k][j] * B[i][k]);
                                }
                            } // if (A[k][j] != 0.0)
                        } // for (k = j+1; k < n; k++)

                        if (nounit) {
                            temp = 1.0 / A[j][j];

                            for (i = 0; i < m; i++) {
                                B[i][j] = temp * B[i][j];
                            }
                        } // if (nounit)
                    } // for (j = n-1; j >= 0; j--)
                } // else lower
            } // if ((transa == 'N') || (transa == 'n')
            else { // ((transa != 'N') && (transa != 'n'))

                // Form B = alpha*B*inv(A')
                if (upper) {

                    for (k = n - 1; k >= 0; k--) {

                        if (nounit) {
                            temp = 1.0 / A[k][k];

                            for (i = 0; i < m; i++) {
                                B[i][k] = temp * B[i][k];
                            }
                        } // if (nounit)

                        for (j = 0; j <= (k - 1); j++) {

                            if (A[j][k] != 0.0) {
                                temp = A[j][k];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] - (temp * B[i][k]);
                                }
                            } // if (A[j][k] != 0.0)
                        } // for (j = 0; j <= k-1; j++)

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][k] = alpha * B[i][k];
                            }
                        } // if (alpha != 1.0)
                    } // for (k = n-1; k >= 0; k--)
                } // if (upper)
                else { // lower

                    for (k = 0; k < n; k++) {

                        if (nounit) {
                            temp = 1.0 / A[k][k];

                            for (i = 0; i < m; i++) {
                                B[i][k] = temp * B[i][k];
                            }
                        } // if (nounit)

                        for (j = k + 1; j < n; j++) {

                            if (A[j][k] != 0.0) {
                                temp = A[j][k];

                                for (i = 0; i < m; i++) {
                                    B[i][j] = B[i][j] - (temp * B[i][k]);
                                }
                            } // if (A[j][k] != 0.0)
                        } // for (j = k+1; j < n; j++)

                        if (alpha != 1.0) {

                            for (i = 0; i < m; i++) {
                                B[i][k] = alpha * B[i][k];
                            }
                        } // if (alpha != 1.0)
                    } // for (k = 0; k < n; k++)
                } // else lower
            } // else ((transa != 'N') && (transa != 'n'))
        } // else !lside

        return;
    } // dtrsm

    /**
     * This is a port of the 10/22/86 Blas routine DTRSV Original version written by: Jack Dongarra, Argonne National
     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
     * Labs. dtrsv solves one of the systems of equations A*x = b or A'*x = b where b and x are n element vectors and A
     * is an n by n unit, or non-unit, upper or lower triangular matrix.
     *
     * <p>No test for singularity or near-singularity is included in this routine. Such test must be performed before
     * calling this routine.</p>
     *
     * @param  uplo   input char On entry, uplo specifies whether the matrix is an upper or lower triangular matrix as
     *                follows = 'U' or 'u' A is an upper triangular matrix. = 'L' or 'l' A is a lower triangular matrix.
     * @param  trans  input char On entry, trans specifies the equations to be solved as follows: = 'N' or 'n' A*x = b =
     *                'T' or 't' A'*x = b = 'C' or 'c' A'*x = b
     * @param  diag   input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A
     *                is assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
     * @param  n      input int On entry, n specifies the order of matrix A. n must be at least zero.
     * @param  A      input double[][] of dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n
     *                upper triangular part of the array A must contain the upper triangular matrix and the strictly
     *                lower triangular part of A is not referenced. Before entry with uplo = 'L' or 'l', the leading n
     *                by n lower triangular part of the array A must contain the lower triangular matrix and the
     *                strictly upper triangular part of A is not referenced. Note that when diag = 'U' or 'u', the
     *                diagonal elements of A are not referenced either, but are assumed to be unity.
     * @param  lda    input int On entry, lda specifies the first dimension of A as declared in the calling (sub)
     *                program. lda must be at least max(1,n).
     * @param  x      input/output double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented
     *                array x must contain the n element right-hand side vector b. On exit, array x is overwritten with
     *                the solution vector x.
     * @param  incx   input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
     */
    private void dtrsv(char uplo, char trans, char diag, int n, double[][] A, int lda, double[] x, int incx) {
        double temp;
        int i;
        int info;
        int ix;
        int j;
        int jx;
        int kx = 1;
        boolean nounit;

        // Test the input parameters
        info = 0;

        if ((uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
            info = 1;
        } else if ((trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') &&
                       (trans != 'c')) {
            info = 2;
        } else if ((diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
            info = 3;
        } else if (n < 0) {
            info = 4;
        } else if (lda < Math.max(1, n)) {
            info = 6;
        } else if (incx == 0) {
            info = 8;
        }

        if (info != 0) {
            MipavUtil.displayError("Error dtrsv had info = " + info);

            return;
        }

        // Quick return if possible
        if (n == 0) {
            return;
        }

        if ((diag == 'N') || (diag == 'n')) {
            nounit = true;
        } else {
            nounit = false;
        }

        // Set up the start point in x if the increment is not unity.  This will
        // be (n-1)*incx too small for descending loops.

        if (incx <= 0) {
            kx = 1 - ((n - 1) * incx);
        } else if (incx != 1) {
            kx = 1;
        }

        // Start the operations.  In this version the elements of A are accessed
        // sequentially with one pass through A.

        if ((trans == 'N') || (trans == 'n')) {

            // Form x = inv(A)*x
            if ((uplo == 'U') || (uplo == 'u')) {

                if (incx == 1) {

                    for (j = n - 1; j >= 0; j--) {

                        if (x[j] != 0.0) {

                            if (nounit) {
                                x[j] = x[j] / A[j][j];
                            }

                            temp = x[j];

                            for (i = j - 1; i >= 0; i--) {
                                x[i] = x[i] - (temp * A[i][j]);
                            }
                        } // if (x[j] != 0.0)
                    } // for (j = n-1; j >= 0; j--)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx + ((n - 1) * incx) - 1;

                    for (j = n - 1; j >= 0; j--) {

                        if (x[jx] != 0.0) {

                            if (nounit) {
                                x[jx] = x[jx] / A[j][j];
                            }

                            temp = x[jx];
                            ix = jx;

                            for (i = j - 1; i >= 0; i--) {
                                ix = ix - incx;
                                x[ix] = x[ix] - (temp * A[i][j]);
                            }
                        } // if (x[jx] != 0.0)

                        jx = jx - incx;
                    } // for (j = n-1; j >= 0; j--)
                } // else incx != 1
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                if (incx == 1) {

                    for (j = 0; j < n; j++) {

                        if (x[j] != 0.0) {

                            if (nounit) {
                                x[j] = x[j] / A[j][j];
                            }

                            temp = x[j];

                            for (i = j + 1; i < n; i++) {
                                x[i] = x[i] - (temp * A[i][j]);
                            }
                        } // if (x[j] != 0.0)
                    } // for (j = 0; j < n; j++)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx - 1;

                    for (j = 0; j < n; j++) {

                        if (x[jx] != 0.0) {

                            if (nounit) {
                                x[jx] = x[jx] / A[j][j];
                            }

                            temp = x[jx];
                            ix = jx;

                            for (i = j + 1; i < n; i++) {
                                ix = ix + incx;
                                x[ix] = x[ix] - (temp * A[i][j]);
                            } // for (i = j+1; i < n; i++)
                        } // if (x[jx] != 0.0)

                        jx = jx + incx;
                    } // for (j = 0; j < n; j++)
                } // else incx != 1
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // if ((trans == 'N') || (trans == 'n'))
        else { // ((trans != 'N') && (trans != 'n'))

            // Form x = inv(A')*x.
            if ((uplo == 'U') || (uplo == 'u')) {

                if (incx == 1) {

                    for (j = 0; j < n; j++) {
                        temp = x[j];

                        for (i = 0; i <= (j - 1); i++) {
                            temp = temp - (A[i][j] * x[i]);
                        }

                        if (nounit) {
                            temp = temp / A[j][j];
                        }

                        x[j] = temp;
                    } // for (j = 0; j < n; j++)
                } // if (incx == 1)
                else { // incx != 1
                    jx = kx - 1;

                    for (j = 0; j < n; j++) {
                        temp = x[jx];
                        ix = kx - 1;

                        for (i = 0; i <= (j - 1); i++) {
                            temp = temp - (A[i][j] * x[ix]);
                            ix = ix + incx;
                        } // for (i = 0; i <= j-1; i++)

                        if (nounit) {
                            temp = temp / A[j][j];
                        }

                        x[jx] = temp;
                        jx = jx + incx;
                    } // for (j = 0; j < n; j++)
                } // else incx != 1
            } // if ((uplo == 'U') || (uplo == 'u'))
            else { // ((uplo == 'L') || (uplo == 'l'))

                if (incx == 1) {

                    for (j = n - 1; j >= 0; j--) {
                        temp = x[j];

                        for (i = n - 1; i >= (j + 1); i--) {
                            temp = temp - (A[i][j] * x[i]);
                        }

                        if (nounit) {
                            temp = temp / A[j][j];
                        }

                        x[j] = temp;
                    } // for (j = n-1; j >= 0; j--)
                } // if (incx == 1)
                else { // incx != 1
                    kx = kx + ((n - 1) * incx);
                    jx = kx - 1;

                    for (j = n - 1; j >= 0; j--) {
                        temp = x[jx];
                        ix = kx - 1;

                        for (i = n - 1; i >= (j + 1); i--) {
                            temp = temp - (A[i][j] * x[ix]);
                            ix = ix - incx;
                        } // for (i = n-1; i >= j+1; i--)

                        if (nounit) {
                            temp = temp / A[j][j];
                        }

                        x[jx] = temp;
                        jx = jx - incx;
                    } // for (j = n-1; j >= 0; j--)
                } // else incx != 1
            } // else ((uplo == 'L') || (uplo == 'l'))
        } // else ((trans != 'N') && (trans != 'n'))

        return;
    }

    /**
     * Version 3.2 auxiliary routine ported form LAPACK Original IEEECK created by Univ. of Tennessee, Univ. of
     * California Berkeley, University of Colorado Denver, and NAG Ltd., November, 2006
     * ieeeck is called form the ilaenv routine to verify that infinity and possibly NaN arithmetic is safe
     * (i.e. will not trap)
     *
     * @param   ispec  input int Specifies whether to test just for infinity arithmetic or whether to test for infinity
     *                 and NaN arithmetic 
     *                 = 0: Verify infinity arithmetic only. 
     *                 = 1: Verify infinity and NaN aritmetic
     * @param   zero   input double Must contain the value 0.0. This is passed to prevent the compiler from optimizing away
     *                 this code
     * @param   one    input double Must contain the value 1.0. This is passed to prevent the compiler from optimizing away
     *                 this code.
     *
     * @return  int    = 0: Arithmetic failed to produce the correct answers 
     *                 = 1: Arithmetic produced the correct answers
     */
    private int ieeeck(int ispec, double zero, double one) {
        double posinf;
        double neginf;
        double negzro;
        double newzro;
        double nan1;
        double nan2;
        double nan3;
        double nan4;
        double nan5;
        double nan6;

        posinf = one / zero;

        if (posinf <= one) {
            return 0;
        }

        neginf = -one / zero;

        if (neginf >= zero) {
            return 0;
        }

        negzro = one / (neginf + one);

        if (negzro != zero) {
            return 0;
        }

        neginf = one / negzro;

        if (neginf >= zero) {
            return 0;
        }

        newzro = negzro + zero;

        if (newzro != zero) {
            return 0;
        }

        posinf = one / newzro;

        if (posinf <= one) {
            return 0;
        }

        neginf = neginf * posinf;

        if (neginf >= zero) {
            return 0;
        }

        posinf = posinf * posinf;

        if (posinf <= one) {
            return 0;
        }

        // Return if we were only asked to check infinity arithmetic
        if (ispec == 0) {
            return 1;
        }

        nan1 = posinf + neginf;

        nan2 = posinf / neginf;

        nan3 = posinf / posinf;

        nan4 = posinf * zero;

        nan5 = neginf * negzro;

        nan6 = nan5 * 0.0;

        if (nan1 == nan1) {
            return 0;
        }

        if (nan2 == nan2) {
            return 0;
        }

        if (nan3 == nan3) {
            return 0;
        }

        if (nan4 == nan4) {
            return 0;
        }

        if (nan5 == nan5) {
            return 0;
        }

        if (nan6 == nan6) {
            return 0;
        }

        return 1;
    } // ieeeck

    /**
     * ilaenv is ported from the version 3.2.1 LAPACK auxiliary routine Original ILAENV created by Univ. of Tennessee,
     * Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd., April, 2009
     *
     * <p>ilaenv is called from the LAPACK routines to choose problem-dependent parameters for the local environment.
     * See ispec for a description of the parameters.</p>
     *
     * <p>This version provides a set of parameters which should give good, but not optimal, performance on many of the
     * currently available computers. Users are encouraged to modify this subroutine to set the tuning parameters for
     * their particular machine using the option and problem size information in the arguments.</p>
     *
     * <p>This routine will not function correctly if it is converted to all lower case. Converting it to all upper case
     * is allowed.</p>
     *
     * @param   ispec  input integer Specifies the parameter to be returned as the value of ilaenv. 
     *                 = 1: the optimal blocksize; if this value is 1,
     *                      an unblocked algorithm will give the best performance. 
     *                 = 2: the minimum block size for which the block routine should be used;
     *                      if the usable block size is less than this value,
     *                      an unblocked routine should be used 
     *                 = 3: the crossover point ( in a block routine, for n less than this value,
     *                      an unblocked routine should be used) 
     *                 = 4: the number of shifts, used in the nonsymmetric eigenvalue routines (deprecated)
     *                 = 5: the minimum column dimension for blocking to be used; 
     *                      rectangular blocks must have dimension at least k by m,
     *                      where k is given by ilaenv(2,...) and m by ilaenv(5,...) 
     *                 = 6: the crossover point for the SVD (when reducing an m by n
     *                      matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds this value,
     *                      a QR factorization is used first to reduce the matrix to a triangular form.)
     *                 = 7: the number of processors 
     *                 = 8: the crossover point for the multishift QR method for nonsymmetric
     *                      eigenvalue problems (deprecated) 
     *                 = 9: maximum size of the subproblems at the bottom of the computation tree in the
     *                      divide-and-conquer algorithm (used by xgelsd and xgesdd) 
     *                = 10: ieee NaN arithmetic can be trusted not to trap 
     *                = 11: infinity can be trusted not to trap
     *                12 <= ispec <= 16:
     *                      xhseqr or one of its subroutines
     *                      see iparmq for detailed explanation
     * @param   name   input String The name of the calling subroutine, in either upper case or lower case.
     * @param   opts   input String The character options to the subroutine name, concatenated into a single character
     *                 string. For example, uplo = 'U', trans = 'T', and diag = 'N' for a triangular routine would be
     *                 specified as opts = 'UTN'. opts has all the character options to subroutine name, in the same
     *                 order that they appear in the argument list for name, even if they are not used in determining
     *                 the value of the parameter specified by ispec.
     * @param   n1     input integer
     * @param   n2     input integer
     * @param   n3     input integer
     * @param   n4     input integer n1 to n4 have problem dimensions for the subroutine name; these may not all be
     *                 required. The problem dimensions n1, n2, n3, and n4 are specified in the order that they appear
     *                 in the argument list for name. n1 is used first, n2 second, and so on, and unused problem
     *                 dimensions are passed a value of -1.
     *
     * @return  answer output integer 
     *                 >= 0; the value of the parameter specified by ispec 
     *                 < 0: il answer = -k, the k-th parameter had an illegal value 
     * The parameter value returned by ilaenv is checked for validity in the calling routine.
     */
    private int ilaenv(int ispec, String name, String opts, int n1, int n2, int n3, int n4) {
        String subnam;
        int answer;
        char first;
        String c1, c2, c3, c4;
        boolean sname;
        boolean cname;
        int nb;
        int nbmin;
        int nx;

        if ((ispec < 1) || (ispec > 16)) {

            // Invalid value for ispec
            return -1;
        }

        if ((ispec == 1) || (ispec == 2) || (ispec == 3)) {

            // Copy name to subnam
            // Make subnam upper case is the first character of name is lower case
            subnam = new String(name);
            first = name.charAt(0);

            if (Character.isLowerCase(first)) {
                subnam = subnam.toUpperCase();
            }

            c1 = subnam.substring(0, 1);

            if ((c1.equals("S")) || (c1.equals("D"))) {
                sname = true;
            } else {
                sname = false;
            }

            if ((c1.equals("C")) || (c1.equals("Z"))) {
                cname = true;
            } else {
                cname = false;
            }

            if (!(cname || sname)) {
                return 1;
            }

            c2 = subnam.substring(1, 3);
            c3 = subnam.substring(3, 6);
            c4 = c3.substring(1, 3);

            if (ispec == 1) {

                // block size
                // In these examples, separate code is provided for setting nb for
                // real and complex.  We assume that nb will take the same value in
                // single or double precision.
                nb = 1;

                if (c2.equals("GE")) {

                    if (c3.equals("TRF")) {
                        nb = 64;
                    } // if (c3.equals("TRF"))
                    else if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF"))) {
                        nb = 32;
                    } // else if ((c3.equals("QRF")) || (c3.equals("RQF")) ||
                    else if (c3.equals("HRD")) {
                        nb = 32;
                    } // else if (c3.equals("HRD"))
                    else if (c3.equals("BRD")) {
                        nb = 32;
                    } // else if (c3.equals("BRD"))
                    else if (c3.equals("TRI")) {
                        nb = 64;
                    } // else if (c3.equals("TRI"))
                } // if (c2.equals("GE"))
                else if (c2.equals("PO")) {

                    if (c3.equals("TRF")) {
                        nb = 64;
                    } // if (c3.equals("TRF"))
                } // else if (c2.equals("PO"))
                else if (c2.equals("SY")) {

                    if (c3.equals("TRF")) {
                        nb = 64;
                    } // if (c3.equals("TRF"))
                    else if (sname && (c3.equals("TRD"))) {
                        nb = 32;
                    } // else if (sname && (c3.equals("TRD")))
                    else if (sname && (c3.equals("GST"))) {
                        nb = 64;
                    } // else if (sname && (c3.equals("GST")))
                } // else if (c2.equals("SY"))
                else if (cname && (c2.equals("HE"))) {

                    if (c3.equals("TRF")) {
                        nb = 64;
                    } // if (c3.equals("TRF"))
                    else if (c3.equals("TRD")) {
                        nb = 32;
                    } // else if (c3.equals("TRD"))
                    else if (c3.equals("GST")) {
                        nb = 64;
                    } // else if (c3.equals("GST"))
                } // else if (cname && (c2.equals("HE")))
                else if (sname && (c2.equals("OR"))) {

                    if ((c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nb = 32;
                        }
                    } // if (c3.substring(0,1).equals("G")) ||
                } // else if (sname && (c2.equals("OR")))
                else if (cname && (c2.equals("UN"))) {

                    if ((c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nb = 32;
                        }
                    } // if (c3.substring(0,1).equals("G")) ||
                } // else if (cname && (c2.equals("UN")))
                else if (c2.equals("GB")) {

                    if (c3.equals("TRF")) {

                        if (n4 <= 64) {
                            nb = 1;
                        } else {
                            nb = 32;
                        }
                    } // if (c3.equals("TRF"))
                } // else if (c2.equals("GB"))
                else if (c2.equals("PB")) {

                    if (c3.equals("TRF")) {

                        if (n2 <= 64) {
                            nb = 1;
                        } else {
                            nb = 32;
                        }
                    } // if (c3.equals("TRF"))
                } // else if (c2.equals("PB"))
                else if (c2.equals("TR")) {

                    if (c3.equals("TRI")) {
                        nb = 64;
                    } // if (c3.equals("TRI"))
                } // else if (C2.equals("TR"))
                else if (c2.equals("LA")) {

                    if (c3.equals("UUM")) {
                        nb = 64;
                    } // if (c3.equals("UUM"))
                } // else if (c2.equals("LA"))
                else if (sname && (c2.equals("ST"))) {

                    if (c3.equals("EBZ")) {
                        nb = 1;
                    } // if (c3.equals("EBZ"))
                } // else if (sname && (c2.equals("ST")))

                return nb;
            } // if (ispec == 1)
            else if (ispec == 2) {
                // minimum block size

                nbmin = 2;

                if (c2.equals("GE")) {

                    if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF")) ||
                            (c3.equals("HRD")) || (c3.equals("BRD")) || (c3.equals("TRI"))) {
                        nbmin = 2;
                    } // if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) ||
                } // if (c2.equals("GE"))
                else if (c2.equals("SY")) {

                    if (c3.equals("TRF")) {
                        nbmin = 8;
                    } // if (c3.equals("TRF"))
                    else if (sname && (c3.equals("TRD"))) {
                        nbmin = 2;
                    } // else if (sname && (c3.equals("TRD")))
                } // else if (c2.equals("SY"))
                else if (cname && (c2.equals("HE"))) {

                    if (c3.equals("TRD")) {
                        nbmin = 2;
                    } // if (c3.equals("TRD"))
                } // else if (cname && (c2.equals("HE")))
                else if (sname && (c2.equals("OR"))) {

                    if ((c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nbmin = 2;
                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
                    } // if ((c3.substring(0,1).equals("G")) ||
                } // else if (sname && (c2.equals("OR")))
                else if (cname && (c2.equals("UN"))) {

                    if ((c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nbmin = 2;
                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
                    } // if ((c3.substring(0,1).equals("G")) ||
                } // else if (cname && (c2.equals("UN")))

                return nbmin;
            } // else if (ispec == 2)
            else { // ispec == 3

                // crossover point

                nx = 0;

                if (c2.equals("GE")) {

                    if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF")) ||
                            (c3.equals("HRD")) || (c3.equals("BRD"))) {
                        nx = 128;
                    } // if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) ||
                } // if (c2.equals("GE"))
                else if (c2.equals("SY")) {

                    if (sname && (c3.equals("TRD"))) {
                        nx = 32;
                    } // if (sname && (c3.equals("TRD")))
                } // else if (c2.equals("SY"))
                else if (cname && (c2.equals("HE"))) {

                    if (c3.equals("TRD")) {
                        nx = 32;
                    } // if (c3.equals("TRD"))
                } // else if (cname && (c2.equals("HE")))
                else if (sname && (c2.equals("OR"))) {

                    if (c3.substring(0, 1).equals("G")) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nx = 128;
                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
                    } // if (c3.substring(0,1).equals("G"))
                } // else if (sname && (c2.equals("OR")))
                else if (cname && (c2.equals("UN"))) {

                    if (c3.substring(0, 1).equals("G")) {

                        if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL")) ||
                                (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
                            nx = 128;
                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
                    } // if (c3.substring(0,1).equals("G"))
                } // else if (cname && (c2.equals("UN")))

                return nx;
            } // else ispec == 3
        } // if ((ispec == 1) || (ispec == 2) || (ispec == 3))
        else if (ispec == 4) {

            // number of shifts (used by xhseqr)
            return 6;
        } // else if (ispec == 4)
        else if (ispec == 5) {

            // minimum column dimension (not used)
            return 2;
        } // else if (ispec == 5)
        else if (ispec == 6) {

            // crossover point for SVD (used by xgelss and xgesvd)
            return (int) (1.6 * Math.min(n1, n2));
        } // else if (ispec == 6)
        else if (ispec == 7) {

            // number of processors (not used)
            return 1;
        } // else if (ispec == 7)
        else if (ispec == 8) {

            // crossover point for multishift (used by xhseqr)
            return 50;
        } // else if (ispec == 8)
        else if (ispec == 9) {

            // maximum size of the subproblems at the bottom of the computation
            // tree in divide-and-conquer algorithm (used by xgelsd and xgesdd)
            return 25;
        } // else if (ispec == 9)
        else if (ispec == 10) {

            // ieee NaN arithmetic can be trusted not to trap
            answer = ieeeck(1, 0.0, 1.0);

            return answer;
        } // else if (ispec == 10)
        else if (ispec == 11){

            // infinity arithmetic can be trusted not to trap
            answer = ieeeck(0, 0.0, 1.0);

            return answer;
        } // else ispec == 11
        else { // 12 <= ispec <= 16
            // answer = iparmq(ispec, name, opts, n1, n2, n3, n4);
            
            return -1;
        }
    } // ilaenv

}
