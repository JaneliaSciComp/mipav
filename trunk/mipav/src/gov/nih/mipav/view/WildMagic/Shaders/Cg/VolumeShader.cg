void computeColor( float4 normalMax, float3 light,
                   float3 CameraModelPosition, float3 inPos, float shininessParam,
                   float ambientParam, float diffuseParam, float specularParam,
                   inout float4 color_sample)
{
    float3 normal = normalMax.xyz - (0.5, 0.5, 0.5);
    normal = normalize( normal );

    //float3 lightdir = normalize( light - inPos.xyz );
    float3 lightdir = normalize( light );
    float3 V = normalize( CameraModelPosition - inPos.xyz );
    float3 halfway = normalize( lightdir + V );

    // compute diffuse lighting component
    float diffuse = max(dot(normal.xyz, lightdir), 0);
    // compute specular lighting component
    float specular = pow(max(dot(halfway.xyz, normal.xyz), 0),
                         shininessParam);

    float3 color = 
        ambientParam * color_sample.rgb
        + diffuseParam * diffuse * color_sample.rgb
        + specularParam * specular;

    color_sample.rgb = color.rgb;
}

bool myClip(float3 vec,
            float clipX,
            float clipXInv,
            float clipY,
            float clipYInv,
            float clipZ,
            float clipZInv )
{
    if ( vec.x > clipX )
    {
        return 1;
    }
    if ( vec.x < clipXInv )
    {
        return 1;
    }
    if ( vec.y > clipY )
    {
        return 1;
    }
    if ( vec.y < clipYInv )
    {
        return 1;
    }
    if ( vec.z > clipZ )
    {
        return 1;
    }
    if ( vec.z < clipZInv )
    {
        return 1;
    }
    return 0;
}


// Raycasting vertex program implementation
void v_VolumeShader( in float4 inPosition     : POSITION,
                     in float3 inTexCoord1     : TEXCOORD0, 
                     out float4 outPosition    : POSITION, // For the rasterizer
                     out float3 outTexCoord1    : TEXCOORD0,
                     out float4 outPos,//         : TEXCOORD1,
                     uniform float4x4 WVPMatrix)
{    
    // Transform vertex
    outPosition = mul( inPosition, WVPMatrix );
    outPos = outPosition; 
    outTexCoord1 = inTexCoord1;
}

// Raycasting fragment program implementation
void p_VolumeShader(  in float3 inTexCoord1    : TEXCOORD0,
                      in float4 inPos,//         : TEXCOORD1,
                      out float4 kColor	    : COLOR0,
                      uniform sampler3D volume_tex, 
                      uniform sampler2D tex, 
                      uniform sampler1D colormap, 
                      uniform sampler1D opacitymap, 
                      uniform sampler3D normalmap, 
                      uniform float MIP,
                      uniform float DDR,
                      uniform float Composite,
                      uniform float Surface,
                      uniform float clipX,
                      uniform float clipXInv,
                      uniform float clipY,
                      uniform float clipYInv,
                      uniform float clipZ,
                      uniform float clipZInv,
                      uniform float4 clipArb,
                      uniform float4 clipEye,
                      uniform float4 clipEyeInv,
                      uniform float ambientParam,
                      uniform float diffuseParam,
                      uniform float shininessParam,
                      uniform float specularParam,
                      uniform float3 light,
                      uniform float3 CameraModelPosition,
                      uniform float4x4 WVPMatrix)
{
    float2 texc = ((inPos.xy / inPos.w) + 1) / 2.0; // find the right place to lookup in the backside buffer
    float3 start = inTexCoord1; // the start position of the ray is stored in the texturecoordinate
    float4 back_position  = tex2D(tex, texc);
    float3 dir = float3(0,0,0);
    dir.x = back_position.x - start.x;
    dir.y = back_position.y - start.y;
    dir.z = back_position.z - start.z;
    float len = length(dir.xyz); // the length from front to back is calculated and used to terminate the ray
    float3 norm_dir = normalize(dir);
    float3 vec = start.xyz;
    float4 col_acc = float4(0,0,0,0);
    float alpha_acc = 0;
    float4 color_sample = (0,0,0,0);

    float opacity = 0;
    float4 normal = (0,0,0,0);
    float4 normalMax = (0,0,0,0);
    float fMax = 0;

    float count = 0;

    kColor.rgb = back_position.xyz;
    kColor.a = 0;
    if ( (back_position.x == 0) && (back_position.y == 0) && (back_position.z == 0) )
    {
        return;
    }

    float Iterations = 450;
    float stepsize = len / Iterations;
    float alpha_sample = stepsize;

    for ( int i = 0; i < Iterations; i++ )
    {
        if ( myClip( vec, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
        {
            color_sample = (0,0,0,0);
            opacity = 0;
        }
        else
        {
            float4 aVec = float4(0,0,0,0);
            aVec.xyz = vec.xyz - (.5,.5,.5);
            aVec = mul( aVec, WVPMatrix );
            aVec.xyz = aVec.xyz + (.5,.5,.5);
            float fDot = dot( aVec.xyz, clipEye.xyz );
            float fDotInv = dot( aVec.xyz, clipEyeInv.xyz );
            float fDotArb = dot( aVec.xyz, clipArb.xyz );
            if ( (fDot < clipEye.w) || (fDotInv > clipEyeInv.w) || (fDotArb > clipArb.w) )
            {
                color_sample = (0,0,0,0);
                opacity = 0;
            }
            else
            {
                color_sample = tex3D(volume_tex,vec);
                opacity = tex1D(opacitymap,color_sample.r).r;
                if ( DDR != 0 )
                {
                    color_sample = tex1D(colormap,color_sample.r);
                }
            }
        }
        
        if ( opacity > 0 )
        {
            if ( color_sample.r > fMax ) 
            {
                fMax = color_sample.r;
            }
            if ( Surface != 0 )
            {
                normal = tex3D(normalmap,vec);
                normal.w = 0;

                normalMax = normal;

                computeColor( normalMax, light, CameraModelPosition, inPos.xyz, shininessParam, ambientParam, diffuseParam, specularParam, color_sample );
                if ( Composite != 0 )
                {
                    col_acc   = (1.0 - opacity) * col_acc + opacity * color_sample;
                    alpha_acc += opacity;
                }
                else if ( (color_sample.x != 0) || (color_sample.y != 0) || (color_sample.z != 0) )
                {
                    col_acc   = color_sample;
                    break;
                }
            }
            else
            {
                if ( Composite != 0 )
                {
                    col_acc   = (1.0 - opacity) * col_acc + opacity * color_sample;
                    alpha_acc += opacity;
                }
                else
                {
                    col_acc   += (1.0 - alpha_acc) * color_sample * alpha_sample * 3;
                    alpha_acc += (1 - alpha_acc) * alpha_sample;
                }
            }
        }


        vec.x = norm_dir.x * i * stepsize + start.x;
        vec.y = norm_dir.y * i * stepsize + start.y;
        vec.z = norm_dir.z * i * stepsize + start.z;
        if ( (Composite != 0) && (alpha_acc >= 1.0) )
        {
            break;
        }

        if ( (MIP==1) && (fMax>=1))
        {
            break;
        }
    } 

    if ( (Surface == 0) && (alpha_acc > 1) )
    {
        col_acc.r /= alpha_acc;
        col_acc.g /= alpha_acc;
        col_acc.b /= alpha_acc;
    }

    kColor = col_acc;
    kColor.a = alpha_acc;
    if ( MIP != 0 )
    {
        kColor = tex1D(colormap,fMax);
        kColor.a = fMax;
    }
}
