/**
 * Compute the surface color based on lighting.
 */
void computeColor( float4 normal, float3 light,
                   float3 CameraModelPosition, float3 inPos, float shininessParam,
                   float ambientParam, float diffuseParam, float specularParam, float Composite,
                   inout float4 color_sample)
{
    float3 local_normal = normal.xyz - (0.5, 0.5, 0.5);
    local_normal = normalize( local_normal );

    //float3 lightdir = normalize( light - inPos.xyz );
    float3 lightdir = normalize( light );
    float3 V = normalize( CameraModelPosition - inPos.xyz );
    float3 halfway = normalize( lightdir + V );

    // compute diffuse lighting component
    float diffuse = max(dot(local_normal.xyz, lightdir), 0);
    // compute specular lighting component
    float specular = pow(max(dot(halfway.xyz, local_normal.xyz), 0),
                         shininessParam);
    float3 color;
    if ( Composite != 0 )
    {
        color = 
            ambientParam * color_sample.rgb
            + diffuseParam * diffuse * color_sample.rgb
            + specularParam * specular * color_sample.rgb;
    }
    else
    {
        color = 
            ambientParam * color_sample.rgb
            + diffuseParam * diffuse * color_sample.rgb
            + specularParam * specular;
    }
    color_sample.rgb = color.rgb;
}

/**
 * Clip the volume based on the x,y,z axes.
 * returns 1 when the volume is clipped, 0 when not clipped.
 */
bool myClip(float3 vec,
            float clipX,
            float clipXInv,
            float clipY,
            float clipYInv,
            float clipZ,
            float clipZInv )
{
    if ( vec.x > clipX )
    {
        return 1;
    }
    if ( vec.x < clipXInv )
    {
        return 1;
    }
    if ( vec.y > clipY )
    {
        return 1;
    }
    if ( vec.y < clipYInv )
    {
        return 1;
    }
    if ( vec.z > clipZ )
    {
        return 1;
    }
    if ( vec.z < clipZInv )
    {
        return 1;
    }
    return 0;
}


/** Raycasting vertex program implementation */
void v_VolumeShader( in float4 inPosition     : POSITION,
                     in float3 inTexCoord1     : TEXCOORD0, 
                     out float4 outPosition    : POSITION, // For the rasterizer
                     out float3 outTexCoord1    : TEXCOORD0,
                     out float4 outPos,
                     uniform float4x4 WVPMatrix)
{    
    // Transform vertex
    outPosition = mul( inPosition, WVPMatrix );
    outPos = outPosition; 
    outTexCoord1 = inTexCoord1;
}

/** Raycasting fragment program implementation */
void p_VolumeShader(  in float3 inTexCoord1    : TEXCOORD0,
                      in float4 inPos,
                      out float4 kColor	    : COLOR0,
                      uniform sampler3D volume_tex, 
                      uniform sampler2D tex, 
                      uniform sampler1D colormap, 
                      uniform sampler1D opacitymap, 
                      uniform sampler3D normalmap, 
                      uniform float stepsize,
                      uniform float MIP,
                      uniform float DDR,
                      uniform float Composite,
                      uniform float Surface,
                      uniform float clipX,
                      uniform float clipXInv,
                      uniform float clipY,
                      uniform float clipYInv,
                      uniform float clipZ,
                      uniform float clipZInv,
                      uniform float4 clipArb,
                      uniform float4 clipEye,
                      uniform float4 clipEyeInv,
                      uniform float ambientParam,
                      uniform float diffuseParam,
                      uniform float shininessParam,
                      uniform float specularParam,
                      uniform float3 light,
                      uniform float3 CameraModelPosition,
                      uniform float4x4 WVPMatrix)
{
    // find the right place to lookup in the backside buffer
    float2 texc = ((inPos.xy / inPos.w) + 1) / 2.0;
    float4 back_position  = tex2D(tex, texc);

    // the start position of the ray is stored in the texturecoordinate
    float3 start = inTexCoord1; 

    // the ray direction
    float3 dir = back_position.xyz - start;

    // the length from front to back is calculated and used to terminate the ray
    float len = length(dir.xyz); 

    // normalized direction vector:
    float3 norm_dir = normalize(dir);

    // current position along the ray: 
    float3 position = start.xyz;

    // The accumulated color and alpha values:
    float4 color_acc = float4(0,0,0,0);
    float alpha_acc = 0;

    // output color:
    kColor = (0,0,0,0);
    if ( (back_position.x == 0) && (back_position.y == 0) && (back_position.z == 0) )
    {
        return;
    }

    // limit the number of iterations to 450, make sure that the stepsize will
    // cover the entire ray:
    if ( (len/stepsize) > 450 )
    {
        stepsize = len/450.0;
    }

    // The color at the current position along the ray:
    float4 color = (0,0,0,0);
    // The opacity at the current position along the ray:
    float opacity = 0;

    // The normal at the current position along the ray:
    float4 normal = (0,0,0,0);

    // Maximum value along the ray for MIP
    float fMax = 0;
    // Intensity value of color:
    float intensity_color = 0;
    // maximum color value along the ray
    float3 color_max = (0,0,0);

    float alpha_sample = stepsize;
    float delta = stepsize;
    float3 delta_dir = norm_dir * delta;
    float delta_dir_len = length(delta_dir);
    float length_acc = 0;


    // For some profiles the number of loop iterations must be determined at
    // compile time:
    for( int i = 0; i < 450; i++ )
    {
        // axis-aligned clipping:
        if ( myClip( position, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
        {
            color = (0,0,0,0);
            opacity = 0;
        }
        else
        {
            // eye clipping and arbitrary clipping:
            float4 aPosition = float4(0,0,0,0);
            aPosition.xyz = position.xyz - (.5,.5,.5);
            aPosition = mul( aPosition, WVPMatrix );
            aPosition.xyz = aPosition.xyz + (.5,.5,.5);
            float fDot = dot( aPosition.xyz, clipEye.xyz );
            float fDotInv = dot( aPosition.xyz, clipEyeInv.xyz );
            float fDotArb = dot( position.xyz, clipArb.xyz );
            if ( (fDot < clipEye.w) || (fDotInv > clipEyeInv.w) || (fDotArb > clipArb.w) )
            {
                color = (0,0,0,0);
                opacity = 0;
            }
            // The value is not clipped, compute the color:
            else
            {
                color = tex3D(volume_tex,position);
                opacity = tex1D(opacitymap,color.r).r;
                if ( DDR != 0 )
                {
                    color = tex1D(colormap,color.r);
                }
            }
        }
        // If the opacity is not zero:
        if ( opacity > 0 )
        {
            // MIP: Store the maximum value:
            intensity_color = dot(color.rgb, (.3,.3,.3));
            if ( intensity_color > fMax ) 
            {
                fMax = intensity_color;
                color_max = color.rgb;
            }
            // Surface and Composite surface display:
            if ( Surface != 0 )
            {
                normal = tex3D(normalmap,position);
                normal.w = 0;

                // Get the color based on lighting:
                computeColor( normal, light, CameraModelPosition, inPos.xyz,
                              shininessParam, ambientParam, diffuseParam, specularParam, Composite, color );
                // Composite surface:
                if ( Composite != 0 )
                {
                    color_acc   = (1.0 - alpha_acc) * color * opacity + color_acc;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }
                // Surface:
                else if ( (color.x != 0) || (color.y != 0) || (color.z != 0) )
                {
                    color_acc   = color;
                    break;
                }
            }
            // DDR, and Composite display:
            else
            {
                // Composite:
                if ( Composite != 0 )
                {
                    color_acc   = (1.0 - alpha_acc) * color * opacity + color_acc;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }
                // DDR:
                else
                {
                    color_acc   += (1.0 - alpha_acc) * color * alpha_sample * 3;
                    alpha_acc += (1 - alpha_acc) * alpha_sample;
                }
            }
        }
        // Break early if the accumulate alpha value for composite or composite surface is >= 1
        if ( (Composite != 0) && (alpha_acc >= 1.0) )
        {
            break;
        }
        // Break early if the max is >= 1
        if ( (MIP==1) && (fMax>=1))
        {
            break;
        }
        // Increment position along the ray:
        position += delta_dir;
        length_acc += delta_dir_len;
        // Break when the end of the ray is reached, or if alpha >= 1;
        if ( (length_acc >= len) || (alpha_acc >= 1.0) )
        {
            break;
        }
    } 

    //if ( (Surface == 0) && (alpha_acc > 1) )
//     if ( alpha_acc > 1 )
//     {
//         color_acc.r /= alpha_acc;
//         color_acc.g /= alpha_acc;
//         color_acc.b /= alpha_acc;
//     }

    kColor.rgb = color_acc.rgb;
    kColor.a = 1;
    if ( MIP != 0 )
    {
        kColor.rgb = tex1D(colormap,fMax).rgb;
        kColor.a = fMax;
    }
}
