
package gov.nih.mipav.view;


import gov.nih.mipav.model.algorithms.*;
import gov.nih.mipav.model.algorithms.utilities.*;
import gov.nih.mipav.model.dicomcomm.*;
import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.srb.SRBFileTransferer;
import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.model.util.NDARPipeline;

import gov.nih.mipav.plugins.*;

import gov.nih.mipav.view.dialogs.*;
import gov.nih.mipav.view.renderer.*;
import gov.nih.mipav.view.renderer.surfaceview.plotterview.*;

import java.awt.*;
import java.awt.event.*;

import java.io.*;

import java.util.*;

import javax.swing.*;
import javax.swing.event.*;


/**
 * Makes a frame and put a single image component into it.
 *
 * @version  1.0 Sept 28, 1998
 * @author   Matthew J. McAuliffe, Ph.D.
 * @see      ViewJComponentEditImage
 */
public class ViewJFrameImage extends ViewJFrameBase implements KeyListener, MouseListener {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** Use serialVersionUID for interoperability. */
    private static final long serialVersionUID = -5990635548319625443L;

    /** Width of the display screen. */
    protected static final int xScreen = Toolkit.getDefaultToolkit().getScreenSize().width;

    /** Height of the display screen. */
    protected static final int yScreen = Toolkit.getDefaultToolkit().getScreenSize().height;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** Object where DICOM image, ... is converted and displayed as a Java image */
    protected ViewJComponentEditImage componentImage;

    /** Reference to the toolbars located in the controls object. */
    protected ViewControlsImage controls;

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float heightResFactor;

    /** Buffer used to store image intensities the presently viewed slice of image A. */
    protected float[] imageBufferA;

    /** Buffer used to store image intensities the presently viewed slice of image B. */
    protected float[] imageBufferB;

    /** reference to the JDialogImageInfo for updating slice/resolutions. */
    protected JDialogImageInfo infoDialogA = null;

    /** DOCUMENT ME! */
    protected JDialogImageInfo infoDialogB = null;

    /**
     * Flag indicating whether or not that the image should be displayed in Log scale. Used primarily for displaying the
     * FFT of an image.
     */
    protected boolean logMagDisplay;

    /** Reference to the frame's menu bar. */
    protected JMenuBar menuBar;

    /** Constructs the image menu bar. */
    protected ViewMenuBar menuBarMaker;

    /** This object contains a number of useful functions for building a menu and querying the state of menu items. */
    protected ViewMenuBuilder menuBuilder;

    /** Number of slices in a 3D dataset. */
    protected int nImage;

    /** Number of time sequences in a 4D dataset. */
    protected int nTImage;

    /**
     * Integer buffer (4 bytes that stores the concatenated Alpha (1 byte), Red (1 byte), Green ( 1 byte ), Blue (1 byte
     * ) data. The ARGB values are generated by using the imageA intensities as a index into a LUT.
     */
    protected int[] pixBuffer;

    /**
     * Integer buffer (4 bytes that stores the concatenated Alpha (1 byte), Red (1 byte), Green ( 1 byte ), Blue (1 byte
     * ) data. The ARGB values are generated by using the imageB intensities as a index into a LUT.
     */
    protected int[] pixBufferB;

    /** Storage of the image voxel resolutions. One resolution value per dimension. */
    protected float[] resols;

    /** The scrollPane where the image is displayed. */
    protected JScrollPane scrollPane;

    /** Image time sequence number of image that is displayed. Zero indexed based. */
    protected int tSlice;

    /** Storage of the resolution units of measure. For example, mm, cm, inches ... */
    protected int[] units;

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float widthResFactor;

    /** Reference to the two window and level dialogs where [0] is for imageA, [1] for imageB. */
    protected JDialogWinLevel[] windowLevel;

    /** Defaults magnification of image to 1. */
    protected float zoom = 1;

    /** Image slice number of image that is displayed. Zero indexed based. */
    protected int zSlice;

    /** Reference to the color chooser. */
    private ViewJColorChooser colorChooser;

    /** DOCUMENT ME! */
    private boolean doOrients = true;

    /** When loading an image into B slot, should origins and orients be matched? */
    private boolean doOrigins = false;

    /** DOCUMENT ME! */
    private int lastVOI_UID = -1;

    /** tells whether or not to XOR when creating binary masks (allowing holes). */
    private boolean useXOR = Preferences.is(Preferences.PREF_USE_VOI_XOR);

    /** Reference to the magnification tool. */
    private JDialogZoom zoomDialog = null;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Makes a frame and puts an image into it. Image will be centered on screen.
     *
     * @param  _imageA  ModelImage - first image to display
     */
    public ViewJFrameImage(ModelImage _imageA) {
        this(_imageA, null, null);
    }

    /**
     * Makes a frame and puts an image into it. Image will be centered on screen.
     *
     * @param  _imageA  ModelImage - first image to display
     * @param  LUTa     LUT of the imageA (if null grayscale LUT is constructed)
     */
    public ViewJFrameImage(ModelImage _imageA, ModelLUT LUTa) {
        this(_imageA, LUTa, null);
    }

    /**
     * Makes a frame and puts an image component into it.
     *
     * @param  _imageA  First image to display
     * @param  LUTa     LUT of the imageA (if null grayscale LUT is constructed)
     * @param  loc      location where image should be initially placed
     */
    public ViewJFrameImage(ModelImage _imageA, ModelLUT LUTa, Dimension loc) {

        this(_imageA, LUTa, loc, _imageA.getLogMagDisplay());
    }

    /**
     * Creates a new ViewJFrameImage object.
     *
     * @deprecated  - Reference to ViewUserInterface no longer required. Use ViewJFrameImage(ModelImage, ModelLUT,
     *              Dimension) instead. Makes a frame and puts an image component into it.
     *
     * @param       _imageA  First image to display
     * @param       LUTa     LUT of the imageA (if null grayscale LUT is constructed)
     * @param       loc      location where image should be initially placed
     * @param       ui       main user interface frame.
     */
    public ViewJFrameImage(ModelImage _imageA, ModelLUT LUTa, Dimension loc, ViewUserInterface ui) {

        this(_imageA, LUTa, loc, _imageA.getLogMagDisplay());
    }

    /**
     * Makes a frame and puts an image component into it.
     *
     * @param  _imageA        First image to display
     * @param  LUTa           LUT of the imageA (if null grayscale LUT is constructed)
     * @param  loc            location where image should be initially placed
     * @param  logMagDisplay  Display log magnitude of image
     */
    public ViewJFrameImage(ModelImage _imageA, ModelLUT LUTa, Dimension loc, boolean logMagDisplay) {
        super(_imageA, null);

        // if we don't have an image, then we're done
        if (imageA == null) {
            return;
        }

        // initialize based on logMagDisplay
        init(LUTa, loc, logMagDisplay);

        if (imageA.getFileInfo(0).getModality() == FileInfoBase.COMPUTED_TOMOGRAPHY) {
            controls.getTools().setCTButtonEnabled(true);
        }

        // Matt take a look - Always set LUT zero to 1 default for gray images ?
        if (getLUTa() != null) {
            getLUTa().zeroToOneLUTAdjust();
        }
    }

    /**
     * Creates a new ViewJFrameImage object.
     *
     * @deprecated  - Reference to ViewUserInterface no longer required. Use ViewJFrameImage(ModelImage, ModelLUT,
     *              Dimension, boolean) instead. Makes a frame and puts an image component into it.
     *
     * @param       _imageA        First image to display
     * @param       LUTa           LUT of the imageA (if null grayscale LUT is constructed)
     * @param       loc            location where image should be initially placed
     * @param       ui             main user interface frame.
     * @param       logMagDisplay  Display log magnitude of image
     */
    public ViewJFrameImage(ModelImage _imageA, ModelLUT LUTa, Dimension loc, ViewUserInterface ui,
                           boolean logMagDisplay) {
        this(_imageA, LUTa, loc, logMagDisplay);
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Creates and initializes the LUT for an image.
     *
     * @param   img  the image to create a LUT for
     *
     * @return  a LUT for the image <code>img</code> (null if a color image)
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    public static ModelLUT initLUT(ModelImage img) throws OutOfMemoryError {
        ModelLUT newLUT = null;

        // only make a lut for non color images
        if (img.isColorImage() == false) {
            int[] dimExtentsLUT = new int[2];

            dimExtentsLUT[0] = 4;
            dimExtentsLUT[1] = 256;

            newLUT = new ModelLUT(ModelLUT.GRAY, 256, dimExtentsLUT);

            float min, max;

            if (img.getType() == ModelStorageBase.UBYTE) {
                min = 0;
                max = 255;
            } else if (img.getType() == ModelStorageBase.BYTE) {
                min = -128;
                max = 127;
            } else {
                min = (float) img.getMin();
                max = (float) img.getMax();
            }

            float imgMin = (float) img.getMin();
            float imgMax = (float) img.getMax();

            newLUT.resetTransferLine(min, imgMin, max, imgMax);
        }

        return newLUT;
    }

    /**
     * Makes an aboutDialog box and displays information of the image plane presently being displayed.
     */
    public void about() {
        super.about(zSlice, tSlice);
    }

    // ************************************************************************
    // **************************** Action Events *****************************
    // ************************************************************************

    /**
     * calls various methods depending on the action.
     *
     * @param  event  event that triggered function
     */
    public void actionPerformed(ActionEvent event) {
        Object source = event.getSource();
        final String command = event.getActionCommand();

        if ((command != null) && userInterface.isShorcutRecording()) {
            userInterface.setShortcutRecording(false);
            Preferences.addShortcut(command);
            userInterface.showShortcutEditor(true);

            return;
        }

        if (command.equals("PropagatePaintPrev")) {
            propagatePaintToPreviousSlice();
        } else if (command.equals("PropagatePaintNext")) {
            propagatePaintToNextSlice();
        } else if (command.equals("PropagatePaintAll")) {
            propagatePaintToAllSlices();
        } else if (command.equals("PowerPaint")) {
            new JDialogPowerPaint(this, getActiveImage());
        } else if (command.equals("ShowPaintBorder")) {

            // swap the border painting
            Preferences.setProperty("ShowPaintBorder",
                                    String.valueOf("" + !Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)));
            updateImages(true);
            getActiveImage().notifyImageDisplayListeners();
        } else if (command.equals("OpenXCEDESchema")) {
            userInterface.openXCEDESchema();
        } else if (command.equals("SaveXCEDESchema")) {
            userInterface.saveXCEDESchema();
        } else if (command.equals("Zoom linearly")) {
            componentImage.zoomMode = ViewJComponentEditImage.LINEAR;
        } else if (command.equals("Zoom exponentially")) {
            componentImage.zoomMode = ViewJComponentEditImage.EXPONENTIAL;
        } else if (command.equals("Dicom")) {

            if (((JCheckBoxMenuItem) source).isSelected()) {
                Preferences.setProperty("EnableDICOMReceiver", "true");

                if (userInterface.getDICOMCatcher() != null) {

                    userInterface.getDICOMCatcher().setStop();

                    try {
                        wait(2000);
                    } catch (Exception ex) { }
                }

                userInterface.setDICOMCatcher(new DICOM_Receiver());
                menuBuilder.setMenuItemEnabled("DICOM database access", true);
            } else {
                Preferences.setProperty("EnableDICOMReceiver", "false");

                if (userInterface.getDICOMCatcher() != null) {
                    userInterface.getDICOMCatcher().setStop();
                }

                menuBuilder.setMenuItemEnabled("DICOM database access", false);

                /**
                 * Also need to disable the auto upload to srb function.
                 */
                JCheckBoxMenuItem menuItemAutoUpload = (JCheckBoxMenuItem) menuBuilder.getMenuItem("Auto Upload on|off");
                if (menuItemAutoUpload.isSelected()) {
                    menuItemAutoUpload.setSelected(false);
                }
                if (userInterface.getNDARPipeline() != null) {
                    userInterface.getNDARPipeline().uninstall();
                }
            }
        } else if (command.startsWith("LastImage")) {
            int number = Integer.valueOf(command.substring(10)).intValue();
            userInterface.openLastImage(number);
        } else if (command.equals("OpenNewImage")) {
            userInterface.openImageFrame();
        } else if (command.equals("CreateBlankImage")) {
            userInterface.createBlankImage(null);
        } else if (command.equals("BrowseImages")) {
            userInterface.buildTreeDialog();
        } else if (command.equals("BrowseDICOM")) {
            userInterface.buildDICOMFrame();
        } else if (command.equals("OpenSRBFile")) {
            userInterface.openSRBFile();
        } else if (command.equals("SaveSRBFile")) {
            userInterface.saveSRBFile();
        } else if (command.equals("TransferSRBFiles")) {
            userInterface.transferSRBFiles();
        } else if (command.equals("AutoUploadToSRB")) {
            NDARPipeline pipeline = userInterface.getNDARPipeline();
            if (pipeline == null) {
                pipeline = new NDARPipeline();
                userInterface.setNDARPipeline(pipeline);
            }
            if (((JCheckBoxMenuItem) source).isSelected()) {
                JCheckBoxMenuItem itemDicom = (JCheckBoxMenuItem) menuBuilder.getMenuItem("Enable DICOM receiver");
                if (!itemDicom.isSelected()) {
                    if (userInterface.getDICOMCatcher() != null) {
                        userInterface.getDICOMCatcher().setStop();
                    }
                    itemDicom.setSelected(true);
                    userInterface.setDICOMCatcher(new DICOM_Receiver());
                    menuBuilder.setMenuItemEnabled("DICOM database access", true);
                }
                pipeline.install(userInterface.getDICOMCatcher());
            } else {
                pipeline.uninstall();
                pipeline = null;
            }
        } else if (command.equals("OpenNewGraph")) {
            new ViewJFrameGraph("Graph", true);
        } else if (command.equals("QueryDatabase")) {

            if (userInterface.getDICOMQueryFrame() == null) {
                userInterface.setDICOMQueryFrame(new ViewJFrameDICOMQuery(userInterface));
            }
            // ViewJFrameDICOMQuery DICOMQuery = new ViewJFrameDICOMQuery(userInterface);
        } else if (command.equals("AnonymizeDirectory")) {
            userInterface.buildAnonDirectoryDialog();
        } else if (command.equals("RecordScript") || command.equals("ToolbarScriptRecord")) {

            if (userInterface.getScriptDialog() != null) {
                MipavUtil.displayError("Already recording.  You must save or exit the first script to begin a new one.");
            } else {
                JDialogScript scriptDialog = new JDialogScript("Record New Script", userInterface);

                scriptDialog.addWindowListener((WindowListener) userInterface);
                userInterface.setRecordingScript(true);
                scriptDialog.setVisible(true);

                if (userInterface.getActiveImageFrame() != null) {
                    scriptDialog.setActiveImageFlag(true);
                } else {
                    scriptDialog.setActiveImageFlag(false);
                }
                // userInterface.activeImageRegistryMonitoring();
            }
        } else if (command.equals("RunScript")) {

            if (userInterface.isScriptRecording()) {
                MipavUtil.displayError("Cannot run a script within a script.");

                return;
            } else {
                JDialogMultiple multiple = new JDialogMultiple("Run script on multiple images", getUserInterface());

                multiple.setVisible(true);
            }
        } else if (command.equals("ToolbarScriptDir")) {

            // this action is to set the home directory and
            // and save it to preferences
            Preferences.debug("Set the script home directory.\n");

            // get the selected directory
            ViewDirectoryChooser chooser = new ViewDirectoryChooser();
            String dir = chooser.getDirectory();

            // set the default script directory
            if (dir != null) {
                userInterface.setDefaultScriptDirectory(dir);

                // reset the scripting toolbar on the controls
                controls.updateScripts(dir);
            }

        } else if (command.equals("ToolbarScriptRefresh")) {
            controls.updateScripts(userInterface.getDefaultScriptDirectory());
        } else if (command.equals("ToolbarScriptRun")) {

            // this is different from RunScript ... this is from the
            // scripting toolbar
            if (userInterface.isScriptRecording()) {
                MipavUtil.displayError("Cannot run a script within a script.");

                return;
            } else {
                Preferences.debug("Run the current selected script on the active image.\n");
                controls.runScript(getUserInterface());
            }
        } else if (command.equals("ComponentLoadB")) {

            if (isMultipleImages() == true) {
                JDialogLoadImage loadImageB = new JDialogLoadImage(this);

                doOrigins = loadImageB.getMatchOrigins();
                doOrients = loadImageB.getMatchOrients();

                if (loadImage(loadImageB.getImage(), componentImage, false, doOrigins, doOrients)) {

                    if ((imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                        removeControls();
                        controls = new ViewControlsImage(this); // Build controls used in this frame
                        menuBuilder = new ViewMenuBuilder(this);
                        tSlice = 0;
                        nTImage = imageB.getExtents()[3];
                        zSlice = (imageB.getExtents()[2] - 1) / 2;
                        nImage = imageB.getExtents()[2];
                        menuBar = menuBarMaker.getMenuBar(this, 4, imageB.getType(), imageB.isDicomImage());
                        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                                              menuBuilder.isMenuItemSelected("VOI toolbar"),
                                              menuBuilder.isMenuItemSelected("Paint toolbar"),
                                              menuBuilder.isMenuItemSelected("Scripting toolbar"),
                                              componentImage.getVOIHandler().getVOI_ID());
                    }

                    if (this.canCloseImageBAfterLoad()) {
                        menuBuilder.setMenuItemEnabled("Close image(B)", true);
                    }

                    setControls();
                    setTitle();
                }
            } else {
                MipavUtil.displayError("There are no other images to load.\n");
            }
        } else if (command.equals("LoadB") || command.equals("OpenMask")) {
            File fil = pickImageFile();

            if (fil == null) {
                return;
            }

            if (loadImage(fil, componentImage, userInterface.getLastStackFlag(), doOrigins, doOrients)) {

                if ((imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                    removeControls();
                    controls = new ViewControlsImage(this); // Build controls used in this frame
                    menuBuilder = new ViewMenuBuilder(this);
                    tSlice = 0;
                    nTImage = imageB.getExtents()[3];
                    zSlice = (imageB.getExtents()[2] - 1) / 2;
                    nImage = imageB.getExtents()[2];
                    menuBar = menuBarMaker.getMenuBar(this, 4, imageB.getType(), imageB.isDicomImage());
                    controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                                          menuBuilder.isMenuItemSelected("VOI toolbar"),
                                          menuBuilder.isMenuItemSelected("Paint toolbar"),
                                          menuBuilder.isMenuItemSelected("Scripting toolbar"),
                                          componentImage.getVOIHandler().getVOI_ID());
                }

                if (this.canCloseImageBAfterLoad()) {
                    menuBuilder.setMenuItemEnabled("Close image(B)", true);
                }

                if (command.equals("OpenMask") && !imageA.isColorImage()) {
                    getLUTb().makeStripedLUT();
                }

                if (linkTriFrame != null) {
                    linkTriFrame.setImageSelectorPanelVisible(true);
                }

                updateImages(true);
                setActiveImage(ViewJFrameImage.IMAGE_B); // set image B to active by default, for convenience of user
                controls.setActiveImage(ViewJFrameImage.IMAGE_B); // set the controls to show that image B is active
                setControls();
                setTitle();
            }

        } else if (command.equals("AndMask")) {

            if (imageB == null) {
                MipavUtil.displayError("This image has no mask. To use this function, please add a mask.");
            } else {

                try {
                    ModelImage destImage = new ModelImage(imageA.getType(), imageA.getExtents(), "maskImage");

                    AlgorithmImageCalculator algImageCalc = new AlgorithmImageCalculator(destImage, imageA, imageB,
                                                                                         AlgorithmImageCalculator.AND,
                                                                                         AlgorithmImageMath.CLIP, true,
                                                                                         null);

                    algImageCalc.setRunningInSeparateThread(false);
                    algImageCalc.run();

                    destImage.setFileInfo(imageA.getFileInfo());

                    new ViewJFrameImage(destImage);
                } catch (OutOfMemoryError error) {
                    System.gc();
                    MipavUtil.displayError("Out of memory: unable to open new frame");
                }
            }
        } else if (command.equals("NewMask")) {

            if (imageB != null) { // ask for confirmation if mask already exists

                int response = JOptionPane.showConfirmDialog(this, "This image already has a mask. Discard it?",
                                                             "Create new mask", JOptionPane.YES_NO_OPTION);

                if (response != JOptionPane.YES_OPTION) {
                    return; // do not create a new mask if one already exists
                }

                // user wants a new mask, so kill current mask
                setActiveImage(ViewJFrameImage.IMAGE_A);
                imageB.disposeLocal();
            }

            if (imageA.isColorImage()) {
                imageB = new ModelImage(ModelStorageBase.ARGB, imageA.getExtents(), imageA.getImageName() + "_mask");
                imageB.copyFileTypeInfoSansBufferType(imageA);
                imageB.calcMinMax();
                setImageB(imageB);
            } else {
                imageB = new ModelImage(ModelStorageBase.UBYTE, imageA.getExtents(), imageA.getImageName() + "_ubMask");
                imageB.copyFileTypeInfoSansBufferType(imageA);
                imageB.calcMinMax();
                setImageB(imageB);
                getLUTb().makeStripedLUT(); // make striped look up table by default
                getLUTb().resetTransferLine(0, 255);
            }

            if (linkTriFrame != null) {
                linkTriFrame.setImageSelectorPanelVisible(true); // set the selector panel to visible in the
                                                                 // ViewJFrameTriImage, if it exists
            }

            menuBuilder.setMenuItemEnabled("Close image(B)", true);

            setActiveImage(ViewJFrameImage.IMAGE_B); // set image B to active by default, for convenience of user
            controls.setActiveImage(ViewJFrameImage.IMAGE_B); // set the controls to show that image B is active

            setControls();
            setTitle();
        } else if (command.equals("LoadBlankB")) {

            try {

                if (imageA.isColorImage()) {
                    ModelImage imgB = new ModelImage(imageA.getType(), imageA.getExtents(), " Blank");

                    setImageB(imgB);
                    menuBuilder.setMenuItemEnabled("Close image(B)", true);
                    setControls();
                    setTitle();
                } else {
                    JDialogBlankImage blankImageDialog = new JDialogBlankImage(this);

                    if (blankImageDialog.isCancelled() == false) {
                        setImageB(blankImageDialog.getImage());
                        menuBuilder.setMenuItemEnabled("Close image(B)", true);
                        setControls();
                        setTitle();
                        getLUTb().resetTransferLine(0, 255);
                    }

                    blankImageDialog.dispose();
                }
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open new Image");

                return;
            }

        } else if (command.equals("SaveImage")) {
            saveImageInfo();
            save(new FileWriteOptions(false), -1);
        } else if (command.equals("SaveMask")) {

            if (imageB == null) {
                JOptionPane.showMessageDialog(this, "Image has no mask.", "Save mask", JOptionPane.ERROR_MESSAGE);

                return;
            }

            int currentDisplayMode = displayMode;

            displayMode = IMAGE_B;

            saveImageInfo();
            save(new FileWriteOptions(true), -1);

            displayMode = currentDisplayMode;

            // reset the title to the new name
            setTitle();

        } else if (command.equals("SaveImageAs")) {
            saveImageInfo();
            save(new FileWriteOptions(true), -1);

            // reset the title to the new name
            setTitle();
        } else if (command.equals("PrintImage")) {
            printImage();
        } else if (command.equals("CloseImageB")) {

            if (imageB != null) {
                setActiveImage(IMAGE_A);

                Vector frameList = imageB.getImageFrameVector();

                for (int i = 0; i < frameList.size(); i++) {

                    if (((ViewJFrameBase) frameList.elementAt(i)) != this) {
                        ((ViewJFrameBase) frameList.elementAt(i)).closeImageB();
                    }
                }

                if (imageA.getHistoLUTFrame() != null) {
                    imageA.getHistoLUTFrame().removeHistoLUTb();
                } else if (imageA.getHistoRGBFrame() != null) {
                    imageA.getHistoRGBFrame().removeHistoRGBb();
                }

                imageBufferB = null;
                componentImage.setImageBufferB(null);
                componentImage.setImageB(null);

                if ((imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                    removeControls();
                    controls = new ViewControlsImage(this); // Build controls used in this frame
                    menuBuilder = new ViewMenuBuilder(this);
                    tSlice = 0;
                    nTImage = 0;
                    zSlice = (imageA.getExtents()[2] - 1) / 2;
                    nImage = imageA.getExtents()[2];
                    menuBar = menuBarMaker.getMenuBar(this, 3, imageA.getType(), imageA.isDicomImage());
                    controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                                          menuBuilder.isMenuItemSelected("VOI toolbar"),
                                          menuBuilder.isMenuItemSelected("Paint toolbar"),
                                          menuBuilder.isMenuItemSelected("Scripting toolbar"),
                                          componentImage.getVOIHandler().getVOI_ID());
                }

                closeImageB();

                menuBuilder.setMenuItemEnabled("Close image(B)", false);
                setControls();
                setTitle();
                updateImages(null, null, true, -1);
            }

            if (imageA.getFileInfo()[0] instanceof FileInfoXML) {
                String path = ((FileInfoImageXML) imageA.getFileInfo(0)).getLinkedImagePath();

                if (path != null) {

                    int response = JOptionPane.showConfirmDialog(this, "Maintain link to closed image?", "Linked image",
                                                                 JOptionPane.YES_NO_OPTION);

                    if (response == JOptionPane.NO_OPTION) {
                        ((FileInfoImageXML) imageA.getFileInfo(0)).setLinkedImagePath(null);
                    }

                }

            }
        } else if (command.equals("EditImageInfo")) {
            showEditImageInfo();
        } else if (command.equals("Exit")) {
            userInterface.windowClosing(null);
        } else if (command.equals("dccieconvert")) {
            new JDialogDCCIEConversion(userInterface);
        } else if (command.equals("convertXML")) {
            ViewDirectoryChooser chooser = new ViewDirectoryChooser();
            String dir = chooser.getImageDirectory();

            if (dir != null) {
                AlgorithmConvertOldXML algo = new AlgorithmConvertOldXML(userInterface, dir);

                algo.run();
            }
        } else if (command.equals("loadLeica")) {
            // open a file chooser to select .txt header

            JFileChooser chooser = new JFileChooser(userInterface.getDefaultDirectory());

            chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
            chooser.setDialogTitle("Select Leica header file");

            int returnVal = chooser.showDialog(this, "Open");

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                new JDialogLoadLeica(this, chooser.getSelectedFile());
            } else {
                return;
            }
        } // Toolbars
        else if (command.equals("openImgSeq")) {
            new ViewOpenImageSequence();
        } else if (command.equals("VOIToolbar") || command.equals("PaintToolbar") || command.equals("ImageToolbar") ||
                       command.equals("ScriptToolbar")) {

            removeControls();
            controls = new ViewControlsImage(this);

            boolean showImage = menuBuilder.isMenuItemSelected("Image toolbar");
            boolean showVOI = menuBuilder.isMenuItemSelected("VOI toolbar");
            boolean showPaint = menuBuilder.isMenuItemSelected("Paint toolbar");
            boolean showScript = menuBuilder.isMenuItemSelected("Scripting toolbar");

            Preferences.setProperty(Preferences.PREF_SCRIPTING_TOOLBAR_ON, String.valueOf(showScript));
            Preferences.setProperty(Preferences.PREF_VOI_TOOLBAR_ON, String.valueOf(showVOI));
            Preferences.setProperty(Preferences.PREF_IMAGE_TOOLBAR_ON, String.valueOf(showImage));
            Preferences.setProperty(Preferences.PREF_PAINT_TOOLBAR_ON, String.valueOf(showPaint));

            controls.buildToolbar(showImage, showVOI, showPaint, showScript, componentImage.getVOIHandler().getVOI_ID());
            setControls();
        } else if (command.equals("PaintBrush")) {
            componentImage.setMode(ViewJComponentEditImage.PAINT_VOI);
        } else if (command.equals("Dropper")) {
            componentImage.setMode(ViewJComponentEditImage.DROPPER_PAINT);
        } else if (command.equals("Eraser")) {
            componentImage.setMode(ViewJComponentEditImage.ERASER_PAINT);
        } else if (command.equals("EraseAll")) {
            componentImage.eraseAllPaint(false);
        } else if (command.equals("EraseCurrent")) {
            componentImage.eraseAllPaint(true);
        } // VOIs
        else if (command.equals("undoVOI")) {
            componentImage.getVOIHandler().undoLastVOI();
        } else if (command.equals("XOR")) {
            userInterface.setUseVOIXOR(menuBuilder.isMenuItemSelected("Allow VOI holes (XOR)"));
        } else if (command.equals("PaintMask")) {
            getActiveImage().setMask(getActiveImage().generateVOIMask(useXOR, true));
            componentImage.setPaintMask(getActiveImage().getMask());
            updateImages(true);
            getActiveImage().notifyImageDisplayListeners();

        } else if (command.equals("Pointer")) {
            componentImage.setMode(ViewJComponentEditImage.DEFAULT);
        } else if (command.equals("Point")) {

            if (!checkForVOICompatibility(VOI.POINT)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.POINT_VOI);
        } else if (command.equals("Line")) {

            if (!checkForVOICompatibility(VOI.LINE)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.LINE);
        } else if (command.equals("Polyslice")) {

            if (!checkForVOICompatibility(VOI.POLYLINE_SLICE)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.POLYLINE_SLICE_VOI);
        } else if (command.equals("protractor")) {

            if (!checkForVOICompatibility(VOI.PROTRACTOR)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.PROTRACTOR);
        } else if (command.equals("Polyline")) {

            if (!checkForVOICompatibility(VOI.POLYLINE)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.POLYLINE);
        } else if (command.equals("TextVOI")) {

            if (!checkForVOICompatibility(VOI.CONTOUR)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.ANNOTATION);
        } else if (command.equals("RectVOI")) {

            if (!checkForVOICompatibility(VOI.CONTOUR)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.RECTANGLE);
        } else if (command.equals("EllipseVOI")) {

            if (!checkForVOICompatibility(VOI.CONTOUR)) {
                componentImage.setMode(ViewJComponentEditImage.NEW_VOI);
            }

            componentImage.setMode(ViewJComponentEditImage.ELLIPSE);
        } else if (command.equals("LevelSetVOI")) {
            checkForVOICompatibility(VOI.CONTOUR);
            componentImage.setMode(ViewJComponentEditImage.LEVELSET);
        } else if (command.equals("Rect3DVOI")) {
            checkForVOICompatibility(VOI.CONTOUR);
            componentImage.setMode(ViewJComponentEditImage.RECTANGLE3D);
        } else if (command.equals("LiveWireVOI")) {
            checkForVOICompatibility(VOI.CONTOUR);

            if (componentImage.getVOIHandler().isLivewireNull()) {
                JDialogLivewire dialog = new JDialogLivewire(this);

                if (!dialog.isCancelled()) {
                    componentImage.getVOIHandler().setModeLivewire(dialog.getSelection());
                }
            } else {
                componentImage.setMode(ViewJComponentEditImage.LIVEWIRE);
            }
        } else if (command.equals("NewVOI")) {
            componentImage.setMode(ViewJComponentEditImage.NEW_VOI);

            // if (getActiveImage().getVOIs().size() > 0)
            // System.err.println(" NEW ID: " + (((VOI)(getActiveImage().getVOIs().lastElement())).getID() + 1));


            int id = (getActiveImage().getVOIs().size() > 0)
                     ? (((VOI) (getActiveImage().getVOIs().lastElement())).getID() + 1) : -1;

            /*
             * Color voiColor = new Color(0,0,0);
             *
             * if (getActiveImage().getVOIs().size() > 0) { Color lastColor = ( (VOI) (
             * getActiveImage().getVOIs().lastElement() ) ).getColor();
             *
             * //convert rgb to hsb float [] hsb = new float[3]; int red = lastColor.getRed(); int green =
             * lastColor.getGreen(); int blue = lastColor.getBlue(); Color.RGBtoHSB(red, green, blue, hsb);
             *
             * hsb[0] *= 360.0; //  System.err.println("HSB Value: " + hsb[0]); hsb[0] = Math.round(hsb[0]/35.0);
             * System.err.println("HSB Value (div 35 int): " + hsb[0]);
             *
             * hsb[0]++;
             *
             * float hue = (float)(((((hsb[0])*35)%360)/360.0)); getControls().setVOIColor( Color.getHSBColor(hue,
             * (float)1.0, (float)1.0) ); }
             */

            getControls().setVOIColor(id);
        } else if (command.equals("cutVOI")) {

            if (componentImage.getVOIHandler().copyVOItoClipBrd()) {
                componentImage.getVOIHandler().deleteSelectedVOI(true);
            }
        } else if (command.equals("copyVOI")) {
            componentImage.getVOIHandler().copyVOItoClipBrd();
        } else if (command.equals("pasteVOI")) {
            componentImage.getVOIHandler().pasteVOI();
        } else if (command.equals("selectAllVOIs")) {
            componentImage.getVOIHandler().selectAllVOIs(true);
        } else if (command.equals("deleteVOI")) {
            componentImage.getVOIHandler().deleteSelectedVOI(true);
        } else if (command.equals("BringToFront")) {
            componentImage.getVOIHandler().changeVOIOrder(false, VOIHandler.FRONT);
        } else if (command.equals("SendToBack")) {
            componentImage.getVOIHandler().changeVOIOrder(false, VOIHandler.BACK);
        } else if (command.equals("BringContourToFront")) {
            componentImage.getVOIHandler().changeVOIOrder(true, VOIHandler.FRONT);
        } else if (command.equals("SendContourToBack")) {
            componentImage.getVOIHandler().changeVOIOrder(false, VOIHandler.BACK);
        } else if (command.equals("PropVOIUp")) {

            // It appears JButtons don't pass key modifiers
            // if((event.getModifiers() & ActionEvent.SHIFT_MASK) != 0) {}
            if (componentImage.getVOIHandler().propVOI(1, false) == true) {
                incSlice();
            }
        } else if (command.equals("PropVOIDown")) {

            if (componentImage.getVOIHandler().propVOI(-1, false) == true) {
                decSlice();
            }
        } else if (command.equals("PropVOIActiveUp")) {

            // It appears JButtons don't pass key modifiers
            // if((event.getModifiers() & ActionEvent.SHIFT_MASK) != 0) {}
            if (componentImage.getVOIHandler().propVOI(1, true) == true) {
                incSlice();
            }
        } else if (command.equals("PropVOIActiveDown")) {

            if (componentImage.getVOIHandler().propVOI(-1, true) == true) {
                decSlice();
            }
        } else if (command.equals("PropVOIAll")) {
            componentImage.getVOIHandler().propVOIAll();
        } else if (command.equals("BringForward")) {
            componentImage.getVOIHandler().changeVOIOrder(false, VOIHandler.FORWARD);
        } else if (command.equals("SendBackward")) {
            componentImage.getVOIHandler().changeVOIOrder(false, VOIHandler.BACKWARD);
        } else if (command.equals("SendContourForward")) {
            componentImage.getVOIHandler().changeVOIOrder(true, VOIHandler.FORWARD);
        } else if (command.equals("SendContourBackward")) {
            componentImage.getVOIHandler().changeVOIOrder(true, VOIHandler.BACKWARD);
        } else if (command.equals("VOIProperties")) {

            componentImage.getVOIHandler().showVOIProperties(false);

        } else if (command.equals("VOIPropertiesColor")) {

            if (getActiveImage().getVOIs().size() > 0) {

                ViewVOIVector VOIs = getActiveImage().getVOIs();
                Vector[] curves;

                int i;
                int nVOI = VOIs.size();

                for (i = 0; i < nVOI; i++) {

                    if ((VOIs.VOIAt(i).isActive() == true) &&
                            ((VOIs.VOIAt(i).getCurveType() == VOI.CONTOUR) ||
                                 (VOIs.VOIAt(i).getCurveType() == VOI.POLYLINE) ||
                                 (VOIs.VOIAt(i).getCurveType() == VOI.POINT) ||
                                 (VOIs.VOIAt(i).getCurveType() == VOI.LINE) ||
                                 (VOIs.VOIAt(i).getCurveType() == VOI.PROTRACTOR))) {
                        break;
                    } else if ((VOIs.VOIAt(i).isActive() == true) && (VOIs.VOIAt(i).getCurveType() == VOI.ANNOTATION)) {
                        MipavUtil.displayInfo("Double-click annotation to change properties");
                        i = -1;

                        break;
                    }
                }

                if (i == nVOI) {
                    MipavUtil.displayError("Please select VOI");
                } else if (i == -1) { // there was an annotation selected, do nothing
                } else {
                    componentImage.getVOIHandler().showVOIProperties(true);
                }
            } else {
                MipavUtil.displayWarning("Image has no VOIs!");
            }

        } else if (command.equals("VOIStatistics")) {
            componentImage.showStatisticsCalculator();
        } else if (command.equals("boundaryIntensity")) {
            componentImage.getVOIHandler().graphVOI();
        } else if (command.equals("totalIntensity")) {
            componentImage.getVOIHandler().graph25VOI_CalcInten(true, false, 0);
        } else if (command.equals("avgIntensity")) {
            componentImage.getVOIHandler().graph25VOI_CalcInten(false, false, 0);
        } else if (command.equals("GroupVOIs")) {

            if (displayMode == IMAGE_A) {
                imageA.groupVOIs();
            } else {
                imageB.groupVOIs();
            }

            componentImage.getVOIHandler().fireVOISelectionChange(null);
        } else if (command.equals("UngroupVOIs")) {

            if (displayMode == IMAGE_A) {
                imageA.ungroupVOIs();
            } else {
                imageB.ungroupVOIs();
            }

            componentImage.getVOIHandler().fireVOISelectionChange(null);
        } else if (command.equals("Cardio")) {
            new JDialogCardiology(this, imageA);
        } else if (command.equals("BinaryMask")) {
            ModelImage maskImage = null;

            try {

                if (componentImage.getVOIHandler().getActiveVOICount() == 0) {
                    componentImage.getVOIHandler().selectAllVOIs(true);
                }

                maskImage = getActiveImage().generateBinaryImage(useXOR, true);

                if (maskImage != null) {
                    maskImage.setImageName(getActiveImage().getImageName() + "_bmask");
                    new ViewJFrameImage(maskImage, null, new Dimension(610, 200), false);
                }
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open new frame");

                if (maskImage != null) {
                    maskImage.disposeLocal();
                }

                maskImage = null;

                return;
            }

            if (userInterface.isScriptRecording()) {
                userInterface.getScriptDialog().append("VOI_to_BinaryMask " +
                                                       userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                                                       " \n");
            }
        } else if (command.equals("ShortMask")) {
            ModelImage shortImage = null;

            try {

                if (componentImage.getVOIHandler().getActiveVOICount() == 0) {
                    componentImage.getVOIHandler().selectAllVOIs(true);
                }

                shortImage = getActiveImage().generateShortImage(1, useXOR, true);

                if (shortImage != null) {
                    shortImage.setImageName(getActiveImage().getImageName() + "_smask");
                    new ViewJFrameImage(shortImage, null, new Dimension(610, 200), false);
                }
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open new frame");

                if (shortImage != null) {
                    shortImage.disposeLocal();
                }

                shortImage = null;

                return;
            }

            if (userInterface.isScriptRecording()) {
                userInterface.getScriptDialog().append("VOI_to_ShortMask " +
                                                       userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                                                       " \n");
            }
        } else if (command.equals("UnsignedByteMask")) {
            ModelImage uByteImage = null;

            try {

                if (componentImage.getVOIHandler().getActiveVOICount() == 0) {
                    componentImage.getVOIHandler().selectAllVOIs(true);
                }

                uByteImage = getActiveImage().generateUnsignedByteImage(1, useXOR, true);

                if (uByteImage != null) {
                    uByteImage.setImageName(getActiveImage().getImageName() + "_ubmask");
                    new ViewJFrameImage(uByteImage, null, new Dimension(610, 200), false);
                }
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open new frame");

                if (uByteImage != null) {
                    uByteImage.disposeLocal();
                }

                uByteImage = null;

                return;
            }

            // add the conversion to the script, if one is being recorded
            if (userInterface.isScriptRecording() && (uByteImage != null)) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "VOI_to_UnsignedByteMask " +
                              userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) + " ";
                userInterface.getScriptDialog().putVar(uByteImage.getImageName());
                line += userInterface.getScriptDialog().getVar(uByteImage.getImageName()) + "\n";

                userInterface.getScriptDialog().append(line);
            }
        } else if (command.equals("MaskToVOI")) {
            new JDialogVOIExtraction(this, getActiveImage()).callAlgorithm();

            // add the conversion to the script, if one is being recorded
            if (userInterface.isScriptRecording()) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "MaskToVOI " + userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                              "\n";

                userInterface.getScriptDialog().append(line);
            }
        } else if (command.equals("MaskToPaint")) {
            handleMaskToPaint(true);

            // add the conversion to the script, if one is being recorded
            if (userInterface.isScriptRecording()) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "MaskToPaint " + userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                              "\n";

                userInterface.getScriptDialog().append(line);
            }
        } else if (command.equals("PaintToVOI")) {

            // new JDialogVOIExtraction(this, getActiveImage()).callAlgorithm();
            int xDim = 0, yDim = 0, zDim = 0;
            short voiID;

            if (getActiveImage().getNDims() == 2) {
                xDim = getActiveImage().getExtents()[0];
                yDim = getActiveImage().getExtents()[1];
                zDim = 1;
            } else if (getActiveImage().getNDims() == 3) {
                xDim = getActiveImage().getExtents()[0];
                yDim = getActiveImage().getExtents()[1];
                zDim = getActiveImage().getExtents()[2];
            } else {
                return;
            }

            if ((short) componentImage.getVOIHandler().getVOI_ID() == -1) {
                voiID = (short) getActiveImage().getVOIs().size();
            } else {
                voiID = (short) componentImage.getVOIHandler().getVOI_ID();
            }

            AlgorithmVOIExtractionPaint algoPaintToVOI = new AlgorithmVOIExtractionPaint(getActiveImage(),
                                                                                         componentImage.getPaintBitmap(),
                                                                                         xDim, yDim, zDim, voiID);

            algoPaintToVOI.setRunningInSeparateThread(false);
            algoPaintToVOI.run();

            // add the conversion to the script, if one is being recorded
            if (userInterface.isScriptRecording()) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "PaintToVOI " + userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                              "\n";

                userInterface.getScriptDialog().append(line);
            }

            updateImages();
        } else if (command.equals("PaintToShortMask")) {
            String maskImageName = componentImage.commitPaintToMask();

            // add the conversion to the script, if one is being recorded
            if (userInterface.isScriptRecording() && (maskImageName != null)) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "PaintToShortMask " +
                              userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) + " ";
                userInterface.getScriptDialog().putVar(maskImageName);
                line += userInterface.getScriptDialog().getVar(maskImageName) + "\n";

                userInterface.getScriptDialog().append(line);
            }
        } else if (command.equals("Open VOI")) {
            boolean success = openVOI(false);

            if (success && userInterface.isScriptRecording()) {
                String imageName = getActiveImage().getImageName();

                if (userInterface.getScriptDialog().getImgTableVar(imageName) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(imageName) == null) {
                        userInterface.getScriptDialog().putActiveVar(imageName);
                    }
                }

                String imageVarName = (String) userInterface.getScriptDialog().getVar(imageName);

                userInterface.getScriptDialog().append("OpenVOI " + imageVarName);

                ViewVOIVector VOIs = (ViewVOIVector) getActiveImage().getVOIs();

                int nVOI = VOIs.size();
                int index = 0, i = 0;
                boolean foundActive = false;

                while (!foundActive && (i != nVOI)) {

                    if (VOIs.VOIAt(i).isActive() == true) {
                        index = i;
                        foundActive = true;
                    } else {
                        i++;
                    }
                }

                VOI currVOI = VOIs.VOIAt(index);
                String voiName = currVOI.getName();

                userInterface.getScriptDialog().putVoiVar(voiName);

                String voiVarName = (String) userInterface.getScriptDialog().getVoiVar(voiName);

                userInterface.getScriptDialog().append(" " + voiVarName + "\n");
            }
        } else if (command.equals("Open all VOIs")) {
            loadAllVOIs(false);

            if (userInterface.isScriptRecording()) {
                userInterface.getScriptDialog().append("OpenAllVOIs " +
                                                       userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                                                       "\n");
            }
        } else if (command.equals("Open all VOIs from...")) {

            // get the voi directory
            String fileName = null;
            String directory = null;
            String voiDir = null;

            JFileChooser chooser = new JFileChooser();

            if (userInterface.getDefaultDirectory() != null) {
                chooser.setCurrentDirectory(new File(userInterface.getDefaultDirectory()));
            } else {
                chooser.setCurrentDirectory(new File(System.getProperties().getProperty("user.dir")));
            }

            chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

            int returnVal = chooser.showOpenDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                fileName = chooser.getSelectedFile().getName();
                directory = String.valueOf(chooser.getCurrentDirectory()) + File.separatorChar;
            }

            if (fileName != null) {
                voiDir = new String(directory + fileName + File.separator);
                loadAllVOIsFrom(voiDir, false);
            }
        } else if (command.equals("SaveSelectedContours")) {
            saveVOI(false);
        } else if (command.equals("SaveSelectedContoursAs")) {
            saveVOIAs(false);
        } else if (command.equals("Save VOI")) {
            saveVOI(true);
        } else if (command.equals("Save VOI as")) {
            saveVOIAs(true);
        } else if (command.equals("Save all VOIs")) {
            saveAllVOIs();

            if (userInterface.isScriptRecording()) {

                // check to see if the match image is already in the ImgTable
                if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                    if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) == null) {
                        userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                    }
                }

                String line = "SaveAllVOIs " + userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                              "\n";
                userInterface.getScriptDialog().append(line);
            }
        } else if (command.equals("Save all VOIs to...")) {

            // get the voi directory
            String fileName = null;
            String directory = null;
            String voiDir = null;

            JFileChooser chooser = new JFileChooser();

            if (userInterface.getDefaultDirectory() != null) {
                chooser.setCurrentDirectory(new File(userInterface.getDefaultDirectory()));
            } else {
                chooser.setCurrentDirectory(new File(System.getProperties().getProperty("user.dir")));
            }

            chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

            int returnVal = chooser.showSaveDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                fileName = chooser.getSelectedFile().getName();
                directory = String.valueOf(chooser.getCurrentDirectory()) + File.separatorChar;
            }

            if (fileName != null) {
                voiDir = new String(directory + fileName + File.separator);
                saveAllVOIsTo(voiDir);

                if (userInterface.isScriptRecording()) {

                    // check to see if the match image is already in the ImgTable
                    if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                        if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) ==
                                null) {
                            userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                        }
                    }

                    String line = "SaveAllVOIsTo " +
                                  userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) + " ";
                    line += voiDir + "\n";
                    userInterface.getScriptDialog().append(line);
                }
            }
        } else if (command.equals("Snake")) {
            new JDialogSnake(this, getActiveImage());
        } else if (command.equals("AGVF")) {
            new JDialogAGVF(this, getActiveImage());
        } else if (command.equals("GVF")) {
            new JDialogGVF(this, getActiveImage());
        } else if (command.equals("BSnake")) {
            new JDialogBSnake(this, getActiveImage());
        } else if (command.equals("SmoothVOI")) {
            new JDialogBSmooth(this, getActiveImage(), zSlice);
        } // Paint
        else if (command.equals("ThinPaint")) {
            componentImage.setPaintBrushSize(ViewJComponentEditImage.thinPaint);
        } else if (command.equals("MedPaint")) {
            componentImage.setPaintBrushSize(ViewJComponentEditImage.medPaint);
        } else if (command.equals("ThickPaint")) {
            componentImage.setPaintBrushSize(ViewJComponentEditImage.thickPaint);
        } else if (command.equals("ThickestPaint")) {
            componentImage.setPaintBrushSize(ViewJComponentEditImage.thickestPaint);
        } else if (command.equals("colorPaint")) { // new colour dialog only when null

            if (colorChooser == null) {
                colorChooser = new ViewJColorChooser(this, "Pick paint color", new OkColorListener(), null);
            } else {
                colorChooser.setDialogVisible(true);
            }
        } else if (command.equals("OpacityPaint")) {
            new JDialogOpacityControls(this, controls);
        } else if (command.equals("CommitPaint")) {

            if (getActiveImage() == imageA) {
                componentImage.commitMask(ViewJComponentBase.IMAGE_A, true, true, null);
            } else {
                componentImage.commitMask(ViewJComponentBase.IMAGE_B, true, true, null);
            }

            getActiveImage().notifyImageDisplayListeners(null, true);
        } else if (command.equals("CommitPaintExt")) {

            if (getActiveImage() == imageA) {
                componentImage.commitMask(ViewJComponentBase.IMAGE_A, true, false, null);
            } else {
                componentImage.commitMask(ViewJComponentBase.IMAGE_B, true, false, null);
            }

            getActiveImage().notifyImageDisplayListeners(null, true);
        } else if (command.equals("UndoPaint")) {
            componentImage.undoLastPaint();
            getActiveImage().notifyImageDisplayListeners(null, true);
        } else if (command.equals("CalcPaint")) {
            componentImage.calcPaintedVolume(null);
        } else if (command.equals("PaintCan")) {
            componentImage.setMode(ViewJComponentEditImage.PAINT_CAN);

            if (componentImage.growDialog != null) {
                return;
            }

            Vector listeners = new Vector();

            listeners.add(componentImage);
            componentImage.growDialog = new JDialogPaintGrow(this, listeners);
            // componentImage.regionGrow(); getActiveImage().notifyImageDisplayListeners(null, true);
        } // Algorithms
        else if (command.equals("Anisotropic diffusion")) {
            new JDialogAnisotropicDiffusion(this, getActiveImage());
        } else if (command.equals("BoundaryAttenuation")) {
            new JDialogBoundaryAttenuation(this, getActiveImage());
        } else if (command.equals("CoherDiff")) {
            new JDialogCoherenceEnhancingDiffusion(this, getActiveImage());
        } else if (command.equals("RegIsoDiff")) {
            new JDialogRegularizedIsotropicDiffusion(this, getActiveImage());
        } else if (command.equals("Clone")) {
            ModelImage clonedImage = null;

            try {
                clonedImage = (ModelImage) getActiveImage().clone();

                ModelLUT lutClone = null;

                if ((displayMode == IMAGE_A) && (LUTa != null)) {
                    lutClone = (ModelLUT) LUTa.clone();
                } else if (LUTb != null) {
                    lutClone = (ModelLUT) LUTb.clone();
                }

                new ViewJFrameImage(clonedImage, lutClone, new Dimension(610, 200),
                                    getActiveImage().getLogMagDisplay());
                System.gc();

                if (userInterface.isScriptRecording()) {

                    // check to see if the image is already in the ImgTable
                    if (userInterface.getScriptDialog().getImgTableVar(getActiveImage().getImageName()) == null) {

                        if (userInterface.getScriptDialog().getActiveImgTableVar(getActiveImage().getImageName()) ==
                                null) {
                            userInterface.getScriptDialog().putActiveVar(getActiveImage().getImageName());
                        }
                    }

                    userInterface.getScriptDialog().append("Clone " +
                                                           userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                                                           " ");
                    userInterface.getScriptDialog().putVar(clonedImage.getImageName());
                    userInterface.getScriptDialog().append(userInterface.getScriptDialog().getVar(clonedImage.getImageName()) +
                                                           "\n");
                }
            } catch (OutOfMemoryError error) {

                if (clonedImage != null) {
                    clonedImage.disposeLocal();
                }

                clonedImage = null;
                System.gc();
                MipavUtil.displayError("Out of memory: unable to open new frame");

                return;
            }
        } else if (command.equals("Concat")) {

            if (isMultipleImages() == true) {
                new JDialogConcat(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to operate on.");

                return;
            }
        } else if (command.equals("DicomOrder")) {

            // Below line must precede dialog creation or dialog run will be executed twice
            int xAxisOrientation = getActiveImage().getFileInfo()[0].getAxisOrientation()[0];
            JDialogDicomOrder dOrder = new JDialogDicomOrder(this, getActiveImage());

            if (xAxisOrientation != FileInfoBase.ORI_UNKNOWN_TYPE) {

                // Axis information is already present so user need not enter it on the dialog
                dOrder.callAlgorithm();
            }
        } else if (command.equals("ReplaceBlankWithAvg")) {
            JDialogReplaceBlankSlicesWithAverages rBlankWithAvg =
                new JDialogReplaceBlankSlicesWithAverages(this, getActiveImage());
            rBlankWithAvg.callAlgorithm();
            
        } else if (command.equals("FlipY")) {
            JDialogFlip flip = new JDialogFlip(this, getActiveImage(), AlgorithmFlip.Y_AXIS);

            flip.callAlgorithm();
        } else if (command.equals("FlipX")) {
            JDialogFlip flip = new JDialogFlip(this, getActiveImage(), AlgorithmFlip.X_AXIS);

            flip.callAlgorithm();
        } else if (command.equals("RotateX180")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateXPlus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateXMinus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateY180")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateYPlus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateYMinus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZ180")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZPlus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZMinus")) {
            JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("Subset")) {

            // JDialogSubset subset =
            new JDialogSubset(this, getActiveImage());
        }
        /*
         *        else if (command.equals("subsampleBy2")) {       /// makes streaks and i don't know why...       if
         * (imageA.getNDims() == 3) {       int newExtents[] = new int[imageA.getNDims()];       float sigmas[] = new
         * float[imageA.getNDims()];       newExtents[0] = imageA.getExtents()[0] / 2;       newExtents[1] =
         * imageA.getExtents()[1] / 2;       newExtents[2] = imageA.getExtents()[2];       sigmas[0] = 1.0f; sigmas[1] =
         * 1.0f; sigmas[2] = 1.0f * (imageA.getFileInfo(0).getResolutions()[0] /
         * imageA.getFileInfo(0).getResolutions()[2]);///       ModelImage resultImage = new
         * ModelImage(imageA.getType(),       newExtents,       imageA.getImageName() + "_subsample_2", userInterface);
         * AlgorithmSubsample algo = new AlgorithmSubsample(imageA, resultImage, newExtents, sigmas, true, true);
         * algo.setActiveImage(false);       algo.run();       //resultImage = algo.getResultImage();      new
         * ViewJFrameImage(resultImage, LUTa, userInterface.getNewFrameLocation(), userInterface);       }  }
         */
        else if (command.equals("subsample")) {
            new JDialogSubsample(this, imageA);
        } else if (command.equals("Swap34")) {

            // JDialogSwap34 swap34 =
            new JDialogSwap34(this, getActiveImage()).callAlgorithm();
        } else if (command.equals("onlyColor")) { // JDialogOnlyColor onlyColorDialog = new JDialogOnlyColor(this,
                                                  // getActiveImage()); onlyColorDialog.callAlgorithm();
        } else if (command.equals("extractSurface")) {

            // JDialogExtractSurface eSurface =
            new JDialogExtractSurface(this, getActiveImage());
        } else if (command.equals("extractSurfaceCubes")) {

            // JDialogExtractSurface eSurface =
            new JDialogExtractSurfaceCubes(this, getActiveImage());
            // } else if (command.equals("adaptiveSkeletonClimbing")) { // Superceded by Extract surface cubes new
            // JDialogClimb3D(this, getActiveImage()); }
        } else if (command.equals("entropyMin")) {
            new JDialogEntropyMinimization(this, getActiveImage());
        } else if (command.equals("MRICorrection")) {
            new JDialogMRIShadingCorrection(this, getActiveImage());
        } else if (command.equals("nonparametric")) {
            new JDialogNonparametricSegmentation(this, getActiveImage());
        } else if (command.equals("graphBasedSeg")) {
            new JDialogGraphBasedSegmentation(this, getActiveImage());
        } else if (command.equals("evalSeg")) {
            new JDialogEvaluateSegmentation(this, getActiveImage());
        } else if (command.equals("evalSegMask")) {
            new JDialogEvaluateMaskSegmentation(this, getActiveImage());
        } else if (command.equals("extractBrainSurfaceBET")) {
            new JDialogExtractBrain(this, getActiveImage());
        } else if (command.equals("extractBrainSurfaceBSE")) {
            new JDialogBrainSurfaceExtractor(this, getActiveImage());
        } else if (command.equals("extractObjectSurface")) {
            new JDialogExtractObject(this, getActiveImage());
        } else if (command.equals("Gaussian blur")) {

            // JDialogGaussianBlur gb =
            new JDialogGaussianBlur(this, getActiveImage());
        } else if (command.equals("GaussianBlurITK")) {
            new JDialogGaussianBlurITK(this, getActiveImage());
        } else if (command.equals("Unsharp mask")) {

            // JDialogUnsharpMask usm =
            new JDialogUnsharpMask(this, getActiveImage());
        } else if (command.equals("Local normalization")) {

            // JDialogLocalNormalization lnorm =
            new JDialogLocalNormalization(this, getActiveImage());
        } else if (command.equals("Gradient magnitude")) {

            // JDialogGradientMag gm =
            new JDialogGradientMagnitude(this, getActiveImage());
        } else if (command.equals("Single channel")) {

            // JDialogFuzzyCMeans fcm =
            new JDialogFuzzyCMeans(this, getActiveImage());
        } else if (command.equals("Multispectral")) {

            // JDialogMSFuzzyCMeans fcm =
            new JDialogMSFuzzyCMeans(this, getActiveImage());
        } else if (command.equals("N3Correction")) {

            // JDialogIHN3Correction N3 =
            new JDialogIHN3Correction(this, getActiveImage());
        } else if (command.equals("waveletThreshold")) {
            new JDialogWaveletThreshold(this, getActiveImage());
        } else if (command.equals("Calculator")) {

            if (isMultipleSameSizeImages(true) == true) {
                new JDialogImageCalculator(this, getActiveImage());
            } else {
                MipavUtil.displayError("There is no image with the same dimensions as\n" +
                                       getActiveImage().getImageName() + " to operate on.");

                return;
            }
        } else if (command.equals("Anonymize face")) {
            new JDialogFaceAnonymizer(this, getActiveImage());
        } else if (command.equals("Anonymize face (BET)")) {
            new JDialogFaceAnonymizerBET(this, getActiveImage());
        } else if (command.equals("Image math")) {

            // JDialogImageMath math =
            new JDialogImageMath(this, getActiveImage());
        } else if (command.equals("matchImages")) {
            new JDialogMatchImages(this, getActiveImage());
        } else if (command.equals("Plot surface")) {

            // JDialogPlotSurface  plotSur =
            new JDialogPlotSurface(this, getActiveImage(), zSlice);
        } else if (command.equals("InverseOrder")) {

            // JDialogInverseOrder order =
            new JDialogInverseOrder(this, getActiveImage()).run();
        } else if (command.equals("performRAHE")) {

            // JDialogAHE ahe =
            new JDialogAHE(this, getActiveImage());
        } else if (command.equals("performNAHE")) {

            // JDialogAHElocal ahe =
            new JDialogAHElocal(this, getActiveImage());
        } else if (command.equals("histMatch")) {

            if (isMultipleImages() == true) {
                new JDialogHistogramMatch(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to histogram match.");
            }
        } else if (command.equals("histTwoDim")) {
            new JDialogHistogram2Dim(this, getActiveImage());
        } else if (command.equals("DENCLUE")) {
            new JDialogDENCLUE(this, getActiveImage());
        } else if (command.equals("colocDENCLUE")) {
            new JDialogColocalizationDENCLUE(this, getActiveImage());
        } else if (command.equals("colocEM")) {
            new JDialogColocalizationEM(this, getActiveImage());
        } else if (command.equals("colocRegression")) {
            new JDialogColocalizationRegression(this, getActiveImage());
        } else if (command.equals("Laplacian")) {

            // JDialogLaplacian lap =
            new JDialogLaplacian(this, getActiveImage());
        } else if (command.equals("Zero X laplacian")) {

            // JDialogEdgeLap lap =
            new JDialogEdgeLaplacian(this, getActiveImage());
        } else if (command.equals("ACC")) {
            new JDialogAutoCorrelation(this, getActiveImage());
        } else if (command.equals("ACCOV")) {
            new JDialogAutoCovariance(this, getActiveImage());
        } else if (command.equals("nmsuppression")) {
            new JDialogNMSuppression(this, getActiveImage());
        } else if (command.equals("zxsuppression")) {
            new JDialogEdgeNMSuppression(this, getActiveImage());
        } else if (command.equals("sliceAveraging")) {
            new JDialogSliceAveraging(this, getActiveImage());
        } else if (command.equals("RGB -> Gray")) {
            new JDialogRGBtoGray(this, getActiveImage());
        } else if (command.equals("EyeSeg")) { // new JDialogEyeSeg(this, getActiveImage());
        } else if (command.equals("RGB -> Grays")) {
            JDialogRGBtoGrays rgb = new JDialogRGBtoGrays(this, getActiveImage());

            rgb.callAlgorithm();
        } else if (command.equals("RGB -> HSB")) {
            JDialogRGBtoHSB hsb = new JDialogRGBtoHSB(this, getActiveImage());

            hsb.callAlgorithm();
        } else if (command.equals("ColorEdge")) {
        //    JDialogColorEdge cEdge = new JDialogColorEdge(this, getActiveImage());
        } else if (command.equals("Grays -> RGB")) {
            JDialogRGBConcat graysToRGB = new JDialogRGBConcat(this, getActiveImage());

            if (graysToRGB.getError() == null) {
                graysToRGB.setVisible(true);
            } else {
                MipavUtil.displayError("" + graysToRGB.getError());
            }
        } else if (command.equals("HistoSummary")) {
            new JDialogHistogramSummary(this, getActiveImage());
        } else if (command.equals("Convert type")) {
            new JDialogConvertType(this, getActiveImage());
        } else if (command.equals("Invert")) {
            new JDialogInvert(this, getActiveImage());
        } else if (command.equals("Convert4Dto3D")) {

            // JDialogConvert4Dto3D convert4Dto3D =
            new JDialogConvert4Dto3D(this, getActiveImage()).callAlgorithm();
        } else if (command.equals("Convert3Dto4D")) {
            new JDialogConvert3Dto4D(this, getActiveImage());
        } else if (command.equals("Crop")) {
            new JDialogCrop(this, getActiveImage(), zSlice);
        } else if (command.equals("CropParam")) {
            new JDialogCropParam(this, getActiveImage());
        } else if (command.equals("FFT")) {
            new JDialogFFT(this, getActiveImage());
        } else if (command.equals("Filters (frequency)")) {
            new JDialogFrequencyFilter(this, getActiveImage());
        } else if (command.equals("gFilter")) {
            new JDialogGaborFilter(this, getActiveImage());
        } else if (command.equals("hFilter")) {
            new JDialogHomomorphicFilter(this, getActiveImage());
        } else if (command.equals("Mask")) {
            new JDialogMask(this, getActiveImage());
        } else if (command.equals("QuickMask")) {
            new JDialogMask(userInterface, getActiveImage(), false, false);
        } else if (command.equals("QuickMaskReverse")) {
            new JDialogMask(userInterface, getActiveImage(), false, true);
        } else if (command.equals("Mean")) {
            new JDialogMean(this, getActiveImage());
        } else if (command.equals("Median")) {
            new JDialogMedian(this, getActiveImage());
        } else if (command.equals("Mode")) {
            new JDialogMode(this, getActiveImage());
        } else if (command.equals("Midsagittal")) {
            new JDialogMidsagittal(this, getActiveImage());
        } else if (command.equals("Close")) {
            new JDialogClose(this, getActiveImage());
        } else if (command.equals("Dilate")) {
            new JDialogDilate(this, getActiveImage());
        } else if (command.equals("Erode")) {
            new JDialogErode(this, getActiveImage());
        } else if (command.equals("Skeletonize")) {
            new JDialogSkeletonize(this, getActiveImage());
        } else if (command.equals("Skeletonize3D")) {
            new JDialogSkeletonize3D(this, getActiveImage());
        } else if (command.equals("SkelGeom3D")) {
            new JDialogSkelGeom3D(this, getActiveImage());
        } else if (command.equals("Find edges")) {
            new JDialogFindEdges(this, getActiveImage());
        } else if (command.equals("Ultimate erode")) {
            new JDialogUltErode(this, getActiveImage());
        } else if (command.equals("Open")) {
            new JDialogOpen(this, getActiveImage());
        } else if (command.equals("ID objects")) {
            new JDialogIDObjects(this, getActiveImage());
        } else if (command.equals("morFilter")) {
            new JDialogMorphologicalFilter(this, getActiveImage());
        } else if (command.equals("Distance map")) {
            new JDialogDistanceMap(this, getActiveImage());
        } else if (command.equals("Bg. distance map")) {
            new JDialogBGDistanceMap(this, getActiveImage());
        } else if (command.equals("Delete objects")) {
            new JDialogDeleteObjects(this, getActiveImage());
        } else if (command.equals("Particle analysis")) {
            new JDialogParticleAnalysisNew(this, getActiveImage());
        } else if (command.equals("Fill holes")) {
            new JDialogFillObjects(this, getActiveImage());
        } else if (command.equals("Noise")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError("Cannot add noise to Boolean image.");
            } else {
                new JDialogNoise(this, getActiveImage());
            }
        } else if (command.equals("ANR")) {
            new JDialogAdaptiveNR(this, getActiveImage());
        } else if (command.equals("adaptivePathSmooth")) {
            new JDialogAdaptivePathSmooth(this, getActiveImage());
        } else if (command.equals("adaptiveSmooth")) {
            new JDialogAdaptiveSmooth(this, getActiveImage());
        } else if (command.equals("NLNR")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError("Cannot perform nonlinear noise reduction on Boolean image.");
            } else {
                new JDialogNLNoiseReduction(this, getActiveImage());
            }
        } else if (command.equals("RandOrder")) {
            new JDialogRandomizeSliceOrder(this, getActiveImage()).run();
        } else if (command.equals("ReplaceValue")) {
            new JDialogReplaceValue(this, getActiveImage());
        } else if (command.equals("StereoDepth")) {
            new JDialogStereoDepth(this, getActiveImage());
        } else if (command.equals("Haralick")) {

            if (getActiveImage().getType() == ModelStorageBase.UBYTE) {
                new JDialogHaralickTexture(this, getActiveImage());
            } else {
                MipavUtil.displayError("Image must be converted to UBYTE for Haralick texture");
            }
        } else if (command.equals("SubVOI")) {
            new JDialogSubtractVOI(this, getActiveImage());
        } else if (command.equals("doFRAP")) {
            new JDialogFRAP(this, getActiveImage());
        } else if (command.equals("doFRET")) {

            if ((getActiveImage().getNDims() == 2) ||
                    ((getActiveImage().getNDims() == 3) && (getActiveImage().getExtents()[2] == 2))) {
                new JDialogFRET(this, getActiveImage());
            } else {
                return;
            }
        } else if (command.equals("doFRETBleed")) {
            new JDialogFRETBleedThrough(this, getActiveImage());
        } else if (command.equals("doFRETEfficiency")) {
            new JDialogFRETEfficiency(this, getActiveImage());
        } else if (command.equals("xcosmEM")) {

            if (isMultipleImages() == true) {
                new JDialogXcosmEM(this, getActiveImage());
            } else {
                MipavUtil.displayError("Requires an image and a PSF image");
            }
        } else if (command.equals("Quantify")) {
            new JDialogQuantify(this, getActiveImage());
        } else if (command.equals("Patient Position")) {

            if (isMultipleImages() == true) {
                new JDialogRegPatientPos(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("BSplineReg")) {
            String[] akNamesCompatibleTargetImages = JDialogRegistrationBSpline.getNamesCompatibleTargetImages(componentImage.getActiveImage(),
                                                                                                               userInterface);

            if (akNamesCompatibleTargetImages.length > 0) {

                if (getActiveImage().getNDims() == 3) {
                    new JDialogRegistrationBSpline(this, getActiveImage(), akNamesCompatibleTargetImages);
                } else if (getActiveImage().getNDims() == 2) {
                    new JDialogRegistrationBSpline(this, getActiveImage(), akNamesCompatibleTargetImages);
                }
            } else {
                MipavUtil.displayError("There are no compatible images to which to register.");
            }
        } else if (command.equals("BSplineReg25D")) {

            if (getActiveImage().getNDims() == 3) {
                new JDialogRegistrationBSpline(this, getActiveImage(), null);
            }
        } else if (command.equals("OAR")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().getNDims() == 3) {
                    JDialogRegistrationOAR3D reg3D = new JDialogRegistrationOAR3D(this, getActiveImage());

                    /*
                     * if ( this.userInterface.getActiveImageMonitor() != null ) {
                     * this.userInterface.getActiveImageMonitor().setJDialogBase(reg3D); }
                     */
                } else if (getActiveImage().getNDims() == 2) {
                    new JDialogRegistrationOAR2D(this, getActiveImage());
                }
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("COAR")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().getNDims() == 3) {
                    JDialogConstrainedOAR3D reg3D = new JDialogConstrainedOAR3D(this, getActiveImage());

                } else if (getActiveImage().getNDims() == 2) {
                    new JDialogRegistrationOAR2D(this, getActiveImage());
                }
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("OAR25D")) {

            if (getActiveImage().getNDims() == 3) {
                new JDialogRegistrationOAR25D(this, getActiveImage());
            } else {
                MipavUtil.displayError("Must be 3D series (2.5D)");
            }
        } else if (command.equals("OAR35D")) {

            if (getActiveImage().getNDims() == 4) {
                new JDialogRegistrationOAR35D(this, getActiveImage());
            } else {
                MipavUtil.displayError("Must be 4D time series (3.5D)");
            }
        } else if (command.equals("TSOAR")) {

            if (getActiveImage().getNDims() == 4) {
                new JDialogRegistrationTSOAR(this, getActiveImage());
            } else {
                MipavUtil.displayError("Must be 4D time series.");
            }
        } else if (command.equals("COSTS")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().isColorImage() == false) {
                    new JDialogShowCosts(this, getActiveImage());
                } else {
                    MipavUtil.displayError("Only works for grayscale images.");
                }
            } else {
                MipavUtil.displayError("There are no other images for comparison.");
            }
        } else if (command.equals("LeastSquares")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationLeastSquares(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("MRIShear")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationShear(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("TPSpline")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationTPSpline(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("AIR linear")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationAIR(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("AIR nonlinear")) {

            if ((isMultipleImages() == true) || (getActiveImage().getNDims() == 3)) {
                new JDialogRegistrationNonlinear(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("Turbo")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationTurbo(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("Chamfer")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationChamfer(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("Manual")) {

            if (getActiveImage().getNDims() > 3) {
                MipavUtil.displayError(" Manual cannot handle images with more than 3 dimensions");
            }

            if (getActiveImage().getRegistrationFrame() == null) {

                if (getActiveImage().getNDims() == 2) {

                    // new JDialog to either load from frame or load from file
                    JDialogLoadImageForRegistration dialog = new JDialogLoadImageForRegistration(this);
                    ModelImage image2load = dialog.getImage();

                    if (image2load != null) {
                        AlgorithmMatchForReference algoRef = new AlgorithmMatchForReference(getActiveImage(),
                                                                                            image2load);

                        algoRef.setRunningInSeparateThread(false);
                        algoRef.run();

                        ModelImage refImage = null;
                        ModelImage adjImage = null;
                        ModelLUT refLUT = null;
                        ModelLUT adjLUT = null;

                        if (algoRef.newReferenceCreated()) {
                            refImage = algoRef.getNewReferenceImage();

                            ViewJFrameImage newRefFrame = new ViewJFrameImage(refImage, null, new Dimension(0, 0));
                        } else {
                            refImage = getActiveImage();
                        }

                        if (algoRef.newAdjustedCreated()) {
                            adjImage = algoRef.getNewAdjustedImage();

                            ViewJFrameImage newAdjFrame = new ViewJFrameImage(adjImage, null, new Dimension(0, 0));
                        } else {
                            adjImage = image2load;
                            adjLUT = dialog.getModelLUT();

                            if (!dialog.isFromFrame()) {
                                ViewJFrameImage adjFrame = new ViewJFrameImage(image2load, dialog.getModelLUT(),
                                                                               new Dimension(0, 0));
                            }
                        }

                        algoRef.finalize();
                        algoRef = null;

                        ViewJFrameRegistrationTool registrationFrame = new ViewJFrameRegistrationTool(refImage,
                                                                                                      adjImage, refLUT,
                                                                                                      adjLUT);

                        registrationFrame.componentResized(null);
                    }
                } else { // nDims == 3

                    try {
                        ModelLUT lut;

                        if (displayMode == IMAGE_A) {
                            lut = componentImage.getLUTa();
                        } else {
                            lut = componentImage.getLUTb();
                        }

                        ViewJFrameRegistration registrationFrame = new ViewJFrameRegistration(getActiveImage(), null);

                        registrationFrame.componentResized(null);
                        // getActiveImage().registerRegistrationFrame(registrationFrame);
                    } catch (OutOfMemoryError error) {
                        MipavUtil.displayError("Out of memory: unable to open Registration frame.");
                    }
                }
            }
        } else if (command.equals("Mosaic")) {
            new JFrameRegistrationMosaic();
        } else if (command.equals("VOILandmark")) {
            new JDialogRegVOILandmark(this, getActiveImage());
        } else if (command.equals("Insert slice")) {
            new JDialogInsertSlice(this, getActiveImage());
        } else if (command.equals("InsertMSlices")) {
            new JDialogInsertMissingSlices(this, getActiveImage());
        } else if (command.equals("Add margins")) {
            new JDialogAddMargins(this, getActiveImage());
        } else if (command.equals("Point area")) {
            new JDialogPointArea(this, getActiveImage(), true);
        } else if (command.equals("Principal components")) {
            new JDialogPrincipalComponents(this, getActiveImage());
        } else if (command.equals("Extract slices / volumes")) {
            new JDialogExtractSlicesVolumes(this, getActiveImage());
        } else if (command.equals("Remove slices")) {
            new JDialogRemoveSlices(this, getActiveImage());
        } else if (command.equals("padding")) {
            new JDialogPadImages(this, getActiveImage());
        } else if (command.equals("Remove time volumes")) {
            new JDialogRemoveTSlices(this, getActiveImage());
        } else if (command.equals("Replace slice")) {
            new JDialogReplaceSlice(this, getActiveImage());
        } else if (command.equals("Iterative blind deconvolution")) {
            new JDialogIteratedBlindDeconvolution(this, getActiveImage());
        } else if (command.equals("Maximum Likelihood Iterative blind deconvolution")) {
            new JDialogMaximumLikelihoodIteratedBlindDeconvolution(this, getActiveImage());
        } else if (command.equals("Reslice - isotropic voxels")) {
            new JDialogReslice(this, getActiveImage());
        } else if (command.equals("Test algorithm")) { // new JDialogRegionGrow(this, getActiveImage());
        } else if (command.equals("Threshold")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError(" Boolean image cannot be thresholded.");
            } else {

                if (getActiveImage().isColorImage()) {
                    new JDialogThresholdRGB(this, getActiveImage());
                } else {
                    new JDialogThreshold(this, getActiveImage());
                }
            }
        } else if (command.equals("Levelset")) {
            new JDialogLevelSet(this, getActiveImage());
        } else if (command.equals("LevelsetDiffusion")) {
            new JDialogLevelSetDiffusion(this, getActiveImage());
        } else if (command.equals("Transform")) {
            new JDialogTransform(this, getActiveImage());
        } else if (command.equals("TransformNL")) {
            new JDialogTransformBSpline(this, getActiveImage());
        } else if (command.equals("Transform to power of 2")) {
            new JDialogDirectResample(imageA, imageB, userInterface, componentImage, this);
        } else if (command.equals("TransformNL")) {
            new JDialogTransformNL(this, getActiveImage());
        }
        /*
         *        else if (command.equals("Transform with Padding")) {       new JDialogTransformWithPad(this,
         * getActiveImage());       }
         */
        // else if ( command.equals( "Vessel Segmentation" ) ) {
        // new JDialogVesselSegmentation( this, getActiveImage() );
        // }
        else if (command.equals("Watershed")) {
            ViewVOIVector VOIs = (ViewVOIVector) getActiveImage().getVOIs();
            int nVOI = VOIs.size();

            if (nVOI < 2) {
                MipavUtil.displayError(" Watershed: 2 or more VOIs required");
            } else {
                new JDialogWatershed(this, getActiveImage());
            }
        } // Views
        else if (command.equals("Animate")) {
            JDialogAnimate dialogAnimate;

            if (componentImage.getImageA().getNDims() > 4) {
                MipavUtil.displayError(" Animate cannot handle images with more than 4 dimensions");
            }

            if (componentImage.getImageA().getAnimateFrame() == null) {

                dialogAnimate = new JDialogAnimate(this, componentImage.getImageA(), componentImage.getLUTa(),
                                                   componentImage.getImageB(), componentImage.getLUTb(), userInterface);

                if (imageA.isColorImage()) {
                    dialogAnimate.setRGBs(componentImage.getRGBTA(), componentImage.getRGBTB());
                }
            }
        } else if (command.equals("Cine (movie)")) {
            componentImage.cine(40);
            componentImage.setSlice(zSlice);
            updateImages(true);
        } else if (command.equals("NextImage")) {
            incSlice();
        } else if (command.equals("PreviousImage")) {
            decSlice();
        } else if (command.equals("MagImage")) {
            componentImage.setMode(ViewJComponentEditImage.ZOOMING_IN);
        } else if (command.equals("UnMagImage")) {
            componentImage.setMode(ViewJComponentEditImage.ZOOMING_OUT);
        } else if (command.equals("LinkFrame")) {

            if (isMultipleSameSizeImages(false) == true) {
                new JDialogFrameLinker(this, getActiveImage());
            } else {

                if (getActiveImage().getNDims() == 3) {
                    MipavUtil.displayError("There is no image with the same z dimension as\n" +
                                           getActiveImage().getImageName() + " to operate on.");
                } else if (getActiveImage().getNDims() == 4) {
                    MipavUtil.displayError("There is no image with the same z and t dimensions as\n" +
                                           getActiveImage().getImageName() + " to operate on.");
                }

                return;
            }
        } else if (command.equals("MagRegion")) {
            componentImage.setMode(ViewJComponentEditImage.MAG_REGION);
        } else if (command.equals("WinRegion")) {
            componentImage.setMode(ViewJComponentEditImage.WIN_REGION);
        } else if (command.equals("CheckerBoard")) {

            if ((componentImage.checkerDialog != null) && componentImage.checkerDialog.isDisplayable()) {
                componentImage.checkerDialog.setVisible(true);

                return;
            }

            componentImage.checkerDialog = new JDialogCheckerBoard(this, componentImage);
        } else if (command.equals("ZoomOne")) {
            updateFrame(1, 1, 0, 0);
        } else if (command.equals("Tri-planar")) {

            // 3 space representation makes no sense on a 2d image!
            if (componentImage.getImageA().getNDims() == 2) {
                MipavUtil.displayError("This tool cannot be used on 2D images!");

                return;
            }

            try {
                linkTriFrame = new ViewJFrameTriImage(componentImage.getImageA(), componentImage.getLUTa(),
                                                      componentImage.getImageB(), componentImage.getLUTb(), controls,
                                                      this);

                if (imageA.isColorImage()) {
                    linkTriFrame.setRGBTA(componentImage.getRGBTA());

                    if (imageB != null) {
                        linkTriFrame.setRGBTB(componentImage.getRGBTB());
                    }
                }

                // to set the radio button correctly in the tri-planar frame
                linkTriFrame.setActiveImage(getControls().getActiveImage());
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open Tri-planar frame.");
            }

        } else if (command.equals("VolTriplanar")) {

            // 3 space representation makes no sense on a 2d image!
            if (componentImage.getImageA().getNDims() == 2) {
                MipavUtil.displayError("This tool cannot be used on 2D images!");

                return;
            }

            try {
                float[] res;
                float diffRatio;
                int[] units = new int[4];

                res = imageA.getFileInfo(0).getResolutions();
                units = imageA.getFileInfo(0).getUnitsOfMeasure();
                diffRatio = Math.max(res[2] / res[0], res[2] / res[1]);

                int unit = units[0];

                if (((units[1] != unit) || (units[2] != unit)) || (diffRatio >= 20)) {
                    int reply = JOptionPane.showConfirmDialog(this,
                                                              "Image resolution or units appear out of range. \nPlease, adjust the image resolution or units",
                                                              "Adjust Image Resolution/Units",
                                                              JOptionPane.YES_NO_OPTION,
                                                              JOptionPane.INFORMATION_MESSAGE);

                    if (reply == JOptionPane.YES_OPTION) {
                        JDialogImageInfo imageInfoDialog = getActiveImageInfoDialog();

                        if (imageInfoDialog != null) {
                            imageInfoDialog.setResolutionTag();
                            imageInfoDialog.populateTalairachTab();
                            imageInfoDialog.setVisible(true);
                            imageInfoDialog.toFront();
                        }
                    } else {
                        new JDialogVolViewResample(imageA, imageB);
                    }
                } else {
                    new JDialogVolViewResample(imageA, imageB);
                }
            } catch (OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open Volume Triplanar frame.");
            }

        } else if (command.equals("MagSettings")) {
            JDialogMagnificationControls magSettings = new JDialogMagnificationControls(this, componentImage,
                                                                                        componentImage.getZoomX(),
                                                                                        null);

            magSettings.setVisible(true);

        } else if (command.equals("MagControls")) {

            if (zoomDialog == null) {

                try {
                    zoomDialog = new JDialogZoom(this, componentImage, componentImage.getZoomX());
                } catch (OutOfMemoryError error) {
                    MipavUtil.displayError("Out of memory.: unable to open LUT frame.");
                }

                zoomDialog.setVisible(true);
            }
        } else if (command.equals("Surface plotter")) {

            try {
                new ViewJFramePlotterView(imageA, componentImage.getLUTa(), zSlice);

            } catch (NoClassDefFoundError notAvailableError) {
                Preferences.debug("ViewJFrameSurfacePlotter cannot be called; encountered " +
                                  "a NoClassDefFoundError.  \nIt is likely that java3D is " +
                                  "not available on this system.  The error is: \n" +
                                  notAvailableError.getLocalizedMessage());
                MipavUtil.displayError("The surface plotter requires java 3D and it cannot " + "be found.");
            } catch (OutOfMemoryError notEnoughError) {
                Preferences.debug("ViewJFrameSurfacePlotter cannot be called as there was " +
                                  "not enough memory allocated.  \n" + "The error is: \n" +
                                  notEnoughError.getLocalizedMessage());
                MipavUtil.displayError("The surface plotter requires more memory " + "than is currently available;\n" +
                                       "See the Memory Allocation menu");
            }

        }
        /*
         *        else if (command.equals("Jogl")) {       new InfiniteShadowVolumes().run();       }       else if
         * (command.equals("Gears")) {       new Gears();       }       else if (command.equals("GearsRotate")) { new
         * GearsRotate();       }       else if (command.equals("GearsDebug")) {       new GearsDebug();       }
         */
        else if (command.equals("Trim")) {
            JDialogTrim trimSettings = new JDialogTrim(this);

            trimSettings.setVisible(true);
        } else if (command.equals("ShowSliceNum")) {
            componentImage.setShowSliceNum(((JCheckBoxMenuItem) event.getSource()).isSelected());
            updateImages(true);
        } else if (command.equals("ShowGrid")) {

            if (((JCheckBoxMenuItem) event.getSource()).isSelected()) {
                componentImage.setGridOverlay(true);
            } else {
                componentImage.setGridOverlay(false);
            }

            componentImage.paintComponent(componentImage.getGraphics());

        } else if (command.equals("GridOptions")) {

            JDialogGridOptions gridOptions = new JDialogGridOptions(this, componentImage);
        } else if (command.equals("ShowOverlay")) {

            componentImage.setOverlay(((JCheckBoxMenuItem) event.getSource()).isSelected());

            // save into preferences
            if (componentImage.getActiveImage().isDicomImage()) {
                Preferences.setShowDICOMOverlays(((JCheckBoxMenuItem) event.getSource()).isSelected());
            } else {
                Preferences.setShowImageOverlays(((JCheckBoxMenuItem) event.getSource()).isSelected());
            }

            componentImage.paintComponent(componentImage.getGraphics());
            // componentImage.repaint();
        } else if (command.equals("DICOMOverlayOptions")) {
            new JDialogOverlay(this, true, null);
        } else if (command.equals("ImageOverlayOptions")) {
            new JDialogOverlay(this, false, null);
        } else if (command.equals("Open LUT")) {
            loadLUT(true, false);
        } else if (command.equals("Open functions")) {
            loadLUT(false, false);
        } else if (command.equals("Open LUT from...")) {
            loadLUTFrom(true, null, null, false);
        } else if (command.equals("Open functions from...")) {
            loadLUTFrom(false, null, null, false);
        } else if (command.equals("Save LUT")) {
            saveLUT(true);
        } else if (command.equals("Save functions")) {
            saveLUT(false);
        } else if (command.equals("Save LUT as...")) {
            saveLUTAs(true, null, null);
        } else if (command.equals("Save functions as...")) {
            saveLUTAs(false, null, null);
        } else if (command.equals("ctPresetsLUT")) {
            JDialogCTPreset ctDialogA = new JDialogCTPreset(this, imageA, componentImage.getLUTa());

            ctDialogA.setVisible(true);
        } else if (command.equals("DisplayLUT")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError(" Cannot change the LUT of a Boolean image.");
            } else {

                if (imageA.getHistoLUTFrame() == null) {
                    JDialogHistogramLUT histogramDialog = null;

                    if (imageA.isColorImage() == false) {

                        try {
                            histogramDialog = new JDialogHistogramLUT(this, imageA, imageB, componentImage.getLUTa(),
                                                                      componentImage.getLUTb(), userInterface);
                        } catch (OutOfMemoryError error) {
                            MipavUtil.displayError("Out of memory: unable to open LUT frame.");
                        }
                    } else {

                        try {
                            histogramDialog = new JDialogHistogramLUT(this, imageA, imageB, componentImage.getRGBTA(),
                                                                      componentImage.getRGBTB(), userInterface);
                        } catch (OutOfMemoryError error) {
                            MipavUtil.displayError("Out of memory: unable to open LUT frame.");
                        }
                    }

                    if (getActiveImage().getVOIs().size() == 0) {
                        histogramDialog.histogramLUT(true);
                    } else {
                        histogramDialog.constructDialog();
                    }
                }
            }
        } else if (command.equals("winLevel")) { // new win-level window when it does not exist

            if (getActiveImage() == imageA) {

                if (windowLevel[0] == null) {
                    windowLevel[0] = new JDialogWinLevel(this, imageA, componentImage.getLUTa());
                }

                windowLevel[0].setVisible(true);
                windowLevel[0].toFront();
            } else {

                if (windowLevel[1] == null) {
                    windowLevel[1] = new JDialogWinLevel(this, imageB, componentImage.getLUTb());
                }

                windowLevel[1].setVisible(true);
                windowLevel[1].toFront();
            }
        } else if (command.equals("invertLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().invertLUT();
            } else if (getActiveImage() == imageB) {
                componentImage.getLUTb().invertLUT();
            }

            if (getActiveImage().getHistoLUTFrame() != null) {
                getActiveImage().getHistoLUTFrame().update();
            }

            getActiveImage().notifyImageDisplayListeners(null, false);
        } else if (command.equals("GrayLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().makeGrayTransferFunctions();
                componentImage.getLUTa().makeLUT(256);
            } else if (getActiveImage() == imageB) {
                componentImage.getLUTb().makeGrayTransferFunctions();
                componentImage.getLUTb().makeLUT(256);
            }

            if (getActiveImage().getHistoLUTFrame() != null) {
                getActiveImage().getHistoLUTFrame().update();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }
        } else if (command.equals("HotMetalLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().makeHotMetalTransferFunctions();
                componentImage.getLUTa().makeLUT(256);
            } else if (getActiveImage() == imageB) {
                componentImage.getLUTb().makeHotMetalTransferFunctions();
                componentImage.getLUTb().makeLUT(256);
            }

            if (getActiveImage().getHistoLUTFrame() != null) {
                getActiveImage().getHistoLUTFrame().update();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }
        } else if (command.equals("OpenUDLUT")) {
            componentImage.openUDLUT();

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }

        } else if (command.equals("SaveUDLUT")) {
            componentImage.saveUDLUT();

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }

        } else if (command.equals("quickLUT")) {
            componentImage.setMode(ViewJComponentEditImage.QUICK_LUT);
        } else if (command.equals("resetLUTs")) {
            componentImage.resetLUTs();

            if ((getActiveImage().isColorImage()) && (getActiveImage().getHistoRGBFrame() != null)) {
                getActiveImage().getHistoRGBFrame().update();
            } else if (getActiveImage().getHistoLUTFrame() != null) {
                getActiveImage().getHistoLUTFrame().update();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }

        } else if (command.equals("Light box")) {
            ViewJFrameLightBox lightBoxFrame;

            if (componentImage.getImageA().getLightBoxFrame() == null) {

                // 3 space representation makes no sense on a 2d image!
                if (componentImage.getImageA().getNDims() == 2) {
                    MipavUtil.displayError("This tool cannot be used on 2D images!");

                    return;
                }

                try {
                    lightBoxFrame = new ViewJFrameLightBox(this, "LightBox", imageA, componentImage.getLUTa(), imageB,
                                                           componentImage.getLUTb(), componentImage.getResolutionX(),
                                                           componentImage.getResolutionY(), new Dimension(50, 200),
                                                           controls);
                    // imageA.registerLightBoxFrame(lightBoxFrame);
                } catch (OutOfMemoryError error) {
                    MipavUtil.displayError("Out of memory: unable to open Lightbox.");
                }

                System.gc();
            }
        } // Misc
        else if (command.equals("AboutImage")) {
            about();
        } else if (command.equals("AboutJava")) {
            userInterface.aboutJava();
        } else if (command.equals("Help")) {
            MipavUtil.showHelp(null);
        } else if (command.equals("MemoryAdjust")) {
            userInterface.memoryAllocation();
        } else if (command.equals("About")) {
            userInterface.about();
        } else if (command.equals("License")) {
            userInterface.showLicense();
        } else if (command.equals("MemoryUsage")) {
            userInterface.memoryFrame();
        } else if (command.equals("ImageRegistryMonitor")) {
            userInterface.imageRegistryMonitoring();
        } else if (command.equals("ActiveImageRegistryMonitor")) {
            userInterface.activeImageRegistryMonitoring();
        } else if (command.equals("Options")) {
            userInterface.options();
        } else if (command.equals("Shortcuts")) {
            userInterface.showShortcutEditor(false);
        } else if (command.equals("PlugInAlgorithm")) {

            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            Preferences.debug("\nplugInName = " + plugInName + "\n");

            try {

                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInAlgorithm) {
                    ((PlugInAlgorithm) thePlugIn).run(userInterface, this, getActiveImage());
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName +
                                           " claims to be an Algorithm PlugIn, but does not implement PlugInAlgorithm.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError(" FrameImage: " + e);
                e.printStackTrace();
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (Instatiation)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (Access)");
            }
        } else if (command.equals("PlugInFileRead")) {

            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFile) {

                    if (((PlugInFile) thePlugIn).canReadImages()) {
                        ((PlugInFile) thePlugIn).readImage();
                    } else {
                        MipavUtil.displayInfo(plugInName + " does not support the reading of images.");
                    }
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName +
                                           " claims to be an File PlugIn, but does not implement PlugInFile.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("PlugInFileWrite")) {
            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFile) {

                    if (((PlugInFile) thePlugIn).canWriteImages()) {
                        ((PlugInFile) thePlugIn).writeImage(getActiveImage());
                    } else {
                        MipavUtil.displayInfo(plugInName + " does not support the writing of images.");
                    }
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName +
                                           " claims to be an File PlugIn, but does not implement PlugInFile.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("PlugInFileTransfer")) {
            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFileTransfer) {
                    ((PlugInFileTransfer) thePlugIn).transferFiles();
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName +
                                           " claims to be an File Transfer PlugIn, but does not implement PlugInFileTransfer.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("PlugInGeneric")) {
            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInGeneric) {
                    ((PlugInGeneric) thePlugIn).run();
                } else {
                    MipavUtil.displayError("Plug-in " + plugInName +
                                           " claims to be an generic PlugIn, but does not implement PlugInGeneric.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("PluginView")) {
            Object thePlugIn = null;
            String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInView) {
                    ((PlugInView) thePlugIn).run(userInterface, this, getActiveImage());
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName +
                                           " claims to be an View PlugIn, but does not implement PlugInView.");
                }
            } catch (ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("InstallPlugin")) {
            JDialogInstallPlugin instPlugin = new JDialogInstallPlugin(this, userInterface);

            instPlugin.setVisible(true);

            int index = menuBar.getComponentIndex(menuBarMaker.getPlugInMenu());

            menuBar.remove(index);
            menuBarMaker.setPlugInMenu(userInterface.buildPlugInsMenu(this));
            menuBar.add(menuBarMaker.getPlugInMenu(), index);
            userInterface.getMainFrame().setJMenuBar(menuBar);
            userInterface.getMainFrame().pack();

        } else if (command.equals("CaptureTiff")) {
            JDialogCaptureScreen screenCapture = new JDialogCaptureScreen(this, userInterface);

            screenCapture.setVisible(true);

        } else if (command.equals("CaptureTiffs")) {
            JDialogCaptureScreens screenCapture = new JDialogCaptureScreens(this, userInterface);

            screenCapture.actionPerformed(new ActionEvent(this, 0, "Script"));
            screenCapture.dispose();
        } else if (command.equals("CorrectSpace")) {
            new JDialogCorrectSpacing(this, getActiveImage()).callAlgorithm();
        }
    }

    /**
     * Closes window and disposes of frame and component.
     */
    public void close() {

        if (Preferences.is(Preferences.PREF_CLOSE_FRAME_CHECK)) {
            int reply = JOptionPane.showConfirmDialog(this, "Do you really want to close this frame?", "Close Frame",
                                                      JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);

            if (reply == JOptionPane.NO_OPTION) {
                return;
            }
        }

        if (userInterface.getActiveFrame() != null) {
            userInterface.getActiveFrame().removeName(imageA.getImageName());
        }

        if (userInterface.isScriptRecording()) {
            userInterface.getScriptDialog().append("CloseFrame " +
                                                   userInterface.getScriptDialog().getVar(getActiveImage().getImageName()) +
                                                   "\n");
        }

        if ((imageA != null) && (imageA.getHistoLUTFrame() != null)) {
            imageA.getHistoLUTFrame().dispose();
        } else if ((imageA != null) && (imageA.getHistoRGBFrame() != null)) {
            imageA.getHistoRGBFrame().dispose();
        }

        // Get all imageA frames
        Vector frameListA = imageA.getImageFrameVector();

        if (frameListA != null) {

            for (int i = 0; i < frameListA.size(); i++) {

                if (frameListA.elementAt(i) instanceof ViewJFrameBase) {

                    if (((ViewJFrameBase) frameListA.elementAt(i)) != this) {
                        ((ViewJFrameBase) frameListA.elementAt(i)).setVisible(false);
                        ((ViewJFrameBase) frameListA.elementAt(i)).close();
                        i--;
                    }
                }
            }
        }

        super.close();

        try {
            this.finalize();
        } catch (Throwable t) {
            MipavUtil.displayError("Error encountered cleaning up image frame: " + t);
        }

        System.gc();
    }

    /**
     * Resizes frame and all components.
     *
     * @param  event  event that triggered function
     */
    public synchronized void componentResized(ComponentEvent event) {
        int width, height;
        float bigger;

        if ((getSize().width >= (xScreen - 20)) || (getSize().height >= (yScreen - 20))) {
            return;
        }

        removeComponentListener(this);

        width = getSize().width - (2 * getInsets().left);
        height = getSize().height - getInsets().top - getInsets().bottom;
        bigger = Math.max(width, height);
        zoom = (int) Math.min((bigger - 1) / ((imageA.getExtents()[0] * widthResFactor) - 1),
                              (bigger - 1) / ((imageA.getExtents()[1] * heightResFactor) - 1));

        if (zoom > componentImage.getZoomX()) {
            componentImage.setZoom((int) zoom, (int) zoom); // ***************************

            // setZoom(zoom, zoom);
            updateImages(true);

            if ((componentImage.getSize(null).width + 200) > xScreen) {
                width = xScreen - 200;
            } else {
                width = componentImage.getSize(null).width /* + fudgeFactor*/;
            }

            if ((componentImage.getSize(null).height + 200) > yScreen) {
                height = yScreen - 200;
            } else {
                height = componentImage.getSize(null).height /* + fudgeFactor*/;
            }
        } else if ((width < componentImage.getSize(null).width) && (height >= componentImage.getSize(null).height)) {

            // width += fudgeFactor;
            height = componentImage.getSize(null).height /* + fudgeFactor*/ +
                     scrollPane.getHorizontalScrollBar().getHeight();
        } else if ((width >= componentImage.getSize(null).width) && (height < componentImage.getSize(null).height)) {
            width = componentImage.getSize(null).width /* + fudgeFactor*/ +
                    scrollPane.getVerticalScrollBar().getWidth();
            // height += fudgeFactor;
        } else if ((width < componentImage.getSize(null).width) || (height < componentImage.getSize(null).height)) { // width += fudgeFactor;
                                                                                                                     // height += fudgeFactor;
        } else if ((width > componentImage.getSize(null).width) || (height > componentImage.getSize(null).height)) {

            if (width > componentImage.getSize(null).width) {
                width = componentImage.getSize(null).width; // ?????

                // height += fudgeFactor;
            }

            if (height > componentImage.getSize(null).height) {
                height = componentImage.getSize(null).height /* + fudgeFactor*/;
                // width += fudgeFactor;
            }
        } else {
            addComponentListener(this);

            return;
        }

        width += scrollPane.getInsets().left + scrollPane.getInsets().right;
        height += scrollPane.getInsets().top + scrollPane.getInsets().bottom;

        scrollPane.setSize(width, height);
        setSize(scrollPane.getSize().width + getInsets().left + getInsets().right,
                scrollPane.getSize().height + getInsets().top + getInsets().bottom);

        validate();
        setTitle();
        addComponentListener(this);
        updateImages(true);
        // componentImage.frameHeight = getSize().height;
        // componentImage.frameWidth = getSize().width;
    }

    /**
     * Decreases the slice to be displayed by one and updates title frame.
     */
    public synchronized void decSlice() {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice > 0) {
            zSlice--;
            controls.setZSlider(zSlice);

            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(zSlice);
                // imageA.getLightBoxFrame().updateImage(zSlice, true);   //turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            componentImage.getVOIHandler().resetLivewire();

            // componentImage.deactivateAllVOI();
            setTitle();

            if (linkFrame != null) {

                // linkFrame.setSlice(zSlice);
                linkFrame.decSlice();
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(zSlice, tSlice);
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(zSlice, tSlice);
            }

            updateImages(true);
        }
    }

    /**
     * Quick and simple way for ViewJFrameBase to tell the ViewJFrameImage it created to set the menu (right now only
     * for 2Dimensional) for image B.
     *
     * @param  enable  whether to enable the imageB related menu items
     */

    public void enableImageB(boolean enable) {
        menuBuilder.setMenuItemEnabled("Close image(B)", enable);
    }

    /**
     * Cleans memory.
     *
     * @throws  Throwable  the <code>Exception</code> raised by this method
     */
    public void finalize() throws Throwable {

        if (componentImage != null) {
            componentImage.dispose(false);
        }

        componentImage = null;
        imageBufferA = null;
        imageBufferB = null;
        pixBuffer = null;
        pixBufferB = null;

        scrollPane = null;

        if (zoomDialog != null) {
            zoomDialog.dispose();
            zoomDialog = null;
        }

        colorChooser = null;

        if (menuBar != null) {
            menuBar.removeAll();
        }

        menuBar = null;

        if (menuBuilder != null) {
            menuBuilder.finalize();
        }

        menuBuilder = null;

        if (menuBarMaker != null) {
            menuBarMaker.finalize();
        }

        menuBarMaker = null;

        if (controls != null) {
            controls.removeAll();
        }

        controls = null;

        super.finalize();
        // System.gc();
    }

    /**
     * Returns the reference to the currently active image.
     *
     * @return  the active image
     */
    public ModelImage getActiveImage() {

        if (componentImage != null) {
            return componentImage.getActiveImage();
        } else {
            return null;
        }
    }

    /**
     * Returns the reference to the component image.
     *
     * @return  component image
     */
    public ViewJComponentEditImage getComponentImage() {
        return componentImage;
    }

    /**
     * Get control widgets (toolbars, sliders) for the image frame.
     *
     * @return  the controls for this image frame
     */
    public ViewControlsImage getControls() {
        return controls;
    }

    /**
     * Return the height that the frame should have.
     *
     * @return  the frame's height
     */
    public int getFrameHeight() {
        return scrollPane.getSize().height + getInsets().top + getInsets().bottom;
    }

    /**
     * Return the preferred size for the frame.
     *
     * @return  the size the frame should be
     */
    public Dimension getFrameSize() {
        return new Dimension(getFrameWidth(), getFrameHeight());
    }

    /**
     * Return the preferred size for the frame.
     *
     * @param   size  if non-null, its dimensions are changed to the size the frame should be
     *
     * @return  the size the frame should be
     */
    public Dimension getFrameSize(Dimension size) {

        if (size == null) {
            return new Dimension(getFrameWidth(), getFrameHeight());
        } else {
            size.setSize(getFrameWidth(), getFrameHeight());

            return size;
        }
    }

    /**
     * Return the width that the frame should have.
     *
     * @return  the frame's width
     */
    public int getFrameWidth() {
        return scrollPane.getSize().width + getInsets().left + getInsets().right;
    }

    /**
     * Returns the reference to imageA.
     *
     * @return  image
     */
    public ModelImage getImageA() {

        if (componentImage != null) {
            return componentImage.getImageA();
        } else {
            return null;
        }
    }

    /**
     * Returns the reference to imageB.
     *
     * @return  imageB
     */
    public ModelImage getImageB() {

        if (componentImage != null) {
            return componentImage.getImageB();
        } else {
            return null;
        }
    }

    // The following 4 functions get and set the RGB tables for ARGB images A and B.
    /**
     * Gets the RGB LUT table for ARGB image A.
     *
     * @return  RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTA() {
        return (componentImage.getRGBTA());
    }

    /**
     * Gets the RGB LUT table for ARGB image B.
     *
     * @return  RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTB() {
        return (componentImage.getRGBTB());
    }

    /**
     * DOCUMENT ME!
     *
     * @return  JScrollPane
     */
    public JScrollPane getScrollPane() {
        return this.scrollPane;
    }

    /**
     * Return the preferred size for the component image scroll pane.
     *
     * @param   size  if non-null, its dimensions are changed to the size the scroll pane should be
     *
     * @return  the size the scroll pane should be
     */
    public Dimension getScrollPaneSize(Dimension size) {

        if (size == null) {
            return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
        } else {
            size.setSize(getScrollPaneWidth(), getScrollPaneHeight());

            return size;
        }
    }

    /**
     * Get the top-most slice.
     *
     * @return  returns the slice which is currently displayed
     */
    public int getViewableSlice() {
        return zSlice;
    }

    /**
     * Gets the current Time slice which is being viewed.
     *
     * @return  int the current time slice
     */
    public int getViewableTimeSlice() {
        return tSlice;
    }


    /**
     * This method is provided for the user to convert a masked area back to a painted area. It only affects those areas
     * that were masked with the intensity value that is currently active.
     *
     * @param  showProgressBar  DOCUMENT ME!
     */
    public void handleMaskToPaint(boolean showProgressBar) {

        if (componentImage != null) {
            float[] intensityMapB = new float[imageA.getExtents()[0] * imageA.getExtents()[1]]; // make intensity map
                                                                                                // same size as image
                                                                                                // dimensions
            BitSet bitSet = componentImage.getPaintMask(); // bitSet is for entire image volume

            if (imageB != null) {
                ViewJProgressBar progressBar = new ViewJProgressBar("Converting", "Converting mask to paint...", 0, 100,
                                                                    true, this, this);
                MipavUtil.centerOnScreen(progressBar);
                progressBar.setVisible(showProgressBar);

                try {
                    int numSlices = ((imageA.getNDims() > 2) ? imageA.getExtents()[2] : 1);

                    // iterate through slices
                    for (int currentSlice = 0; currentSlice < numSlices; currentSlice++) {

                        // here is where we get the slice
                        imageB.exportData(currentSlice * intensityMapB.length, intensityMapB.length, intensityMapB);

                        // examine every pixel and convert to paint if masked intensity is equal to the toolbar's
                        // selected intensity
                        for (int i = 0; i < intensityMapB.length; i++) {

                            if (intensityMapB[i] == componentImage.intensityDropper) {
                                bitSet.set((currentSlice * intensityMapB.length) + i); // turn the paint bit set index
                                                                                       // to ON
                                intensityMapB[i] = 0; // erase the painted mask from this index
                            }
                        }

                        // put the modified slice back into image
                        imageB.importData(currentSlice * intensityMapB.length, intensityMapB, false);

                        progressBar.updateValueImmed((int) ((float) (currentSlice + 1) / (float) numSlices * 100));
                    }

                    updateImages(true);
                } catch (Exception ex) {

                    // do nothing. the error will be displayed when this if block exits
                    MipavUtil.displayError("Cannot complete the operation due to an internal error.");
                } finally {
                    progressBar.dispose();
                }
            } else {

                // if we get here, there is no mask on the image.
                MipavUtil.displayError("This function is only useful when the image has a mask. To use this feature, please add a mask.");
            }
        } else {

            // should never get to this point. big trouble.
            MipavUtil.displayError("Cannot complete the operation due to an internal error.");
        }
    }

    /**
     * Increases the slice to be displayed by one and updates title frame.
     */
    public synchronized void incSlice() {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice < (imageA.getExtents()[2] - 1)) {
            zSlice++;
            controls.setZSlider(zSlice);

            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(zSlice); // turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            componentImage.getVOIHandler().resetLivewire();

            // componentImage.deactivateAllVOI();
            setTitle();

            if (linkFrame != null) {
                linkFrame.incSlice();
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(zSlice, tSlice);
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(zSlice, tSlice);
            }

            updateImages(true);
        }
    }

    /**
     * Initializes the variables based on the image extents. (i.e. number of slices, number of time slices, the initial
     * z-slice, etc.
     *
     * @param  img  the image to set the extent variables for
     */
    public void initExtentsVariables(ModelImage img) {
        int[] slices = null;
        int[] numImages = null;

        slices = initSlicePositions(img);
        numImages = initNumSlices(img);

        zSlice = slices[0];
        tSlice = slices[1];

        nImage = numImages[0];
        nTImage = numImages[1];
    }

    /**
     * ********************************************************************* **************************** Key Events ***
     * **************************.*********************************************************************
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyPressed(KeyEvent e) {

        // System.err.println("got something");
        int keyCode = e.getKeyCode();
        componentImage.rememberPaintBrushSize();

        switch (keyCode) {

            case KeyEvent.VK_PAGE_DOWN:
                decSlice();

                return;

            case KeyEvent.VK_PAGE_UP:
                incSlice();

                return;

            case KeyEvent.VK_1:
                if (!e.isControlDown()) {
                    componentImage.setPaintBrushSize(ViewJComponentEditImage.thinPaint);
                    componentImage.repaint();

                    return;
                }

                break;

            case KeyEvent.VK_2:
                if (!e.isControlDown()) {
                    componentImage.setPaintBrushSize(ViewJComponentEditImage.medPaint);
                    componentImage.repaint();

                    return;
                }

                break;

            case KeyEvent.VK_3:
                if (!e.isControlDown()) {
                    componentImage.setPaintBrushSize(ViewJComponentEditImage.thickPaint);
                    componentImage.repaint();

                    return;
                }

                break;

            case KeyEvent.VK_4:
                if (!e.isControlDown()) {
                    componentImage.setPaintBrushSize(ViewJComponentEditImage.thickestPaint);
                    componentImage.repaint();

                    return;
                }

                break;

            case KeyEvent.VK_UP:
            case KeyEvent.VK_DOWN:
            case KeyEvent.VK_LEFT:
            case KeyEvent.VK_RIGHT:
                getComponentImage().getVOIHandler().handleArrowKeysVOI(e);

                return;
        }

        // look for shortcuts now

        String command = null;
        KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);

        command = Preferences.getShortcutCommand(ks);

        if (command != null) {
            actionPerformed(new ActionEvent(ks, 0, command));
        }

    }

    /**
     * DOCUMENT ME!
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyReleased(KeyEvent e) {
        int keyCode = e.getKeyCode();

        switch (keyCode) {

            case KeyEvent.VK_HOME:
                setSlice(0);

                return;

            case KeyEvent.VK_END:
                if (imageA.getNDims() > 2) { // ignore for 2d images...
                    setSlice(imageA.getExtents()[2] - 1);
                }

                return;

            case KeyEvent.VK_DELETE:
                if (e.isShiftDown()) {
                    componentImage.getVOIHandler().deleteVOIActivePt();
                } else {
                    componentImage.getVOIHandler().deleteSelectedVOI(true);

                }

                return;

            case KeyEvent.VK_1:
            case KeyEvent.VK_2:
            case KeyEvent.VK_3:
            case KeyEvent.VK_4:
                componentImage.resetPaintBrushSize();
                componentImage.repaint();

                return;

            case KeyEvent.VK_C:
                if (e.isControlDown()) {
                    componentImage.getVOIHandler().copyVOItoClipBrd();
                }

                return;

            case KeyEvent.VK_V:
                if (e.isControlDown()) {
                    componentImage.getVOIHandler().pasteVOI();
                }

                return;

            case KeyEvent.VK_X:
                if (e.isControlDown()) {

                    if (componentImage.getVOIHandler().copyVOItoClipBrd()) {
                        componentImage.getVOIHandler().deleteSelectedVOI(true);
                    }
                }

                return;

            case KeyEvent.VK_A:
                if (e.isControlDown()) {
                    componentImage.getVOIHandler().selectAllVOIs(true);
                }

                return;

            case KeyEvent.VK_Z:
                if (e.isControlDown()) {
                    componentImage.getVOIHandler().undoLastVOI();
                }

                return;

            case KeyEvent.VK_Q:
                if (componentImage.getMode() == ViewJComponentEditImage.QUICK_LUT) {
                    componentImage.setMode(ViewJComponentEditImage.DEFAULT);
                }

                return;

        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyTyped(KeyEvent e) { }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void mouseClicked(MouseEvent event) {

        if (event.getButton() == MouseEvent.BUTTON3) {

            if (event.getSource() instanceof JToggleButton) {
                JToggleButton btnSource = (JToggleButton) event.getSource();

                if (btnSource.getActionCommand().equals("MagImage") ||
                        btnSource.getActionCommand().equals("UnMagImage")) {
                    handleZoomPopupMenu(btnSource, event);
                }
            }
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void mouseEntered(MouseEvent event) { }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void mouseExited(MouseEvent event) { }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void mousePressed(MouseEvent event) { }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void mouseReleased(MouseEvent event) { }

    /**
     * Method to send an image to the printer.
     */
    public void printImage() {
        String jobtitle = "Printing Image";

        PrintJob prtJob = getToolkit().getPrintJob(this, jobtitle, null);

        if (prtJob != null) {
            Graphics pGraphics = prtJob.getGraphics();

            if (pGraphics != null) {

                float oldImageWidth = (getActiveImage().getExtents()[0] * componentImage.getZoomX());
                float oldImageHeight = (getActiveImage().getExtents()[1] * componentImage.getZoomY());
                float oldZoomX = componentImage.getZoomX();
                float oldZoomY = componentImage.getZoomY();
                float newZoomX = componentImage.getZoomX();
                float newZoomY = componentImage.getZoomY();

                if ((oldImageWidth > 600) || (oldImageHeight > 780)) {

                    while (((getActiveImage().getExtents()[0] * componentImage.getZoomX()) > 600) ||
                               ((getActiveImage().getExtents()[1] * componentImage.getZoomY()) > 780)) {
                        newZoomX /= 1.1f;
                        newZoomY /= 1.1f;
                        componentImage.setZoom(newZoomX, newZoomY);

                    }
                }

                Preferences.debug("newZoomX, newZoomY = " + newZoomX + ", " + newZoomY + "\n");
                componentImage.paintComponentForPrinter(20, 20, pGraphics);
                componentImage.setZoom(oldZoomX, oldZoomY);
                pGraphics.dispose(); // flush page
            }

            prtJob.end();
        }
    }

    /**
     * Removes the menu and controls of the main frame so that a new frame can load the main frame with the proper
     * controls. Since the controls point to this particular image, when we remove the controls, turn off the highlight
     * box.
     *
     * @see  ViewJComponentEditImage#useHighlight(boolean)
     * @see  ViewJComponentEditImage#repaint()
     */
    public void removeControls() {
        userInterface.getMainFrame().getContentPane().remove(controls);

        // if the frame was just closed, componentImage will be null.
        try {
            componentImage.useHighlight(false);
            getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
        } catch (NullPointerException npe) {
            Preferences.debug("NullPointerException in ViewJFrameImage:\n" + npe.getMessage() +
                              "\n in removeControls().\n", 5);
        }
    }

    /**
     * Saves the image info; need to do before saving image.
     */
    public void saveImageInfo() {
        setLUTs(componentImage.getLUTa(), componentImage.getLUTb());
        setOpacityInfo(componentImage.getOpacity(), componentImage.getAlphaBlend());
        setpaintBitmap(componentImage.getPaintBitmap());
    }

    /**
     * Sets the active image for drawing VOIs. VOIs are only drawn in the active image. In addition, algorithms are
     * executed on the active window.
     *
     * @param  active  IMAGE_A or IMAGE_B
     */
    public void setActiveImage(int active) {

        if (componentImage != null) {
            componentImage.setActiveImage(active);
        }

        if (active == IMAGE_A) {
            displayMode = IMAGE_A;
            setTitle();
        } else {
            displayMode = IMAGE_B;
            setTitle();
        }

        if (linkTriFrame != null) {
            linkTriFrame.setActiveImage(active);
        }

        if (controls != null) {
            controls.setActiveImage(active);
        }

        updateImages(false);
    }

    /**
     * Sets the alpha blending of parameter for two image displaying.
     *
     * @param  value  amount [0,100] that is the percentage of Image A to be displayed
     */
    public void setAlphaBlend(int value) {

        // imageA.setAlphaBlend(value);
        if (componentImage != null) {
            componentImage.setAlphaBlend(value);
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  image2load  DOCUMENT ME!
     */
    public void setAndLoad(ModelImage image2load) {

        if (loadImage(image2load, componentImage, false, doOrigins, doOrients)) {

            if ((imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                removeControls();
                controls = new ViewControlsImage(this); // Build controls used in this frame
                menuBuilder = new ViewMenuBuilder(this);
                tSlice = 0;
                nTImage = imageB.getExtents()[3];
                zSlice = (imageB.getExtents()[2] - 1) / 2;
                nImage = imageB.getExtents()[2];
                menuBar = menuBarMaker.getMenuBar(this, 4, imageB.getType(), imageB.isDicomImage());
                controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                                      menuBuilder.isMenuItemSelected("VOI toolbar"),
                                      menuBuilder.isMenuItemSelected("Paint toolbar"),
                                      menuBuilder.isMenuItemSelected("Scripting toolbar"), componentImage.getVOIHandler().getVOI_ID());
            }

            menuBuilder.setMenuItemEnabled("Close image(B)", true);

            setControls();
            setTitle();
        }
    }

    /**
     * Sets the menu and controls (i.e. toolbars) of the main frame! This puts the menus and controls needed to controls
     * the operations of this frame. Different image frames have different menu and controls. Notify this componentImage
     * that it needs to display highlight box, notifying user that this componentImage is the image being controlled
     *
     * @see  ViewJComponentEditImage#useHighlight(boolean)
     * @see  ViewJComponentEditImage#repaint()
     */
    public void setControls() {

        if (getImageB() != null) {
            controls.addActiveImageControl();
        } else {
            controls.removeActiveImageControl();
        }

        userInterface.getMainFrame().setJMenuBar(menuBar);
        userInterface.getMainFrame().getContentPane().add(controls, BorderLayout.CENTER);
        userInterface.getMainFrame().pack();

        componentImage.useHighlight(true); // the controls point to this componentImage.  Display the highlighter
        getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
    }

    /**
     * Controls whether or not the images/VOIs of the frame can be modified.
     *
     * @param  flag  if true the image/VOIs can be modified; if false image/VOIs can NOT be modified
     */
    public void setEnabled(boolean flag) {

        if (componentImage != null) {
            componentImage.setEnabled(flag);
        }
    }

    /**
     * Sets the reference to imageB.
     *
     * @param  _imageB  image to set the frame to
     */
    public void setImageB(ModelImage _imageB) {
        Vector frameList = imageA.getImageFrameVector();
        float min, max;

        if (frameList == null) {
            return;
        }

        for (int i = 0; i < frameList.size(); i++) {

            if ((frameList.elementAt(i) instanceof ViewJFrameBase) &&
                    (((ViewJFrameBase) frameList.elementAt(i)) != this)) {
                ((ViewJFrameBase) frameList.elementAt(i)).setImageB(_imageB);
            }
        }

        if ((imageB != null) && (!imageB.equals(_imageB))) {
            imageB.disposeLocal(); // Dispose of the memory of the old image
        }

        imageB = _imageB;

        // imageB.setImageOrder(ModelImage.IMAGE_B);
        setZoomB();

        if (componentImage != null) {
            componentImage.setImageB(imageB);
        } else {
            return;
        }

        imageB.addImageDisplayListener(this);

        if ((imageA.isColorImage() == false) && (imageB.isColorImage() == false)) {
            int[] dimExtentsLUT = new int[2];

            dimExtentsLUT[0] = 4;
            dimExtentsLUT[1] = 256;

            ModelLUT LUT = new ModelLUT(ModelLUT.GRAY, 256, dimExtentsLUT);

            float imgMin = (float) imageB.getMin();
            float imgMax = (float) imageB.getMax();

            if (imageB.getType() == ModelStorageBase.UBYTE) {
                min = 0;
                max = 255;
                imgMin = 0;
                imgMax = 255;
            } else if (imageB.getType() == ModelStorageBase.BYTE) {
                min = -128;
                max = 127;
                imgMin = -128;
                imgMax = 127;
            } else {
                min = (float) imageB.getMin();
                max = (float) imageB.getMax();
            }

            LUT.resetTransferLine(min, imgMin, max, imgMax);
            imageB.notifyImageDisplayListeners(LUT, true);

            if (imageA.getHistoLUTFrame() != null) {
                imageB.addImageDisplayListener(imageA.getHistoLUTFrame());
                updateHistoLUTFrame(IMAGE_B);
            }
        } else if (imageA.isColorImage() && imageB.isColorImage()) {
            imageB.notifyImageDisplayListeners(null, true);

            if (imageA.getHistoRGBFrame() != null) {
                imageB.addImageDisplayListener(imageA.getHistoRGBFrame());
                updateHistoRGBFrame(IMAGE_B);
            }
        }

        if (getLUTb() != null) {
            getLUTb().zeroToOneLUTAdjust();
        }
    }


    /**
     * DOCUMENT ME!
     *
     * @param  uid  DOCUMENT ME!
     */
    public void setLastVOI_UID(int uid) {
        this.lastVOI_UID = uid;
    }

    /**
     * Sets the LUT for image A.
     *
     * @param  LUT  the LUT
     */
    public void setLUTa(ModelLUT LUT) {
        componentImage.setLUTa(LUT);
        super.setLUTa(LUT);

        if (linkTriFrame != null) {
            linkTriFrame.setLUTa(LUT);
        }
    }

    /**
     * Sets the LUT for image B.
     *
     * @param  LUT  the LUT
     */
    public void setLUTb(ModelLUT LUT) {
        componentImage.setLUTb(LUT);
        super.setLUTb(LUT);

        if (linkTriFrame != null) {
            linkTriFrame.setLUTb(LUT);
        }
    }

    /**
     * Updates the checkbox to show whether or not the output window is currently displayed.
     *
     * @param  isShown  boolean is the output window shown
     */
    public void setOutputWindowBox(boolean isShown) {
        menuBuilder.setMenuItemSelected("ShowOutput", isShown);
    }

    /**
     * When switching the active image, copy the paintBitmap of the previous active image into the paintBitmap of the
     * new active image.
     *
     * @param  paintBitmapSwitch  if true do not getMask on a setActiveImage command
     */
    public void setPaintBitmapSwitch(boolean paintBitmapSwitch) {

        if (componentImage != null) {
            componentImage.setPaintBitmapSwitch(paintBitmapSwitch);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image A.
     *
     * @param  RGBT  the new RGB LUT to be applied to the image
     */
    public void setRGBTA(ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTA(RGBT);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image B.
     *
     * @param  RGBT  the new RGB LUT to be applied to the image
     */
    public void setRGBTB(ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTB(RGBT);
        }
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     *
     * @param  slice  indicates image slice to be displayed
     */
    public void setSlice(int slice) {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice < imageA.getExtents()[2]) {
            zSlice = slice;
            controls.setZSlider(zSlice);
            updateImages(true);

            // livewire grad mag. should be recalculated for the new slice
            // componentImage.deactivateAllVOI();
            componentImage.getVOIHandler().resetLivewire();
            setTitle();

            if (linkFrame != null) {
                linkFrame.setSlice(slice);
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(zSlice, tSlice);
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(zSlice, tSlice);
            }
        }
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     *
     * @param  slice  indicates image time-slice (4th dimension) to be displayed
     */
    public void setTimeSlice(int slice) {

        if (imageA.getNDims() == 4) {

            if (tSlice < imageA.getExtents()[3]) {
                tSlice = slice;
                controls.setTSlider(slice);

                // livewire grad mag. should be recalculated for the new slice
                componentImage.getVOIHandler().resetLivewire();
                setTitle();
                updateImages(true);

                if (linkFrame != null) {
                    linkFrame.setTimeSlice(tSlice);
                }

                if (infoDialogA != null) {
                    infoDialogA.setSlice(zSlice, tSlice);
                }

                if (infoDialogB != null) {
                    infoDialogB.setSlice(zSlice, tSlice);
                }
            }
        } // if (imageA.getNDims() <= 3)
        else if ((imageB != null) && (imageB.getNDims() == 4)) {

            if (tSlice < imageB.getExtents()[3]) {
                tSlice = slice;
                controls.setTSlider(slice);

                // livewire grad mag. should be recalculated for the new slice
                componentImage.getVOIHandler().resetLivewire();
                setTitle();
                updateImages(true);

                if (linkFrame != null) {
                    linkFrame.setTimeSlice(tSlice);
                }

                if (infoDialogA != null) {
                    infoDialogA.setSlice(zSlice, tSlice);
                }

                if (infoDialogB != null) {
                    infoDialogB.setSlice(zSlice, tSlice);
                }
            }
        } // else if ((imageB != null) && (imageB.getNDims() == 4))
        else {
            return;
        }
    }

    /**
     * Sets the title of the frame with the image name and the slice location.
     */
    public void setTitle() {
        String str = makeTitle();

        setTitle(str);
        userInterface.getMainFrame().setTitle("MIPAV: " + str);
    }

    /**
     * updates the XOR checkbox to reflect whether XOR is currently being used for VOIs.
     *
     * @param  useXOR  boolean is XOR being used for VOIs
     */
    public void setUseVOIXOR(boolean useXOR) {
        this.useXOR = useXOR;
        menuBuilder.setMenuItemSelected("XOR", useXOR);
    }


    /**
     * Sets the magnification of Image B. Allocates the image buffers so that it can be displayed properly.
     *
     * @return  true if setting the zoom on imageB was successful
     */
    public boolean setZoomB() {
        int xDim = imageA.getExtents()[0];
        int yDim = imageA.getExtents()[1];

        float[] imageTempB = null;

        try {

            if (imageB != null) {
                pixBufferB = new int[pixBuffer.length];

                int bufferFactor = 1;

                if (imageA.isColorImage()) {
                    bufferFactor = 4;
                }

                imageTempB = new float[bufferFactor * xDim * yDim];
            }
        } catch (OutOfMemoryError error) {
            imageTempB = null;
            System.gc();
            throw (error);
        }

        imageBufferB = imageTempB;
        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        return true;
    }

    /**
     * Sets the magnification dialog to null.
     */
    public void setZoomDialogNull() {
        zoomDialog = null;
    }

    /**
     * DOCUMENT ME!
     */
    public void showEditImageInfo() {
        JDialogImageInfo imageInfoDialog = getActiveImageInfoDialog();

        if (imageInfoDialog != null) {
            imageInfoDialog.populateTalairachTab();
            imageInfoDialog.setVisible(true);
            imageInfoDialog.toFront();
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  event  DOCUMENT ME!
     */
    public void stateChanged(ChangeEvent event) {

        if (event.getSource() instanceof JSpinner) {
            JSpinner intensitySpinner = (JSpinner) event.getSource();

            componentImage.intensityDropper = ((SpinnerNumberModel) intensitySpinner.getModel()).getNumber().floatValue();
        }
    }

    /**
     * DOCUMENT ME!
     */
    public void triPlanarClosing() {
        linkTriFrame = null;
    }

    /**
     * Updates the this frame's size the components sizes. If the magnified image fits into the frame that will fit into
     * the screen then frame and image are sized appropriately. If the frame, to fit the image, exceeds the screen size
     * the frame remains the same size and the image magnified and placed in the scroll pane.
     *
     * @param  sX  zoom in the x dimension
     * @param  sY  zoom in the y dimension
     */
    public void updateFrame(float sX, float sY) {
        componentImage.setZoom(sX, sY);
        computeIdealWindowSize();
        validate();

        setTitle();
        updateImages(false);
    }

    /**
     * public void updateFrame(float xZoom, float yZoom, int x, int y) This method is called when the user is zooming in
     * or out.
     *
     * @param  sX  float zoom in the x dimension
     * @param  sY  float zoom in the y dimension
     * @param  x   int X-pixel the user wants to zoom around
     * @param  y   int Y-pixel the user wants to zoom around
     */

    public void updateFrame(float sX, float sY, int x, int y) {
        updateFrame(sX, sY);
        adjustScrollbars(x, y);
    }

    /**
     * This methods calls the componentImage's REPAINT method to redraw the screen. The extents on this image have
     * changed, so the extents need to be read in again and menus, panes and slide bars adjusted accordingly.
     *
     * @return  whether the image extents update was successful
     */
    public boolean updateImageExtents() {

        // update the image buffers since their sizes may have changed
        int[] extents = createBuffers();
        initExtentsVariables(imageA);

        componentImage.setImageExtents(extents);
        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }

        // reset the title, since dimensions may have changed
        setTitle();

        // now update the menubar
        updateMenubar();

        // update the image controls
        removeControls();
        controls = new ViewControlsImage(this);

        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                              menuBuilder.isMenuItemSelected("VOI toolbar"),
                              menuBuilder.isMenuItemSelected("Paint toolbar"),
                              menuBuilder.isMenuItemSelected("Scripting toolbar"), componentImage.getVOIHandler().getVOI_ID());

        // controls.setZSlider(zSlice);
        setControls();
        setSlice(zSlice);

        return true;

    } // end updateImageExtents()

    /**
     * This methods calls the componentImage's update method to redraw the screen - fastest of the three update methods.
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages() {

        if (componentImage == null) {
            return false;
        }

        try {
            componentImage.paintComponent(componentImage.getGraphics());
            // componentImage.repaint(); // problems with this method on some machines seems to eat lots of  memory on
            // JVM 1.3
        } catch (OutOfMemoryError error) {
            System.gc();
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen. Without LUT changes.
     *
     * @param   forceShow  forces show to re import image and calc. java image
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages(boolean forceShow) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(tSlice, zSlice, null, null, forceShow, -1) == false) {
            return false;
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen.
     *
     * @param   LUTa        LUT used to update imageA
     * @param   LUTb        LUT used to update imageB
     * @param   forceShow   forces show to re import image and calc. java image
     * @param   interpMode  image interpolation method (Nearest or Smooth)
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages(ModelLUT LUTa, ModelLUT LUTb, boolean forceShow, int interpMode) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(tSlice, zSlice, LUTa, LUTb, forceShow, interpMode) == false) {
            return false;
        }

        // update the luts in this frame
        if (LUTa != null) {
            setLUTa(LUTa);
        }

        if (LUTb != null) {
            setLUTb(LUTb);
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This method updates the menubar; ie: after an image has been opened.
     */
    public void updateMenubar() {
        menuBuilder.updateQuickList();
    }

    /**
     * Update the window level sliders from the CT preset dialog.
     *
     * @param  min  min value.
     * @param  max  max value.
     */
    public void updateWinLevel(int min, int max) {

        if (getActiveImage() == imageA) {

            if (windowLevel[0] != null) {
                windowLevel[0].updateSliders(min, max);
            }
        } else {

            if (windowLevel[1] == null) {
                windowLevel[1].updateSliders(min, max);
            }
        }

    }

    /**
     * tells whether to use XOR for VOI handling.
     *
     * @return  boolean use XOR?
     */
    public boolean useXOR() {
        return this.useXOR;
    }

    /**
     * Closes window and disposes of frame and component.
     *
     * @param  event  Event that triggered function
     */
    public void windowClosing(WindowEvent event) {

        if ((event != null) && (event.getSource() instanceof ViewJProgressBar)) {
            ((ViewJProgressBar) event.getSource()).dispose();
        } else {
            close();
        }
    }

    /**
     * Get the extents of an image. (don't know why this is really needed...)
     *
     * @param   img  the image
     *
     * @return  the image's extents
     */
    protected static int[] initExtents(ModelImage img) {
        int[] extents = null;

        if (img.getNDims() == 2) {
            extents = new int[2];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
        } else if (img.getNDims() == 3) {
            extents = new int[3];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
            extents[2] = Math.round(img.getExtents()[2]);
        } else if (img.getNDims() == 4) {
            extents = new int[4];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
            extents[2] = Math.round(img.getExtents()[2]);
            extents[3] = Math.round(img.getExtents()[3]);
        }

        return extents;
    }

    /**
     * Create the intensity buffer for an image.
     *
     * @param   extents  the extents of the image
     * @param   isColor  whether the image is in color
     *
     * @return  a buffer which is big enough to contain the image intensity data
     */
    protected static float[] initImageBuffer(int[] extents, boolean isColor) {
        int bufferFactor = 1;

        if (isColor) {
            bufferFactor = 4;
        }

        return new float[bufferFactor * extents[0] * extents[1]];
    }

    /**
     * Get the total number of time slices and volume slices.
     *
     * @param   img  the image to get the slices of
     *
     * @return  an array containing the number of volume slices (in the first element) and the number of time slices in
     *          the image (in the second element)
     */
    protected static int[] initNumSlices(ModelImage img) {
        int[] numImages = new int[2];

        if (img.getNDims() == 4) {
            numImages[0] = img.getExtents()[2];
            numImages[1] = img.getExtents()[3];
        } else if (img.getNDims() == 3) {
            numImages[0] = img.getExtents()[2];
            numImages[1] = 0;
        } else {
            numImages[0] = 1;
            numImages[1] = 0;
        }

        return numImages;
    }

    /**
     * Create the pixel buffer for an image.
     *
     * @param   extents  the extents of the image
     *
     * @return  a buffer which is big enough to contain the image pixel data
     */
    protected static int[] initPixelBuffer(int[] extents) {
        return new int[extents[0] * extents[1]];
    }

    /**
     * Get the resolution correction needed for non-isotropic images.
     *
     * @param   imgResols  the image resolution
     * @param   imgUnits   the image units of measure
     *
     * @return  the resolution correction factor in the x (the first element) and y (the second element) dimensions
     */
    protected static float[] initResFactor(float[] imgResols, int[] imgUnits) {
        float[] resFactor = new float[2];

        resFactor[0] = 1.0f;
        resFactor[1] = 1.0f;

        if ((imgResols[1] >= imgResols[0]) && (imgResols[1] < (20.0f * imgResols[0])) && (imgUnits[0] == imgUnits[1])) {
            resFactor[1] = imgResols[1] / imgResols[0];
        } else if ((imgResols[0] > imgResols[1]) && (imgResols[0] < (20.0f * imgResols[1])) &&
                       (imgUnits[0] == imgUnits[1])) {
            resFactor[0] = imgResols[0] / imgResols[1];
        }

        return resFactor;
    }

    /**
     * DOCUMENT ME!
     *
     * @param   img  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    protected static float[] initResolutions(ModelImage img) {
        float[] res = img.getFileInfo(0).getResolutions();

        for (int r = 0; r < img.getNDims(); r++) {

            if (res[r] < 0) {
                res[r] = Math.abs(res[r]);
            } else if (res[r] == 0) {
                res[r] = 1.0f;
            }
        }

        return res;
    }

    /**
     * Get the initial time and volume slice positions.
     *
     * @param   img  the image to get the slice positions of
     *
     * @return  an array containing the slice in the volume (in the first element) and the time slice (in the second
     *          element)
     */
    protected static int[] initSlicePositions(ModelImage img) {
        int[] slices = new int[2];

        if (img.getNDims() == 4) {
            slices[0] = (img.getExtents()[2] - 1) / 2;
            slices[1] = 0;
        } else if (img.getNDims() == 3) {
            slices[0] = (img.getExtents()[2] - 1) / 2;
            slices[1] = 0;
        } else {
            slices[0] = 0;
            slices[1] = 0;
        }

        return slices;
    }

    /**
     * DOCUMENT ME!
     *
     * @param   img  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    protected static int[] initUnits(ModelImage img) {
        return img.getFileInfo(0).getUnitsOfMeasure();
    }

    /**
     * Initializes the zoom variables for an image.
     *
     * @param   img         the image to use to initialize the zoom
     * @param   xResFactor  correction factor in the x direction for images that are do not have isotropic voxels
     * @param   yResFactor  correction factor in the x direction for images that are do not have isotropic voxels
     *
     * @return  the initial zoom to use for this image
     */
    protected static float initZoom(ModelImage img, float xResFactor, float yResFactor) {

        float imgZoom;
        float zoomX = 1, zoomY = 1;

        if ((img.getExtents()[0] * xResFactor) > (xScreen - 300)) {
            zoomX = (xScreen - 300.0f) / (img.getExtents()[0] * xResFactor);
        }

        if ((img.getExtents()[1] * yResFactor) > (yScreen - 300)) {
            zoomY = (yScreen - 300.0f) / (img.getExtents()[1] * yResFactor);
        }

        imgZoom = Math.min(zoomX, zoomY);

        if (imgZoom < 1) {

            if (imgZoom > 0.5) {
                imgZoom = 0.5f;
            } else if (imgZoom > 0.25) {
                imgZoom = 0.25f;
            } else if (imgZoom > 0.125) {
                imgZoom = 0.125f;
            } else if (imgZoom > 0.0625) {
                imgZoom = 0.0625f;
            } else if (imgZoom > 0.03125) {
                imgZoom = 0.03125f;
            } else {
                imgZoom = 0.015625f;
            }
        }

        return imgZoom;

    } // end initZoom()

    /**
     * Create the buffers for imageA and imageB.
     *
     * @return  the extents of the buffers
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    protected int[] createBuffers() throws OutOfMemoryError {
        int[] extents = initExtents(imageA);

        imageBufferA = initImageBuffer(extents, imageA.isColorImage());
        pixBuffer = initPixelBuffer(extents);

        if (imageB != null) {
            imageBufferB = initImageBuffer(imageB.getExtents(), imageB.isColorImage());
            pixBufferB = initPixelBuffer(imageB.getExtents());
        }

        return extents;

    } // end createBuffers()

    /**
     * Get a power of 2 which is close to a given number.
     *
     * @param   dim  the number to get a power of 2 for
     *
     * @return  a power of 2
     */
    protected int dimPowerOfTwo(int dim) {

        // 128^3 x 4 is 8MB
        // 256^3 x 4 is 64MB
        if (dim <= 16) {
            return 16;
        } else if (dim <= 32) {
            return 32;
        } else if (dim <= 64) {

            if (dim > 40) {
                return 64;
            } else {
                return 32;
            }
        } else if (dim <= 128) {

            if (dim > 80) {
                return 128;
            } else {
                return 64;
            }
        } else if (dim <= 256) {

            if (dim > 160) {
                return 256;
            } else {
                return 128;
            }
        } else if (dim <= 512) {

            if (dim > 448) {
                return 512;
            } else {
                return 256;
            }
        } else {
            return 512;
        }
    }

    /**
     * Returns a reference to the image info dialog for the active image. Image A and image B have references to their
     * individual dialogs.
     *
     * @return  a reference to the image info dialog for the active image
     */
    protected JDialogImageInfo getActiveImageInfoDialog() {

        if (getActiveImage() == imageA) {

            if (infoDialogA == null) {
                infoDialogA = new JDialogImageInfo(this, imageA, zSlice, tSlice);
            }

            return infoDialogA;
        } else if (imageB == null) // should never happen, but just in case...
        {
            return null;
        } else // image B is active
        {

            if (infoDialogB == null) {
                infoDialogB = new JDialogImageInfo(this, imageB, zSlice, tSlice);
            }

            return infoDialogB;
        }
    }

    /**
     * Returns the image info dialog for image B.
     *
     * @return  the image info dialog for image B
     */
    protected JDialogImageInfo getImageInfoDialogB() {

        if (imageB != null) {

            if (infoDialogB == null) {
                infoDialogB = new JDialogImageInfo(this, imageB, zSlice, tSlice);
            }

            return infoDialogB;
        } else {
            return null;
        }
    }

    /**
     * Get the height of the scroll pane holding the component image.
     *
     * @return  the height of the component image scroll pane
     */
    protected int getScrollPaneHeight() {
        return componentImage.getSize(null).height + scrollPane.getInsets().top + scrollPane.getInsets().bottom;
    }

    /**
     * Get the size of the scroll pane holding the component image.
     *
     * @return  the size of the component image scroll pane
     */
    protected Dimension getScrollPaneSize() {
        return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
    }

    /**
     * Get the width of the scroll pane holding the component image.
     *
     * @return  the width of the component image scroll pane
     */
    protected int getScrollPaneWidth() {
        return componentImage.getSize(null).width + scrollPane.getInsets().left + scrollPane.getInsets().right;
    }

    /**
     * DOCUMENT ME!
     *
     * @param  component  DOCUMENT ME!
     * @param  event      DOCUMENT ME!
     */
    protected void handleZoomPopupMenu(Component component, MouseEvent event) {
        JPopupMenu popupMenu = new JPopupMenu();

        JMenuItem menuItem = new JMenuItem("Use exponential zoom increment");

        menuItem.addActionListener(this);
        menuItem.setActionCommand("Zoom exponentially");
        popupMenu.add(menuItem);

        menuItem = new JMenuItem("Use linear zoom increment");
        menuItem.addActionListener(this);
        menuItem.setActionCommand("Zoom linearly");
        popupMenu.add(menuItem);

        popupMenu.show(component, event.getX(), event.getY());
    }

    /**
     * Creates and initializes the LUT for the first image (<code>imageA</code>) if it hasn't been already.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    protected void initLUT() throws OutOfMemoryError {

        if (LUTa == null) {
            LUTa = initLUT(imageA);
        }
    }

    /**
     * Initializes the resolutions and units from the image.
     */
    protected void initResolutions() {
        resols = initResolutions(imageA);
        units = initUnits(imageA);

        float[] factor = initResFactor(resols, units);

        widthResFactor = factor[0];
        heightResFactor = factor[1];
    } // end initResolutions()

    /**
     * Initializes the zoom variables for the first image (imageA).
     */
    protected void initZoom() {
        zoom = initZoom(imageA, widthResFactor, heightResFactor);
    } // end initZoom()

    /**
     * Constructs the title of the frame with the image name and the slice location.
     *
     * @return  the image frame title
     */
    protected String makeTitle() {
        String str;

        if (displayMode == IMAGE_A) {

            if (imageA.getNDims() == 4) { // Setup the title for 4D image
                str = imageA.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + "z  " +
                      String.valueOf(tSlice + 1) + "/" + String.valueOf(nTImage) + "t M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else if (imageA.getNDims() == 3) { // Setup the title for 3D image
                str = imageA.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + " M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else {
                str = imageA.getImageName() + "  M:" + makeString(componentImage.getZoomX(), 2);
            }
        } else {

            if (imageB.getNDims() == 4) { // Setup the title for 4D image of image B
                str = imageB.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + "z  " +
                      String.valueOf(tSlice + 1) + "/" + String.valueOf(nTImage) + "t M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else if (imageB.getNDims() == 3) { // Setup the title
                str = imageB.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + " M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else {
                str = imageB.getImageName() + "  M:" + makeString(componentImage.getZoomX(), 2);
            }
        }

        return str;
    }

    /**
     * Tests that the entered parameter is in range.
     *
     * @param   str       the value entered by the user
     * @param   minValue  the minimum value this variable may be set to
     * @param   maxValue  the maximum value this variable may be set to
     *
     * @return  boolean result of test
     */
    protected boolean testParameter(String str, double minValue, double maxValue) {

        double tmp;

        try {
            tmp = Double.valueOf(str).doubleValue();

            if ((tmp > maxValue) || (tmp < minValue)) {
                MipavUtil.displayError("Value is out of range: " + String.valueOf(minValue) + " , " +
                                       String.valueOf(maxValue));

                return false;
            } else {
                return true;
            }
        } catch (NumberFormatException error) {
            MipavUtil.displayError("Must enter numeric value");

            return false;
        }
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     *
     * @param  imageAorB  whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     */
    protected void updateHistoLUTFrame(int imageAorB) {
        updateHistoLUTFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     *
     * @param  imageAorB  whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     * @param  compImg    the component image with the image histogram frames to update
     */
    protected void updateHistoLUTFrame(int imageAorB, ViewJComponentEditImage compImg) {
        updateImages(true);

        if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_A)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(), null, null,
                                                                  true);
        } else if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_B)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(null, null, compImg.getImageB(), compImg.getLUTb(),
                                                                  true);
        } else if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_A_B)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(),
                                                                  compImg.getImageB(), compImg.getLUTb(), true);
        }
    }

    /**
     * Displays histoRGB frame for an RGB image.
     *
     * @param  imageAorB  indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     */
    protected void updateHistoRGBFrame(int imageAorB) {
        updateHistoRGBFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoRGB frame for an RGB image.
     *
     * @param  imageAorB  indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     * @param  compImg    the component image with the image histogram frames to update
     */
    protected void updateHistoRGBFrame(int imageAorB, ViewJComponentEditImage compImg) {
        updateImages(true);

        if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_A)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), null, true);
        } else if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_B)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(null, compImg.getImageB(), true);
        } else if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_A_B)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), compImg.getImageB(), true);
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  x  int
     * @param  y  int
     */
    private void adjustScrollbars(int x, int y) {
        final int xTemp = (int) (x * (componentImage.getZoomX() * componentImage.getResolutionX()));
        final int yTemp = (int) (y * (componentImage.getZoomY() * componentImage.getResolutionY()));

        final int scrollPaneX = getFrameWidth() / 2;
        final int scrollPaneY = getFrameHeight() / 2;

        Runnable adjustScrollbarsAWTEvent = new Runnable() {
            public void run() {
                scrollPane.getHorizontalScrollBar().setValue(xTemp - scrollPaneX);
                scrollPane.getVerticalScrollBar().setValue(yTemp - scrollPaneY);
            }
        };
        SwingUtilities.invokeLater(adjustScrollbarsAWTEvent);
    }

    /**
     * DOCUMENT ME!
     *
     * @param   type  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private boolean checkForVOICompatibility(int type) {

        // System.err.println("Type is: " + type);
        int numVOI = getActiveImage().getVOIs().size();
        int lastType = -1;

        if (numVOI == 0) {
            return true;
        } else if (numVOI == 1) {
            lastType = ((VOI) (getActiveImage().getVOIs().elementAt(0))).getCurveType();
        } else {

            for (int i = 0; i < numVOI; i++) {

                if (((VOI) (getActiveImage().getVOIs().elementAt(i))).getUID() == lastVOI_UID) {
                    lastType = ((VOI) (getActiveImage().getVOIs().elementAt(i))).getCurveType();

                    break;
                }
            }
        }

        // System.err.println("Last type is: " + lastType);

        if (lastType == -1) {
            return true;
        }

        switch (type) {

            case VOI.CONTOUR:
            case VOI.POLYLINE:
                if ((lastType != VOI.CONTOUR) && (lastType != VOI.POLYLINE)) {
                    int id = (((VOI) (getActiveImage().getVOIs().lastElement())).getID() + 1);

                    getControls().setVOIColor(id);

                    return false;
                }

                break;

            default:
                if (type != lastType) {
                    int id = (((VOI) (getActiveImage().getVOIs().lastElement())).getID() + 1);

                    getControls().setVOIColor(id);

                    return false;
                }
        }

        return true;
    }

    /**
     * private void computeIdealWindowSize() This method will enlarge or shrink the window size in response to the
     * componentImage being zoomed. It will only resize the window to IMAGE_SCREEN_RATIO of the screen size, in this
     * case 3/5. If the image is zoomed past that size, scrollbars are added. If the user has dragged the window to a
     * size larger than 3/5 of screen size, I assume he wants it that way and the window will not be resized in that
     * case upon zoom-in.
     */
    private void computeIdealWindowSize() {
        boolean addInsets = true;
        int newWidth = getScrollPaneSize().width;
        int newHeight = getScrollPaneSize().height;

        final float IMAGE_SCREEN_RATIO = 3.0f / 5.0f; // image will not be resized past 3/5 of screen size

        // if the image is too wide, cap the new window width
        if (componentImage.getSize().width > (((float) xScreen) * IMAGE_SCREEN_RATIO)) {
            addInsets = false;
            newWidth = (int) (xScreen * IMAGE_SCREEN_RATIO);
        }

        // if the image is too tall, cap the new window height
        if (componentImage.getSize().height > (((float) yScreen) * IMAGE_SCREEN_RATIO)) {
            addInsets = false;
            newHeight = (int) (yScreen * IMAGE_SCREEN_RATIO);
        }

        // if the window is already wider than IMAGE_SCREEN_RATIO, do not
        // resize the window, since the only way it could have got that big
        // is if the user manually resized it to be that large
        if ((getSize().width > (((float) xScreen) * IMAGE_SCREEN_RATIO)) &&
                (componentImage.getSize().width > getSize().width)) {
            addInsets = false;
            newWidth = getSize().width;
        }

        // if the window is already taller than IMAGE_SCREEN_RATIO, do not
        // resize the window, since the only way it could have got that big
        // is if the user manually resized it to be that large
        if ((getSize().height > (((float) yScreen) * IMAGE_SCREEN_RATIO)) &&
                (componentImage.getSize().height > getSize().height)) {
            addInsets = false;
            newHeight = getSize().height;
        }

        scrollPane.setSize(newWidth, newHeight);

        if (addInsets == true) {
            setSize(getFrameWidth(), getFrameHeight());
        } else {
            setSize(newWidth, newHeight);
        }
    }

    /**
     * Initializes the frame and variables.
     *
     * @param   LUTa           LUT of the imageA (if null grayscale LUT is constructed)
     * @param   loc            location where image should be initially placed
     * @param   logMagDisplay  a boolean indicating if the log magnitude of image should be displayed.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for the GUI
     */
    private void init(ModelLUT LUTa, Dimension loc, boolean logMagDisplay) throws OutOfMemoryError {

        try {
            setIconImage(MipavUtil.getIconImage("davinci_32x32.gif"));
        } catch (FileNotFoundException error) {
            Preferences.debug("Exception ocurred while getting <" + error.getMessage() +
                              ">.  Check that this file is available.\n");
        }

        setResizable(true);

        // initialize logMagDisplay
        this.logMagDisplay = logMagDisplay;
        this.LUTa = LUTa;

        initResolutions();
        initZoom();
        initLUT();

        int[] extents = createBuffers();

        initComponentImage(extents);
        initExtentsVariables(imageA);

        // create and build the menus and controls
        controls = new ViewControlsImage(this); // Build controls used in this frame
        menuBuilder = new ViewMenuBuilder(this);

        // build the menuBar based on the number of dimensions for imageA
        menuBarMaker = new ViewMenuBar(menuBuilder);
        menuBar = menuBarMaker.getMenuBar(this, imageA.getNDims(), imageA.getType(), imageA.isDicomImage());

        menuBar.addKeyListener(this);

        // imageA.

        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"),
                              menuBuilder.isMenuItemSelected("VOI toolbar"),
                              menuBuilder.isMenuItemSelected("Paint toolbar"),
                              menuBuilder.isMenuItemSelected("Scripting toolbar"), componentImage.getVOIHandler().getVOI_ID());

        if (getActiveImage().getFileInfo(0).getFileFormat() == FileBase.DICOM) {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", true);
            menuBuilder.setMenuItemEnabled("DICOM overlay options", true);
            menuBuilder.setMenuItemEnabled("Image overlay options", false);
        } else {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", false);
            menuBuilder.setMenuItemEnabled("DICOM overlay options", false);
            menuBuilder.setMenuItemEnabled("Image overlay options", true);
        }

        setTitle();

        // The component image will be displayed in a scrollpane.
        scrollPane = new JScrollPane(componentImage, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                                     JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        getContentPane().add(scrollPane);
        scrollPane.setBackground(Color.black);

        setSize(scrollPane.getSize().width + getInsets().left + getInsets().right,
                scrollPane.getSize().height + getInsets().top + getInsets().bottom);

        setBackground(Color.black);

        addComponentListener(this);
        addKeyListener(this);

        // MUST register frame to image models
        imageA.addImageDisplayListener(this);

        if (imageB != null) {
            imageB.addImageDisplayListener(this);
        }

        windowLevel = new JDialogWinLevel[2];

        pack();

        if (loc == null) {
            MipavUtil.centerOnScreen(this);
        } else {
            setLocation(loc.width, loc.height);
        }

        if (userInterface.isAppFrameVisible()) {
            setVisible(true);
        } else {
            setVisible(false);
        }

        // build the shortcuts that will fire when CTRL/SHIFT/ALT keys are pressed with another key

        // User interface will have list of frames
        userInterface.registerFrame(this);
        updateImages(true);
        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

    } // end init()

    /**
     * Creates and initializes the component image for the given image.
     *
     * @param   extents  the image dimensionality.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    private void initComponentImage(int[] extents) throws OutOfMemoryError {

        componentImage = new ViewJComponentEditImage(this, imageA, LUTa, imageBufferA, null, null, imageBufferB,
                                                     pixBuffer, zoom, extents, logMagDisplay,
                                                     ViewJComponentEditImage.NA, false,
                                                     imageA.getFileInfo()[0].getAxisOrientation());

        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }

        // if this is a color image, then update the RGB info in the component
        if (imageA.isColorImage()) {

            if (getRGBTA() == null) {
                int[] RGBExtents = new int[2];

                RGBExtents[0] = 4;
                RGBExtents[1] = 256;

                ModelRGB rgb = new ModelRGB(RGBExtents);

                setRGBTA(rgb);
            }
        } // end if image is an RGB type

    } // end initComponentImage()

    /**
     * Helper method to establish if there are other images so that a dialog can be created. Used by registration
     * methods, load frame, etc.
     *
     * @return  <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleImages() {
        Enumeration names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();

            if (!getActiveImage().getImageName().equals(name)) {
                createDialog = true;
            }
        }

        return createDialog;
    }

    /**
     * Helper method to establish if there are images of the same dimensionality so that a dialog can be created. Used
     * by image calculator, concat, etc.
     *
     * @param   isForCalculator  whether this call is being done before using the image calculator
     *
     * @return  <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleSameSizeImages(boolean isForCalculator) {
        Enumeration names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;
        boolean proceed = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();

            if (!getActiveImage().getImageName().equals(name)) {

                try {
                    ModelImage img = userInterface.getRegisteredImageByName(name);

                    if ((getActiveImage().getNDims() == img.getNDims()) ||
                            (isForCalculator && ((getActiveImage().getNDims() == 3) && (img.getNDims() == 2)))) {

                        // System.err.println("two with n-dim equal: " + img.getNDims());
                        if ((getActiveImage().getNDims() == 3) && (img.getNDims() == 3) &&
                                (getActiveImage().getExtents()[2] == img.getExtents()[2])) {

                            // System.err.println("extents 2 are equal");
                            proceed = true;
                        } else if ((getActiveImage().getNDims() == 4) &&
                                       (getActiveImage().getExtents()[2] == img.getExtents()[2]) &&
                                       (getActiveImage().getExtents()[3] == img.getExtents()[3])) {
                            proceed = true;
                        } else if (getActiveImage().getNDims() == 2) {
                            proceed = true;
                        } else if ((getActiveImage().getNDims() == 3) && (img.getNDims() == 2) &&
                                       (getActiveImage().getExtents()[0] == img.getExtents()[0]) &&
                                       (getActiveImage().getExtents()[1] == img.getExtents()[1])) {
                            proceed = true;
                        }

                        if (proceed) {

                            if (isForCalculator && !createDialog) {
                                createDialog = (getActiveImage().isColorImage() == img.isColorImage());
                            } else {
                                createDialog = true;
                            }
                        }
                    }
                } catch (IllegalArgumentException iae) {

                    // MipavUtil.displayError("There was a problem with the supplied name.\n" );
                    Preferences.debug("Illegal Argument Exception in " +
                                      "ViewJFrameImage.isMultipleSameSizeImages(). " +
                                      "Somehow the Image list sent an incorrect name to " +
                                      "the image image hashtable. " + "\n", 1);
                    Preferences.debug("Bad argument.");
                }
            }
        }

        return createDialog;
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToAllSlices() {

        if (componentImage.getImageA().getNDims() > 2) {
            BitSet bitSet = componentImage.getPaintBitmap();

            int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int j = 0; j < componentImage.imageExtents[2]; j++) {

                if (j != zSlice) {

                    for (int i = 0; i < oneSlicePixels; i++) {

                        if (bitSet.get((oneSlicePixels * zSlice) + i) == true) {
                            bitSet.set((oneSlicePixels * j) + i);
                        }
                    }
                }
            }
        }
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToNextSlice() {

        if ((componentImage.getImageA().getNDims() > 2) && (zSlice < componentImage.imageExtents[2])) {
            BitSet bitSet = componentImage.getPaintBitmap();

            int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int i = 0; i < oneSlicePixels; i++) {

                if (bitSet.get((oneSlicePixels * zSlice) + i) == true) {
                    bitSet.set((oneSlicePixels * (zSlice + 1)) + i);
                }
            }

            incSlice();
        }
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToPreviousSlice() {

        if ((componentImage.getImageA().getNDims() > 2) && (zSlice > 0)) {
            BitSet bitSet = componentImage.getPaintBitmap();

            int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int i = 0; i < oneSlicePixels; i++) {

                if (bitSet.get((oneSlicePixels * zSlice) + i) == true) {
                    bitSet.set((oneSlicePixels * (zSlice - 1)) + i);
                }
            }

            decSlice();
        }
    }

    //~ Inner Classes --------------------------------------------------------------------------------------------------

    /**
     * Pick up the selected color and call method to change the VOI color.
     */
    class OkColorListener implements ActionListener {

        /**
         * DOCUMENT ME!
         *
         * @param  e  DOCUMENT ME!
         */
        public void actionPerformed(ActionEvent e) {
            Color color = colorChooser.getColor();

            controls.getTools().setPaintColor(color);

            if (linkTriFrame != null) {
                linkTriFrame.setPaintColor(color);
            }

            getActiveImage().notifyImageDisplayListeners(null, false);
        }
    }


}
