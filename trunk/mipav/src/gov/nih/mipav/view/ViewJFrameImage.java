package gov.nih.mipav.view;


import gov.nih.mipav.plugins.*;

import gov.nih.mipav.model.algorithms.AlgorithmMatchForReference;
import gov.nih.mipav.model.algorithms.itk.AutoItkLoader;
import gov.nih.mipav.model.algorithms.utilities.*;
import gov.nih.mipav.model.dicomcomm.DICOM_Receiver;
import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.provenance.ProvenanceRecorder;
import gov.nih.mipav.model.scripting.ScriptRecorder;
import gov.nih.mipav.model.scripting.actions.*;
import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.dialogs.*;
import gov.nih.mipav.view.dialogs.JDialogSwapSlicesVolumes.SwapMode;
import gov.nih.mipav.view.graphVisualization.JDialogHyperGraph;
import gov.nih.mipav.view.renderer.JDialogVolViewResample;
import gov.nih.mipav.view.renderer.J3D.surfaceview.plotterview.ViewJFramePlotterView;
import gov.nih.mipav.view.renderer.WildMagic.VolumeTriPlanarInterface;
import gov.nih.mipav.view.renderer.WildMagic.DTI_FrameWork.DTIColorDisplay;
import gov.nih.mipav.view.renderer.WildMagic.DTI_FrameWork.DTIPipeline;
import gov.nih.mipav.view.renderer.WildMagic.DTI_FrameWork.JPanelDTIVisualization;
import gov.nih.mipav.view.renderer.WildMagic.Interface.JDialogDTIInput;
import gov.nih.mipav.view.renderer.WildMagic.VOI.*;

import ij.*;
import ij.process.ImageProcessor;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.*;

import javax.media.opengl.GLException;
import javax.swing.*;
import javax.swing.event.ChangeEvent;


import WildMagic.LibFoundation.Mathematics.Vector2f;
import WildMagic.LibFoundation.Mathematics.Vector3f;


/**
 * Makes a frame and put a single image component into it.
 * 
 * @version 1.0 Sept 28, 1998
 * @author Matthew J. McAuliffe, Ph.D.
 * @see ViewJComponentEditImage
 */
public class ViewJFrameImage extends ViewJFrameBase implements KeyListener, MouseListener, MouseMotionListener,
        ViewOpenFrameInterface, VOIManagerInterfaceListener {

    // ~ Static fields/initializers
    // -------------------------------------------------------------------------------------

    /** Use serialVersionUID for interoperability. */
    private static final long serialVersionUID = -5990635548319625443L;

    /** Width of the display screen. */
    protected static final int xScreen = Toolkit.getDefaultToolkit().getScreenSize().width;

    /** Height of the display screen. */
    protected static final int yScreen = Toolkit.getDefaultToolkit().getScreenSize().height;

    // ~ Instance fields
    // ------------------------------------------------------------------------------------------------

    /** Object where DICOM image, ... is converted and displayed as a Java image */
    protected ViewJComponentEditImage componentImage;

    /** Reference to the toolbars located in the controls object. */
    protected ViewControlsImage controls;

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float heightResFactor;

    /** Buffer used to store image intensities the presently viewed slice of image A. */
    protected float[] imageBufferA;

    /** Buffer used to store image intensities the presently viewed slice of image B. */
    protected float[] imageBufferB;

    /** reference to the JDialogImageInfo for updating slice/resolutions. */
    protected JDialogImageInfo infoDialogA = null;

    /** DOCUMENT ME! */
    protected JDialogImageInfo infoDialogB = null;

    /**
     * Flag indicating whether or not that the image should be displayed in Log scale. Used primarily for displaying the
     * FFT of an image.
     */
    protected boolean logMagDisplay;

    /** Reference to the frame's menu bar. */
    protected JMenuBar menuBar;

    /** Constructs the image menu bar. */
    protected ViewMenuBar menuBarMaker;

    /** This object contains a number of useful functions for building a menu and querying the state of menu items. */
    protected ViewMenuBuilder menuBuilder;

    /** Number of slices in a 3D dataset. */
    protected int nImage;

    /** Number of time sequences in a 4D dataset. */
    protected int nTImage;

    /**
     * Integer buffer (4 bytes that stores the concatenated Alpha (1 byte), Red (1 byte), Green ( 1 byte ), Blue (1 byte )
     * data. The ARGB values are generated by using the imageA intensities as a index into a LUT.
     */
    protected int[] pixBuffer;

    /**
     * Integer buffer (4 bytes that stores the concatenated Alpha (1 byte), Red (1 byte), Green ( 1 byte ), Blue (1 byte )
     * data. The ARGB values are generated by using the imageB intensities as a index into a LUT.
     */
    protected int[] pixBufferB;

    /** Storage of the image voxel resolutions. One resolution value per dimension. */
    protected float[] resols;

    /** The scrollPane where the image is displayed. */
    protected JScrollPane scrollPane;

    /** Storage of the resolution units of measure. For example, mm, cm, inches ... */
    protected int[] units;

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float widthResFactor;

    /** Reference to the two window and level dialogs where [0] is for imageA, [1] for imageB. */
    protected JDialogWinLevel[] windowLevel;

    /** Defaults magnification of image to 1. */
    protected float zoom = 1;

    /** Reference to the color chooser. */
    private ViewJColorChooser colorChooser;

    /** DOCUMENT ME! */
    private final boolean doOrients = true;

    /** When loading an image into B slot, should origins and orients be matched? */
    private final boolean doOrigins = false;

    /** Only want one gridoptions dialog per jframeimage. */
    private JDialogGridOptions gridOptions = null;

    /** boolean indicating if shift button is down. */
    private boolean isShiftDown = false;

    /**
     * used in conjuction with the above variable, stating that the paint brush has been changed but will change back to
     * previous.
     */
    private boolean paintBrushLocked = false;

    /** DOCUMENT ME! */
    private int quickPaintBrushIndex = -1;

    /** tells whether or not to XOR when creating binary masks (allowing holes). */
    // private boolean useXOR = Preferences.is(Preferences.PREF_USE_VOI_XOR);
    /** Reference to the magnification tool. */
    private JDialogZoom zoomDialog = null;

    /** Data provenance dialog */
    private JDialogDataProvenance dpDialog = null;

    AutoItkLoader m_kAutoItkLoader = null;

    /** reference to the JDialogMultiPaint for shortcuts */
    protected JDialogMultiPaint multipaintDialog = null;

    protected ButtonGroup VOIGroup = new ButtonGroup();

    protected JMenu voiMenu;

    protected VOIManagerInterface voiManager;

    // ~ Constructors
    // ---------------------------------------------------------------------------------------------------

    /**
     * Makes a frame and puts an image into it. Image will be centered on screen.
     * 
     * @param _imageA ModelImage - first image to display
     */
    public ViewJFrameImage(final ModelImage _imageA) {
        this(_imageA, null, null);
    }

    /**
     * Makes a frame and puts an image into it. Image will be centered on screen.
     * 
     * @param _imageA ModelImage - first image to display
     * @param LUTa LUT of the imageA (if null grayscale LUT is constructed)
     */
    public ViewJFrameImage(final ModelImage _imageA, final ModelLUT LUTa) {
        this(_imageA, LUTa, null);
    }

    /**
     * Makes a frame and puts an image component into it.
     * 
     * @param _imageA First image to display
     * @param LUTa LUT of the imageA (if null grayscale LUT is constructed)
     * @param loc location where image should be initially placed
     */
    public ViewJFrameImage(final ModelImage _imageA, final ModelLUT LUTa, final Dimension loc) {

        this(_imageA, LUTa, loc, _imageA.getLogMagDisplay());
    }

    /**
     * Makes a frame and puts an image component into it, does not display the frame through ViewJFrameImage's init()
     * method.
     * 
     * @param _imageA First image to display
     * @param _imageB Second image to display
     */
    public ViewJFrameImage(final ModelImage _imageA, final ModelImage _imageB) {
        super(_imageA, _imageB);
    }

    /**
     * Makes a frame and puts an image component into it.
     * 
     * @param _imageA First image to display
     * @param LUTa LUT of the imageA (if null grayscale LUT is constructed)
     * @param loc location where image should be initially placed
     * @param logMagDisplay Display log magnitude of image
     */
    public ViewJFrameImage(final ModelImage _imageA, final ModelLUT LUTa, final Dimension loc,
            final boolean logMagDisplay) {
        super(_imageA, null);

        // if we don't have an image, then we're done
        if (imageA == null) {
            return;
        }

        // initialize based on logMagDisplay
        init(LUTa, loc, logMagDisplay);

        if (imageA.getFileInfo(0).getModality() == FileInfoBase.COMPUTED_TOMOGRAPHY) {
            controls.getTools().setCTButtonEnabled(true);
        }

        // Matt take a look - Always set LUT zero to 1 default for gray images ?
        if (getLUTa() != null) {
            getLUTa().zeroToOneLUTAdjust();
        }

    }

    /**
     * Constructs a ModelSimpleImage VJF
     * 
     * @param simpleImage
     * @param name
     */
    public ViewJFrameImage(final ModelSimpleImage simpleImage, final String name) {
        this(new ModelImage(simpleImage, name));

    }

    // ~ Methods
    // --------------------------------------------------------------------------------------------------------

    /**
     * Makes an aboutDialog box and displays information of the image plane presently being displayed.
     */
    public void about() {
        super.about(componentImage.getSlice(), componentImage.getTimeSlice());
    }

    // ************************************************************************
    // **************************** Action Events *****************************
    // ************************************************************************

    /**
     * calls various methods depending on the action.
     * 
     * @param event event that triggered function
     */
    public void actionPerformed(final ActionEvent event) {
        final Object source = event.getSource();
        final String command = event.getActionCommand();

        if ( (command != null) && userInterface.isShorcutRecording()) {
            userInterface.setShortcutRecording(false);
            Preferences.addShortcut(command);
            userInterface.showShortcutEditor(true);

            return;
        }

        else if ( (voiMenu != null) && ViewMenuBar.isMenuCommand(voiMenu, command)) {
            voiManager.actionPerformed(event);
        } else if (command.equals("ScrollLink")) {
            final Enumeration<ModelImage> regImages = ViewUserInterface.getReference().getRegisteredImages();
            // add only the framed ones to a new list...also..dont include the active image
            final int activeImageNumDims = getImageA().getNDims();
            boolean hasMatch = false;
            while (regImages.hasMoreElements()) {
                final ModelImage image = regImages.nextElement();
                // check if it is a framed image...and if its not the active image...also make sure its just imageA
                if ( (image.getParentFrame() != null) && ( !image.getImageName().equals(getImageA().getImageName()))
                        && ( ( (image.getParentFrame())).getImageA() == image)) {

                    // now check the dimensionality to see if it matches with the active image
                    final int regFramedNumDims = image.getNDims();

                    if (regFramedNumDims == activeImageNumDims) { // same dimensionality required
                        hasMatch = true;
                        break;

                    }
                }
            }

            if ( !hasMatch) {
                getControls().getTools().scrollButton.setSelected(false);
                linkedScrolling = false;
            } else {
                linkedScrolling = !linkedScrolling;
            }

        }else if(command.equals(CustomUIBuilder.PARAM_IMAGE_SYNC.getActionCommand())) {
      
        	 
        	 final int activeImageNumDims = getImageA().getNDims();

        	 if(activeImageNumDims == 3 || activeImageNumDims == 4) {
	        	 final Enumeration<ModelImage> regImages = ViewUserInterface.getReference().getRegisteredImages();
	             // add only the framed ones to a new list...also..dont include the active image
	        	 int activeImageCurrentSlice = getImageA().getParentFrame().getComponentImage().getSlice();
	             while (regImages.hasMoreElements()) {
	                 final ModelImage image = regImages.nextElement();
	                 // check if it is a framed image...and if its not the active image...also make sure its just imageA
	                 if ( (image.getParentFrame() != null) && ( !image.getImageName().equals(getImageA().getImageName())) && ( ( (image.getParentFrame())).getImageA() == image)) {
	
	                	 //final int regFramedNumDims = image.getNDims();
	
	                	 
	                     //if (regFramedNumDims == activeImageNumDims) { // same dimensionality required
	                    	 
	                    	 
	                    
	                    		if(activeImageCurrentSlice < image.getExtents()[2]) {
	                    			image.setSlice(activeImageCurrentSlice);
	                    		}
	                    	
	                    
	                    // }
	                	 
	                	 
	                	 
	                	 
	                	 
	                 }
	             }
        	 }
             
             
        	
        }else if (command.equals("QuantifyMasks")) {
            new JDialogQuantifyMask(this, this.getActiveImage());
        } else if (command.equals("PaintBrushEditor")) {
            new ViewJFrameCreatePaint();
        } else if (command.equals("PropagatePaintPrev")) {
            propagatePaintToPreviousSlice();
        } else if (command.equals("PropagatePaintNext")) {
            propagatePaintToNextSlice();
        } else if (command.equals("PropagatePaintAll")) {
            propagatePaintToAllSlices();
        } else if (command.equals("PowerPaint")) {
            new JDialogPowerPaint(this, getImageA());
        } else if (command.equals("AdvancedPaint")) {
            menuBuilder.setMenuItemEnabled("Extract image(B)", true);
            multipaintDialog = new JDialogMultiPaint(this, getImageA());
            getControls().getTools().setPaintBrushButtonSelected();
            componentImage.setCursorMode(ViewJComponentBase.PAINT_VOI);
        } else if (command.startsWith("AdvancedPaint:")) {
            if (event.getSource() instanceof KeyStroke) {
                if (multipaintDialog != null) {
                    multipaintDialog.actionPerformed(event);
                }
            }

        } else if (command.equals("DisplayBorder")) {
            if (Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)) {
                getControls().getTools().bogusBorderPaintButton.setSelected(true);
                if (linkTriFrame != null) {
                    linkTriFrame.bogusBorderPaintButton.setSelected(true);
                }
            } else {
                getControls().getTools().borderPaintButton.setSelected(true);
                if (linkTriFrame != null) {
                    linkTriFrame.borderPaintButton.setSelected(true);
                }
            }

            // swap the border painting
            Preferences.setProperty(Preferences.PREF_SHOW_PAINT_BORDER, String.valueOf(""
                    + !Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)));

            updateImages(true);
            getActiveImage().notifyImageDisplayListeners();
        } else if (command.equals("Dicom")) {
            if (Preferences.is(Preferences.PREF_ASK_DICOM_RECEIVER)) {
                new DicomQueryListener().queryForDicomAutostart();
            }

            if ( ((JCheckBoxMenuItem) source).isSelected()) {

                if (userInterface.getDICOMCatcher() != null) {

                    userInterface.getDICOMCatcher().setStop();

                    try {
                        wait(2000);
                    } catch (final Exception ex) {}
                }

                userInterface.setDICOMCatcher(new DICOM_Receiver());
            } else {

                if (userInterface.getDICOMCatcher() != null) {
                    userInterface.getDICOMCatcher().setStop();
                }
            }
        } else if (command.startsWith("LastImage")) {
            final int number = Integer.valueOf(command.substring(10)).intValue();
            userInterface.openLastImage(number);
        } else if (command.equals("OpenNewImage")) {
            userInterface.openImageFrame();
        } else if (command.equals("closeAllImages")) {
            userInterface.closeAllImages();
        } else if (command.equals("CreateBlankImage")) {
            userInterface.createBlankImage(null);
        } else if (command.equals("BrowseImages")) {
            userInterface.buildTreeDialog();
        } else if (command.equals("BrowseDICOM")) {
            userInterface.buildDICOMFrame();
        } else if (command.equals("BrowseDICOMDIR")) {
            userInterface.buildDICOMDIRFrame();
        } else if (command.equals("LoadDWIDIR")) {
            userInterface.buildDICOMDIRFrame();   
        } else if (command.equals("OpenNewGraph")) {
            new ViewJFrameGraph("Graph", true);
        } else if (command.equals("QueryDatabase")) {

            if (userInterface.getDICOMQueryFrame() == null) {
                userInterface.setDICOMQueryFrame(new ViewJFrameDICOMQuery());
            }
            // ViewJFrameDICOMQuery DICOMQuery = new ViewJFrameDICOMQuery();
        } else if (command.equals("AnonymizeDirectory")) {
            userInterface.buildAnonDirectoryDialog();
        } else if (command.equals("RecordScript") || command.equals("ToolbarScriptRecord")) {

            // pass script events to the VUI, since there's no need to have the same implementation twice
            ViewUserInterface.getReference().actionPerformed(event);
        } else if (command.equals("RunScript")) {

            // pass script events to the VUI, since there's no need to have the same implementation twice
            ViewUserInterface.getReference().actionPerformed(event);
        } else if (command.equals("ToolbarScriptDir")) {

            // this action is to set the home directory and
            // and save it to preferences
            Preferences.debug("Set the script home directory.\n");

            // get the selected directory
            final ViewDirectoryChooser chooser = new ViewDirectoryChooser();
            final String dir = chooser.getDirectory();

            // set the default script directory
            if (dir != null) {
                userInterface.setDefaultScriptDirectory(dir);

                // reset the scripting toolbar on the controls
                controls.updateScripts(dir);
            }

        } else if (command.equals("ToolbarScriptRefresh")) {
            controls.updateScripts(userInterface.getDefaultScriptDirectory());
        } else if (command.equals("ToolbarScriptRun")) {

            // this is different from RunScript ... this is from the scripting toolbar
            if (ScriptRecorder.getReference().getRecorderStatus() != ScriptRecorder.STOPPED) {
                MipavUtil.displayError("Cannot run a script while recording a script.");

                return;
            } else {
                Preferences.debug("Run the currently selected script from the toolbar.\n");
                controls.runCurrentScript();
            }
        } else if (command.equals("ComponentLoadB")) {

            if (isMultipleImages() == true) {
                new JDialogLoadImage(this, getImageA(), JDialogLoadImage.LOAD_FROM_FRAME);
            } else {
                MipavUtil.displayError("There are no other images to load.\n");
            }
        } else if (command.equals("LoadB") || command.equals("OpenMask")) {
            final File fil = pickImageFile();

            if (fil == null) {
                return;
            }

            if (loadImage(fil, componentImage, userInterface.getLastStackFlag(), doOrigins, doOrients, 0, 0, 0, 0, false)) {
                
                if (this.newFrameBeenCreated()) {
                    return;
                }

                if ( (imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                    removeControls();
                    controls = new ViewControlsImage(this); // Build controls used in this frame
                    menuBuilder = new ViewMenuBuilder(this);
                    componentImage.setTimeSlice(0);
                    nTImage = imageB.getExtents()[3];
                    componentImage.setSlice( (imageB.getExtents()[2] - 1) / 2);
                    nImage = imageB.getExtents()[2];
                    menuBar = menuBarMaker.getMenuBar(this, 4, imageB.getType(), imageB.isDicomImage());
                    voiMenu = menuBarMaker.getVOIMenu();
                    controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), voiManager.getToolBar(),
                            VOIGroup, voiManager.getPointerButton(), menuBuilder.isMenuItemSelected("Paint toolbar"),
                            menuBuilder.isMenuItemSelected("Scripting toolbar"));
                }

                if (this.canCloseImageBAfterLoad()) {
                    menuBuilder.setMenuItemEnabled("Close image(B)", true);
                    menuBuilder.setMenuItemEnabled("Extract image(B)", true);
                }

                if (command.equals("OpenMask") && !imageA.isColorImage()) {
                    getLUTb().makeStripedLUT();
                }

                if (linkTriFrame != null) {
                    linkTriFrame.setImageSelectorPanelVisible(true);
                }

                updateImages(true);
                setActiveImage(ViewJFrameBase.IMAGE_B); // set image B to active by default, for convenience of user
                controls.setActiveImage(ViewJFrameBase.IMAGE_B); // set the controls to show that image B is active
                setControls();
                setTitle();
            }

        } else if (command.equals("AndMask")) {

            if (imageB == null) {
                MipavUtil.displayError("This image has no mask. To use this function, please add a mask.");
            } else {

                try {
                    final ModelImage destImage = new ModelImage(imageA.getType(), imageA.getExtents(), "maskImage");

                    final AlgorithmImageCalculator algImageCalc = new AlgorithmImageCalculator(destImage, imageA,
                            imageB, AlgorithmImageCalculator.AND, AlgorithmImageMath.CLIP, true, null);

                    algImageCalc.setRunningInSeparateThread(false);
                    algImageCalc.run();

                    destImage.setFileInfo(imageA.getFileInfo());

                    new ViewJFrameImage(destImage);
                } catch (final OutOfMemoryError error) {
                    System.gc();
                    MipavUtil.displayError("Out of memory: unable to open new frame");
                }
            }
        } else if (command.equals("NewMask")) {

            if (imageB != null) { // ask for confirmation if mask already exists

                final int response = JOptionPane.showConfirmDialog(this, "This image already has a mask. Discard it?",
                        "Create new mask", JOptionPane.YES_NO_OPTION);

                if (response != JOptionPane.YES_OPTION) {
                    return; // do not create a new mask if one already exists
                }

                // user wants a new mask, so kill current mask
                setActiveImage(ViewJFrameBase.IMAGE_A);
                imageB.disposeLocal();
            }

            if (imageA.isColorImage()) {
                imageB = new ModelImage(ModelStorageBase.ARGB, imageA.getExtents(), imageA.getImageName() + "_mask");

                imageB.copyFileTypeInfo(imageA);

                for (int i = 0; i < imageB.getFileInfo().length; i++) {
                    imageB.getFileInfo(i).setDataType(imageB.getType());
                    imageB.getFileInfo(i).setFileDirectory(imageA.getFileInfo(i).getFileDirectory());
                    imageB.getFileInfo(i).setFileName(
                            imageA.getImageName() + "_mask" + imageB.getFileInfo(i).getFileSuffix());
                }

                imageB.calcMinMax();
                setImageB(imageB);
            } else {
                imageB = new ModelImage(ModelStorageBase.UBYTE, imageA.getExtents(), imageA.getImageName() + "_ubMask");

                imageB.copyFileTypeInfo(imageA);

                for (int i = 0; i < imageB.getFileInfo().length; i++) {
                    imageB.getFileInfo(i).setDataType(imageB.getType());
                    imageB.getFileInfo(i).setFileDirectory(imageA.getFileInfo(i).getFileDirectory());
                    imageB.getFileInfo(i).setFileName(
                            imageA.getImageName() + "_ubMask" + imageB.getFileInfo(i).getFileSuffix());
                }

                imageB.calcMinMax();
                setImageB(imageB);
                getLUTb().makeStripedLUT(); // make striped look up table by default
                getLUTb().resetTransferLine(0, 255);
            }

            imageB.getMatrixHolder().replaceMatrices(imageA.getMatrixHolder().getMatrices());

            if (linkTriFrame != null) {
                linkTriFrame.setImageSelectorPanelVisible(true); // set the selector panel to visible in the
                // ViewJFrameTriImage, if it exists
            }

            menuBuilder.setMenuItemEnabled("Extract image(B)", true);
            menuBuilder.setMenuItemEnabled("Close image(B)", true);
            menuBuilder.setMenuItemEnabled("Clone/extract image(B)", true);

            setActiveImage(ViewJFrameBase.IMAGE_B); // set image B to active by default, for convenience of user
            controls.setActiveImage(ViewJFrameBase.IMAGE_B); // set the controls to show that image B is active

            setControls();
            setTitle();
        } else if (command.equals("LoadBlankB")) {
            new JDialogLoadImage(this, getImageA(), JDialogLoadImage.LOAD_BLANK);
        } else if (command.equals("SaveImage")) {
            saveImageInfo();
            save(new FileWriteOptions(false), -1);
        } else if (command.equals("SaveMask")) {

            if (imageB == null) {
                JOptionPane.showMessageDialog(this, "Image has no mask.", "Save mask", JOptionPane.ERROR_MESSAGE);

                return;
            }

            final int currentDisplayMode = displayMode;

            displayMode = ViewJFrameBase.IMAGE_B;

            saveImageInfo();
            save(new FileWriteOptions(true), -1);

            displayMode = currentDisplayMode;

            // reset the title to the new name
            setTitle();

        } else if (command.equals("SaveImageAs")) {
            saveImageInfo();
            save(new FileWriteOptions(true), -1);

            // reset the title to the new name
            setTitle();
        } else if (command.equals("PrintImage")) {
            printImage();
        } else if (command.equals("CloseImageB")) {

            if (imageB != null) {
                setActiveImage(ViewJFrameBase.IMAGE_A);

                final Vector<ViewImageUpdateInterface> frameList = imageB.getImageFrameVector();

                for (int i = 0; i < frameList.size(); i++) {

                    if ( frameList.elementAt(i) instanceof ViewJFrameBase )
                    {
                        if ( ((ViewJFrameBase) frameList.elementAt(i)) != this)
                        {
                        	((ViewJFrameBase) frameList.elementAt(i)).closeImageB();
                        }
                    }
                }

                if (imageA.getHistogramFrame() != null) {
                    imageA.getHistogramFrame().closeImageB();
                }

                imageBufferB = null;
                componentImage.setImageBufferB(null);
                componentImage.setImageB(null);
                if (voiManager != null) {
                    voiManager.getVOIManager(0).setImageB(null);
                }

                if ( (imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                    removeControls();
                    controls = new ViewControlsImage(this); // Build controls used in this frame
                    menuBuilder = new ViewMenuBuilder(this);
                    componentImage.setTimeSlice(0);
                    nTImage = 0;
                    componentImage.setSlice( (imageA.getExtents()[2] - 1) / 2);
                    nImage = imageA.getExtents()[2];
                    menuBar = menuBarMaker.getMenuBar(this, 3, imageA.getType(), imageA.isDicomImage());
                    voiMenu = menuBarMaker.getVOIMenu();
                    controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), voiManager.getToolBar(),
                            VOIGroup, voiManager.getPointerButton(), menuBuilder.isMenuItemSelected("Paint toolbar"),
                            menuBuilder.isMenuItemSelected("Scripting toolbar"));
                }

                closeImageB();

                menuBuilder.setMenuItemEnabled("Close image(B)", false);
                menuBuilder.setMenuItemEnabled("Extract image(B)", false);
                setControls();
                setTitle();
                if(Preferences.is(Preferences.PREF_FILE_LUT_DISPLAY) && imageA.getFileInfo(componentImage.getSlice()).getLUT() != null) {
                	updateImages(imageA.getFileInfo(componentImage.getSlice()).getLUT(), null, true, -1);
                } else {
                	updateImages(null, null, true, -1);
                }
            }

            if (imageA.getFileInfo()[0] instanceof FileInfoXML) {
                final String path = ((FileInfoImageXML) imageA.getFileInfo(0)).getLinkedImagePath();

                if (path != null) {

                    final int response = JOptionPane.showConfirmDialog(this, "Maintain link to closed image?",
                            "Linked image", JOptionPane.YES_NO_OPTION);

                    if (response == JOptionPane.NO_OPTION) {
                        ((FileInfoImageXML) imageA.getFileInfo(0)).setLinkedImagePath(null);
                    }

                }

            }
        } else if (command.equals("ExtractImageB")) {
            ModelImage clonedImage = null;

            try {
                clonedImage = (ModelImage) getImageB().clone();

                ModelLUT lutClone = null;

                if (LUTb != null) {
                    lutClone = (ModelLUT) LUTb.clone();
                }

                new ViewJFrameImage(clonedImage, lutClone, new Dimension(610, 200), getImageB().getLogMagDisplay());
                System.gc();

                ScriptRecorder.getReference().addLine(new ActionExtractImageB(getImageA(), clonedImage));
                ProvenanceRecorder.getReference().addLine(new ActionExtractImageB(getImageA(), clonedImage));
            } catch (final OutOfMemoryError error) {

                if (clonedImage != null) {
                    clonedImage.disposeLocal();
                }

                clonedImage = null;
                System.gc();
                MipavUtil.displayError("Out of memory: unable to open new frame");

                return;
            }
        } else if (command.equals("EditImageInfo")) {
            showEditImageInfo();
        } else if (command.equals("Exit")) {
            userInterface.windowClosing(null);
        } else if (command.equals("loadLeica")) {
            // open a file chooser to select .txt header

            final JFileChooser chooser = new JFileChooser(userInterface.getDefaultDirectory());

            chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
            chooser.setDialogTitle("Select Leica header file");

            final int returnVal = chooser.showDialog(this, "Open");

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                new JDialogLoadLeica(this, chooser.getSelectedFile());
            } else {
                return;
            }
        } // Toolbars
        else if (command.equals("openImgSeq")) {
            new ViewOpenImageSequence();
        } else if (command.equals("VOIToolbar") || command.equals("PaintToolbar") || command.equals("ImageToolbar")
                || command.equals("ScriptToolbar")) {

            if (command.equals("VOIToolbar")) {
                voiManager.getToolBar().setVisible(menuBuilder.isMenuItemSelected("VOI toolbar"));
            }

            removeControls();
            controls = new ViewControlsImage(this);

            final boolean showImage = menuBuilder.isMenuItemSelected("Image toolbar");
            final boolean showVOI = menuBuilder.isMenuItemSelected("VOI toolbar");
            final boolean showPaint = menuBuilder.isMenuItemSelected("Paint toolbar");
            final boolean showScript = menuBuilder.isMenuItemSelected("Scripting toolbar");

            Preferences.setProperty(Preferences.PREF_SCRIPTING_TOOLBAR_ON, String.valueOf(showScript));
            Preferences.setProperty(Preferences.PREF_VOI_TOOLBAR_ON, String.valueOf(showVOI));
            Preferences.setProperty(Preferences.PREF_IMAGE_TOOLBAR_ON, String.valueOf(showImage));
            Preferences.setProperty(Preferences.PREF_PAINT_TOOLBAR_ON, String.valueOf(showPaint));

            controls.buildToolbar(showImage, voiManager.getToolBar(), VOIGroup, voiManager.getPointerButton(),
                    showPaint, showScript);
            setControls();
        } else if (command.equals("PaintBrush")) {
            componentImage.setCursorMode(ViewJComponentBase.PAINT_VOI);
        } else if (command.equals("Dropper")) {
            componentImage.setCursorMode(ViewJComponentBase.DROPPER_PAINT);
        } else if (command.equals("Eraser")) {
            componentImage.setCursorMode(ViewJComponentBase.ERASER_PAINT);
        } else if (command.equals("EraseAll")) {
            componentImage.eraseAllPaint(false);
        } else if (command.equals("EraseCurrent")) {
            componentImage.eraseAllPaint(true);
        } else if (command.equals("PaintMask")) {
            if ( !checkForActiveVOIs()) {
                MipavUtil.displayWarning("Please select a VOI!");
                return;
            }
            System.err.println("PaintMask");
            getActiveImage().setMask(getActiveImage().generateVOIMask(false, true));
            componentImage.setPaintMask(getActiveImage().getMask());
            updateImages(true);
            getActiveImage().notifyImageDisplayListeners();

        } else if (command.equals("CollapseAllToSinglePaint")) {
            collapseAlltoSinglePaint(false);
        }

        // Paint
        else if (command.equals("colorPaint")) { // new colour dialog only when null

            if (colorChooser == null) {
                colorChooser = new ViewJColorChooser(this, "Pick paint color", new OkColorListener(), null);
            } else {
                colorChooser.setDialogVisible(true);
            }
        } else if (command.equals("RGBPaintComponent")) {
            new JDialogPaintRGBComponents(this, getComponentImage().getRGBPaintComponents());
        } else if (command.equals("OpacityPaint")) {
            new JDialogOpacityControls(this, controls);

        } else if (command.equals("CommitPaint") || command.equals("CommitPaintExt")) {
            final boolean outputNew = Preferences.is(Preferences.PREF_PAINT_TO_MASK_NEW);
            final boolean polarity = command.equals("CommitPaint");
            boolean saveMasksAs4D = false;
            if (getActiveImage().getNDims() == 4) {
                final JDialogMask3D4D dialogMask3D4D = new JDialogMask3D4D(this);
                if (dialogMask3D4D.isCancelled()) {
                    return;
                }
                saveMasksAs4D = dialogMask3D4D.isSaveMasksAs4D();
            }

            if (outputNew == true) {
                final ModelImage cloneImage = (ModelImage) getActiveImage().clone();
                final ViewJFrameImage newFrame = new ViewJFrameImage(cloneImage);
                newFrame.getComponentImage().intensityDropper = getComponentImage().intensityDropper;

                if (getActiveImage() == imageA) {
                    newFrame.getComponentImage().commitMask(ViewJComponentBase.IMAGE_A, true, polarity, null,
                            saveMasksAs4D);
                } else {
                    newFrame.getComponentImage().commitMask(ViewJComponentBase.IMAGE_B, true, polarity, null,
                            saveMasksAs4D);
                }
                // reset to default
                newFrame.getComponentImage().intensityDropper = 1f;

                newFrame.getActiveImage().notifyImageDisplayListeners(null, true);
            } else {

                if (getActiveImage() == imageA) {
                    componentImage.commitMask(ViewJComponentBase.IMAGE_A, true, polarity, null, saveMasksAs4D);
                } else {
                    componentImage.commitMask(ViewJComponentBase.IMAGE_B, true, polarity, null, saveMasksAs4D);
                }

                getActiveImage().notifyImageDisplayListeners(null, true);
            }

        } else if (command.equals("UndoPaint")) {
            componentImage.undoLastPaint();
            getActiveImage().notifyImageDisplayListeners(null, true);
        } else if (command.equals("CalcPaint")) {
            componentImage.calcPaintedVolume(getActiveImage().getImageName());
        } else if (command.equals("PaintCan")) {
            componentImage.setCursorMode(ViewJComponentBase.PAINT_CAN);

            if (componentImage.growDialog != null) {
                return;
            }

            final Vector<PaintGrowListener> listeners = new Vector<PaintGrowListener>();

            listeners.add(componentImage);
            componentImage.growDialog = new JDialogPaintGrow(this, listeners);
            // componentImage.regionGrow(); getActiveImage().notifyImageDisplayListeners(null, true);
        } // Algorithms
        else if (command.equals("Anisotropic diffusion")) {
            new JDialogAnisotropicDiffusion(this, getActiveImage());
        } else if (command.equals("BoundaryAttenuation")) {
            new JDialogBoundaryAttenuation(this, getActiveImage());
        } else if (command.equals("CoherDiff")) {
            new JDialogCoherenceEnhancingDiffusion(this, getActiveImage());
        } else if (command.equals("RegIsoDiff")) {
            new JDialogRegularizedIsotropicDiffusion(this, getActiveImage());
        } else if (command.equals("Clone")) {
            ModelImage clonedImage = null;

            try {
                clonedImage = (ModelImage) getActiveImage().clone();

                ModelLUT lutClone = null;

                if ( (displayMode == ViewJFrameBase.IMAGE_A) && (LUTa != null)) {
                    lutClone = (ModelLUT) LUTa.clone();
                } else if (LUTb != null) {
                    lutClone = (ModelLUT) LUTb.clone();
                }

                new ViewJFrameImage(clonedImage, lutClone, new Dimension(610, 200), getActiveImage().getLogMagDisplay());
                System.gc();

                ScriptRecorder.getReference().addLine(new ActionClone(getActiveImage(), clonedImage));
                ProvenanceRecorder.getReference().addLine(new ActionClone(getActiveImage(), clonedImage));
            } catch (final OutOfMemoryError error) {

                if (clonedImage != null) {
                    clonedImage.disposeLocal();
                }

                clonedImage = null;
                System.gc();
                MipavUtil.displayError("Out of memory: unable to open new frame");

                return;
            }
        } else if (command.equals("Concat")) {

        	 if (getActiveImage().getNDims() == 2) {

                 final Enumeration<String> names = userInterface.getRegisteredImageNames();
                 final ArrayList<ModelImage> imagesToConcat = new ArrayList<ModelImage>();
                 imagesToConcat.add(getActiveImage());

                 // Add images from user interface that have the same exact dimensionality
                 while (names.hasMoreElements()) {
                     final String name = names.nextElement();

                     if ( !getActiveImage().getImageName().equals(name)) {

                         final ModelImage img = userInterface.getRegisteredImageByName(name);

                         if (getActiveImage().getNDims() == img.getNDims()) {
                             if (getActiveImage().getExtents()[0] == img.getExtents()[0]
                                     && getActiveImage().getExtents()[1] == img.getExtents()[1]) {
                                 if (img.getDataType() == getActiveImage().getDataType()) {
                                     imagesToConcat.add(img);
                                 }
                             }

                         }

                     }
                 }
                 if (imagesToConcat.size() <= 1) {
                     MipavUtil.displayError("There are no other images of like dimension to concatenate");
                     return;
                 }

                 new JDialogConcatMult2Dto3D(this, imagesToConcat);

             }
        } else if (command.equals("ReplaceBlankWithAvg")) {
            final JDialogReplaceBlankSlicesWithAverages rBlankWithAvg = new JDialogReplaceBlankSlicesWithAverages(this,
                    getActiveImage());
            rBlankWithAvg.callAlgorithm();

        } else if (command.equals("ImageFlipY")) {
            new JDialogFlip(this, getActiveImage(), AlgorithmFlip.Y_AXIS, AlgorithmFlip.IMAGE);
        } else if (command.equals("ImageFlipX")) {
            new JDialogFlip(this, getActiveImage(), AlgorithmFlip.X_AXIS, AlgorithmFlip.IMAGE);
        } else if (command.equals("ImageFlipZ")) {
            new JDialogFlip(this, getActiveImage(), AlgorithmFlip.Z_AXIS, AlgorithmFlip.IMAGE);
        } else if (command.equals("RotateX180")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateXPlus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateXMinus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.X_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateY180")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateYPlus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateYMinus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Y_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZ180")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_180);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZPlus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_PLUS);

            rotate.callAlgorithm();
        } else if (command.equals("RotateZMinus")) {
            final JDialogRotate rotate = new JDialogRotate(this, getActiveImage(), AlgorithmRotate.Z_AXIS_MINUS);

            rotate.callAlgorithm();
        } else if (command.equals("Subset")) {

            // JDialogSubset subset =
            new JDialogSubset(this, getActiveImage());
        }
        /*
         * else if (command.equals("subsampleBy2")) { /// makes streaks and i don't know why... if (imageA.getNDims() ==
         * 3) { int newExtents[] = new int[imageA.getNDims()]; float sigmas[] = new float[imageA.getNDims()];
         * newExtents[0] = imageA.getExtents()[0] / 2; newExtents[1] = imageA.getExtents()[1] / 2; newExtents[2] =
         * imageA.getExtents()[2]; sigmas[0] = 1.0f; sigmas[1] = 1.0f; sigmas[2] = 1.0f *
         * (imageA.getFileInfo(0).getResolutions()[0] / imageA.getFileInfo(0).getResolutions()[2]);/// ModelImage
         * resultImage = new ModelImage(imageA.getType(), newExtents, imageA.getImageName() + "_subsample_2",
         * userInterface); AlgorithmSubsample algo = new AlgorithmSubsample(imageA, resultImage, newExtents, sigmas,
         * true, true); algo.setActiveImage(false); algo.run(); //resultImage = algo.getResultImage(); new
         * ViewJFrameImage(resultImage, LUTa, userInterface.getNewFrameLocation(), userInterface); } }
         */
        else if (command.equals("subsample")) {
            new JDialogSubsample(this, imageA);
        } else if (command.equals("Swap34")) {

            new JDialogSwapDims(this, getActiveImage(), AlgorithmSwapDims.SWAP34).callAlgorithm();
        } else if (command.equals("Swap14")) {

            new JDialogSwapDims(this, getActiveImage(), AlgorithmSwapDims.SWAP14).callAlgorithm();
        } else if (command.equals("onlyColor")) { // JDialogOnlyColor onlyColorDialog = new JDialogOnlyColor(this,
            // getActiveImage()); onlyColorDialog.callAlgorithm();
        } else if (command.equals("extractSurfaceCubes")) {

            // JDialogExtractSurface eSurface =
            new JDialogExtractSurfaceCubes(this, getActiveImage());
            // } else if (command.equals("adaptiveSkeletonClimbing")) { // Superceded by Extract surface cubes new
            // JDialogClimb3D(this, getActiveImage()); }
        } else if (command.equals("antigradient2")) {
            new JDialogAntigradient2(this, getActiveImage());
        } else if (command.equals("entropyMin")) {
            new JDialogEntropyMinimization(this, getActiveImage());
        } else if (command.equals("IsophoteCurvature")) {
            new JDialogIsophoteCurvature(this, getActiveImage());
        } else if (command.equals("MRICorrection")) {
            new JDialogMRIShadingCorrection(this, getActiveImage());
        } else if (command.equals("sm2")) {
            new JDialogSM2(this, getActiveImage());
        } else if (command.equals("evalSeg")) {
            new JDialogEvaluateSegmentation(this, getActiveImage());
        } else if (command.equals("evalSegMask")) {
            new JDialogEvaluateMaskSegmentation(this, getActiveImage());
        } else if (command.equals("extractBrainSurfaceBET")) {
            new JDialogExtractBrain(this, getActiveImage());
        } else if (command.equals("extractBrainSurfaceBSE")) {
            new JDialogBrainSurfaceExtractor(this, getActiveImage());
        } else if (command.equals("extractObjectSurface")) {
            new JDialogExtractObject(this, getActiveImage());
        } else if (command.equals("Bilateral filter")) {
            new JDialogBilateralFilter(this, getActiveImage());
        } else if (command.equals("Deconvolution")) {
            new JDialogDeconvolution(this, getImageA(), getImageB());
        }  else if (command.equals("Gaussian blur")) {
            // JDialogGaussianBlur gb =
            new JDialogGaussianBlur(this, getActiveImage());
        } else if (command.equals("Unsharp mask")) {
            // JDialogUnsharpMask usm =
            new JDialogUnsharpMask(this, getActiveImage());
        } else if (command.equals("Local normalization")) {

            // JDialogLocalNormalization lnorm =
            new JDialogLocalNormalization(this, getActiveImage());
        } else if (command.equals("Gradient magnitude")) {

            final JDialogGradientMagnitude gm = new JDialogGradientMagnitude(this, getActiveImage());
            gm.setVisible(true);
        } else if (command.equals("Single channel")) {

            // JDialogFuzzyCMeans fcm =
            new JDialogFuzzyCMeans(this, getActiveImage());
        } else if (command.equals("Multispectral")) {

            // JDialogMSFuzzyCMeans fcm =
            new JDialogMSFuzzyCMeans(this, getActiveImage());
        } else if (command.equals("N3Correction")) {

            // JDialogIHN3Correction N3 =
            new JDialogIHN3Correction(this, getActiveImage());
        } else if (command.equals("SMRISNR")) {
            new JDialogSingleMRIImageSNR(this, getActiveImage());
        } else if (command.equals("DMRISNR")) {
            new JDialogTwoMRIImagesSNR(this, getActiveImage());
        } else if (command.equals("ANY2SNR")) {
        	new JDialogAnyTwoImagesSNR(this, getActiveImage());
        } else if (command.equals("waveletThreshold")) {
            new JDialogWaveletThreshold(this, getActiveImage());
        } else if (command.equals("waveletMultiscaleProducts")) {
            new JDialogWaveletMultiscaleProducts(this, getActiveImage());
        } else if (command.equals("LLE")) {
            new JDialogLLE(this, getActiveImage());
        } else if (command.equals("fuzzyMin")) {
        	new JDialogFuzzyMinimization(this, getActiveImage());
        } else if (command.equals("FuzzMinDeAndChatterji")) {
        	new JDialogFuzzMinDeAndChatterji(this, getActiveImage());
        } else if (command.equals("rbcEnhancement")) {
        	new JDialogRuleBasedContrastEnhancement(this, getActiveImage());
        } else if (command.equals("fireEdgeExtraction")) {
        	new JDialogFIREEdgeExtraction(this, getActiveImage());
        } else if (command.equals("Calculator")) {
            // whether valid images are available is handled in the image calculator
            new JDialogImageCalculator(this, getActiveImage());
        } else if (command.equals("BulkCalculator")) {

            if (isMultipleSameSizeImages(true) == true) {
                new JDialogBulkImageCalculator(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no images with the same dimensions as\n"
                        + getActiveImage().getImageName() + " to operate on.");

                return;
            }
        } else if (command.equals("Anonymize face (BET)")) {
            new JDialogFaceAnonymizerBET(this, getActiveImage());
        } else if (command.equals("Image math")) {

            // JDialogImageMath math =
            new JDialogImageMath(this, getActiveImage());
        } else if (command.equals("LightboxGenerator")) {
            new JDialogLightboxGen(this, getActiveImage());
        } else if (command.equals("matchImages")) {
            new JDialogMatchImages(this, getActiveImage());
        } else if (command.equals("maximumIntensityProjection")) {
            new JDialogMaximumIntensityProjection(this, getActiveImage());
        } else if (command.equals("performRAHE")) {

            // JDialogAHE ahe =
            new JDialogAHE(this, getActiveImage());
        } else if (command.equals("performNAHE")) {

            // JDialogAHElocal ahe =
            new JDialogAHElocal(this, getActiveImage());
        } else if (command.equals("histImageMatch")) {

            if (isMultipleImages() == true) {
                new JDialogHistogramMatch(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to histogram match.");
            }
        } else if (command.equals("histSliceMatch")) {
            new JDialogHistogramSliceMatch(this, getActiveImage());
        } else if (command.equals("histTwoDim")) {
            new JDialogHistogram2Dim(this, getActiveImage());
        } else if (command.equals("cumHistogram")) {
            new JDialogCumulativeHistogram(this, getActiveImage());
        } else if (command.equals("colocEM")) {
            new JDialogColocalizationEM(this, getActiveImage());
        } else if (command.equals("colocRegression")) {
            new JDialogColocalizationRegression(this, getActiveImage());
        } else if (command.equals("Laplacian")) {

            final JDialogLaplacian lap = new JDialogLaplacian(this, getActiveImage());
            lap.setVisible(true);
        } else if (command.equals("Zero X laplacian")) {

            // JDialogEdgeLap lap =
            new JDialogEdgeLaplacian(this, getActiveImage());
        } else if (command.equals("ACC")) {
            new JDialogAutoCorrelation(this, getActiveImage());
        } else if (command.equals("ACCOV")) {
            new JDialogAutoCovariance(this, getActiveImage());
        } else if (command.equals("boxcount")) {
            new JDialogBoxCount(this, getActiveImage());
        } else if (command.equals("nmsuppression")) {
            new JDialogNMSuppression(this, getActiveImage());
        } else if (command.equals("sobel")) {
            new JDialogSobel(this, getActiveImage());
        } else if (command.equals("zxsuppression")) {
            new JDialogEdgeNMSuppression(this, getActiveImage());
        } else if (command.equals("sliceAveraging")) {
            new JDialogSliceAveraging(this, getActiveImage());
        } else if (command.equals("RGB -> Gray")) {
            new JDialogRGBtoGray(this, getActiveImage());
        } else if (command.equals("EyeSeg")) { // new JDialogEyeSeg(this, getActiveImage());
        } else if (command.equals("RGB -> Grays")) {
            final JDialogRGBtoGrays rgb = new JDialogRGBtoGrays(this, getActiveImage());

            rgb.callAlgorithm();
        } else if (command.equals("RGB -> HSB")) {
            final JDialogRGBtoHSB hsb = new JDialogRGBtoHSB(this, getActiveImage());

            hsb.callAlgorithm();
        } else if (command.equals("ColorEdge")) {
            new JDialogColorEdge(this, getActiveImage());
        } else if (command.equals("Grays -> RGB")) {
            new JDialogRGBConcat(this, getActiveImage());
        } else if (command.equals("MIPAV -> ImageJ")) {
            final ModelImage mi = getActiveImage();
            final int type = mi.getType();
            if ( ! (type == ModelStorageBase.UBYTE || type == ModelStorageBase.FLOAT || type == ModelStorageBase.USHORT || type == ModelStorageBase.ARGB)) {
                MipavUtil.displayError("<html>Image type must either be UBYTE, USHORT, FLOAT, or ARGB.<br>See Utilities -&gt; Conversion tools -&gt; Convert type.</html>");
                return;
            }
            if (mi.is2DImage()) {
                final ImageProcessor ip = ModelImageToImageJConversion.convert2D(mi);
                new ImagePlus("ImageJ:" + mi.getImageName(), ip).show();
            } else if (mi.is3DImage()) {
                final ImageStack is = ModelImageToImageJConversion.convert3D(mi);
                new ImagePlus("ImageJ:" + mi.getImageName(), is).show();

            }
        } else if (command.equals("launchImageJ")) {

            new ij.ImageJ();
        }

        else if (command.equals("ImageJ -> MIPAV")) {
            final ImagePlus imp = WindowManager.getCurrentImage();

            if (imp != null) {

                final ImageStack is = imp.getStack();
                if (is == null || imp.getStackSize() == 1) {
                    final ImageProcessor ip = imp.getProcessor();
                    final ModelImage mi = ImageJToModelImageConversion.convert2D(ip);
                    new ViewJFrameImage(mi);
                } else {
                    final ModelImage mi = ImageJToModelImageConversion.convert3D(is);
                    new ViewJFrameImage(mi);
                }

            }else {
            	MipavUtil.displayError("There are no active ImageJ images open");
            }

        } else if (command.equals("HistoSummary")) {
            new JDialogHistogramSummary(this, getActiveImage());
        } else if (command.equals("Convert type")) {
            new JDialogConvertType(this, getActiveImage());
        } else if (command.equals("Invert")) {
            new JDialogInvert(this, getActiveImage());
        } else if (command.equals("Convert4Dto3D")) {

            // JDialogConvert4Dto3D convert4Dto3D =
            new JDialogConvert4Dto3D(this, getActiveImage()).callAlgorithm();
        } else if (command.equals("Convert4DtoMultiple3D")) {

            
        	
        	//
        	new JDialogConvert4DtoMultiple3D(this, getActiveImage()).callAlgorithm();
        	
        }else if(command.equals("4DImageCalculator")) {
        	new JDialog4DImageCalculator(this, getActiveImage());
        }else if (command.equals("ConvertMultiple3Dto4D")) {

            if (getActiveImage().getNDims() == 3) {

                final Enumeration<String> names = userInterface.getRegisteredImageNames();
                final ArrayList<ModelImage> imagesToConcat = new ArrayList<ModelImage>();
                imagesToConcat.add(getActiveImage());

                // Add images from user interface that have the same exact dimensionality
                while (names.hasMoreElements()) {
                    final String name = names.nextElement();

                    if ( !getActiveImage().getImageName().equals(name)) {

                        final ModelImage img = userInterface.getRegisteredImageByName(name);

                        if (getActiveImage().getNDims() == img.getNDims()) {
                            if (getActiveImage().getExtents()[0] == img.getExtents()[0]
                                    && getActiveImage().getExtents()[1] == img.getExtents()[1]
                                    && getActiveImage().getExtents()[2] == img.getExtents()[2]) {
                                if (img.getDataType() == getActiveImage().getDataType()) {
                                    imagesToConcat.add(img);
                                }
                            }

                        }

                    }
                }
                if (imagesToConcat.size() <= 1) {
                    MipavUtil.displayError("There are no other images of like dimension to concatenate");
                    return;
                }

                new JDialogConcatMult3Dto4D(this, imagesToConcat);

            }

        } else if (command.equals("ConvertMultiple3Dto3D")) {

            if (getActiveImage().getNDims() == 3) {

                final Enumeration<String> names = userInterface.getRegisteredImageNames();
                final ArrayList<ModelImage> imagesToConcat = new ArrayList<ModelImage>();
                imagesToConcat.add(getActiveImage());

                // Add images from user interface that have the same exact dimensionality
                while (names.hasMoreElements()) {
                    final String name = names.nextElement();

                    if ( !getActiveImage().getImageName().equals(name)) {

                        final ModelImage img = userInterface.getRegisteredImageByName(name);

                        if (getActiveImage().getNDims() == img.getNDims()) {
                            if (getActiveImage().getExtents()[0] == img.getExtents()[0]
                                    && getActiveImage().getExtents()[1] == img.getExtents()[1]
                                    && getActiveImage().getExtents()[2] == img.getExtents()[2]) {
                                if (img.getDataType() == getActiveImage().getDataType()) {
                                    imagesToConcat.add(img);
                                }
                            }

                        }

                    }
                }
                if (imagesToConcat.size() <= 1) {
                    MipavUtil.displayError("There are no other images of like dimension to concatenate");
                    return;
                }

                new JDialogConcatMult3Dto3D(this, imagesToConcat);

            }

        } else if (command.equals("Convert4DtoRGB")) {
            new JDialogConvert4DtoRGB(this, getActiveImage());
        } else if (command.equals("Convert3Dto4D")) {
            new JDialogConvert3Dto4D(this, getActiveImage());
        } else if (command.equals("Crop")) {
            new JDialogCrop(this, getActiveImage());
        } else if (command.equals("Pad")) {
            new JDialogAddMargins(this, getActiveImage());
        } else if (command.equals("CropBoundaryParam")) {
            new JDialogCropBoundaryParam(this, getActiveImage());
        } else if (command.equals("CropPointParam")) {
            new JDialogCropPointParam(this, getActiveImage());
        } else if (command.equals("FFT")) {
            new JDialogFFT(this, getActiveImage());
        } else if (command.equals("TiltCorrection")) {
            new JDialogTiltCorrection(this, getActiveImage());
        } else if (command.equals("High/lowpass")) {
            new JDialogFrequencyFilter(this, getActiveImage());
        } else if (command.equals("HoughCircle")) {
            new JDialogHoughCircle(this, getActiveImage());
        } else if (command.equals("HoughEllipse")) {
            new JDialogHoughEllipse(this, getActiveImage());
        } else if (command.equals("HoughHyperbola")) {
            new JDialogHoughHyperbola(this, getActiveImage());
        } else if (command.equals("HoughLine")) {
            new JDialogHoughLine(this, getActiveImage());
        } else if (command.equals("HoughParabola")) {
            new JDialogHoughParabola(this, getActiveImage());
        } else if (command.equals("gFilter")) {
            new JDialogGaborFilter(this, getActiveImage());
        } else if (command.equals("hFilter")) {
            new JDialogHomomorphicFilter(this, getActiveImage());
        } else if (command.equals("Fill image")) {
            new JDialogMask(this, getActiveImage());
        } else if (command.equals("Mean")) {
            new JDialogMean(this, getActiveImage());
        } else if (command.equals("Median")) {
            new JDialogMedian(this, getActiveImage());
        } else if (command.equals("Mode")) {
            new JDialogMode(this, getActiveImage());
        } else if (command.equals("Midsagittal")) {
            new JDialogMidsagittal(this, getActiveImage());
        } else if (command.equals("talairachTransform")) {
            new JDialogTalairachTransform(this, getActiveImage());
        } else if (command.equals("Close")) {
            new JDialogClose(this, getActiveImage());
        } else if (command.equals("Dilate")) {
            new JDialogDilate(this, getActiveImage());
        } else if (command.equals("Erode")) {
            new JDialogErode(this, getActiveImage());
        } else if (command.equals("Skeletonize")) {
            new JDialogSkeletonize(this, getActiveImage());
        } else if(command.equals("SWI")) { 
            new JDialogSWI(this, getActiveImage());
        } else if (command.equals("Find edges")) {
            new JDialogFindEdges(this, getActiveImage());
        } else if (command.equals("Ultimate erode")) {
            new JDialogUltErode(this, getActiveImage());
        } else if (command.equals("Open")) {
            new JDialogOpen(this, getActiveImage());
        } else if (command.equals("ID objects")) {
            new JDialogIDObjects(this, getActiveImage());
        } else if (command.equals("morFilter")) {
            new JDialogMorphologicalFilter(this, getActiveImage());
        } else if (command.equals("morGradient")) {
            new JDialogMorphologicalGradient(this, getActiveImage());
        } else if (command.equals("morLaplacian")) {
            new JDialogMorphologicalLaplacian(this, getActiveImage());
        } else if (command.equals("topHat")) {
            new JDialogTopHat(this, getActiveImage());
        } else if (command.equals("bottomHat")) {
            new JDialogBottomHat(this, getActiveImage());
        } else if (command.equals("FG distance map")) {
            new JDialogDistanceMap(this, getActiveImage());
        } else if (command.equals("BG distance map")) {
            new JDialogBGDistanceMap(this, getActiveImage());
        } else if (command.equals("BG + FG distance map")) {
            new JDialogBGAndFGDistanceMap(this, getActiveImage());
        } else if (command.equals("Delete objects")) {
            new JDialogDeleteObjects(this, getActiveImage());
        } else if (command.equals("Particle analysis")) {
            new JDialogParticleAnalysisNew(this, getActiveImage());
        } else if (command.equals("Fill holes")) {
            new JDialogFillObjects(this, getActiveImage());
        } else if (command.equals("Noise")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError("Cannot add noise to Boolean image.");
            } else {
                new JDialogNoise(this, getActiveImage());
            }
        } else if (command.equals("MosaicTo3D")) {
            new JDialogMosaicToSlices(this, getActiveImage());
        } else if (command.equals("MosaicTo4D")) {
            new JDialog3DMosaicTo4DSlices(this, getActiveImage());
        } else if (command.equals("NLNR")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError("Cannot perform nonlinear noise reduction on Boolean image.");
            } else {
                new JDialogNLNoiseReduction(this, getActiveImage());
            }
        } else if (command.equals("kernelRegression")) {
            new JDialogKernelRegression(this, getActiveImage());
        } else if (command.equals("nlMeansFilter")) {
            new JDialogNonlocalMeansFilter(this, getActiveImage());
        } else if (command.equals("CircleGen")) {
            new JDialogCircleGeneration(this);
        } else if (command.equals("SphereGen")) {
            new JDialogSphereGeneration(this);
        } else if (command.equals("RandOrder")) {
            new JDialogRandomizeSliceOrder(this, getActiveImage()).callAlgorithm();
        } else if (command.equals("ReplaceValue")) {
            new JDialogReplaceValue(this, getActiveImage());
        } else if (command.equals("Haralick")) {
            new JDialogHaralickTexture(this, getActiveImage());
        } else if (command.equals("Tamura")) {
            new JDialogTamuraTexture(this, getActiveImage());
        } else if (command.equals("Hurst")) {
            new JDialogHurstIndex(this, getActiveImage());
        } else if (command.equals("SubVOI")) {
            new JDialogSubtractVOI(this, getActiveImage());
        } else if (command.equals("doFRAP")) {
            new JDialogFRAP(this, getActiveImage());
        } else if (command.equals("doFRET")) {

            if ( (getActiveImage().getNDims() == 2)
                    || ( (getActiveImage().getNDims() == 3) && (getActiveImage().getExtents()[2] == 2))) {
                new JDialogFRET(this, getActiveImage());
            } else {
                MipavUtil.displayError("Image does not have proper dimensions and extents");
            }
        } else if (command.equals("doFRETBleed")) {
            new JDialogFRETBleedThrough(this, getActiveImage());
        } else if (command.equals("doFRETEfficiency")) {
            new JDialogFRETEfficiency(this, getActiveImage());
        } else if (command.equals("Quantify")) {
            new JDialogQuantify(this, getActiveImage());
        } else if (command.equals("Patient Position")) {

            if (isMultipleImages() == true) {
                new JDialogRegPatientPos(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("diffDemons")) {

            if (isMultipleImages() == true) {
                new JDialogDemonsLite(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("BSplineReg")) {
            final String[] akNamesCompatibleTargetImages = JDialogRegistrationBSpline
                    .getNamesCompatibleTargetImages(componentImage.getActiveImage());

            if (akNamesCompatibleTargetImages.length > 0) {

                if (getActiveImage().getNDims() == 3) {
                    new JDialogRegistrationBSpline(this, getActiveImage(), akNamesCompatibleTargetImages);
                } else if (getActiveImage().getNDims() == 2) {
                    new JDialogRegistrationBSpline(this, getActiveImage(), akNamesCompatibleTargetImages);
                }
            } else {
                MipavUtil.displayError("There are no compatible images to which to register.");
            }
        } else if (command.equals("BSplineReg25D")) {

            if (getActiveImage().getNDims() == 3) {
                new JDialogRegistrationBSpline(this, getActiveImage(), null);
            }
        } else if (command.equals("OAR")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().getNDims() == 3) {
                    new JDialogRegistrationOAR3D(this, getActiveImage());

                    /*
                     * if ( this.userInterface.getActiveImageMonitor() != null ) {
                     * this.userInterface.getActiveImageMonitor().setJDialogBase(reg3D); }
                     */
                } else if (getActiveImage().getNDims() == 2) {
                    new JDialogRegistrationOAR2D(this, getActiveImage());
                }
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("COAR")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().getNDims() == 3) {
                    new JDialogConstrainedOAR3D(this, getActiveImage());

                }
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("OAR25D")) {

            if (getActiveImage().getNDims() == 3) {
                new JDialogRegistrationOAR25D(this, getActiveImage());
            } else {
                MipavUtil.displayError("Must be 3D series (2.5D)");
            }
        } else if (command.equals("OAR35D")) {

            if (getActiveImage().getNDims() == 4) {
                new JDialogRegistrationOAR35D(this, getActiveImage());
            } else {
                MipavUtil.displayError("Must be 4D time series (3.5D)");
            }
        } else if (command.equals("COSTS")) {

            if (isMultipleImages() == true) {

                if (getActiveImage().isColorImage() == false) {
                    new JDialogShowCosts(this, getActiveImage());
                } else {
                    MipavUtil.displayError("Only works for grayscale images.");
                }
            } else {
                MipavUtil.displayError("There are no other images for comparison.");
            }
        } else if (command.equals("LeastSquares")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationLeastSquares(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("RegValidation")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationValidation(this, getActiveImage());
            } else {
                MipavUtil.displayError("There is no registered image for validation.");
            }
        } else if (command.equals("TPSpline")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationTPSpline(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("Chamfer")) {

            if (isMultipleImages() == true) {
                new JDialogRegistrationChamfer(this, getActiveImage());
            } else {
                MipavUtil.displayError("There are no other images to register.");
            }
        } else if (command.equals("Manual")) {

            if (getActiveImage().getNDims() > 3) {
                MipavUtil.displayError(" Manual cannot handle images with more than 3 dimensions");
            }

            if (getActiveImage().getRegistrationFrame() == null) {

                if (getActiveImage().getNDims() == 2) {

                    // new JDialog to either load from frame or load from file
                    final JDialogLoadImageForRegistration dialog = new JDialogLoadImageForRegistration(this);
                    final ModelImage image2load = dialog.getImage();

                    if (image2load != null) {
                        AlgorithmMatchForReference algoRef = new AlgorithmMatchForReference(getActiveImage(),
                                image2load);

                        algoRef.setRunningInSeparateThread(false);
                        algoRef.run();

                        ModelImage refImage = null;
                        ModelImage adjImage = null;
                        final ModelLUT refLUT = null;
                        ModelLUT adjLUT = null;

                        if (algoRef.newReferenceCreated()) {
                            refImage = algoRef.getNewReferenceImage();

                            new ViewJFrameImage(refImage, null, new Dimension(0, 0));
                        } else {
                            refImage = getActiveImage();
                        }

                        if (algoRef.newAdjustedCreated()) {
                            adjImage = algoRef.getNewAdjustedImage();

                            new ViewJFrameImage(adjImage, null, new Dimension(0, 0));
                        } else {
                            adjImage = image2load;
                            adjLUT = dialog.getModelLUT();

                            if ( !dialog.isFromFrame()) {
                                new ViewJFrameImage(image2load, dialog.getModelLUT(), new Dimension(0, 0));
                            }
                        }

                        algoRef.finalize();
                        algoRef = null;

                        final ViewJFrameRegistrationTool registrationFrame = new ViewJFrameRegistrationTool(refImage,
                                adjImage, refLUT, adjLUT);

                        registrationFrame.componentResized(null);
                    }
                } else { // nDims == 3

                    try {
                        final ViewJFrameRegistration registrationFrame = new ViewJFrameRegistration(getActiveImage(),
                                null);

                        registrationFrame.componentResized(null);
                        // getActiveImage().registerRegistrationFrame(registrationFrame);
                    } catch (final OutOfMemoryError error) {
                        MipavUtil.displayError("Out of memory: unable to open Registration frame.");
                    }
                }
            }
        } else if (command.equals("Mosaic")) {
            new JFrameRegistrationMosaic();
        } else if (command.equals("VABRA")) {
            new JDialogVABRA(this, getActiveImage());
        }  else if (command.equals("VOILandmark")) {
            new JDialogRegVOILandmark(this, getActiveImage());
        } // else if (command.equals("REGTEST")) {
        // new RegistrationTest(getActiveImage());
        // }
        else if (command.equals("Insert slice")) {
            new JDialogInsertSlice(this, getActiveImage());
        } else if (command.equals("Insert volume")) {
           new JDialogInsertVolume(this, getActiveImage());
        } else if (command.equals("InsertMSlices")) {
            new JDialogInsertMissingSlices(this, getActiveImage());
        } else if (command.equals("Add margins")) {
            new JDialogAddMargins(this, getActiveImage());
        } else if (command.equals("Point area")) {
            new JDialogPointArea(this, getActiveImage(), true);
        } else if (command.equals("Principal components")) {
            new JDialogPrincipalComponents(this, getActiveImage());
        } else if (command.equals("Independent components")) {
            new JDialogIndependentComponents(this, getActiveImage());
        } else if (command.equals("Reorientation")) {
            new JDialogReorient(this, getActiveImage());
        } else if (command.equals("Extract slices")) {
            new JDialogExtractSlicesVolumes(this, getActiveImage());
        } else if(command.equals("Swap slices")) {
            new JDialogSwapSlicesVolumes(this, getActiveImage(), SwapMode.ThreeD);
        } else if(command.equals("Swap volumes")) {
            new JDialogSwapSlicesVolumes(this, getActiveImage(), SwapMode.FourD);
        }else if (command.equals("Remove slices")) {
            new JDialogRemoveSlices(this, getActiveImage());
        } else if (command.equals("padding")) {
            new JDialogPadImages(this, getActiveImage());
        } else if (command.equals("Remove volumes")) {
            new JDialogRemoveTSlices(this, getActiveImage());
        } else if (command.equals("Replace slice")) {
            new JDialogReplaceSlice(this, getActiveImage());
        } else if (command.equals("Maximum likelihood iterative blind deconvolution")) {
            new JDialogMaximumLikelihoodIteratedBlindDeconvolution(this, getActiveImage());
        } else if (command.equals("Reslice - isotropic voxels")) {
            new JDialogReslice(this, getActiveImage());
        } else if (command.equals("Test algorithm")) { // new JDialogRegionGrow(this, getActiveImage());
        } else if (command.equals("SCD")) {
            new JDialogSCDSegmentation(this, getActiveImage());
        } else if (command.equals("threshMinMax")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError(" Boolean image cannot be thresholded.");
            } else {

                if (getActiveImage().isColorImage()) {
                    new JDialogThresholdRGB(this, getActiveImage());
                } else {
                    new JDialogThreshold(this, getActiveImage());
                }
            }
        } else if (command.equals("COM")) {
            if (getActiveImage().isColorImage()) {
                new JDialogCenterOfMassRGB(this, getActiveImage());
            } else {
                new JDialogCenterOfMass(this, getActiveImage());
            }
        } else if (command.equals("threshStdDev")) {
            new JDialogStandardDeviationThreshold(this, getActiveImage());
        } else if (command.equals("Levelset")) {
            new JDialogLevelSet(this, getActiveImage());
        } else if (command.equals("LevelsetDiffusion")) {
            new JDialogLevelSetDiffusion(this, getActiveImage());
        } else if (command.equals("Barrel")) {
            new JDialogBarrelDistortion(this, getActiveImage());
        } else if (command.equals("CirToRec")) {
            new JDialogCircularSectorToRectangle(this, getActiveImage());
        } else if (command.equals("CircleToRec")) {
            new JDialogCircleToRectangle(this, getActiveImage());
        } else if (command.equals("ColorSaturation")) {
        	new JDialogColorSaturation(this, getActiveImage());
            // } else if (command.equals("EllipseToCircle")) {
            // new JDialogEllipseToCircle(this, getActiveImage());
        } else if (command.equals("NearlyCircleToCircle")) {
            new JDialogNearlyCircleToCircle(this, getActiveImage());
        } else if (command.equals("Transform")) {
            new JDialogScriptableTransform(this, getActiveImage());
        } else if (command.equals("TransformNL")) {
            new JDialogTransformBSpline(this, getActiveImage());
        } else if (command.equals("Transform to power of 2")) {
            new JDialogDirectResample(imageA, imageB);
        }
        /*
         * else if (command.equals("Transform with Padding")) { new JDialogTransformWithPad(this, getActiveImage()); }
         */
        // else if ( command.equals( "Vessel Segmentation" ) ) {
        // new JDialogVesselSegmentation( this, getActiveImage() );
        // }
        else if (command.equals("Watershed")) {
            final ViewVOIVector VOIs = getActiveImage().getVOIs();
            final int nVOI = VOIs.size();

            if (nVOI < 2) {
                MipavUtil.displayError(" Watershed: 2 or more VOIs required");
            } else {
                new JDialogWatershed(this, getActiveImage());
            }
        } else if (command.equals("DiffusionLevelsetITK")) {
            new JDialogFastMarching(this, getActiveImage(), 0);
            /*
             * if ( getActiveImage().getNDims() == 2 ) { new
             * ViewJFrameFastMarching2((ModelImage)getActiveImage().clone(), null); } else { new
             * ViewJFrameFastMarching3((ModelImage)getActiveImage().clone(), null); }
             */
        } else if (command.equals("GeodesicActiveContourLevelsetITK")) {
            new JDialogFastMarching(this, getActiveImage(), 1);
        } else if (command.equals("ThresholdLevelsetITK")) {
            new JDialogFastMarching(this, getActiveImage(), 2);
        } else if (command.equals("Animate")) {
            JDialogAnimate dialogAnimate;

            if (componentImage.getImageA().getNDims() > 4) {
                MipavUtil.displayError(" Animate cannot handle images with more than 4 dimensions");
            }

            if (componentImage.getImageA().getAnimateFrame() == null) {

                dialogAnimate = new JDialogAnimate(this, componentImage.getImageA(), componentImage.getLUTa(),
                        componentImage.getImageB(), componentImage.getLUTb());

                if (imageA.isColorImage()) {
                    dialogAnimate.setRGBs(componentImage.getRGBTA(), componentImage.getRGBTB());
                }
            }
        } else if (command.equals("Cine (movie)")) {
            componentImage.cine(40);
            updateImages(true);
        } else if (command.equals("NextImage")) {
            // incSlice();
        } else if (command.equals("PreviousImage")) {
            // decSlice();
        } else if (command.equals("MagImage")) {
            componentImage.getVOIManager().setActive(false);
            componentImage.setCursorMode(ViewJComponentBase.ZOOMING_IN);
        } else if (command.equals("MagCustom")) {
            componentImage.setCursorMode(ViewJComponentBase.DEFAULT);
            if (zoomDialog == null) {

                try {
                    zoomDialog = new JDialogZoom(this, componentImage, componentImage.getZoomX());
                } catch (final OutOfMemoryError error) {
                    MipavUtil.displayError("Out of memory.: unable to open LUT frame.");
                }

                zoomDialog.setVisible(true);
            }
        } else if (command.equals("UnMagImage")) {
            componentImage.getVOIManager().setActive(false);
            componentImage.setCursorMode(ViewJComponentBase.ZOOMING_OUT);
        } else if (command.equals("LinkFrame")) {

            if (isMultipleSameSizeImages(false) == true) {
                new JDialogFrameLinker(this, getActiveImage());
            } else {

                if (getActiveImage().getNDims() == 3) {
                    MipavUtil.displayError("There is no image with the same z dimension as\n"
                            + getActiveImage().getImageName() + " to operate on.");
                } else if (getActiveImage().getNDims() == 4) {
                    MipavUtil.displayError("There is no image with the same z and t dimensions as\n"
                            + getActiveImage().getImageName() + " to operate on.");
                }

                return;
            }
        } else if (command.equals("MagRegion")) {
            componentImage.getVOIManager().setActive(false);
            componentImage.setCursorMode(ViewJComponentBase.MAG_REGION);
        } else if (command.equals("WinRegion")) {
            componentImage.getVOIManager().setActive(false);
            componentImage.setCursorMode(ViewJComponentBase.WIN_REGION);
        } else if (command.equals("CheckerBoard")) {

            if ( (componentImage.checkerDialog != null) && componentImage.checkerDialog.isDisplayable()) {
                componentImage.getVOIManager().setActive(false);
                componentImage.checkerDialog.setVisible(true);

                return;
            }

            componentImage.checkerDialog = new JDialogCheckerBoard(this, componentImage);
        } else if (command.equals("ZoomOne")) {
            updateFrame(1, 1, 0, 0);
        } else if (command.equals("Tri-planar")) {

            // 3 space representation makes no sense on a 2d image!
            if (componentImage.getImageA().getNDims() == 2) {
                MipavUtil.displayError("This tool cannot be used on 2D images!");

                return;
            }

            try {
                linkTriFrame = new ViewJFrameTriImage(componentImage.getImageA(), componentImage.getLUTa(), componentImage.getRGBTA(),
                        componentImage.getImageB(), componentImage.getLUTb(), componentImage.getRGBTB(), controls, this);

                // to set the radio button correctly in the tri-planar frame
                linkTriFrame.setActiveImage(getControls().getActiveImage());
            } catch (final OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open Tri-planar frame.");
            }
        } else if (command.equals("VolTriplanar")) {

            // 3 space representation makes no sense on a 2d image!
            if (componentImage.getImageA().getNDims() == 2) {
                MipavUtil.displayError("This tool cannot be used on 2D images!");

                return;
            }

            try {
                float[] res;
                float diffRatio;
                int[] units = new int[4];

                res = imageA.getFileInfo(0).getResolutions();
                units = imageA.getFileInfo(0).getUnitsOfMeasure();
                diffRatio = Math.max(res[2] / res[0], res[2] / res[1]);

                final int unit = units[0];

                if ( ( (units[1] != unit) || (units[2] != unit)) || (diffRatio >= 20)) {
                    final int reply = JOptionPane
                            .showConfirmDialog(
                                    this,
                                    "Image resolution or units appear out of range. \nPlease, adjust the image resolution or units",
                                    "Adjust Image Resolution/Units", JOptionPane.YES_NO_OPTION,
                                    JOptionPane.INFORMATION_MESSAGE);

                    if (reply == JOptionPane.YES_OPTION) {
                        final JDialogImageInfo imageInfoDialog = getActiveImageInfoDialog();

                        if (imageInfoDialog != null) {
                            imageInfoDialog.setResolutionTag();
                            imageInfoDialog.populateTalairachTab();
                            imageInfoDialog.setVisible(true);
                            imageInfoDialog.toFront();
                        }
                    } else {
                        new JDialogVolViewResample(imageA, imageB, command);
                    }
                } else {
                    new JDialogVolViewResample(imageA, imageB, command);
                }
            } catch (final OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open Volume Triplanar frame.");
            }
        } else if (command.equals("WMVolTriplanar")) {

            // 3 space representation makes no sense on a 2d image!
            if (componentImage.getImageA().getNDims() == 2) {
                MipavUtil.displayError("This tool cannot be used on 2D images!");

                return;
            }

            try {
                float[] res;
                float diffRatio;
                int[] units = new int[4];

                res = imageA.getFileInfo(0).getResolutions();
                units = imageA.getFileInfo(0).getUnitsOfMeasure();
                diffRatio = Math.max(res[2] / res[0], res[2] / res[1]);

                final int unit = units[0];

                if ( ( (units[1] != unit) || (units[2] != unit)) || (diffRatio >= 20)) {
                    final int reply = JOptionPane
                            .showConfirmDialog(
                                    this,
                                    "Image resolution or units appear out of range. \nPlease, adjust the image resolution or units",
                                    "Adjust Image Resolution/Units", JOptionPane.YES_NO_OPTION,
                                    JOptionPane.INFORMATION_MESSAGE);

                    if (reply == JOptionPane.YES_OPTION) {
                        final JDialogImageInfo imageInfoDialog = getActiveImageInfoDialog();

                        if (imageInfoDialog != null) {
                            imageInfoDialog.setResolutionTag();
                            imageInfoDialog.populateTalairachTab();
                            imageInfoDialog.setVisible(true);
                            imageInfoDialog.toFront();
                        }
                    } else {
                        try {
                        	VolumeTriPlanarInterface triVolume = new VolumeTriPlanarInterface(imageA, imageB);
                        	if(LUTa != null || LUTb != null) {
                        		triVolume.updateImages(LUTa, LUTb, true, -1);
                        	}
                        	// new VolumeTriPlanarDialog(imageA, imageB);
                        } catch (GLException e) {
                        	e.printStackTrace();
                        	MipavUtil.displayError("Unable to start GPU renderer.\n" +
                        			               "Your GPU/driver/OS combination may not support the\n" +
                        			               "version of OpenGL the renderer requires.");
                        }
                    }
                } else {
                	try {
                		VolumeTriPlanarInterface triVolume = new VolumeTriPlanarInterface(imageA, imageB);
                    	if(LUTa != null || LUTb != null) {
                    		triVolume.updateImages(LUTa, LUTb, true, -1);
                    	}
                		// new VolumeTriPlanarDialog(imageA, imageB);
                    } catch (GLException e) {
                    	e.printStackTrace();
                    	MipavUtil.displayError("Unable to start GPU renderer.\n" +
                    			               "Your GPU/driver/OS combination may not support the\n" +
                    			               "version of OpenGL the renderer requires.");
                    }
                }
            } catch (final OutOfMemoryError error) {
                MipavUtil.displayError("Out of memory: unable to open Volume Triplanar frame.");
            }
        } else if (command.equals("MagSettings")) {
            final JDialogMagnificationControls magSettings = new JDialogMagnificationControls(this, componentImage,
                    componentImage.getZoomX(), null);

            magSettings.setVisible(true);

        } else if (command.equals("MagControls")) {

            if (zoomDialog == null) {

                try {
                    zoomDialog = new JDialogZoom(this, componentImage, componentImage.getZoomX());
                } catch (final OutOfMemoryError error) {
                    MipavUtil.displayError("Out of memory.: unable to open LUT frame.");
                }

                zoomDialog.setVisible(true);
            }
        } else if (command.equals("Surface plotter")) {

            try {
                new ViewJFramePlotterView(imageA, componentImage.getLUTa(), componentImage.getSlice());

            } catch (final NoClassDefFoundError notAvailableError) {
                Preferences.debug("ViewJFrameSurfacePlotter cannot be called; encountered "
                        + "a NoClassDefFoundError.  \nIt is likely that java3D is "
                        + "not available on this system.  The error is: \n" + notAvailableError.getLocalizedMessage());
                MipavUtil.displayError("The surface plotter requires java 3D and it cannot " + "be found.");
            } catch (final OutOfMemoryError notEnoughError) {
                Preferences.debug("ViewJFrameSurfacePlotter cannot be called as there was "
                        + "not enough memory allocated.  \n" + "The error is: \n"
                        + notEnoughError.getLocalizedMessage());
                MipavUtil.displayError("The surface plotter requires more memory " + "than is currently available;\n"
                        + "See the Memory Allocation menu");
            }

        }
        /*
         * else if (command.equals("Jogl")) { new InfiniteShadowVolumes().run(); } else if (command.equals("Gears")) {
         * new Gears(); } else if (command.equals("GearsRotate")) { new GearsRotate(); } else if
         * (command.equals("GearsDebug")) { new GearsDebug(); }
         */
        else if (command.equals("ShowSliceNum")) {
            componentImage.setShowSliceNum( ((JCheckBoxMenuItem) event.getSource()).isSelected());
            updateImages(true);
        }else if (command.equals("writeGrid")) {
            new JDialogGenerateGrid(this, componentImage);
        }

        else if (command.equals("GridOptions")) {

            if (gridOptions != null) {
                gridOptions.setVisible(true);
            } else {
                gridOptions = new JDialogGridOptions(this, componentImage);
            }
        } else if (command.equals("ShowOverlay")) {

            componentImage.setOverlay( ((JCheckBoxMenuItem) event.getSource()).isSelected());

            // save into preferences
            if (componentImage.getActiveImage().isDicomImage()) {
                Preferences.setShowDICOMOverlays( ((JCheckBoxMenuItem) event.getSource()).isSelected());
            } else {
                Preferences.setShowImageOverlays( ((JCheckBoxMenuItem) event.getSource()).isSelected());
            }

            componentImage.paintComponent(componentImage.getGraphics());
            // componentImage.repaint();
        } else if (command.equals("DICOMOverlayOptions")) {
            new JDialogOverlay(this, true, null,componentImage);
        } else if (command.equals("ImageOverlayOptions")) {
            new JDialogOverlay(this, false, null, componentImage);
        } else if (command.equals("Open LUT")) {
            loadLUT(true, false);
        } else if (command.equals("Open functions")) {
            loadLUT(false, false);
        } else if (command.equals("Open LUT from...")) {
            loadLUTandTransferFunctionFrom(true, null, null, false);
        } else if (command.equals("Open functions from...")) {
            loadLUTandTransferFunctionFrom(false, null, null, false);
        } else if (command.equals("Save LUT")) {
            saveLUT(true);
        } else if (command.equals("Save functions")) {
            saveLUT(false);
        } else if (command.equals("Save LUT as...")) {
            saveLUTAs(true, null, null);
        } else if (command.equals("Save functions as...")) {
            saveLUTAs(false, null, null);
        } else if (command.equals("ctPresetsLUT")) {
            final JDialogCTPreset ctDialogA = new JDialogCTPreset(this, imageA, componentImage.getLUTa());

            ctDialogA.setVisible(true);
        } else if (command.equals("DisplayLUT")) {

            if (getActiveImage().getType() == ModelStorageBase.BOOLEAN) {
                MipavUtil.displayError(" Cannot change the LUT of a Boolean image.");
            } else {
                if (imageA.getHistogramFrame() == null)
                {
                	ModelStorageBase lutA = imageA.isColorImage() ? componentImage.getRGBTA() : componentImage.getLUTa();
                	ModelStorageBase lutB = (imageB != null) ? imageB.isColorImage() ? componentImage.getRGBTB() : componentImage.getLUTb() : null;
                	JFrameHistogram test = new JFrameHistogram( this, imageA, imageB, lutA, lutB );
                	// if there is no VOI Contour type present, do not allow VOI histogram option
                	boolean foundContour = false;
                	for (int i = 0; i < getActiveImage().getVOIs().size(); i++)
                	{
                		if (getActiveImage().getVOIs().VOIAt(i).getCurveType() == VOI.CONTOUR)
                		{
                			foundContour = true;
                		}
                	}
                	if (foundContour)
                	{
                		test.constructDialog(true);
                	}
                	else
                	{
                		test.histogramLUT(true, true);
                	}
                }
            }
        } else if (command.equals("winLevel")) { // new win-level window when it does not exist

            if (getActiveImage() == imageA) {

                if (windowLevel[0] == null) {
                    windowLevel[0] = new JDialogWinLevel(this, imageA, componentImage.getLUTa());
                }

                windowLevel[0].setVisible(true);
                windowLevel[0].toFront();
                if (windowLevel[0].tabbedPane.getSelectedIndex() == 0) {
                    final int lev = windowLevel[0].levelSlider.getValue();
                    final int win = windowLevel[0].windowSlider.getValue();
                    // needed this line below b/c otherwise the event was not getting invoked
                    windowLevel[0].levelSlider.setValue(lev + 1);

                    windowLevel[0].levelSlider.setValue(lev);
                    windowLevel[0].windowSlider.setValue(win);
                } else if (windowLevel[0].tabbedPane.getSelectedIndex() == 1) {
                    final int min = windowLevel[0].minSlider.getValue();
                    final int max = windowLevel[0].maxSlider.getValue();

                    // needed this line below b/c otherwise the event was not getting invoked
                    windowLevel[0].minSlider.setValue(min + 1);

                    windowLevel[0].minSlider.setValue(min);
                    windowLevel[0].maxSlider.setValue(max);
                }

            } else {

                if (windowLevel[1] == null) {
                    windowLevel[1] = new JDialogWinLevel(this, imageB, componentImage.getLUTb());
                }

                windowLevel[1].setVisible(true);
                windowLevel[1].toFront();
                if (windowLevel[1].tabbedPane.getSelectedIndex() == 0) {
                    windowLevel[1].levelSlider.setValue(windowLevel[1].levelSlider.getValue());
                    windowLevel[1].windowSlider.setValue(windowLevel[1].windowSlider.getValue());
                } else if (windowLevel[1].tabbedPane.getSelectedIndex() == 1) {
                    windowLevel[1].minSlider.setValue(windowLevel[1].minSlider.getValue());
                    windowLevel[1].maxSlider.setValue(windowLevel[1].maxSlider.getValue());
                }

            }
        } else if (command.equals("invertLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().invertLUT();
            } else if (getActiveImage() == imageB) {
                System.err.println("should be inverting the lutB");
                componentImage.getLUTb().invertLUT();
            }

            if (getActiveImage().getHistogramFrame() != null) {
                getActiveImage().getHistogramFrame().redrawFrames();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }
        } else if (command.equals("GrayLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().makeGrayTransferFunctions();
                componentImage.getLUTa().makeLUT(256);
            } else if (getActiveImage() == imageB) {
                componentImage.getLUTb().makeGrayTransferFunctions();
                componentImage.getLUTb().makeLUT(256);
            }

            if (getActiveImage().getHistogramFrame() != null) {
                getActiveImage().getHistogramFrame().redrawFrames();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }
        } else if (command.equals("HotMetalLUT")) {

            if (getActiveImage() == imageA) {
                componentImage.getLUTa().makeHotMetalTransferFunctions();
                componentImage.getLUTa().makeLUT(256);
            } else if (getActiveImage() == imageB) {
                componentImage.getLUTb().makeHotMetalTransferFunctions();
                componentImage.getLUTb().makeLUT(256);
            }

            if (getActiveImage().getHistogramFrame() != null) {
                getActiveImage().getHistogramFrame().redrawFrames();
            }

            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }
        } else if (command.equals("OpenUDLUT")) {
            componentImage.openUDLUTandTransferFunct();
        } else if (command.equals("SaveUDLUT")) {
            componentImage.saveUDLUT();
        } else if (command.equals("quickLUT")) {
            componentImage.setCursorMode(ViewJComponentBase.QUICK_LUT);
            if (voiManager != null) {
                voiManager.doVOI(CustomUIBuilder.PARAM_LUT_QUICK.getActionCommand());
            }
        } else if (command.equals("resetLUTs")) {
            componentImage.resetLUTs();

            if (  getActiveImage().getHistogramFrame() != null ) {
                getActiveImage().getHistogramFrame().redrawFrames();
            }
            if (getActiveImage() == imageA) {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTa(), false);
            } else {
                getActiveImage().notifyImageDisplayListeners(componentImage.getLUTb(), false);
            }

        } else if (command.equals("Light box")) {

            if (componentImage.getImageA().getLightBoxFrame() == null) {

                // 3 space representation makes no sense on a 2d image!
                if (componentImage.getImageA().getNDims() == 2) {
                    MipavUtil.displayError("This tool cannot be used on 2D images!");

                    return;
                }

                try {
                    new ViewJFrameLightBox(this, "LightBox", imageA, componentImage.getLUTa(), imageB, componentImage
                            .getLUTb(), componentImage.getResolutionX(), componentImage.getResolutionY(),
                            new Dimension(50, 200), controls, voiManager);
                } catch (final OutOfMemoryError error) {
                    MipavUtil.displayError("Out of memory: unable to open Lightbox.");
                }

                System.gc();
            }
        } // Misc
        else if (command.equals("AboutImage")) {
            about();
        } else if (command.equals("AboutJava")) {
            userInterface.aboutJava();
        } else if (command.equals("DataProvenance")) {
            userInterface.aboutDataProvenance();
        } else if (command.equals("ImageDataProvenance")) {
            if (dpDialog == null) {
                dpDialog = new JDialogDataProvenance(this, getActiveImage().getImageName(), getActiveImage()
                        .getImageDirectory(), getActiveImage().getProvenanceHolder(), false);
            } else {
                dpDialog.setVisible();
                dpDialog.requestFocus();
            }

        } else if (command.equals("Help")) {
            //MipavUtil.showHelp(null);
            MipavUtil.showWebHelp("MIPAV_Help");
        } else if (command.equals("MemoryAdjust")) {
            userInterface.memoryAllocation();
        } else if (command.equals("About")) {
            userInterface.about();
        } else if (command.equals("License")) {
            userInterface.showLicense();
        } else if (command.equals("MemoryUsage")) {
            userInterface.memoryFrame();
        } else if (command.equals("ImageRegistryMonitor")) {
            userInterface.imageRegistryMonitoring();
        } else if (command.equals("Options")) {
            userInterface.options();
        } else if (command.equals("Shortcuts")) {
            userInterface.showShortcutEditor(false);
        } else if (command.startsWith("PlugInAlgorithm")) {
            Object thePlugIn = null;
            final String plugInName = "PlugIn" + command.substring(15);

            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            Preferences.debug("\nplugInName = " + plugInName + "\n");

            try {

                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInAlgorithm) {
                    ((PlugInAlgorithm) thePlugIn).run(this, getActiveImage());
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName
                            + " claims to be an Algorithm PlugIn, but does not implement PlugInAlgorithm.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError(" FrameImage: " + e);
                e.printStackTrace();
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (Instatiation)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (Access)");
            }
        } else if (command.startsWith("PlugInFileRead")) {

            Object thePlugIn = null;

            final String plugInName = "PlugIn" + command.substring(14);
            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFile) {

                    if ( ((PlugInFile) thePlugIn).canReadImages()) {
                        ((PlugInFile) thePlugIn).readImage();
                    } else {
                        MipavUtil.displayInfo(plugInName + " does not support the reading of images.");
                    }
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName
                            + " claims to be an File PlugIn, but does not implement PlugInFile.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.startsWith("PlugInFileWrite")) {
            Object thePlugIn = null;

            final String plugInName = "PlugIn" + command.substring(15);
            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFile) {

                    if ( ((PlugInFile) thePlugIn).canWriteImages()) {
                        ((PlugInFile) thePlugIn).writeImage(getActiveImage());
                    } else {
                        MipavUtil.displayInfo(plugInName + " does not support the writing of images.");
                    }
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName
                            + " claims to be an File PlugIn, but does not implement PlugInFile.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.startsWith("PlugInFileTransfer")) {
            Object thePlugIn = null;

            final String plugInName = "PlugIn" + command.substring(18);
            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInFileTransfer) {
                    ((PlugInFileTransfer) thePlugIn).transferFiles();
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName
                            + " claims to be an File Transfer PlugIn, but does not implement PlugInFileTransfer.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.startsWith("PlugInGeneric")) {
            Object thePlugIn = null;

            final String plugInName = "PlugIn" + command.substring(13);
            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInGeneric) {
                    ((PlugInGeneric) thePlugIn).run();
                } else {
                    MipavUtil.displayError("Plugin " + plugInName + " is not a generic plugin.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.startsWith("PluginView")) {
            Object thePlugIn = null;

            final String plugInName = "PlugIn" + command.substring(10);
            // String plugInName = ((JMenuItem) (event.getSource())).getComponent().getName();

            try {
                thePlugIn = Class.forName(plugInName).newInstance();

                if (thePlugIn instanceof PlugInView) {
                    ((PlugInView) thePlugIn).run(this, getActiveImage());
                } else {
                    MipavUtil.displayError("PlugIn " + plugInName
                            + " claims to be an View PlugIn, but does not implement PlugInView.");
                }
            } catch (final ClassNotFoundException e) {
                MipavUtil.displayError("PlugIn not found: " + plugInName);
            } catch (final InstantiationException e) {
                MipavUtil.displayError("Unable to load plugin (ins)");
            } catch (final IllegalAccessException e) {
                MipavUtil.displayError("Unable to load plugin (acc)");
            }
        } else if (command.equals("InstallPlugin")) {
            final JDialogInstallPlugin instPlugin = new JDialogInstallPlugin(this);
            instPlugin.setVisible(true);

            final int index = menuBar.getComponentIndex(menuBarMaker.getPlugInMenu());

            menuBar.remove(index);
            menuBarMaker.setPlugInMenu(userInterface.buildPlugInsMenu(this));
            menuBar.add(menuBarMaker.getPlugInMenu(), index);
            userInterface.getMainFrame().setJMenuBar(menuBar);
            userInterface.getMainFrame().pack();

        } else if (command.equals("UninstallPlugin")) {
            final JDialogUninstallPlugin uninstPlugin = new JDialogUninstallPlugin(this);
            uninstPlugin.setVisible(true);

            final int index = menuBar.getComponentIndex(menuBarMaker.getPlugInMenu());

            menuBar.remove(index);
            menuBarMaker.setPlugInMenu(userInterface.buildPlugInsMenu(this));
            menuBar.add(menuBarMaker.getPlugInMenu(), index);
            userInterface.getMainFrame().setJMenuBar(menuBar);
            userInterface.getMainFrame().pack();

        } else if (command.equals("CaptureTiff")) {
            final JDialogCaptureScreen screenCapture = new JDialogCaptureScreen(this);

            screenCapture.setVisible(true);

        } else if (command.equals("CaptureTiffs")) {
            new JDialogCaptureScreens(this);
        } else if (command.equals("CorrectSpace")) {
            new JDialogCorrectSpacing(this, getActiveImage()).callAlgorithm();
        } else if (command.equals("ToggleImageIntensities")) {
            controls.toggleSlider();
        } else if (command.equals("loadDWI")) {
            new JDialogDTIInput(JDialogDTIInput.DWI);
        } else if (command.equals("loadDTI")) {
            new JDialogDTIInput(JDialogDTIInput.DTI);
        } else if (command.equals("loadEG_FA")) {
            new JDialogDTIInput(JDialogDTIInput.EG_FA);
        } else if (command.equals("loadDTIFrame")) {
        	JPanelDTIVisualization.createFrame();
        } else if (command.equals("createListFile")) {
            new JDialogDTICreateListFile();
        }else if (command.equals("dtiPipeline")) { 
            new DTIPipeline();
        }else if (command.equals("dtiColor")) { 
            new DTIColorDisplay(true);
        }else if (command.equals("estimateTensor")) {
            new JDialogDTIEstimateTensor();
        /*} else if (command.equals("fiberTracking")) {
            JPanelDTIFiberTracking.createFrame();
        } else if (command.equals("dtiVisualization")) {
        	JPanelDTIVisualization.createFrame();*/
        } else if (command.equals("treT1")) {
            new JDialogTreT1(this, getActiveImage());
        } else if (command.equals("treT2")) {
            new JDialogTreT2(this, getActiveImage());
        } else if (command.equals("LogSlope")) {
            new JDialogLogSlopeMapping();
        } else if (command.equals("TimeFitting")) {
            new JDialogTimeFitting();
        } else if (command.equals("KMeans")) {
            new JDialogKMeans();
        } else if (command.equals("SpectralClustering")) {
            new JDialogSpectralClustering();
        } else if (command.equals("HyperGraph")) {
            new JDialogHyperGraph(this);
        } else if (command.startsWith("PlugInImageJ")) {
            ViewUserInterface.getReference().actionPerformed(event);
        }
    }

    /**
     * Closes window and disposes of frame and component.
     */
    public void close() {
        isClosing = true;
    	
    	if (Preferences.is(Preferences.PREF_CLOSE_FRAME_CHECK)) {
            final int reply = JOptionPane.showConfirmDialog(this, "Do you really want to close this frame?",
                    "Close Frame", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);

            if (reply == JOptionPane.NO_OPTION) {
                return;
            }
        }

        ScriptRecorder.getReference().addLine(new ActionCloseFrame(getActiveImage()));
        ProvenanceRecorder.getReference().addLine(new ActionCloseFrame(getActiveImage()));

        if ( (imageA != null) && (imageA.getHistogramFrame() != null)) {
            imageA.getHistogramFrame().closeFrame();
        }

        // Get all imageA frames
        final Vector<ViewImageUpdateInterface> frameListA = imageA.getImageFrameVector();

        if (frameListA != null) {

            for (int i = 0; i < frameListA.size(); i++) {

                if (frameListA.elementAt(i) instanceof ViewJFrameBase) {

                    if ( ((ViewJFrameBase) frameListA.elementAt(i)) != this && !((ViewJFrameBase)frameListA.elementAt(i)).isClosing) {
                    	((ViewJFrameBase) frameListA.elementAt(i)).setVisible(false);
                    	((ViewJFrameBase) frameListA.elementAt(i)).close();
                    	i--;
                    }
                }
            }
        }

        super.close();

        isClosing = true;
        
        try {
            this.finalize();
        } catch (final Throwable t) {
            MipavUtil.displayError("Error encountered cleaning up image frame: " + t);
        }

        System.gc();
        
        isClosing = false;
    }

    /**
     * This method is provided for the user to convert a masked area back to a painted area. It only affects those areas
     * that were masked with the intensity value that is currently active.
     * 
     * @param showProgressBar DOCUMENT ME!
     */
    public void collapseAlltoSinglePaint(final boolean showProgressBar) {

        if (componentImage != null) {

            ModelImage refImage;
            
            if (imageB != null) {
                refImage = imageB;
            } else {
                refImage = imageA;
            }
            
            
            float[] intensityMapRef;

            if (refImage.isColorImage()) {
                intensityMapRef = new float[ (imageA.getExtents()[0] * imageA.getExtents()[1]) * 4]; // make
                // intensity map
            } else {
                intensityMapRef = new float[imageA.getExtents()[0] * imageA.getExtents()[1]]; // make intensity map
            }

            // same size as image
            // dimensions
            final BitSet bitSet = componentImage.getPaintMask(); // bitSet is for entire image volume
            ViewJProgressBar progressBar = null;

            if (showProgressBar) {
                progressBar = new ViewJProgressBar("Converting", "Converting mask to paint...", 0, 100, true, this,
                        this);
                MipavUtil.centerOnScreen(progressBar);
                progressBar.setVisible(showProgressBar);
            }

            try {
                final int numSlices = ( (imageA.getNDims() > 2) ? imageA.getExtents()[2] : 1);

                // iterate through slices
                for (int currentSlice = 0; currentSlice < numSlices; currentSlice++) {

                    // here is where we get the slice
                    refImage.exportData(currentSlice * intensityMapRef.length, intensityMapRef.length, intensityMapRef);

                    // examine every pixel and convert to paint if masked intensity is equal to the toolbar's
                    // selected intensity

                    if (refImage.isColorImage()) {

                        for (int k = 0; k <= (intensityMapRef.length - 4); k = k + 4) {
                            int r, g, b;
                            r = (new Float(intensityMapRef[k + 1])).intValue();
                            g = (new Float(intensityMapRef[k + 2])).intValue();
                            b = (new Float(intensityMapRef[k + 3])).intValue();

                            if ( ! ( (r == 0) && (g == 0) && (b == 0))) {
                                bitSet.set( (currentSlice * (intensityMapRef.length / 4)) + (k / 4)); // turn the
                                // paint bit
                                // set index to ON
                                intensityMapRef[k + 1] = 0; // erase the painted mask from this index
                                intensityMapRef[k + 2] = 0; // erase the painted mask from this index
                                intensityMapRef[k + 3] = 0; // erase the painted mask from this index
                            }
                        }
                    } else {

                        for (int i = 0; i < intensityMapRef.length; i++) {

                            if (intensityMapRef[i] != 0) {
                                bitSet.set( (currentSlice * intensityMapRef.length) + i); // turn the paint bit set
                                // index to ON
                                intensityMapRef[i] = 0; // erase the painted mask from this index
                            }
                        }
                    }

                    // put the modified slice back into image
                    refImage.importData(currentSlice * intensityMapRef.length, intensityMapRef, false);

                    if (progressBar != null) {
                        progressBar.updateValueImmed((int) ((float) (currentSlice + 1) / (float) numSlices * 100));
                    }
                }

                updateImages(true);
            } catch (final Exception ex) {

                // do nothing. the error will be displayed when this if block exits
                ex.printStackTrace();
                MipavUtil.displayError("Cannot complete the operation due to an internal error.");
            } finally {

                if (progressBar != null) {
                    progressBar.dispose();
                }
            }
             
        } else {
            MipavUtil.displayError("No image is displayed, please open an image.");
        }
    }

    /**
     * Resizes frame and all components.
     * 
     * @param event event that triggered function
     */
    public synchronized void componentResized(final ComponentEvent event) {
        int width, height;
        float bigger;
        final int minFrameWidth = 123; // /minimum frame width... function of java or windows? need to check w\ linux
        // build

        boolean imageSizeSmall = false;
        // check to see if the image width is SMALLER than the minimum frame width
        if (componentImage.getActiveImage().getExtents()[0] <= minFrameWidth) {
            imageSizeSmall = true;
            // System.err.println("Image size small");
        }

        // System.err.println("Current zoom: " + componentImage.getZoomX());

        // if the window size is greater than the display window size - 20 (in either direction)
        // do nothing
        if ( (getSize().width >= (ViewJFrameImage.xScreen - 20))
                || (getSize().height >= (ViewJFrameImage.yScreen - 20))) {
            return;
        }

        // width and height calculated by size minus both insets
        width = getSize().width - (getInsets().left + getInsets().right);
        height = getSize().height - (getInsets().top + getInsets().bottom);

        width -= (scrollPane.getInsets().left + scrollPane.getInsets().right);
        height -= (scrollPane.getInsets().top + scrollPane.getInsets().bottom);

        // System.err.println("current size: " + getSize());
        // System.err.println("current insets: " + getInsets());
        // System.err.println("current scrollinsets: " + scrollPane.getInsets());
        // System.err.println("Current comp size: " + componentImage.getSize(null));
        // System.err.println("Current scrollPane size: " + scrollPane.getSize() + "\n");

        // System.err.println("calculated width, height: " + width + " , " + height);

        // determine the larger of width/height
        // in order to find the zoom based the current window size (not necessarily the current zoom)
        bigger = Math.max(width, height);
        zoom = (int) Math.min( (bigger) / ( (imageA.getExtents()[0] * widthResFactor)), (bigger)
                / ( (imageA.getExtents()[1] * heightResFactor)));

        // check to see if we are dealing with a small sized image at the minimum frame width
        if (imageSizeSmall && (zoom > componentImage.getZoomX()) && (getSize().width <= minFrameWidth)) {

            // System.err.println("Doing nothing, returning\n\n\n");
            return;
        }

        // remove the componentListener so this function will not be called twice
        removeComponentListener(this);

        // System.err.println("Calculated zoom: " + zoom);
        // System.err.println("ComponentImage size (pre-adjustment): " + componentImage.getSize(null));

        // if the zoom is larger than the current zoom, set the current zoom to the calculated zoom
        if (zoom > componentImage.getZoomX()) {
            // System.err.println("Setting componentImage to calculated zoom");
            componentImage.setZoom((int) zoom, (int) zoom); // ***************************

            updateImages(true);

            // checking componentImage size after updateImages (with new zoom)

            if ( (componentImage.getSize(null).width + 200) > ViewJFrameImage.xScreen) {
                width = ViewJFrameImage.xScreen - 200;
            } else {
                width = componentImage.getSize(null).width;
            }

            if ( (componentImage.getSize(null).height + 200) > ViewJFrameImage.yScreen) {
                height = ViewJFrameImage.yScreen - 200;
            } else {
                height = componentImage.getSize(null).height;
            }
            // System.err.println("componentImage size now: " + componentImage.getSize(null));

        } else if ( (width < componentImage.getSize(null).width) && (height >= componentImage.getSize(null).height)) {
            // System.err.println("Width is less than compImage.width, height is greater than compImage.height");

            height = componentImage.getSize(null).height + scrollPane.getHorizontalScrollBar().getHeight();
            width = componentImage.getSize(null).width + scrollPane.getVerticalScrollBar().getWidth();
        } else if ( (width >= componentImage.getSize(null).width) && (height < componentImage.getSize(null).height)) {
            width = componentImage.getSize(null).width + scrollPane.getVerticalScrollBar().getWidth();
            height = componentImage.getSize(null).height + scrollPane.getHorizontalScrollBar().getHeight();

            // System.err.println("Height is less than compImage.height, width is greater than compImage.width");

        } else if ( (width < componentImage.getSize(null).width) || (height < componentImage.getSize(null).height)) { // width
            // +=
            // fudgeFactor;

            // System.err.println("either width is less than component width or height is less than component
            // height...returning\n\n");
            addComponentListener(this);

            return;
        } else if ( (width > componentImage.getSize(null).width) || (height > componentImage.getSize(null).height)) {

            // System.err.println("Width or height is greater than compImage width/height, setting to compImage width
            // and height");

            if (width > componentImage.getSize(null).width) {
                width = componentImage.getSize(null).width;
            }

            if (height > componentImage.getSize(null).height) {
                height = componentImage.getSize(null).height;
            }
        } else {
            // System.err.println("apparently width and height are set okay (comparing to
            // compeditimage)...returning\n\n");

            addComponentListener(this);

            return;
        }

        // System.err.println("Adjusting scrollpane width, height with scrollpane insets: " + scrollPane.getInsets());

        width += scrollPane.getInsets().left + scrollPane.getInsets().right;
        height += scrollPane.getInsets().top + scrollPane.getInsets().bottom;

        // System.err.println("Old scrollpane width, height: " + scrollPane.getSize());

        if (scrollPane.getSize().width != width || scrollPane.getSize().height != height) {
            // System.err.println("New scrollpane width, height: " + width + " , " + height);
            scrollPane.setSize(width, height);
            // System.err.println("Scrollpane after setting width, height: " + scrollPane.getSize());

            // System.err.println("Frame insets are currently: " + getInsets());

            // System.err.println("setting frame size to: " + (scrollPane.getSize().width + getInsets().left +
            // getInsets().right) + " , " +
            // (scrollPane.getSize().height + getInsets().top + getInsets().bottom));
            setSize(scrollPane.getSize().width + getInsets().left + getInsets().right, scrollPane.getSize().height
                    + getInsets().top + getInsets().bottom);

            validate();
            setTitle();
            // System.err.println("New frame size: " + getSize());
            updateImages(true);
        }

        // System.err.println("Adding complistener back...done\n\n");
        
        
        componentImage.restartCheckerboardAnimateThread();
        
        addComponentListener(this);
    }

    /**
     * Decreases the slice to be displayed by one and updates title frame.
     */
    public synchronized void decSlice() {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (componentImage.getSlice() > 0) {
            componentImage.setSlice(componentImage.getSlice() - 1);
            controls.setZSlider(componentImage.getSlice());

            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(componentImage.getSlice());
                // imageA.getLightBoxFrame().updateImage(zSlice, true); //turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            voiManager.resetLivewire();

            // componentImage.deactivateAllVOI();
            setTitle();
            // need to get all other images in sync if there are other matching images and if shift was down
            if (linkedScrolling || isShiftDown) {
                doLinkedScrolling( -1);
            }

            if (linkFrame != null) {

                // linkFrame.setSlice(zSlice);
                linkFrame.decSlice();
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }

            updateImages(true);
            
            componentImage.restartCheckerboardAnimateThread();

            // registeredFramedImages = null;
        }
    }

    public void doLinkedScrolling(final int offset) {
        if ( !linkedScrolling && !isShiftDown) {
            return;
        }

        final int activeImageNumDims = getImageA().getNDims();
        int activeImageNumVolumes = 1, activeImageNumChannels = 1;

        switch (getImageA().getNDims()) { // all extents above 3D need to be checked, since these must match for
                                            // linking
            case 5:
                activeImageNumChannels = getImageA().getExtents()[4];
                activeImageNumVolumes = getImageA().getExtents()[3];
                break;
            case 4:
                activeImageNumVolumes = getImageA().getExtents()[3];

        }
        // get all registered images
        final Enumeration<ModelImage> regImages = ViewUserInterface.getReference().getRegisteredImages();
        // add only the framed ones to a new list...also..dont include the active image

        while (regImages.hasMoreElements()) {
            final ModelImage image = regImages.nextElement();
            // check if it is a framed image...and if its not the active image...also make sure its just imageA
            if ( (image.getParentFrame() != null) && ( !image.getImageName().equals(getImageA().getImageName()))
                    && ( ( (image.getParentFrame())).getImageA() == image)) {

                // now check the dimensionality to see if it matches with the active image
                final int regFramedNumDims = image.getNDims();

                if (regFramedNumDims == activeImageNumDims) { // same dimensionality required

                    int currentSlice;
                    int activeImageCurrentSlice;
                    switch (image.getNDims()) {
                        case 5:
                            if (image.getExtents()[4] != activeImageNumChannels) {
                                break;
                            }
                            if (image.getExtents()[3] != activeImageNumVolumes) {
                                break;
                            }
                            currentSlice = image.getParentFrame().getComponentImage().getSlice();
                            if (currentSlice + offset > -1 && currentSlice + offset < image.getExtents()[2]) {
                                image.setSlice(currentSlice + offset);
                            }

                            break;
                        case 4:
                            if (image.getExtents()[3] != activeImageNumVolumes) {
                                break;
                            }
                            currentSlice = image.getParentFrame().getComponentImage().getSlice();
                            if (currentSlice + offset > -1 && currentSlice + offset < image.getExtents()[2]) {
                                image.setSlice(currentSlice + offset);
                            }
                            break;
                        case 3:
                        	currentSlice = image.getParentFrame().getComponentImage().getSlice();
                            if (currentSlice + offset > -1 && currentSlice + offset < image.getExtents()[2]) {
                                image.setSlice(currentSlice + offset);
                            }    
                    }
                }
            }
        }
    }

    /**
     * Quick and simple way for ViewJFrameBase to tell the ViewJFrameImage it created to set the menu (right now only
     * for 2Dimensional) for image B.
     * 
     * @param enable whether to enable the imageB related menu items
     */

    public void enableImageB(final boolean enable) {
        menuBuilder.setMenuItemEnabled("Close image(B)", enable);
        menuBuilder.setMenuItemEnabled("Extract image(B)", enable);
    }

    /**
     * Routine to enable some menu items and disable othter menu items when the dimensionality or type of the image is
     * changed.
     * 
     */
    public void changeMenuEnables() {
        menuBarMaker.enableAllMenuItems();
        menuBarMaker.setEnabledMenuItems(imageA.getNDims(), imageA.getType());
    }

    /**
     * Cleans memory.
     * 
     * @throws Throwable the <code>Exception</code> raised by this method
     */
    public void finalize() throws Throwable {

        if (componentImage != null) {
            componentImage.dispose(false);
        }

        componentImage = null;
        imageBufferA = null;
        imageBufferB = null;
        pixBuffer = null;
        pixBufferB = null;

        scrollPane = null;

        if (zoomDialog != null) {
            zoomDialog.dispose();
            zoomDialog = null;
        }

        colorChooser = null;

        if (menuBar != null) {
            menuBar.removeAll();
        }

        menuBar = null;

        if (menuBuilder != null) {
            menuBuilder.finalize();
        }

        menuBuilder = null;

        if (menuBarMaker != null) {
            menuBarMaker.finalize();
        }

        menuBarMaker = null;

        if (controls != null) {
            controls.removeAll();
        }

        controls = null;

        if (voiManager != null) {
            voiManager.disposeLocal(true);
            voiManager = null;
        }

        super.finalize();
        // System.gc();
    }

    /**
     * Returns the reference to the currently active image.
     * 
     * @return the active image
     */
    public ModelImage getActiveImage() {

        if (componentImage != null) {
            return componentImage.getActiveImage();
        }
        return null;
    }

    /**
     * Returns the alphaBlend value for blending between imageA and imageB.
     * 
     * @return the alphaBlend value for blending between imageA and imageB
     */
    public float getAlphaBlend() {

        if (componentImage != null) {
            return componentImage.getAlphaBlend();
        }

        return 0.5f;
    }

    /**
     * Returns the reference to the component image.
     * 
     * @return component image
     */
    public ViewJComponentEditImage getComponentImage() {
        return componentImage;
    }

    /**
     * Get control widgets (toolbars, sliders) for the image frame.
     * 
     * @return the controls for this image frame
     */
    public ViewControlsImage getControls() {
        return controls;
    }

    /**
     * Return the height that the frame should have.
     * 
     * @return the frame's height
     */
    public int getFrameHeight() {
        return scrollPane.getSize().height + getInsets().top + getInsets().bottom;
    }

    /**
     * Return the preferred size for the frame.
     * 
     * @return the size the frame should be
     */
    public Dimension getFrameSize() {
        return new Dimension(getFrameWidth(), getFrameHeight());
    }

    /**
     * Return the preferred size for the frame.
     * 
     * @param size if non-null, its dimensions are changed to the size the frame should be
     * 
     * @return the size the frame should be
     */
    public Dimension getFrameSize(final Dimension size) {

        if (size == null) {
            return new Dimension(getFrameWidth(), getFrameHeight());
        } else {
            size.setSize(getFrameWidth(), getFrameHeight());

            return size;
        }
    }

    /**
     * Return the width that the frame should have.
     * 
     * @return the frame's width
     */
    public int getFrameWidth() {
        return scrollPane.getSize().width + getInsets().left + getInsets().right;
    }

    /**
     * Returns the reference to imageA.
     * 
     * @return image
     */
    public ModelImage getImageA() {

        if (componentImage != null) {
            return componentImage.getImageA();
        } else {
            return null;
        }
    }

    /**
     * Returns the reference to imageB.
     * 
     * @return imageB
     */
    public ModelImage getImageB() {

        if (componentImage != null) {
            return componentImage.getImageB();
        } else {
            return null;
        }
    }

    /**
     * 
     * @return menuBarMaker
     */
    public ViewMenuBar getViewMenuBar() {
        return menuBarMaker;
    }

    /**
     * @return menuBar
     */
    public JMenuBar getJMenuBar() {
        return menuBar;
    }

    /**
     * Returns the Vector of Registered Framed Images that are of the same number of dimensions as the active image and
     * same extents for dimesions 3, 4, and 5.
     * 
     * @return Vector
     */
    public Vector<ModelImage> getRegisteredFramedImages(final ModelImage activeImage) {
        final int activeImageNumDims = activeImage.getNDims();
        int activeImageNumSlices = 1, activeImageNumVolumes = 1, activeImageNumChannels = 1;

        switch (activeImage.getNDims()) { // all extents above 2D need to be checked
            case 5:
                activeImageNumChannels = activeImage.getExtents()[4];
                activeImageNumVolumes = activeImage.getExtents()[3];
                activeImageNumSlices = activeImage.getExtents()[2];
                break;
            case 4:
                activeImageNumVolumes = activeImage.getExtents()[3];
                activeImageNumSlices = activeImage.getExtents()[2];
                break;
            case 3:
                activeImageNumSlices = activeImage.getExtents()[2];

        }

        final Vector<ModelImage> registeredFramedImages = new Vector<ModelImage>();

        // check if there is more than 1 regsitered framed image
        if (ViewUserInterface.getReference().getRegisteredFramedImagesNum() > 1) {

            // get all registered images
            final Enumeration<ModelImage> regImages = ViewUserInterface.getReference().getRegisteredImages();
            // add only the framed ones to a new list...also..dont include the active image

            while (regImages.hasMoreElements()) {
                final ModelImage image = regImages.nextElement();

                // check if it is a framed image...and if its not the active image...also make sure its just imageA
                if ( (image.getParentFrame() != null) && ( !image.getImageName().equals(activeImage.getImageName()))
                        && ( ( (image.getParentFrame())).getImageA() == image)) {

                    // now check the dimensionality to see if it matches with the active image
                    final int regFramedNumDims = image.getNDims();

                    if (regFramedNumDims == activeImageNumDims) { // same dimensionality required

                        switch (image.getNDims()) {
                            case 5:
                                if (image.getExtents()[4] != activeImageNumChannels) {
                                    break;
                                }
                                if (image.getExtents()[3] != activeImageNumVolumes) {
                                    break;
                                }
                                if (image.getExtents()[2] != activeImageNumSlices) {
                                    break;
                                }
                                // if reached, each n dimension's extents for image and n-d active image are equal
                                registeredFramedImages.add(image);
                                break;
                            case 4:
                                if (image.getExtents()[3] != activeImageNumVolumes) {
                                    break;
                                }
                                if (image.getExtents()[2] != activeImageNumSlices) {
                                    break;
                                }
                                // if reached, each n dimension's extents for image and n-d active image are equal
                                registeredFramedImages.add(image);
                                break;
                            case 3:
                                if (image.getExtents()[2] != activeImageNumSlices) {
                                    break;
                                }
                                // if reached, each n dimension's extents for image and n-d active image are equal
                                registeredFramedImages.add(image);
                                break;
                            default:
                                Preferences.debug(image.getImageName() + " will not be linked to "
                                        + activeImage.getImageName(), Preferences.DEBUG_MINOR);
                        }
                    }
                }
            }
        }

        return registeredFramedImages;
    }

    /**
     * If active image is 4D, this returns all 3d images that have same x,y,and z dimensionality as the 4d image
     * 
     * @return Vector
     */
    public Vector<ModelImage> getRegisteredFramedImages4D3D(final ModelImage activeImage) {
        final Vector<ModelImage> registeredFramedImages = new Vector<ModelImage>();
        final int activeImageNumDims = activeImage.getNDims();
        if (activeImageNumDims != 4) {
            return registeredFramedImages;
        }
        int activeImageNumSlices = 1;

        activeImageNumSlices = activeImage.getExtents()[2];

        // check if there is more than 1 regsitered framed image
        if (ViewUserInterface.getReference().getRegisteredFramedImagesNum() > 1) {

            // get all registered images
            final Enumeration<ModelImage> regImages = ViewUserInterface.getReference().getRegisteredImages();
            // add only the framed ones to a new list...also..dont include the active image

            while (regImages.hasMoreElements()) {
                final ModelImage image = regImages.nextElement();

                // check if it is a framed image...and if its not the active image...also make sure its just imageA
                if ( (image.getParentFrame() != null) && ( !image.getImageName().equals(activeImage.getImageName()))
                        && ( ( (image.getParentFrame())).getImageA() == image)) {

                    // now check the dimensionality to see if it matches with the active image
                    final int regFramedNumDims = image.getNDims();

                    if (regFramedNumDims == 3) {
                        if (image.getExtents()[2] == activeImageNumSlices) {
                            registeredFramedImages.add(image);
                        }
                    }
                }
            }
        }

        return registeredFramedImages;
    }

    /**
     * Returns the size of the RegisteredFramedImages Vector.
     * 
     * @return size of the Vector
     */
    public int getRegisteredFramedImagesSize() {
        final int size = getRegisteredFramedImages(getImageA()).size();

        return size;
    }

    // The following 4 functions get and set the RGB tables for ARGB images A and B.
    /**
     * Gets the RGB LUT table for ARGB image A.
     * 
     * @return RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTA() {
        return (componentImage.getRGBTA());
    }

    /**
     * Gets the RGB LUT table for ARGB image B.
     * 
     * @return RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTB() {
        return (componentImage.getRGBTB());
    }

    /**
     * DOCUMENT ME!
     * 
     * @return JScrollPane
     */
    public JScrollPane getScrollPane() {
        return this.scrollPane;
    }

    /**
     * Return the preferred size for the component image scroll pane.
     * 
     * @param size if non-null, its dimensions are changed to the size the scroll pane should be
     * 
     * @return the size the scroll pane should be
     */
    public Dimension getScrollPaneSize(final Dimension size) {

        if (size == null) {
            return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
        } else {
            size.setSize(getScrollPaneWidth(), getScrollPaneHeight());

            return size;
        }
    }

    /**
     * Get the top-most slice.
     * 
     * @return returns the slice which is currently displayed
     */
    public int getViewableSlice() {
        return componentImage.getSlice();
    }

    /**
     * Gets the current Time slice which is being viewed.
     * 
     * @return int the current time slice
     */
    public int getViewableTimeSlice() {
        return componentImage.getTimeSlice();
    }

    /**
     * This method is provided for the user to convert a masked area back to a painted area. It only affects those areas
     * that were masked with the intensity value that is currently active.
     * 
     * @param showProgressBar DOCUMENT ME!
     * 
     * @return DOCUMENT ME!
     */
    public boolean handleMaskToPaint(final boolean showProgressBar) {

        boolean success = false;

        if (componentImage != null) {

            ModelImage refImage;
            
            if (imageB != null) {
                refImage = imageB;
            } else {
                refImage = imageA;
            }
                
            float[] intensityMapRef;

            if (refImage.isColorImage()) {
                intensityMapRef = new float[ (imageA.getExtents()[0] * imageA.getExtents()[1]) * 4]; // make
                // intensity map
            } else {
                intensityMapRef = new float[imageA.getExtents()[0] * imageA.getExtents()[1]]; // make intensity map
            }

            // same size as image
            // dimensions
            final BitSet bitSet = componentImage.getPaintMask(); // bitSet is for entire image volume
            ViewJProgressBar progressBar = null;

            if (showProgressBar) {
                progressBar = new ViewJProgressBar("Converting", "Converting mask to paint...", 0, 100, true, this,
                        this);
                MipavUtil.centerOnScreen(progressBar);
                progressBar.setVisible(showProgressBar);
            }

            try {
                final int numSlices = ( (imageA.getNDims() > 2) ? imageA.getExtents()[2] : 1);

                // iterate through slices
                for (int currentSlice = 0; currentSlice < numSlices; currentSlice++) {

                    // here is where we get the slice
                    refImage.exportData(currentSlice * intensityMapRef.length, intensityMapRef.length, intensityMapRef);

                    // examine every pixel and convert to paint if masked intensity is equal to the toolbar's
                    // selected intensity

                    final Color activeColor = getControls().getTools().getPaintColor();
                    final int activeRed = activeColor.getRed();
                    final int activeGreen = activeColor.getGreen();
                    final int activeBlue = activeColor.getBlue();

                    if (refImage.isColorImage()) {

                        for (int k = 0; k <= (intensityMapRef.length - 4); k = k + 4) {
                            int r, g, b;
                            r = (new Float(intensityMapRef[k + 1])).intValue();
                            g = (new Float(intensityMapRef[k + 2])).intValue();
                            b = (new Float(intensityMapRef[k + 3])).intValue();

                            if ( (r == activeRed) && (g == activeGreen) && (b == activeBlue)) {
                                bitSet.set( (currentSlice * (intensityMapRef.length / 4)) + (k / 4)); // turn the
                                // paint bit

                                // set index to ON
                                intensityMapRef[k + 1] = 0; // erase the painted mask from this index
                                intensityMapRef[k + 2] = 0; // erase the painted mask from this index
                                intensityMapRef[k + 3] = 0; // erase the painted mask from this index
                            }
                        }
                    } else {

                        for (int i = 0; i < intensityMapRef.length; i++) {

                            if (intensityMapRef[i] == componentImage.intensityDropper) {
                                bitSet.set( (currentSlice * intensityMapRef.length) + i); // turn the paint bit set
                                // index to ON
                                intensityMapRef[i] = 0; // erase the painted mask from this index
                            }
                        }
                    }

                    // put the modified slice back into image
                    refImage.importData(currentSlice * intensityMapRef.length, intensityMapRef, false);

                    if (progressBar != null) {
                        progressBar.updateValueImmed((int) ((float) (currentSlice + 1) / (float) numSlices * 100));
                    }
                }

                updateImages(true);
                success = true;
            } catch (final Exception ex) {
                // do nothing. the error will be displayed when this if block exits
                ex.printStackTrace();
                MipavUtil.displayError("Cannot complete the operation due to an internal error.");
            } finally {

                if (progressBar != null) {
                    progressBar.dispose();
                }
            }
             
        } else {
            MipavUtil.displayError("No image is open, please open an image.");
        }

        return success;
    }

    /**
     * Increases the slice to be displayed by one and updates title frame.
     */
    public synchronized void incSlice() {
        if (imageA.getNDims() <= 2) {
            return;
        }

        if (componentImage.getSlice() < (imageA.getExtents()[2] - 1)) {
            componentImage.setSlice(componentImage.getSlice() + 1);
            controls.setZSlider(componentImage.getSlice());

            // ////
            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(componentImage.getSlice()); // turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            voiManager.resetLivewire();

            // componentImage.deactivateAllVOI();
            setTitle();

            // need to get all other images in sync if there are other matching images and if shift was down

            if (linkedScrolling || isShiftDown) {
                doLinkedScrolling(1);
            }
            // ////

            if (linkFrame != null) {
                linkFrame.incSlice();
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }

            updateImages(true);
            
            componentImage.restartCheckerboardAnimateThread();

            // registeredFramedImages = null;

        }
    }

    /**
     * Initializes the variables based on the image extents. (i.e. number of slices, number of time slices, the initial
     * z-slice, etc.
     * 
     * @param img the image to set the extent variables for
     */
    public void initExtentsVariables(final ModelImage img) {
        int[] slices = null;
        int[] numImages = null;

        slices = ViewJFrameBase.initSlicePositions(img);
        numImages = ViewJFrameBase.initNumSlices(img);

        componentImage.setSlice(slices[0]);
        componentImage.setTimeSlice(slices[1]);

        nImage = numImages[0];
        nTImage = numImages[1];
    }

    /**
     * ********************************************************************* **************************** Key Events ***
     * **************************.*********************************************************************
     * 
     * @param e DOCUMENT ME!
     */
    public void keyPressed(final KeyEvent e) {
        // System.err.println("ViewJFrame keyPressed" );

        final int keyCode = e.getKeyCode();

        switch (keyCode) {

            case KeyEvent.VK_PAGE_DOWN:
                decSlice();

                return;

            case KeyEvent.VK_PAGE_UP:
                incSlice();

                return;
        }

        if ( !e.isControlDown()) {

            if ( (keyCode >= '0') && (keyCode <= '9')) {

                int index = keyCode - 49;

                if (index < 0) {
                    index = 10;
                }

                if ( !paintBrushLocked) {

                    if (quickPaintBrushIndex == index) {
                        getComponentImage().quickSwitchBrush();
                        getComponentImage().getActiveImage().notifyImageDisplayListeners(null, true);
                        paintBrushLocked = true;
                    } else {
                        quickPaintBrushIndex = index;

                        final String name = getControls().getTools().getPaintBrushName(index);

                        if (name != null) {
                            getComponentImage().loadPaintBrush(name, true);
                            getComponentImage().getActiveImage().notifyImageDisplayListeners(null, true);
                            paintBrushLocked = true;
                        }
                    }
                }

                return;
            }
        }

        // look for shortcuts now

        String command = null;
        final KeyStroke ks = KeyStroke.getKeyStrokeForEvent(e);

        command = Preferences.getShortcutCommand(ks);

        // Don't pass the VOI key-commands to the actionPerformed function, this
        // will be done by the VOIManager which will also get the KeyEvents.
        if ( (command != null) && ! ( (voiMenu != null) && ViewMenuBar.isMenuCommand(voiMenu, command))) {
            actionPerformed(new ActionEvent(ks, 0, command));
        }

    }

    /**
     * DOCUMENT ME!
     * 
     * @param e DOCUMENT ME!
     */
    public void keyReleased(final KeyEvent e) {
        // System.err.println("ViewJFrame keyReleased" );
        final int keyCode = e.getKeyCode();
        switch (keyCode) {

            case KeyEvent.VK_HOME:
                setSlice(0);

                return;

            case KeyEvent.VK_END:
                if (imageA.getNDims() > 2) { // ignore for 2d images...
                    setSlice(imageA.getExtents()[2] - 1);
                }

                return;
            case KeyEvent.VK_B:

                // swap the border painting
                if (Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)) {
                    getControls().getTools().bogusBorderPaintButton.setSelected(true);
                    if (linkTriFrame != null) {
                        linkTriFrame.bogusBorderPaintButton.setSelected(true);
                    }
                } else {
                    getControls().getTools().borderPaintButton.setSelected(true);
                    if (linkTriFrame != null) {
                        linkTriFrame.borderPaintButton.setSelected(true);
                    }
                }

                Preferences.setProperty(Preferences.PREF_SHOW_PAINT_BORDER, String.valueOf(""
                        + !Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)));
                componentImage.getActiveImage().notifyImageDisplayListeners(null, true);

                return;

        }

        if ( !e.isControlDown()) {

            if ( (keyCode >= '0') && (keyCode <= '9')) {

                if (paintBrushLocked) {
                    getComponentImage().quickSwitchBrush();
                    getComponentImage().getActiveImage().notifyImageDisplayListeners(null, true);
                    paintBrushLocked = false;
                }

            }
        }

    }

    /**
     * DOCUMENT ME!
     * 
     * @param e DOCUMENT ME!
     */
    public void keyTyped(final KeyEvent e) {}

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void mouseClicked(final MouseEvent event) {

        if (event.getButton() == MouseEvent.BUTTON3) {

            if (event.getSource() instanceof JToggleButton) {
                final JToggleButton btnSource = (JToggleButton) event.getSource();

                if (btnSource.getActionCommand().equals("MagImage")
                        || btnSource.getActionCommand().equals("UnMagImage")) {
                    handleZoomPopupMenu(btnSource, event);
                }
            } else if (event.getSource() instanceof JButton) {

                if ( ((JButton) event.getSource()).getActionCommand().equals(
                        CustomUIBuilder.PARAM_VOI_QUICK_AND_OP.getActionCommand())
                        || ((JButton) event.getSource()).getActionCommand().equals(
                                CustomUIBuilder.PARAM_VOI_QUICK_NOT_OP.getActionCommand())) {
                    ViewJFrameBase.handleMaskPopupMenu((Component) event.getSource(), event);
                } else if ( ((JButton) event.getSource()).getActionCommand().equals("CommitPaint")
                        || ((JButton) event.getSource()).getActionCommand().equals("CommitPaintExt")) {
                    handlePaintToMaskPopupMenu((Component) event.getSource(), event);
                }
            }
        }

        if (event.getButton() == MouseEvent.BUTTON1) {

            if (event.getSource() instanceof JButton) {
                final JButton buttonSource = (JButton) event.getSource();

                if (buttonSource.getActionCommand().equals("NextImage")) {

                    if (event.isShiftDown()) {

                        if (getImageA().getNDims() == 3) {
                            isShiftDown = true;
                            // setRegisteredFramedImages();
                        }
                    } else {
                        isShiftDown = false;
                        // registeredFramedImages = null;
                    }

                    incSlice();
                } else if (buttonSource.getActionCommand().equals("PreviousImage")) {

                    if (event.isShiftDown()) {

                        if (getImageA().getNDims() == 3) {
                            isShiftDown = true;
                            // setRegisteredFramedImages();
                        }
                    } else {
                        isShiftDown = false;
                        // registeredFramedImages = null;
                    }

                    decSlice();
                }
            }
        }
    }

    /**
     * DOCUMENT ME!
     * 
     * @param e DOCUMENT ME!
     */
    public void mouseDragged(final MouseEvent e) {}

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void mouseEntered(final MouseEvent event) {}

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void mouseExited(final MouseEvent event) {}

    /**
     * DOCUMENT ME!
     * 
     * @param e DOCUMENT ME!
     */
    public void mouseMoved(final MouseEvent e) {}

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void mousePressed(final MouseEvent event) {}

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void mouseReleased(final MouseEvent event) {}

    /**
     * ViewOpenFrameInterface function to create a new frame from a result image (jdialog produced)
     */
    public ViewJFrameImage openFrame(final ModelImage image) {
        return new ViewJFrameImage(image);
    }

    /**
     * Method to send an image to the printer.
     */
    public void printImage() {
        final String jobtitle = "Printing Image";

        final PrintJob prtJob = getToolkit().getPrintJob(this, jobtitle, null);

        if (prtJob != null) {
            final Graphics pGraphics = prtJob.getGraphics();

            if (pGraphics != null) {

                final float oldImageWidth = (getActiveImage().getExtents()[0] * componentImage.getZoomX());
                final float oldImageHeight = (getActiveImage().getExtents()[1] * componentImage.getZoomY());
                final float oldZoomX = componentImage.getZoomX();
                final float oldZoomY = componentImage.getZoomY();
                float newZoomX = componentImage.getZoomX();
                float newZoomY = componentImage.getZoomY();

                if ( (oldImageWidth > 600) || (oldImageHeight > 780)) {

                    while ( ( (getActiveImage().getExtents()[0] * componentImage.getZoomX()) > 600)
                            || ( (getActiveImage().getExtents()[1] * componentImage.getZoomY()) > 780)) {
                        newZoomX /= 1.1f;
                        newZoomY /= 1.1f;
                        componentImage.setZoom(newZoomX, newZoomY);

                    }
                }

                Preferences.debug("newZoomX, newZoomY = " + newZoomX + ", " + newZoomY + "\n");
                componentImage.paintComponentForPrinter(20, 20, pGraphics);
                componentImage.setZoom(oldZoomX, oldZoomY);
                pGraphics.dispose(); // flush page
            }

            prtJob.end();
        }
    }

    /**
     * Removes the menu and controls of the main frame so that a new frame can load the main frame with the proper
     * controls. Since the controls point to this particular image, when we remove the controls, turn off the highlight
     * box.
     * 
     * @see ViewJComponentEditImage#useHighlight(boolean)
     * @see ViewJComponentEditImage#repaint()
     */
    public void removeControls() {
        if (controls != null) {
            userInterface.getMainFrame().getContentPane().remove(controls);
        }

        // if the frame was just closed, componentImage will be null.
        try {
            componentImage.useHighlight(false);
            getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
        } catch (final NullPointerException npe) {
            Preferences.debug("NullPointerException in ViewJFrameImage:\n" + npe.getMessage() + "\n in removeControls().\n", Preferences.DEBUG_MINOR);
        }
    }

    /**
     * Saves the image info; need to do before saving image.
     */
    public void saveImageInfo() {
        setLUTs(componentImage.getLUTa(), componentImage.getLUTb());
        setOpacityInfo(componentImage.getOpacity(), componentImage.getAlphaBlend());
        setpaintBitmap(componentImage.getPaintBitmap());
    }

    /**
     * Sets the active image for drawing VOIs. VOIs are only drawn in the active image. In addition, algorithms are
     * executed on the active window.
     * 
     * @param active IMAGE_A or IMAGE_B
     */
    public void setActiveImage(final int active) {

        if (componentImage != null) {
            componentImage.setActiveImage(active);
        }
        if (voiManager != null) {
            voiManager.getVOIManager(0).setImageB(imageB);
            voiManager.getVOIManager(0).setActiveImage(active);
        }

        if (active == ViewJFrameBase.IMAGE_A) {
            displayMode = ViewJFrameBase.IMAGE_A;
            setTitle();
        } else {
            displayMode = ViewJFrameBase.IMAGE_B;
            setTitle();
        }

        if (linkTriFrame != null) {
            linkTriFrame.setActiveImage(active);
        }

        if (controls != null) {
            controls.setActiveImage(active);
        }

        if ( getActiveImage().getHistogramFrame() != null )
        {
        	getActiveImage().getHistogramFrame().setActiveImage(getActiveImage());
        }
        updateImages(false);
    }

    /**
     * Sets the alpha blending of parameter for two image displaying.
     * 
     * @param value amount [0,100] that is the percentage of Image A to be displayed
     */
    public void setAlphaBlend(final int value) {

        // imageA.setAlphaBlend(value);
        if (componentImage != null) {
            componentImage.setAlphaBlend(value);
        }
    }

    /**
     * DOCUMENT ME!
     * 
     * @param image2load DOCUMENT ME!
     * 
     * @return DOCUMENT ME!
     */
    public boolean setAndLoad(final ModelImage image2load) {
        return setAndLoad(image2load, doOrigins, doOrients, 0, 0, 0, 0);
    }

    /**
     * DOCUMENT ME!
     * 
     * @param image2load DOCUMENT ME!
     * @param doOrigins DOCUMENT ME!
     * @param doOrients DOCUMENT ME!
     * 
     * @return DOCUMENT ME!
     */
    public boolean setAndLoad(final ModelImage image2load, final boolean doOrigins, final boolean doOrients,
            final double defaultValue, final double defaultRed, final double defaultGreen, final double defaultBlue) {

        if (loadImage(image2load, componentImage, false, doOrigins, doOrients, defaultValue, defaultRed, defaultGreen,
                defaultBlue, false)) {

            if ( (imageA.getNDims() == 3) && (imageB.getNDims() == 4)) {
                removeControls();
                controls = new ViewControlsImage(this); // Build controls used in this frame
                menuBuilder = new ViewMenuBuilder(this);
                componentImage.setTimeSlice(0);
                nTImage = imageB.getExtents()[3];
                componentImage.setSlice( (imageB.getExtents()[2] - 1) / 2);
                nImage = imageB.getExtents()[2];
                menuBar = menuBarMaker.getMenuBar(this, 4, imageB.getType(), imageB.isDicomImage());
                voiMenu = menuBarMaker.getVOIMenu();
                controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), voiManager.getToolBar(),
                        VOIGroup, voiManager.getPointerButton(), menuBuilder.isMenuItemSelected("Paint toolbar"),
                        menuBuilder.isMenuItemSelected("Scripting toolbar"));
            }

            menuBuilder.setMenuItemEnabled("Close image(B)", true);
            menuBuilder.setMenuItemEnabled("Extract image(B)", true);

            setControls();
            setTitle();

            return true;
        }

        return false;
    }

    /**
     * Sets the menu and controls (i.e. toolbars) of the main frame! This puts the menus and controls needed to controls
     * the operations of this frame. Different image frames have different menu and controls. Notify this componentImage
     * that it needs to display highlight box, notifying user that this componentImage is the image being controlled
     * 
     * @see ViewJComponentEditImage#useHighlight(boolean)
     * @see ViewJComponentEditImage#repaint()
     */
    public void setControls() {
        if (getImageB() != null) {
            menuBuilder.setMenuItemEnabled("Close image(B)", true);
            controls.addActiveImageControl();
        } else {
            menuBuilder.setMenuItemEnabled("Close image(B)", false);
            controls.removeActiveImageControl();
        }

        userInterface.getMainFrame().setJMenuBar(menuBar);
        userInterface.getMainFrame().getContentPane().add(controls, BorderLayout.CENTER);
        userInterface.getMainFrame().pack();

        componentImage.useHighlight(true); // the controls point to this componentImage. Display the highlighter
        getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
    }

    /**
     * Controls whether or not the images/VOIs of the frame can be modified.
     * 
     * @param flag if true the image/VOIs can be modified; if false image/VOIs can NOT be modified
     */
    public void setEnabled(final boolean flag) {

        if (componentImage != null) {
            componentImage.setEnabled(flag);
        }
        if (voiManager != null) {
            voiManager.setEnabled(flag);
        }
    }

    /**
     * Sets the reference to imageB.
     * 
     * @param _imageB image to set the frame to
     */
    public void setImageB(final ModelImage _imageB) {
        final Vector<ViewImageUpdateInterface> frameList = imageA.getImageFrameVector();
        float min, max;

        if (frameList == null) {
            return;
        }

        for (int i = 0; i < frameList.size(); i++) {

            if ( (frameList.elementAt(i) instanceof ViewJFrameBase)
                    && ( ((ViewJFrameBase) frameList.elementAt(i)) != this)) {
                ((ViewJFrameBase) frameList.elementAt(i)).setImageB(_imageB);
            }
        }

        if ( (imageB != null) && ( !imageB.equals(_imageB))) {
            imageB.disposeLocal(); // Dispose of the memory of the old image
        }
        
        imageB = _imageB;

        // imageB.setImageOrder(ModelImage.IMAGE_B);
        setZoomB();

        if (componentImage != null) {
            componentImage.setImageB(imageB);
        } else {
            return;
        }

        imageB.addImageDisplayListener(this);
        ModelStorageBase LUT = null;
        if ( !imageB.isColorImage())
        {
            final int[] dimExtentsLUT = new int[2];

            dimExtentsLUT[0] = 4;
            dimExtentsLUT[1] = 256;

            LUT = new ModelLUT(ModelLUT.GRAY, 256, dimExtentsLUT);

            float imgMin = (float) imageB.getMin();
            float imgMax = (float) imageB.getMax();

            if (imageB.getType() == ModelStorageBase.UBYTE) {
                min = 0;
                max = 255;
                imgMin = 0;
                imgMax = 255;
            } else if (imageB.getType() == ModelStorageBase.BYTE) {
                min = -128;
                max = 127;
                imgMin = -128;
                imgMax = 127;
            } else {
                min = (float) imageB.getMin();
                max = (float) imageB.getMax();
            }

            ((ModelLUT)LUT).resetTransferLine(min, imgMin, max, imgMax);
            
            setLUTb((ModelLUT)LUT);
        } 
        else if (imageB.isColorImage())
        {
			final float[] x = new float[4];
			final float[] y = new float[4];
			final Dimension dim = new Dimension(256, 256);

			// Set ModelRGB min max values;
			x[0] = 0;
			y[0] = dim.height - 1;

			x[1] = 255 * 0.333f;
			y[1] = (dim.height - 1) - ( (dim.height - 1) / 3.0f);

			x[2] = 255 * 0.667f;
			y[2] = (dim.height - 1) - ( (dim.height - 1) * 0.67f);

			x[3] = 255;
			y[3] = 0;

			final int[] RGBExtents = new int[2];
			RGBExtents[0] = 4;
			RGBExtents[1] = 256;
			
			LUT = new ModelRGB(RGBExtents);
			((ModelRGB)LUT).getRedFunction().importArrays(x, y, 4);
			((ModelRGB)LUT).getGreenFunction().importArrays(x, y, 4);
			((ModelRGB)LUT).getBlueFunction().importArrays(x, y, 4);
			((ModelRGB)LUT).makeRGB( -1);
        	
			setRGBTB((ModelRGB)LUT);
        }
        if (imageA.getHistogramFrame() != null) {
        	imageA.getHistogramFrame().setImageB(imageB, LUT);
        }


        if (getLUTb() != null) {
            getLUTb().zeroToOneLUTAdjust();
        }
    }

    /**
     * Sets the LUT for image A.
     * 
     * @param LUT the LUT
     */
    public void setLUTa(final ModelLUT LUT) {
        componentImage.setLUTa(LUT);
        super.setLUTa(LUT);

        if (linkTriFrame != null) {
            linkTriFrame.setLUTa(LUT);
        }
    }

    /**
     * Sets the LUT for image B.
     * 
     * @param LUT the LUT
     */
    public void setLUTb(final ModelLUT LUT) {
        componentImage.setLUTb(LUT);
        super.setLUTb(LUT);

        if (linkTriFrame != null) {
            linkTriFrame.setLUTb(LUT);
        }
    }

    /**
     * Updates the checkbox to show whether or not the output window is currently displayed.
     * 
     * @param isShown boolean is the output window shown
     */
    public void setOutputWindowBox(final boolean isShown) {
        menuBuilder.setMenuItemSelected("ShowOutput", isShown);
    }

    /**
     * When switching the active image, copy the paintBitmap of the previous active image into the paintBitmap of the
     * new active image.
     * 
     * @param paintBitmapSwitch if true do not getMask on a setActiveImage command
     */
    public void setPaintBitmapSwitch(final boolean paintBitmapSwitch) {

        if (componentImage != null) {
            componentImage.setPaintBitmapSwitch(paintBitmapSwitch);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image A.
     * 
     * @param RGBT the new RGB LUT to be applied to the image
     */
    public void setRGBTA(final ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTA(RGBT);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image B.
     * 
     * @param RGBT the new RGB LUT to be applied to the image
     */
    public void setRGBTB(final ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTB(RGBT);
        }
    }

    /**
     * DOCUMENT ME.*
     * 
     * @param isShiftDown DOCUMENT ME!
     */
    public void setShiftDown(final boolean isShiftDown) {
        this.isShiftDown = isShiftDown;
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     * 
     * @param slice indicates image slice to be displayed
     */
    public void setSlice(final int slice) {
        setSlice(slice, true);

    }

    /**
     * DOCUMENT ME!
     * 
     * @param slice DOCUMENT ME!
     * @param updateLinkedImages DOCUMENT ME!
     */
    public void setSlice(final int slice, final boolean updateLinkedImages) {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (componentImage.getSlice() < imageA.getExtents()[2]) {
            componentImage.setSlice(slice);
            controls.setZSlider(componentImage.getSlice());
            updateImages(true);

            // when we set the slice of the other images, make SURE they do not try to update linked images (infinite
            // loop)
            if (updateLinkedImages && linkedScrolling) {
                // final Vector<ModelImage> registeredFramedImages = getRegisteredFramedImages(getImageA());

                /*
                 * if(getImageA().is4DImage()) { Vector registeredFramedImages2 =
                 * getRegisteredFramedImages4D3D(getImageA()); for (int i = 0; i < registeredFramedImages2.size(); i++) {
                 * registeredFramedImages.add((ModelImage) registeredFramedImages2.get(i)); } }
                 * 
                 * for (int i = 0; i < registeredFramedImages.size(); i++) { final ModelImage img = (ModelImage)
                 * registeredFramedImages.get(i); final ViewJFrameImage framedImg =
                 * ViewUserInterface.getReference().getFrameContainingImage(img);
                 * framedImg.setSlice(componentImage.getSlice(), false); framedImg.updateImages(); }
                 */
            }

            // livewire grad mag. should be recalculated for the new slice
            // componentImage.deactivateAllVOI();
            voiManager.resetLivewire();
            setTitle();

            if (linkFrame != null) {
                linkFrame.setSlice(slice);
            }

            if (infoDialogA != null) {
                infoDialogA.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }

            if (infoDialogB != null) {
                infoDialogB.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
            }
        }
        
        componentImage.restartCheckerboardAnimateThread();
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     * 
     * @param slice indicates image time-slice (4th dimension) to be displayed
     */
    public void setTimeSlice(final int slice) {
        setTimeSlice(slice, true);
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     * 
     * @param slice indicates image time-slice (4th dimension) to be displayed
     * @param whether linked images should change their linked image sets
     */
    public void setTimeSlice(final int slice, final boolean checkScroll) {
    	
        if (imageA.getNDims() == 4) {

            if (componentImage.getTimeSlice() < imageA.getExtents()[3]) {
                componentImage.setTimeSlice(slice);
                controls.setTSlider(slice);

                // livewire grad mag. should be recalculated for the new slice
                voiManager.resetLivewire();
                setTitle();
                if(Preferences.is(Preferences.PREF_FILE_LUT_DISPLAY) && imageA.getFileInfo(slice*imageA.getExtents()[2]).getLUT() != null) {
                	updateImages(imageA.getFileInfo(slice*imageA.getExtents()[2]).getLUT(), null, true, -1);      	
                } else if(defaultLUTa != componentImage.getLUTa()) {
                	updateImages(defaultLUTa, null, true, -1);      	
                } else {
                	updateImages(true);
                }
                	
                if (linkFrame != null) {
                    linkFrame.setTimeSlice(componentImage.getTimeSlice());
                }

                if (infoDialogA != null) {
                    infoDialogA.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
                }

                if (infoDialogB != null) {
                    infoDialogB.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
                }

                // when we set the slice of the other images, make SURE they do not try to update linked images
                // (infinite loop)
                if (checkScroll && linkedScrolling) {
                    final Vector<ModelImage> registeredFramedImages = getRegisteredFramedImages(getImageA());

                    for (int i = 0; i < registeredFramedImages.size(); i++) {
                        final ModelImage img = registeredFramedImages.get(i);
                        final ViewJFrameImage framedImg = ViewUserInterface.getReference().getFrameContainingImage(img);
                        framedImg.setTimeSlice(componentImage.getTimeSlice(), false);
                        framedImg.updateImages();
                    }
                }
            }
        } // if (imageA.getNDims() <= 3)
        else if ( (imageB != null) && (imageB.getNDims() == 4)) {

            if (componentImage.getTimeSlice() < imageB.getExtents()[3]) {
                componentImage.setTimeSlice(slice);
                controls.setTSlider(slice);

                // livewire grad mag. should be recalculated for the new slice
                voiManager.resetLivewire();
                setTitle();
                if(Preferences.is(Preferences.PREF_FILE_LUT_DISPLAY) && imageB.getFileInfo(slice*imageB.getExtents()[2]).getLUT() != null) {
                	updateImages(null, imageB.getFileInfo(slice*imageB.getExtents()[2]).getLUT(), true, -1);
                } else if(defaultLUTb != componentImage.getLUTb()) {
                	updateImages(null, defaultLUTb, true, -1);
                } else {
                	updateImages(true);
                }

                if (linkFrame != null) {
                    linkFrame.setTimeSlice(componentImage.getTimeSlice());
                }

                if (infoDialogA != null) {
                    infoDialogA.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
                }

                if (infoDialogB != null) {
                    infoDialogB.setSlice(componentImage.getSlice(), componentImage.getTimeSlice());
                }

                if (checkScroll && linkedScrolling) {
                    final Vector<ModelImage> registeredFramedImages = getRegisteredFramedImages(getImageB());

                    for (int i = 0; i < registeredFramedImages.size(); i++) {
                        final ModelImage img = registeredFramedImages.get(i);
                        final ViewJFrameImage framedImg = ViewUserInterface.getReference().getFrameContainingImage(img);
                        framedImg.setTimeSlice(componentImage.getTimeSlice(), false);
                        framedImg.updateImages();
                    }
                }
            }

        } // else if ((imageB != null) && (imageB.getNDims() == 4))
        else {
            return;
        }
    }

    /**
     * Sets the title of the frame with the image name and the slice location.
     */
    public void setTitle() {
        final String str = makeTitle();

        setTitle(str);
        
        userInterface.getMainFrame().setTitle(ViewUserInterface.getReference().getAppTitle() + "     " + str);
    }

    /**
     * updates the XOR checkbox to reflect whether XOR is currently being used for VOIs.
     * 
     * @param useXOR boolean is XOR being used for VOIs
     */
    /*
     * public void setUseVOIXOR(final boolean useXOR) { this.useXOR = useXOR; menuBuilder.setMenuItemSelected("XOR",
     * useXOR); }
     */

    /**
     * Sets the magnification of Image B. Allocates the image buffers so that it can be displayed properly.
     * 
     * @return true if setting the zoom on imageB was successful
     */
    public boolean setZoomB() {
        final int xDim = imageA.getExtents()[0];
        final int yDim = imageA.getExtents()[1];

        float[] imageTempB = null;

        try {

            if (imageB != null) {
                pixBufferB = new int[pixBuffer.length];

                int bufferFactor = 1;

                if (imageB.isColorImage()) {
                    bufferFactor = 4;
                }

                imageTempB = new float[bufferFactor * xDim * yDim];
            }
        } catch (final OutOfMemoryError error) {
            imageTempB = null;
            System.gc();
            throw (error);
        }

        imageBufferB = imageTempB;
        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        return true;
    }

    /**
     * Sets the magnification dialog to null.
     */
    public void setZoomDialogNull() {
        zoomDialog = null;
    }

    /**
     * DOCUMENT ME!
     */
    public void showEditImageInfo() {
        final JDialogImageInfo imageInfoDialog = getActiveImageInfoDialog();

        if (imageInfoDialog != null) {
            imageInfoDialog.populateTalairachTab();
            imageInfoDialog.setVisible(true);
            imageInfoDialog.toFront();
        }
    }

    /**
     * DOCUMENT ME!
     * 
     * @param event DOCUMENT ME!
     */
    public void stateChanged(final ChangeEvent event) {

        if (event.getSource() instanceof JSpinner) {
            final JSpinner intensitySpinner = (JSpinner) event.getSource();

            componentImage.intensityDropper = ((SpinnerNumberModel) intensitySpinner.getModel()).getNumber()
                    .floatValue();
        }
    }

    /**
     * DOCUMENT ME!
     */
    public void triPlanarClosing() {
        linkTriFrame = null;
    }

    /**
     * Updates the this frame's size the components sizes. If the magnified image fits into the frame that will fit into
     * the screen then frame and image are sized appropriately. If the frame, to fit the image, exceeds the screen size
     * the frame remains the same size and the image magnified and placed in the scroll pane.
     * 
     * @param sX zoom in the x dimension
     * @param sY zoom in the y dimension
     */
    public void updateFrame(final float sX, final float sY) {
        componentImage.setZoom(sX, sY);
        computeIdealWindowSize();
        validate();

        setTitle();
        updateImages(false);
    }

    /**
     * public void updateFrame(float xZoom, float yZoom, int x, int y) This method is called when the user is zooming in
     * or out.
     * 
     * @param sX float zoom in the x dimension
     * @param sY float zoom in the y dimension
     * @param x int X-pixel the user wants to zoom around
     * @param y int Y-pixel the user wants to zoom around
     */

    public void updateFrame(final float sX, final float sY, final int x, final int y) {
        updateFrame(sX, sY);
        adjustScrollbars(x, y);
    }

    /**
     * This methods calls the componentImage's REPAINT method to redraw the screen. The extents on this image have
     * changed, so the extents need to be read in again and menus, panes and slide bars adjusted accordingly.
     * 
     * @return whether the image extents update was successful
     */
    public boolean updateImageExtents() {

        // update the image buffers since their sizes may have changed
        final int[] extents = createBuffers();
        initExtentsVariables(imageA);

        componentImage.setImageExtents(extents);
        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }

        // reset the title, since dimensions may have changed
        setTitle();

        // now update the menubar
        updateMenubar();

        // update the image controls
        removeControls();
        controls = new ViewControlsImage(this);

        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), voiManager.getToolBar(), VOIGroup,
                voiManager.getPointerButton(), menuBuilder.isMenuItemSelected("Paint toolbar"), menuBuilder
                        .isMenuItemSelected("Scripting toolbar"));

        // controls.setZSlider(zSlice);
        setControls();
        setSlice(componentImage.getSlice());

        return true;

    } // end updateImageExtents()

    /**
     * This methods calls the componentImage's update method to redraw the screen - fastest of the three update methods.
     * 
     * @return boolean confirming successful update
     */
    public synchronized boolean updateImages() {

        if (componentImage == null) {
            return false;
        }

        try {
            componentImage.paintComponent(componentImage.getGraphics());
            // componentImage.repaint(); // problems with this method on some machines seems to eat lots of memory on
            // JVM 1.3
        } catch (final OutOfMemoryError error) {
            System.gc();
        }

        final ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen. Without LUT changes.
     * 
     * @param forceShow forces show to re import image and calc. java image
     * 
     * @return boolean confirming successful update
     */
    public synchronized boolean updateImages(final boolean forceShow) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(componentImage.getTimeSlice(), componentImage.getSlice(), null, null, forceShow, -1) == false) {
            return false;
        }

        final ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }
    
    /**
     * This methods calls the componentImage's update method to redraw the screen. Without LUT changes.
     * 
     * @param forceShow forces show to re import image and calc. java image
     * @param interpMode
     * 
     * @return boolean confirming successful update
     */
    public synchronized boolean updateImages(final boolean forceShow, final int interpMode) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(componentImage.getTimeSlice(), componentImage.getSlice(), null, null, forceShow, interpMode) == false) {
            return false;
        }

        final ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen.
     * 
     * @param LUTa LUT used to update imageA
     * @param LUTb LUT used to update imageB
     * @param forceShow forces show to re import image and calc. java image
     * @param interpMode image interpolation method (Nearest or Smooth)
     * 
     * @return boolean confirming successful update
     */
    public synchronized boolean updateImages(final ModelLUT LUTa, final ModelLUT LUTb, final boolean forceShow,
            final int interpMode) {

        if (componentImage == null) {
            return false;
        }

        // redraw the paintBrushCursor (quick)
        componentImage.updatePaintBrushCursor();

        if (componentImage.show(componentImage.getTimeSlice(), componentImage.getSlice(), LUTa, LUTb, forceShow,
                interpMode) == false) {
            return false;
        }

        // update the luts in this frame
        if (LUTa != null) {
            setLUTa(LUTa);
        }

        if (LUTb != null) {
            setLUTb(LUTb);
        }

        final ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This method updates the menubar; ie: after an image has been opened.
     */
    public void updateMenubar() {
        menuBuilder.updateQuickList();

        // update plugins menu, if it already exists
        final int index = menuBar.getComponentIndex(menuBarMaker.getPlugInMenu());
        if (index != -1) {
            menuBar.remove(index);
            menuBarMaker.setPlugInMenu(userInterface.buildPlugInsMenu(this));
            menuBar.add(menuBarMaker.getPlugInMenu(), index);
            userInterface.getMainFrame().setJMenuBar(menuBar);
            userInterface.getMainFrame().pack();
        }
    }

    /**
     * Update the window level sliders from the CT preset dialog.
     * 
     * @param min min value.
     * @param max max value.
     */
    public void updateWinLevel(final int min, final int max) {

        if (getActiveImage() == imageA) {

            if (windowLevel[0] != null) {
                windowLevel[0].updateSliders(min, max);
            }
        } else {

            if (windowLevel[1] == null) {
                windowLevel[1].updateSliders(min, max);
            }
        }

    }

    /**
     * tells whether to use XOR for VOI handling.
     * 
     * @return boolean use XOR?
     */
    /*
     * public boolean useXOR() { return this.useXOR; }
     */

    /**
     * Closes window and disposes of frame and component.
     * 
     * @param event Event that triggered function
     */
    public void windowClosing(final WindowEvent event) {

        if ( (event != null) && (event.getSource() instanceof ViewJProgressBar)) {
            ((ViewJProgressBar) event.getSource()).dispose();
        } else {
            close();
        }
    }

    /**
     * Create the buffers for imageA and imageB.
     * 
     * @return the extents of the buffers
     * 
     * @throws OutOfMemoryError if enough memory cannot be allocated for this method
     */
    protected int[] createBuffers() throws OutOfMemoryError {
        final int[] extents = ViewJFrameBase.initExtents(imageA);

        imageBufferA = ViewJFrameBase.initImageBuffer(extents, imageA.isColorImage(), imageA.getType());
        pixBuffer = ViewJFrameBase.initPixelBuffer(extents);

        if (imageB != null) {
            imageBufferB = ViewJFrameBase.initImageBuffer(imageB.getExtents(), imageB.isColorImage(), imageB.getType());
            pixBufferB = ViewJFrameBase.initPixelBuffer(imageB.getExtents());
        }

        return extents;

    } // end createBuffers()

    /**
     * Returns a reference to the image info dialog for the active image. Image A and image B have references to their
     * individual dialogs.
     * 
     * @return a reference to the image info dialog for the active image
     */
    protected JDialogImageInfo getActiveImageInfoDialog() {

        if (getActiveImage() == imageA) {
            infoDialogA = null;
            infoDialogA = new JDialogImageInfo(this, imageA, componentImage.getSlice(), componentImage.getTimeSlice());

            return infoDialogA;
        } else if (imageB == null) // should never happen, but just in case...
        {
            return null;
        } else // image B is active
        {

            infoDialogB = null;
            infoDialogB = new JDialogImageInfo(this, imageB, componentImage.getSlice(), componentImage.getTimeSlice());

            return infoDialogB;
        }
    }

    /**
     * Returns the image info dialog for image B.
     * 
     * @return the image info dialog for image B
     */
    protected JDialogImageInfo getImageInfoDialogB() {

        if (imageB != null) {

            if (infoDialogB == null) {
                infoDialogB = new JDialogImageInfo(this, imageB, componentImage.getSlice(), componentImage
                        .getTimeSlice());
            }

            return infoDialogB;
        } else {
            return null;
        }
    }

    /**
     * Get the height of the scroll pane holding the component image.
     * 
     * @return the height of the component image scroll pane
     */
    protected int getScrollPaneHeight() {
        return componentImage.getSize(null).height + scrollPane.getInsets().top + scrollPane.getInsets().bottom;
    }

    /**
     * Get the size of the scroll pane holding the component image.
     * 
     * @return the size of the component image scroll pane
     */
    protected Dimension getScrollPaneSize() {
        return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
    }

    /**
     * Get the width of the scroll pane holding the component image.
     * 
     * @return the width of the component image scroll pane
     */
    protected int getScrollPaneWidth() {
        return componentImage.getSize(null).width + scrollPane.getInsets().left + scrollPane.getInsets().right;
    }

    /**
     * Creates and initializes the LUT for the first image (<code>imageA</code>) if it hasn't been already.
     * 
     * @throws OutOfMemoryError if enough memory cannot be allocated for this method
     */
    protected void initLUT() throws OutOfMemoryError {

        if (LUTa == null) {
            LUTa = ViewJFrameBase.initLUT(imageA);
            defaultLUTa = LUTa;
        } else {
        	TransferFunction transfer = LUTa.getTransferFunction();
        	int size = transfer.size();
        	double localMin = 256;
        	double localMax = -1;
        	for(int i=0; i<size; i++) {
        		Vector2f point = transfer.getPoint(i);
        		if(point.X < imageA.getMin() || point.X > imageA.getMax()) {
        			transfer.removePoint(i);
        			if(point.X < imageA.getMin()) {
        				localMin = point.Y;
        			}
        			if(point.X > imageA.getMax()) {
        				localMax = point.Y;
        			}
        			i--;
        			size--;
        		}
        	}
        	
        	if(localMin < 256) {
        		transfer.insertPoint((float) imageA.getMin(), (float) localMin, 0);
        	}
        	
        	if(localMax > -1) {
        		transfer.addPoint((float) imageA.getMax(), (float) localMax);
        	}
        }
    }

    /**
     * Initializes the resolutions and units from the image.
     */
    public void initResolutions() {
        resols = ViewJFrameBase.initResolutions(imageA);
        units = ViewJFrameBase.initUnits(imageA);

        final float[] factor = ViewJFrameBase.initResFactor(resols, units);

        widthResFactor = factor[0];
        heightResFactor = factor[1];
    } // end initResolutions()

    /**
     * Initializes the zoom variables for the first image (imageA).
     */
    public void initZoom() {
        zoom = ViewJFrameBase.initZoom(imageA, widthResFactor, heightResFactor, ViewJFrameImage.xScreen,
                ViewJFrameImage.yScreen);
    } // end initZoom()

    /**
     * Constructs the title of the frame with the image name and the slice location.
     * 
     * @return the image frame title
     */
    protected String makeTitle() {
        String str;
        String imageNameArray[] = null;

        if (displayMode == ViewJFrameBase.IMAGE_A) {
            imageNameArray = imageA.getImageNameArray();

            if (imageA.getNDims() == 4) { // Setup the title for 4D image
                if (imageNameArray != null) {
                    str = imageNameArray[componentImage.getSlice() + nImage * componentImage.getTimeSlice()] + "      "
                            + String.valueOf(componentImage.getSlice()) + "/" + String.valueOf(nImage - 1) + "z      "
                            + String.valueOf(componentImage.getTimeSlice()) + "/" + String.valueOf(nTImage - 1)
                            + "t     M:" + makeString(componentImage.getZoomX(), 2);
                } else {
                    str = imageA.getImageName() + "      " + String.valueOf(componentImage.getSlice()) + "/"
                            + String.valueOf(nImage - 1) + "z      " + String.valueOf(componentImage.getTimeSlice()) + "/"
                            + String.valueOf(nTImage - 1) + "t     M:" + makeString(componentImage.getZoomX(), 2);
                }
            } else if (imageA.getNDims() == 3) { // Setup the title for 3D image
                if (imageNameArray != null) {
                    str = imageNameArray[componentImage.getSlice()] + "      " + String.valueOf(componentImage.getSlice())
                            + "/" + String.valueOf(nImage - 1) + "     M:" + makeString(componentImage.getZoomX(), 2);
                } else {
                    str = imageA.getImageName() + "      " + String.valueOf(componentImage.getSlice()) + "/"
                            + String.valueOf(nImage - 1) + "     M:" + makeString(componentImage.getZoomX(), 2);
                }
            } else {
                str = imageA.getImageName() + "     M:" + makeString(componentImage.getZoomX(), 2);
            }
        } else {
            imageNameArray = imageB.getImageNameArray();
            if (imageB.getNDims() == 4) { // Setup the title for 4D image of image B
                if (imageNameArray != null) {
                    str = imageNameArray[componentImage.getSlice() + nImage * componentImage.getTimeSlice()] + "      "
                            + String.valueOf(componentImage.getSlice()) + "/" + String.valueOf(nImage - 1) + "z      "
                            + String.valueOf(componentImage.getTimeSlice()) + "/" + String.valueOf(nTImage - 1)
                            + "t     M:" + makeString(componentImage.getZoomX(), 2);
                } else {
                    str = imageB.getImageName() + "      " + String.valueOf(componentImage.getSlice()) + "/"
                            + String.valueOf(nImage - 1) + "z      " + String.valueOf(componentImage.getTimeSlice()) + "/"
                            + String.valueOf(nTImage - 1) + "t     M:" + makeString(componentImage.getZoomX(), 2);
                }
            } else if (imageB.getNDims() == 3) { // Setup the title
                if (imageNameArray != null) {
                    str = imageNameArray[componentImage.getSlice()] + "      " + String.valueOf(componentImage.getSlice())
                            + "/" + String.valueOf(nImage - 1) + "     M:" + makeString(componentImage.getZoomX(), 2);
                } else {
                    str = imageB.getImageName() + "      " + String.valueOf(componentImage.getSlice()) + "/"
                            + String.valueOf(nImage - 1) + "     M:" + makeString(componentImage.getZoomX(), 2);
                }
            } else {
                str = imageB.getImageName() + "     M:" + makeString(componentImage.getZoomX(), 2);
            }
        }

        return str;
    }

    /**
     * Tests that the entered parameter is in range.
     * 
     * @param str the value entered by the user
     * @param minValue the minimum value this variable may be set to
     * @param maxValue the maximum value this variable may be set to
     * 
     * @return boolean result of test
     */
    protected boolean testParameter(final String str, final double minValue, final double maxValue) {

        double tmp;

        try {
            tmp = Double.valueOf(str).doubleValue();

            if ( (tmp > maxValue) || (tmp < minValue)) {
                MipavUtil.displayError("Value is out of range: " + String.valueOf(minValue) + " , "
                        + String.valueOf(maxValue));

                return false;
            } else {
                return true;
            }
        } catch (final NumberFormatException error) {
            MipavUtil.displayError("Must enter numeric value");

            return false;
        }
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     * 
     * @param imageAorB whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     * @deprecated
     */
    protected void updateHistoLUTFrame(final int imageAorB) {
        updateHistoLUTFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     * 
     * @param imageAorB whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     * @param compImg the component image with the image histogram frames to update
     * @deprecated
     */
    protected void updateHistoLUTFrame(final int imageAorB, final ViewJComponentEditImage compImg) {
//        updateImages(true);
//
//        if ( (compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_A)) {
//            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(), null, null,
//                    true);
//        } else if ( (compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_B)) {
//            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(null, null, compImg.getImageB(), compImg.getLUTb(),
//                    true);
//        } else if ( (compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_A_B)) {
//            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(),
//                    compImg.getImageB(), compImg.getLUTb(), true);
//        }
    }

    /**
     * Displays histoRGB frame for an RGB image.
     * 
     * @param imageAorB indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     * @deprecated
     */
    protected void updateHistoRGBFrame(final int imageAorB) {
        updateHistoRGBFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoRGB frame for an RGB image.
     * 
     * @param imageAorB indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     * @param compImg the component image with the image histogram frames to update
     * @deprecated
     */
    protected void updateHistoRGBFrame(final int imageAorB, final ViewJComponentEditImage compImg) {
//        updateImages(true);
//
//        if ( (compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_A)) {
//            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), null, true);
//        } else if ( (compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_B)) {
//            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(null, compImg.getImageB(), true);
//        } else if ( (compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == ViewJFrameBase.IMAGE_A_B)) {
//            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), compImg.getImageB(), true);
//        }
    }

    /**
     * DOCUMENT ME!
     * 
     * @param x int
     * @param y int
     */
    private void adjustScrollbars(final int x, final int y) {
        final int xTemp = (int) (x * (componentImage.getZoomX() * componentImage.getResolutionX()));
        final int yTemp = (int) (y * (componentImage.getZoomY() * componentImage.getResolutionY()));

        final int scrollPaneX = getFrameWidth() / 2;
        final int scrollPaneY = getFrameHeight() / 2;

        final Runnable adjustScrollbarsAWTEvent = new Runnable() {
            public void run() {
                scrollPane.getHorizontalScrollBar().setValue(xTemp - scrollPaneX);
                scrollPane.getVerticalScrollBar().setValue(yTemp - scrollPaneY);
            }
        };
        SwingUtilities.invokeLater(adjustScrollbarsAWTEvent);
    }

    /**
     * private void computeIdealWindowSize() This method will enlarge or shrink the window size in response to the
     * componentImage being zoomed. It will only resize the window to IMAGE_SCREEN_RATIO of the screen size, in this
     * case 3/5. If the image is zoomed past that size, scrollbars are added. If the user has dragged the window to a
     * size larger than 3/5 of screen size, I assume he wants it that way and the window will not be resized in that
     * case upon zoom-in.
     */
    protected void computeIdealWindowSize() {
        boolean addInsets = true;
        int newWidth = getScrollPaneSize().width;
        int newHeight = getScrollPaneSize().height;

        final float IMAGE_SCREEN_RATIO = 3.0f / 5.0f; // image will not be resized past 3/5 of screen size

        // if the image is too wide, cap the new window width
        if (componentImage.getSize().width > ( (ViewJFrameImage.xScreen) * IMAGE_SCREEN_RATIO)) {
            addInsets = false;
            newWidth = (int) (ViewJFrameImage.xScreen * IMAGE_SCREEN_RATIO);
        }

        // if the image is too tall, cap the new window height
        if (componentImage.getSize().height > ( (ViewJFrameImage.yScreen) * IMAGE_SCREEN_RATIO)) {
            addInsets = false;
            newHeight = (int) (ViewJFrameImage.yScreen * IMAGE_SCREEN_RATIO);
        }

        // if the window is already wider than IMAGE_SCREEN_RATIO, do not
        // resize the window, since the only way it could have got that big
        // is if the user manually resized it to be that large
        if ( (getSize().width > ( (ViewJFrameImage.xScreen) * IMAGE_SCREEN_RATIO))
                && (componentImage.getSize().width > getSize().width)) {
            addInsets = false;
            newWidth = getSize().width;
        }

        // if the window is already taller than IMAGE_SCREEN_RATIO, do not
        // resize the window, since the only way it could have got that big
        // is if the user manually resized it to be that large
        if ( (getSize().height > ( (ViewJFrameImage.yScreen) * IMAGE_SCREEN_RATIO))
                && (componentImage.getSize().height > getSize().height)) {
            addInsets = false;
            newHeight = getSize().height;
        }

        scrollPane.setSize(newWidth, newHeight);

        if (addInsets == true) {
            setSize(getFrameWidth(), getFrameHeight());
        } else {
            setSize(newWidth, newHeight);
        }
    }

    /**
     * Initializes the frame and variables.
     * 
     * @param LUTa LUT of the imageA (if null grayscale LUT is constructed)
     * @param loc location where image should be initially placed
     * @param logMagDisplay a boolean indicating if the log magnitude of image should be displayed.
     * 
     * @throws OutOfMemoryError if enough memory cannot be allocated for the GUI
     */
    private void init(final ModelLUT LUTa, final Dimension loc, final boolean logMagDisplay) throws OutOfMemoryError {
        addKeyListener(this);

        try {
            setIconImage(MipavUtil.getIconImage("davinci_32x32.gif"));
        } catch (final FileNotFoundException error) {
            Preferences.debug("Exception ocurred while getting <" + error.getMessage()
                    + ">.  Check that this file is available.\n");
        }

        setResizable(true);

        // initialize logMagDisplay
        this.logMagDisplay = logMagDisplay;
        this.LUTa = LUTa;

        initResolutions();
        initZoom();
        initLUT();

        final int[] extents = createBuffers();

        initComponentImage(extents);
        initExtentsVariables(imageA);

        // create and build the menus and controls
        menuBuilder = new ViewMenuBuilder(this);

        // build the menuBar based on the number of dimensions for imageA
        menuBarMaker = new ViewMenuBar(menuBuilder);
        menuBar = menuBarMaker.getMenuBar(this, imageA.getNDims(), imageA.getType(), imageA.isDicomImage());
        voiMenu = menuBarMaker.getVOIMenu();

        menuBar.addKeyListener(this);

        if (voiManager == null) {
            initVOI();
        }
        // imageA.
        controls = new ViewControlsImage(this); // Build controls used in this frame
        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), voiManager.getToolBar(), VOIGroup,
                voiManager.getPointerButton(), menuBuilder.isMenuItemSelected("Paint toolbar"), menuBuilder
                        .isMenuItemSelected("Scripting toolbar"));

        if (getActiveImage().getFileInfo(0).getFileFormat() == FileUtility.DICOM) {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", true);
            menuBuilder.setMenuItemEnabled("DICOM overlay", true);
            menuBuilder.setMenuItemEnabled("Image overlay", false);
        } else {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", false);
            menuBuilder.setMenuItemEnabled("DICOM overlay", false);
            menuBuilder.setMenuItemEnabled("Image overlay", true);
        }

        setTitle();

        // The component image will be displayed in a scrollpane.
        scrollPane = new JScrollPane(componentImage, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,
                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        getContentPane().add(scrollPane);
        scrollPane.setBackground(Color.black);

        setBackground(Color.black);

        // MUST register frame to image models
        imageA.addImageDisplayListener(this);

        if (imageB != null) {
            imageB.addImageDisplayListener(this);
        }

        windowLevel = new JDialogWinLevel[2];

        if (loc == null) {
            MipavUtil.centerOnScreen(this);
        } else {
            setLocation(loc.width, loc.height);
        }
        // build the shortcuts that will fire when CTRL/SHIFT/ALT keys are pressed with another key
        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);

        // User interface will have list of frames and sets controls
        userInterface.registerFrame(this);

        addComponentListener(this);

        pack(); // Pack before making visible.
        if (userInterface.isAppFrameVisible()) {
            setVisible(true);
        } else {
            setVisible(false);
        }

        // removing the ITK menu items until the Java binding situation is worked out
        //final JMenuItem kAutoITKMenu = menuBuilder.getMenuItem("Insight toolkit (auto ITK)");
        //m_kAutoItkLoader = new AutoItkLoader(this, (JMenu) kAutoITKMenu);

        if ((imageA != null) && (imageB != null)) {
            if (Preferences.isInterpolateDisplay()) {
        	    updateImages(true,ViewJComponentBase.INTERPOLATE_BOTH);
        	}
            else {
            	updateImages(true, ViewJComponentBase.NEAREST_BOTH);
            }
        }
        else if (imageA != null) {
        	if (Preferences.isInterpolateDisplay()) {
        	    updateImages(true,ViewJComponentBase.INTERPOLATE_A);
        	}
            else {
            	updateImages(true, ViewJComponentBase.NEAREST_BOTH);
            }	
        }
        else if (imageB != null) {
        	if (Preferences.isInterpolateDisplay()) {
        	    updateImages(true,ViewJComponentBase.INTERPOLATE_B);
        	}
            else {
            	updateImages(true, ViewJComponentBase.NEAREST_BOTH);
            }		
        }

        if (controls.getTImageSlider() != null) {
            ((ViewJSlider) controls.getTImageSlider()).resizeSlider();
        }
        if (controls.getZImageSlider() != null) {
            ((ViewJSlider) controls.getZImageSlider()).resizeSlider();
        }
    } // end init()

    /**
     * Creates and initializes the component image for the given image.
     * 
     * @param extents the image dimensionality.
     * 
     * @throws OutOfMemoryError if enough memory cannot be allocated for this method
     */
    protected void initComponentImage(final int[] extents) throws OutOfMemoryError {

        componentImage = new ViewJComponentEditImage(this, imageA, LUTa, imageBufferA, null, null, imageBufferB,
                pixBuffer, zoom, extents, logMagDisplay, FileInfoBase.UNKNOWN_ORIENT);

        componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, pixBufferB);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }
        componentImage.addKeyListener(this);

        // if this is a color image, then update the RGB info in the component
        if (imageA.isColorImage()) {

            if (getRGBTA() == null) {
                setRGBTA(ViewJFrameBase.initRGB(imageA));
            }
        } // end if image is an RGB type

    } // end initComponentImage()

    /**
     * Helper method to establish if there are other images so that a dialog can be created. Used by registration
     * methods, load frame, etc.
     * 
     * @return <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleImages() {
        final Enumeration<String> names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            final String name = names.nextElement();

            if ( !imageA.getImageName().equals(name)) {
                createDialog = true;

                if ( (imageB != null) && imageB.getImageName().equals(name)) {
                    createDialog = false;
                }
            }
        }

        return createDialog;
    }

    /**
     * Helper method to establish if there are images of the same dimensionality so that a dialog can be created. Used
     * by image calculator, concat, etc.
     * 
     * @param isForCalculator whether this call is being done before using the image calculator
     * 
     * @return <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleSameSizeImages(final boolean isForCalculator) {
        final Enumeration<String> names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;
        boolean proceed = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            final String name = names.nextElement();

            if ( !getActiveImage().getImageName().equals(name)) {

                try {
                    final ModelImage img = userInterface.getRegisteredImageByName(name);

                    if ( (getActiveImage().getNDims() == img.getNDims())
                            || (isForCalculator && ( (getActiveImage().getNDims() == 3) && (img.getNDims() == 2)))) {

                        // System.err.println("two with n-dim equal: " + img.getNDims());
                        if ( (getActiveImage().getNDims() == 3) && (img.getNDims() == 3)
                                && (getActiveImage().getExtents()[2] == img.getExtents()[2])) {

                            // System.err.println("extents 2 are equal");
                            proceed = true;
                        } else if ( (getActiveImage().getNDims() == 4)
                                && (getActiveImage().getExtents()[2] == img.getExtents()[2])
                                && (getActiveImage().getExtents()[3] == img.getExtents()[3])) {
                            proceed = true;
                        } else if (getActiveImage().getNDims() == 2) {
                            proceed = true;
                        } else if ( (getActiveImage().getNDims() == 3) && (img.getNDims() == 2)
                                && (getActiveImage().getExtents()[0] == img.getExtents()[0])
                                && (getActiveImage().getExtents()[1] == img.getExtents()[1])) {
                            proceed = true;
                        }

                        if (proceed) {

                            if (isForCalculator && !createDialog) {
                                createDialog = (getActiveImage().isColorImage() == img.isColorImage());
                            } else {
                                createDialog = true;
                            }
                        }
                    }
                } catch (final IllegalArgumentException iae) {

                    // MipavUtil.displayError("There was a problem with the supplied name.\n" );
                    Preferences.debug("Illegal Argument Exception in " + "ViewJFrameImage.isMultipleSameSizeImages(). "
                            + "Somehow the Image list sent an incorrect name to " + "the image image hashtable. "
                            + "\n", 1);
                    Preferences.debug("Bad argument.");
                }
            }
        }

        return createDialog;
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToAllSlices() {

        if (componentImage.getImageA().getNDims() > 2) {
            final BitSet bitSet = componentImage.getPaintBitmap();

            final int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int j = 0; j < componentImage.imageExtents[2]; j++) {

                if (j != componentImage.getSlice()) {

                    for (int i = 0; i < oneSlicePixels; i++) {

                        if (bitSet.get( (oneSlicePixels * componentImage.getSlice()) + i) == true) {
                            bitSet.set( (oneSlicePixels * j) + i);
                        }
                    }
                }
            }
        }
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToNextSlice() {

        if ( (componentImage.getImageA().getNDims() > 2)
                && (componentImage.getSlice() < componentImage.imageExtents[2])) {
            final BitSet bitSet = componentImage.getPaintBitmap();

            final int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int i = 0; i < oneSlicePixels; i++) {

                if (bitSet.get( (oneSlicePixels * componentImage.getSlice()) + i) == true) {
                    bitSet.set( (oneSlicePixels * (componentImage.getSlice() + 1)) + i);
                }
            }

            incSlice();
        }
    }

    /**
     * DOCUMENT ME!
     */
    private void propagatePaintToPreviousSlice() {

        if ( (componentImage.getImageA().getNDims() > 2) && (componentImage.getSlice() > 0)) {
            final BitSet bitSet = componentImage.getPaintBitmap();

            final int oneSlicePixels = componentImage.imageExtents[0] * componentImage.imageExtents[1];

            for (int i = 0; i < oneSlicePixels; i++) {

                if (bitSet.get( (oneSlicePixels * componentImage.getSlice()) + i) == true) {
                    bitSet.set( (oneSlicePixels * (componentImage.getSlice() - 1)) + i);
                }
            }

            decSlice();
        }
    }

    private boolean checkForActiveVOIs() {
        boolean foundActive = false;
        ViewVOIVector VOIs;
        int nVOI;

        VOIs = componentImage.getActiveImage().getVOIs();
        nVOI = VOIs.size();

        for (int i = 0; i < nVOI; i++) {

            if (VOIs.VOIAt(i).isActive() && VOIs.VOIAt(i).isVisible()) {

                foundActive = true;
                break;
            }
        }

        return foundActive;
    }

    private class DicomQueryListener implements ActionListener {

        private JCheckBox checkBox;

        private JDialog dialog;

        /**
         * Ask user whether the dicom receiver should be enabled on startup.
         */
        private void queryForDicomAutostart() {

            final String message = "Would you like to have the DICOM receiver begin when MIPAV starts?";
            dialog = new JDialog();
            dialog.setLayout(new BorderLayout());
            dialog.setTitle("Auto-start option");
            final JPanel messagePanel = new JPanel();
            messagePanel.add(new JLabel(message));
            dialog.add(messagePanel, BorderLayout.NORTH);
            final JPanel checkBoxPanel = new JPanel();
            checkBox = new JCheckBox("Click here to stop this message from displaying.");
            checkBoxPanel.add(checkBox);
            dialog.add(checkBoxPanel, BorderLayout.CENTER);
            final JPanel yesNoPanel = new JPanel();
            final JButton yes = new JButton("Yes");
            yes.addActionListener(this);
            final JButton no = new JButton("No");
            no.addActionListener(this);
            yesNoPanel.add(yes);
            yesNoPanel.add(no);
            dialog.add(yesNoPanel, BorderLayout.SOUTH);
            dialog.setLocationRelativeTo(null);
            dialog.pack();
            dialog.setVisible(true);

        }

        public void actionPerformed(final ActionEvent e) {
            if (e.getActionCommand().equals("Yes")) {
                Preferences.setProperty(Preferences.PREF_AUTOSTART_DICOM_RECEIVER, "true");
            } else if (e.getActionCommand().equals("No")) {
                Preferences.setProperty(Preferences.PREF_AUTOSTART_DICOM_RECEIVER, "false");
            }
            Preferences.setProperty(Preferences.PREF_ASK_DICOM_RECEIVER, Boolean.valueOf( !checkBox.isSelected())
                    .toString());

            dialog.dispose();
        }
    }

    // ~ Inner Classes
    // --------------------------------------------------------------------------------------------------

    /**
     * Pick up the selected color and call method to change the VOI color.
     */
    class OkColorListener implements ActionListener {

        /**
         * DOCUMENT ME!
         * 
         * @param e DOCUMENT ME!
         */
        public void actionPerformed(final ActionEvent e) {

            final Color color = colorChooser.getColor();
            controls.getTools().setPaintColor(color);

            if (linkTriFrame != null) {
                linkTriFrame.setPaintColor(color);
            }

            getActiveImage().notifyImageDisplayListeners(null, false);
        }
    }

    /**
     * Initialize the 3D VOI interface.
     */
    protected void initVOI() {
        voiManager = new VOIManagerInterface(this, imageA, imageB, 1, false, VOIGroup);
        voiManager.getVOIManager(0).init(this, imageA, imageB, componentImage, componentImage,
                componentImage.getOrientation());
        voiManager.getToolBar().setVisible(true);
        componentImage.setVOIManager(voiManager.getVOIManager(0));
    }

    public void enableBoth(final boolean bEnable) {
    // radioImageBoth.setEnabled(bEnable);
    }

    public Vector3f getCenterPt() {
        return new Vector3f(0, 0, componentImage.getSlice());
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#getFrame()
     */
    public JFrame getFrame() {
        return this;
    }

    public VOIManagerInterface getVOIManager() {
        return voiManager;
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#PointerActive(boolean)
     */
    public void PointerActive(final boolean bActive) {
        if (bActive) {
            componentImage.setCursorMode(ViewJComponentBase.VOI_3D);
        } else {
            componentImage.setCursorMode(ViewJComponentBase.DEFAULT);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#PropDown(int)
     */
    public Vector3f PropDown(final int iActive) {
        final Vector3f kReturn = componentImage.downSlice();
        controls.setZSlider(componentImage.getSlice());
        setTitle();
        updateImages(true);
        return kReturn;
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#PropUp(int)
     */
    public Vector3f PropUp(final int iActive) {
        final Vector3f kReturn = componentImage.upSlice();
        controls.setZSlider(componentImage.getSlice());
        setTitle();
        updateImages(true);
        return kReturn;
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#create3DVOI(boolean)
     */
    public void create3DVOI(final boolean bIntersection) {
        final ModelImage kImage = new ModelImage(ModelStorageBase.INTEGER, imageA.getExtents(), "Temp");
        kImage.copyFileTypeInfo(imageA);

        voiManager.make3DVOI(bIntersection, kImage);
        kImage.calcMinMax();
        new JDialogExtractSurfaceCubes(this, kImage, true);
    }

    @Override
    public void setActiveImage(final ModelImage kImage) {
        if (kImage == imageA) {
            setActiveImage(ViewJFrameBase.IMAGE_A);
        } else {
            setActiveImage(ViewJFrameBase.IMAGE_B);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#setCenter(WildMagic.LibFoundation.Mathematics.Vector3f)
     */
    public void setCenter(final Vector3f kCenter) {
        setSlice((int) kCenter.Z);
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.awt.Window#setCursor(java.awt.Cursor)
     */
    public void setCursor(final Cursor kCursor) {
        componentImage.setCursor(kCursor);
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#setModified()
     */
    public void setModified() {
        updateImages();
    }

    /*
     * (non-Javadoc)
     * 
     * @see gov.nih.mipav.view.renderer.WildMagic.VOI.VOIManagerInterfaceListener#updateData(boolean)
     */
    public void updateData(final boolean bCopyToCPU) {}

    @Override
    public ModelLUT getActiveLUT() {
        if (componentImage != null) {
            return componentImage.getActiveLUT();
        }
        return null;
    }

    @Override
    public ModelRGB getActiveRGB() {
        if (componentImage != null) {
            return componentImage.getActiveRGB();
        }
        return null;
    }

    @Override
    public void setPaintMask(final BitSet mask) {
        if (componentImage != null) {
            componentImage.setPaintMask(mask);
        }
    }

    @Override
    public void paintToShortMask() {
        final ModelImage maskImage = ViewUserInterface.getReference().getRegisteredImageByName(
                componentImage.commitPaintToMask());

        ScriptRecorder.getReference().addLine(
                new ActionPaintToMask(getActiveImage(), maskImage, ActionPaintToMask.MASK_SHORT));
        ProvenanceRecorder.getReference().addLine(
                new ActionPaintToMask(getActiveImage(), maskImage, ActionPaintToMask.MASK_SHORT));
    }

    @Override
    public void paintToUbyteMask() {
        final ModelImage maskImage = ViewUserInterface.getReference().getRegisteredImageByName(
                componentImage.commitPaintToUbyteMask());

        ScriptRecorder.getReference().addLine(
                new ActionPaintToMask(getActiveImage(), maskImage, ActionPaintToMask.MASK_UBYTE));
        ProvenanceRecorder.getReference().addLine(
                new ActionPaintToMask(getActiveImage(), maskImage, ActionPaintToMask.MASK_UBYTE));
    }

    @Override
    public void maskToPaint() {
        // TODO: only runs with an imageB mask, not if imageA is a mask itself.
        final boolean success = handleMaskToPaint(true);

        if (success) {
            ScriptRecorder.getReference().addLine(new ActionMaskToPaint(getActiveImage()));
            ProvenanceRecorder.getReference().addLine(new ActionMaskToPaint(getActiveImage()));
        }
    }
}
