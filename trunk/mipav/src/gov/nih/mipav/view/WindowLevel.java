package gov.nih.mipav.view;

import gov.nih.mipav.model.structures.*;
import gov.nih.mipav.view.*;
import gov.nih.mipav.view.renderer.*;
import java.awt.*;
import java.io.*;


/**
 * Class that sets the window and level for the ViewJComponentEditImage,
 * ViewJComponentTriImage and PlaneRender classes.
 *
 */
public class WindowLevel
{

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /**
     * Member variables used to adjust the winow and level (contrast and
     * bringtness) by dragging with the right-mouse button:.
     */
    private float[] m_afXWin = new float[4];

    /**
     * Member variables used to adjust the winow and level (contrast and
     * bringtness) by dragging with the right-mouse button:.
     */
    private float[] m_afYWin = new float[4];

    /** image max value */
    private float m_fMax = Float.MIN_VALUE;
    /** image min value */
    private float m_fMin = Float.MAX_VALUE;

    /** previous mouse x-position */
    private float m_fOldX;

    /** previous mouse y-position */
    private float m_fOldY;

    /** Default alpha blending value: */
    private float m_fAlpha = 0.5f;


    //~ Constructors ---------------------------------------------------------------------------------------------------

    public WindowLevel() {}

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Clean memory.
     */
    public void disposeLocal()
    {
        m_afXWin = null;
        m_afYWin = null;
    }


    /**
     * If the right mouse button is pressed and dragged. updateWinLevel
     * updates the HistoLUT window and level (contrast and brightness)
     *
     * @param  kEvent  the mouse event generated by a mouse drag
     */
    public boolean updateWinLevel( float fX, float fY, boolean bFirstDrag,
                                   ModelStorageBase kLookupTable,
                                   ModelImage kImage )
    {
        /* If this is the first time the mouse is dragged after the right
         * mouse button has been pressed, setup the member variables to change
         * the HistoLUT. This setup happens each time after the right mouse
         * button is pressed and relased: */
        if (bFirstDrag)
        {
            if ( kImage.isColorImage() )
            {
                initWinLevelRGB( fX, fY, (ModelRGB)kLookupTable, kImage );
            }
            else
            {
                initWinLevelGray( fX, fY, (ModelLUT)kLookupTable, kImage );
            }
            
            /* Keep track if the mouse position changed: */
            m_fOldX = fX;
            m_fOldY = fY;
        }
        /* Dragging has been initialized on the previous call, this changes
         * the HistoLUT: */
        else if ((kImage != null) && (kLookupTable != null) &&
                 ((m_fOldX != fX) || (m_fOldY != fY)))
        {
            /* Determine the HistoLUT window image size based on the
             * ModelImage: */
            float fMinImageWin = m_fMin;
            float fMaxImageWin = m_fMax;

            /* The new window value is based on the x coordinate position of
             * the mouse in the PlaneRender window: */
            float fWindow = 2.0f * fX * (fMaxImageWin - fMinImageWin);

            if (fWindow > (2.0f * (fMaxImageWin - fMinImageWin))) {
                fWindow = 2.0f * (fMaxImageWin - fMinImageWin);
            } else if (fWindow < 0) {
                fWindow = 0;
            }

            /* The new level value is based on the y coordinate of the mouse
             * in the PlaneRender window: */
            float fLevel = fY * (fMaxImageWin - fMinImageWin);

            if ( fLevel > fMaxImageWin) {
                fLevel = fMaxImageWin;
            } else if ( fLevel < fMinImageWin) {
                fLevel = fMinImageWin;
            }

            /* The new x positions, and y positions of the middle points on
             * the transfer line: */
            m_afXWin[2] = fLevel + (fWindow / 2.0f);
            m_afXWin[1] = fLevel - (fWindow / 2.0f);
            m_afYWin[2] = m_afYWin[3];
            m_afYWin[1] = m_afYWin[0];

            if (m_afXWin[2] > fMaxImageWin) {
                m_afYWin[2] = 255.0f * (m_afXWin[2] - fMaxImageWin) / fWindow;

                if (m_afYWin[2] > 255.0f) {
                    m_afYWin[2] = 255.0f;
                }
                m_afXWin[2] = fMaxImageWin;
            }

            if (m_afXWin[1] < fMinImageWin) {
                m_afYWin[1] = 255.0f - (255.0f * (fMinImageWin - m_afXWin[1]) / fWindow);

                if (m_afYWin[1] < 0.0f) {
                    m_afYWin[1] = 0.0f;
                }
                m_afXWin[1] = fMinImageWin;
            }
            
            if ( kImage.isColorImage() )
            {
                updateWinLevelRGB( (ModelRGB)kLookupTable, kImage, m_afXWin, m_afYWin );
            }
            else
            {
                updateWinLevelGray( (ModelLUT)kLookupTable, kImage, m_afXWin, m_afYWin );
            }

            /* Store old change in X,Y positions: */
            m_fOldX = fX;
            m_fOldY = fY;
            
            return true;
        }
        return false;
    }
    
    /** Sets alpha for the notifyWindowDisplayListeners call */
    public void setAlpha( float fAlpha )
    {
        m_fAlpha = fAlpha;
    }

    private void initWinLevelRGB(  float fX, float fY,
                                   ModelRGB kRGBT,
                                   ModelImage kImage )
    {
        m_fMin = (float)Math.min( kImage.getMinR(), kImage.getMinG() );
        m_fMin = (float)Math.min( m_fMin, kImage.getMinB() );
        m_fMax = (float)Math.max( kImage.getMaxR(), kImage.getMaxG() );
        m_fMax = (float)Math.max( m_fMax, kImage.getMaxB() );
        if ( kImage.getType() == ModelStorageBase.ARGB ) {
            m_afXWin[1] = m_fMin;
            m_afXWin[2] = m_fMax;
        }
        else {
            m_afXWin[1] = m_fMin * 255 / m_fMax;
            m_afXWin[2] = 255;
        }
        m_afXWin[0] = 0;
        m_afXWin[3] = 255;
        
        m_afYWin[0] = 255;
        m_afYWin[1] = 255;
        m_afYWin[2] = 0;
        m_afYWin[3] = 0;

        updateWinLevelRGB( kRGBT, kImage, m_afXWin, m_afYWin );
    }

    private void initWinLevelGray(  float fX, float fY,
                                    ModelLUT kLUT,
                                    ModelImage kImage )
    {
        m_fMin = (float) kImage.getMin();
        m_fMax = (float) kImage.getMax();
        
        if ( kImage.getType() == ModelStorageBase.UBYTE ) {
            m_fMin = 0;
            m_fMax = 255;
        } else if ( kImage.getType() == ModelStorageBase.BYTE ) {
            m_fMin = -128;
            m_fMax = 127;
        }

        /* Reset the transferline: */
        if ((kImage != null) && (kLUT != null))
        {
            kLUT.resetTransferLine(m_fMin, m_fMax);
            kLUT.getTransferFunction().exportArrays(m_afXWin, m_afYWin);
            
            m_afXWin[1] = m_afXWin[0];
            m_afXWin[2] = m_afXWin[3];
            m_afYWin[1] = m_afYWin[0];
            m_afYWin[2] = m_afYWin[3];
            
            updateWinLevelGray( kLUT, kImage, m_afXWin, m_afYWin);
        }
    }

    private void updateWinLevelRGB( ModelRGB kRGBT, ModelImage kImage, float[] afXWin, float[] afYWin )
    {
        if ( kRGBT.getROn() )
        {
            kRGBT.getRedFunction().importArrays( afXWin, afYWin, 4 );
        }
        if ( kRGBT.getGOn() )
        {
            kRGBT.getGreenFunction().importArrays( afXWin, afYWin, 4 );
        }
        if ( kRGBT.getBOn() )
        {
            kRGBT.getBlueFunction().importArrays( afXWin, afYWin, 4 );
        }
        kRGBT.makeRGB( -1 );
        kImage.notifyImageDisplayListeners( false, (int) (m_fAlpha * 100), kRGBT );
        if (kImage.getHistoRGBFrame() != null) {
            kImage.getHistoRGBFrame().update();
        }
        
    }
    private void updateWinLevelGray( ModelLUT kLUT, ModelImage kImage, float[] afXWin, float[] afYWin )
    {
        /* Update the HistoLUT and the renderers: */
        kLUT.getTransferFunction().importArrays( afXWin, afYWin, 4 );
        kImage.notifyImageDisplayListeners( kLUT, false );
    }
}
