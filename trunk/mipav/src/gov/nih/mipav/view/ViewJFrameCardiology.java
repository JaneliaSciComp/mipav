package gov.nih.mipav.view;

import WildMagic.LibFoundation.Mathematics.Vector3f;

import gov.nih.mipav.model.algorithms.*;
import gov.nih.mipav.model.algorithms.utilities.*;
import gov.nih.mipav.model.file.*;
import gov.nih.mipav.model.scripting.*;
import gov.nih.mipav.model.scripting.actions.*;
import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.dialogs.*;

import java.awt.*;
import java.awt.event.*;

import java.io.*;

import java.util.*;

import javax.swing.*;


/**
 * Makes a frame and put a single image component into it.
 *
 * @version  1.0 Sept 28, 1998
 * @author   Matthew J. McAuliffe, Ph.D.
 * @see      ViewJComponentEditImage
 */
public class ViewJFrameCardiology extends ViewJFrameBase implements KeyListener {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** Use serialVersionUID for interoperability. */
    private static final long serialVersionUID = -5959179080746432639L;

    /** Width of the display screen. */
    protected static final int xScreen = Toolkit.getDefaultToolkit().getScreenSize().width;

    /** Height of the display screen. */
    protected static final int yScreen = Toolkit.getDefaultToolkit().getScreenSize().height;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** Object where DICOM image, ... is converted and displayed as a Java image */
    protected ViewJComponentCardiology componentImage;


    /** Reference to the toolbars located in the controls object. */
    protected ViewControlsImage controls;

    /**
     * Frame adjustment to keep the frame from being just small enough for the ScrollPane to display the scroll bars.
     * Windows seems to find an inset value needing a fudge factor of 3, but Mac OS 10 (X), doesn't, and needs a fudge
     * factor of 7 to not require scroll bars. Either way, insets + fudge-factor must equal 7.
     */
    protected int fudgeFactor = 0; // assume Windos.

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float heightResFactor;

    /** Buffer used to store image intensities the presently viewed slice of image A. */
    protected float[] imageBufferA;

    /**
     * Flag indicating whether or not that the image should be displayed in Log scale. Used primarily for displaying the
     * FFT of an image.
     */
    protected boolean logMagDisplay;

    /** Reference to the frame's menu bar. */
    protected JMenuBar menuBar;

    /** Constructs the image menu bar. */
    protected ViewMenuBar menuBarMaker;

    /** This object contains a number of useful functions for building a menu and querying the state of menu items. */
    protected ViewMenuBuilder menuBuilder;

    /** Number of slices in a 3D dataset. */
    protected int nImage;

    /** Number of time sequences in a 4D dataset. */
    protected int nTImage;

    /**
     * Integer buffer (4 bytes that stores the concatenated Alpha (1 byte), Red (1 byte), Green ( 1 byte ), Blue (1 byte
     * ) data. The ARGB values are generated by using the imageA intensities as a index into a LUT.
     */
    protected int[] pixBuffer;

    /** Storage of the image voxel resolutions. One resolution value per dimension. */
    protected float[] resols;

    /** The scrollPane where the image is displayed. */
    protected JScrollPane scrollPane;

    /** Image time sequence number of image that is displayed. Zero indexed based. */
    protected int tSlice;

    /** Storage of the resolution units of measure. For example, mm, cm, inches ... */
    protected int[] units;

    /** Storage for correction parameters where datasets have non isotropic values. */
    protected float widthResFactor;

    /** Reference to the two window and level dialogs where [0] is for imageA, [1] for imageB. */
    protected JDialogWinLevel[] windowLevel;

    /** Defaults magnification of image to 1. */
    protected float zoom = 1;

    /** Image slice number of image that is displayed. Zero indexed based. */
    protected int zSlice;

    /** Reference to the color chooser. */
    private ViewJColorChooser colorChooser;

    /** When loading an image into B slot, should origins be matched? */
    private boolean doOrigins = false;

    /** reference to the JDialogImageInfo for updating slice/resolutions. */
    private JDialogImageInfo infoDialog = null;

    /** DOCUMENT ME! */
    private int lastVOI_UID = -1;

    /** tells whether or not to XOR when creating binary masks (allowing holes). */
    private boolean useXOR = false;

    /** Reference to the magnification tool. */
    private JDialogZoom zoomDialog = null;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Makes a frame and puts an image component into it.
     *
     * @param  _imageA  First image to display
     * @param  LUTa     LUT of the imageA (if null grayscale LUT is constructed)
     * @param  loc      location where image should be initially placed
     */
    public ViewJFrameCardiology(ModelImage _imageA, ModelLUT LUTa, Dimension loc) {

        this(_imageA, LUTa, loc, _imageA.getLogMagDisplay());
    }

    /**
     * Makes a frame and puts an image component into it.
     *
     * @param  _imageA        First image to display
     * @param  LUTa           LUT of the imageA (if null grayscale LUT is constructed)
     * @param  loc            location where image should be initially placed
     * @param  logMagDisplay  Display log magnitude of image
     */
    public ViewJFrameCardiology(ModelImage _imageA, ModelLUT LUTa, Dimension loc, boolean logMagDisplay) {

        super(_imageA, null);

        // if we don't have an image, then we're done
        if (imageA == null) {
            return;
        }

        // initialize based on logMagDisplay
        init(LUTa, loc, logMagDisplay);
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Makes an aboutDialog box and displays information of the image plane presently being displayed.
     */
    public void about() {
        super.about(zSlice, tSlice);
    }

    // ************************************************************************
    // **************************** Action Events *****************************
    // ************************************************************************

    /**
     * calls various methods depending on the action.
     *
     * @param  event  event that triggered function
     */
    public void actionPerformed(ActionEvent event) {
        Object source = event.getSource();
        String command = event.getActionCommand();

        if (command.equals("MagImage")) {
            float zoom = 2.0f * componentImage.getZoomX();

            updateFrame(zoom, zoom);
        } else if (command.equals("UnMagImage")) {
            float zoom = 0.5f * componentImage.getZoomX();

            updateFrame(zoom, zoom);

        } else if (command.equals("ZoomOne")) {
            updateFrame(1, 1);
        }
    }

    /**
     * Closes window and disposes of frame and component.
     */
    public void close() {

        if (Preferences.is(Preferences.PREF_CLOSE_FRAME_CHECK)) {
            int reply = JOptionPane.showConfirmDialog(this, "Do you really want to close this frame?", "Close Frame",
                                                      JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);

            if (reply == JOptionPane.NO_OPTION) {
                return;
            }
        }

        ScriptRecorder.getReference().addLine(new ActionCloseFrame(getActiveImage()));

        if ((imageA != null) && (imageA.getHistoLUTFrame() != null)) {
            imageA.getHistoLUTFrame().dispose();
        } else if ((imageA != null) && (imageA.getHistoRGBFrame() != null)) {
            imageA.getHistoRGBFrame().dispose();
        }

        // Get all frames
        Vector frameList = imageA.getImageFrameVector();

        if (frameList != null) {

            for (int i = 0; i < frameList.size(); i++) {

                if (frameList.elementAt(i) instanceof ViewJFrameBase) {

                    if (((ViewJFrameBase) frameList.elementAt(i)) != this) {
                        ((ViewJFrameBase) frameList.elementAt(i)).setVisible(false);
                        ((ViewJFrameBase) frameList.elementAt(i)).close();
                        i--;
                    }
                }
            }
        }

        super.close();

        try {
            this.finalize();
        } catch (Throwable t) {
            MipavUtil.displayError("Error encountered cleaning up image frame: " + t);
        }

        System.gc();
    }

    /**
     * Resizes frame and all components.
     *
     * @param  event  event that triggered function
     */
    public synchronized void componentResized(ComponentEvent event) {
        int width, height;
        float bigger;

        if ((getSize().width >= (xScreen - 20)) || (getSize().height >= (yScreen - 20))) {
            return;
        }

        removeComponentListener(this);

        width = getSize().width - (2 * getInsets().left) - fudgeFactor;
        height = getSize().height - getInsets().top - getInsets().bottom - fudgeFactor;
        bigger = Math.max(width, height);
        zoom = (int) Math.min((bigger - 1) / ((imageA.getExtents()[0] * widthResFactor) - 1),
                              (bigger - 1) / ((imageA.getExtents()[1] * heightResFactor) - 1));

        if (zoom > componentImage.getZoomX()) {
            componentImage.setZoom((int) zoom, (int) zoom); // ***************************

            // setZoom(zoom, zoom);
            updateImages(true);

            if ((componentImage.getSize(null).width + 200) > xScreen) {
                width = xScreen - 200;
            } else {
                width = componentImage.getSize(null).width /* + fudgeFactor*/;
            }

            if ((componentImage.getSize(null).height + 200) > yScreen) {
                height = yScreen - 200;
            } else {
                height = componentImage.getSize(null).height /* + fudgeFactor*/;
            }
        } else if ((width < componentImage.getSize(null).width) && (height >= componentImage.getSize(null).height)) {

            // width += fudgeFactor;
            height = componentImage.getSize(null).height /* + fudgeFactor*/ +
                     scrollPane.getHorizontalScrollBar().getHeight();
        } else if ((width >= componentImage.getSize(null).width) && (height < componentImage.getSize(null).height)) {
            width = componentImage.getSize(null).width /* + fudgeFactor*/ +
                    scrollPane.getVerticalScrollBar().getWidth();
            // height += fudgeFactor;
        } else if ((width < componentImage.getSize(null).width) || (height < componentImage.getSize(null).height)) { // width += fudgeFactor;

            // height += fudgeFactor;
        } else if ((width > componentImage.getSize(null).width) || (height > componentImage.getSize(null).height)) {

            if (width > componentImage.getSize(null).width) {
                width = componentImage.getSize(null).width; // ?????

                // height += fudgeFactor;
            }

            if (height > componentImage.getSize(null).height) {
                height = componentImage.getSize(null).height /* + fudgeFactor*/;
                // width += fudgeFactor;
            }
        } else {
            addComponentListener(this);

            return;
        }

        width += scrollPane.getInsets().left + scrollPane.getInsets().right;
        height += scrollPane.getInsets().top + scrollPane.getInsets().bottom;

        scrollPane.setSize(width, height);
        setSize(scrollPane.getSize().width + getInsets().left + getInsets().right + fudgeFactor, // 7 FOR THE MAC
                scrollPane.getSize().height + getInsets().top + getInsets().bottom + fudgeFactor);

        validate();
        setTitle();
        addComponentListener(this);
        updateImages(true);
        // componentImage.frameHeight = getSize().height;
        // componentImage.frameWidth = getSize().width;
    }

    /**
     * Decreases the slice to be displayed by one and updates title frame.
     */
    public synchronized void decSlice() {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice > 0) {
            zSlice--;

            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(zSlice);
                // imageA.getLightBoxFrame().updateImage(zSlice, true);   //turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            componentImage.getVOIHandler().resetLivewire();
            setTitle();

            if (linkFrame != null) {

                // linkFrame.setSlice(zSlice);
                linkFrame.decSlice();
            }

            if (infoDialog != null) {
                infoDialog.setSlice(zSlice, tSlice);
            }

            updateImages(true);
        }
    }

    /**
     * Cleans memory.
     *
     * @throws  Throwable  the <code>Exception</code> raised by this method
     */
    public void finalize() throws Throwable {

        if (componentImage != null) {
            componentImage.dispose(false);
        }

        componentImage = null;
        imageBufferA = null;
        pixBuffer = null;

        scrollPane = null;

        if (zoomDialog != null) {
            zoomDialog.dispose();
            zoomDialog = null;
        }

        colorChooser = null;

        if (menuBar != null) {
            menuBar.removeAll();
        }

        menuBar = null;

        super.finalize();
    }

    /**
     * Returns the reference to the currently active image.
     *
     * @return  the active image
     */
    public ModelImage getActiveImage() {

        if (componentImage != null) {
            return componentImage.getActiveImage();
        } else {
            return null;
        }
    }


    /**
     * Returns the reference to the component image.
     *
     * @return  component image
     */
    public ViewJComponentCardiology getComponentImage() {
        return componentImage;
    }

    /**
     * Get control widgets (toolbars, sliders) for the image frame.
     *
     * @return  the controls for this image frame
     */
    public ViewControlsImage getControls() {
        return controls;
    }

    /**
     * Return the height that the frame should have.
     *
     * @return  the frame's height
     */
    public int getFrameHeight() {
        return scrollPane.getSize().height + getInsets().top + getInsets().bottom + fudgeFactor;
    }

    /**
     * Return the preferred size for the frame.
     *
     * @return  the size the frame should be
     */
    public Dimension getFrameSize() {
        return new Dimension(getFrameWidth(), getFrameHeight());
    }

    /**
     * Return the preferred size for the frame.
     *
     * @param   size  if non-null, its dimensions are changed to the size the frame should be
     *
     * @return  the size the frame should be
     */
    public Dimension getFrameSize(Dimension size) {

        if (size == null) {
            return new Dimension(getFrameWidth(), getFrameHeight());
        } else {
            size.setSize(getFrameWidth(), getFrameHeight());

            return size;
        }
    }

    /**
     * Return the width that the frame should have.
     *
     * @return  the frame's width
     */
    public int getFrameWidth() {
        return scrollPane.getSize().width + getInsets().left + getInsets().right + fudgeFactor;
    }

    /**
     * Returns the reference to imageA.
     *
     * @return  image
     */
    public ModelImage getImageA() {

        if (componentImage != null) {
            return componentImage.getImageA();
        } else {
            return null;
        }
    }

    /**
     * Returns the reference to imageB.
     *
     * @return  imageB
     */
    public ModelImage getImageB() {

        if (componentImage != null) {
            return componentImage.getImageB();
        } else {
            return null;
        }
    }

    // The following 4 functions get and set the RGB tables for ARGB images A and B.
    /**
     * Gets the RGB LUT table for ARGB image A.
     *
     * @return  RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTA() {
        return (componentImage.getRGBTA());
    }

    /**
     * Gets the RGB LUT table for ARGB image B.
     *
     * @return  RGBT the new RGB LUT to be applied to the image
     */
    public ModelRGB getRGBTB() {
        return (componentImage.getRGBTB());
    }

    /**
     * Return the preferred size for the component image scroll pane.
     *
     * @param   size  if non-null, its dimensions are changed to the size the scroll pane should be
     *
     * @return  the size the scroll pane should be
     */
    public Dimension getScrollPaneSize(Dimension size) {

        if (size == null) {
            return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
        } else {
            size.setSize(getScrollPaneWidth(), getScrollPaneHeight());

            return size;
        }
    }

    /*
     *  sets the magnification
     */

    /* public boolean setZoomA() {
     * int xDim     = imageA.getExtents()[0]; int yDim     = imageA.getExtents()[1]; float imageTemp[]       = null; int
     * pixBufferTemp[]   = null; int   paintBufferTemp[] = null; try   { if (imageA != null) { int bufferFactor = 1; if
     * ( imageA.isColorImage() ) { bufferFactor = 4; } imageTemp       = new float [bufferFactor * xDim * yDim];
     * pixBufferTemp   = new int[xDim * yDim]; paintBufferTemp = new int[xDim * yDim]; } } catch (OutOfMemoryError
     * error){ imageTemp      = null; pixBufferTemp   = null; paintBufferTemp = null; System.gc(); throw(error); }
     * imageBufferA  = imageTemp; pixBuffer     = pixBufferTemp; paintBuffer   = paintBufferTemp;
     * componentImage.setBuffers(imageBufferA, imageBufferB, pixBuffer, paintBuffer); return true; }*/

    /**
     * Get the top-most slice.
     *
     * @return  returns the slice which is currently displayed
     */
    public int getViewableSlice() {
        return zSlice;
    }

    /**
     * Increases the slice to be displayed by one and updates title frame.
     */
    public synchronized void incSlice() {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice < (imageA.getExtents()[2] - 1)) {
            zSlice++;

            if (imageA.getLightBoxFrame() != null) { // move highlight on images in lightbox
                imageA.getLightBoxFrame().setSlice(zSlice); // turn highlight on in old image
            }

            // livewire grad mag. should be recalculated for the new slice
            componentImage.getVOIHandler().resetLivewire();
            setTitle();

            if (linkFrame != null) {
                linkFrame.incSlice();
            }

            if (infoDialog != null) {
                infoDialog.setSlice(zSlice, tSlice);
            }

            updateImages(true);
        }
    }

    /**
     * ********************************************************************* **************************** Key Events ***
     * **************************.*********************************************************************
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();

        componentImage.rememberPaintBrushSize();

        switch (keyCode) {

            case KeyEvent.VK_1:
            //    componentImage.setPaintBrushSize(componentImage.thinPaint);
                break;

            case KeyEvent.VK_2:
           //     componentImage.setPaintBrushSize(componentImage.medPaint);
                break;

            case KeyEvent.VK_3:
            //    componentImage.setPaintBrushSize(componentImage.thickPaint);
                break;

            case KeyEvent.VK_4:
             //   componentImage.setPaintBrushSize(componentImage.thickestPaint);
                break;
        }

        componentImage.repaint();
    }

    /**
     * DOCUMENT ME!
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyReleased(KeyEvent e) {
        int keyCode = e.getKeyCode();

        switch (keyCode) {

            case KeyEvent.VK_PAGE_DOWN:
                decSlice();
                break;

            case KeyEvent.VK_PAGE_UP:
                incSlice();
                break;

            case KeyEvent.VK_HOME:
                setSlice(0);
                break;

            case KeyEvent.VK_END:
                if (imageA.getNDims() > 2) { // ignore for 2d images...
                    setSlice(imageA.getExtents()[2] - 1);
                }

                break;

            case KeyEvent.VK_DELETE:
                componentImage.getVOIHandler().deleteSelectedVOI(true);
                break;

            case KeyEvent.VK_B:

                // swap the border painting
            	if(Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)) {
                	getControls().getTools().bogusBorderPaintButton.setSelected(true);
                	if (linkTriFrame != null) {
                		linkTriFrame.bogusBorderPaintButton.setSelected(true);
                	}
                }else {
                	getControls().getTools().borderPaintButton.setSelected(true);
                	if (linkTriFrame != null) {
                		linkTriFrame.borderPaintButton.setSelected(true);
                	}
                }
            	
                Preferences.setProperty(Preferences.PREF_SHOW_PAINT_BORDER, String.valueOf("" + !Preferences.is(Preferences.PREF_SHOW_PAINT_BORDER)));
                componentImage.getActiveImage().notifyImageDisplayListeners(null, true);

                updateImages(true);
                break;

            case KeyEvent.VK_1:
            case KeyEvent.VK_2:
            case KeyEvent.VK_3:
            case KeyEvent.VK_4:
                componentImage.resetPaintBrushSize();
                componentImage.repaint();
                break;
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  e  DOCUMENT ME!
     */
    public void keyTyped(KeyEvent e) { }

    /**
     * Method to send an image to the printer.
     */
    public void printImage() {
        String jobtitle = "Printing Image";

        PrintJob prtJob = getToolkit().getPrintJob(this, jobtitle, null);

        if (prtJob != null) {
            Graphics pGraphics = prtJob.getGraphics();

            if (pGraphics != null) {

                float oldImageWidth = (getActiveImage().getExtents()[0] * componentImage.getZoomX());
                float oldImageHeight = (getActiveImage().getExtents()[1] * componentImage.getZoomY());
                float oldZoomX = componentImage.getZoomX();
                float oldZoomY = componentImage.getZoomY();
                float newZoomX = componentImage.getZoomX();
                float newZoomY = componentImage.getZoomY();

                if ((oldImageWidth > 600) || (oldImageHeight > 780)) {

                    while (((getActiveImage().getExtents()[0] * componentImage.getZoomX()) > 600) ||
                               ((getActiveImage().getExtents()[1] * componentImage.getZoomY()) > 780)) {
                        newZoomX /= 1.1f;
                        newZoomY /= 1.1f;
                        componentImage.setZoom(newZoomX, newZoomY);

                    }
                }

                Preferences.debug("newZoomX, newZoomY = " + newZoomX + ", " + newZoomY + "\n");
                componentImage.paintComponentForPrinter(20, 20, pGraphics);
                componentImage.setZoom(oldZoomX, oldZoomY);
                pGraphics.dispose(); // flush page
            }

            prtJob.end();
        }
    }

    /**
     * Removes the menu and controls of the main frame so that a new frame can load the main frame with the proper
     * controls. Since the controls point to this particular image, when we remove the controls, turn off the highlight
     * box.
     *
     * @see  ViewJComponentEditImage#useHighlight(boolean)
     * @see  ViewJComponentEditImage#repaint()
     */
    public void removeControls() {
        userInterface.getMainFrame().getContentPane().remove(controls);

        // if the frame was just closed, componentImage will be null.
        try {
            componentImage.useHighlight(false);
            getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
        } catch (NullPointerException npe) {
            Preferences.debug("NullPointerException in ViewJFrameImage:\n" + npe.getMessage() +
                              "\n in removeControls().\n", 5);
        }
    }

    /**
     * Saves the image info; need to do before saving image.
     */
    public void saveImageInfo() {
        setLUTs(componentImage.getLUTa(), componentImage.getLUTb());
        setOpacityInfo(componentImage.getOpacity(), componentImage.getAlphaBlend());
        setpaintBitmap(componentImage.getPaintBitmap());
    }


    /**
     * Sets the active image for drawing VOIs. VOIs are only drawn in the active image. In addition, algorithms are
     * executed on the active window.
     *
     * @param  active  IMAGE_A or IMAGE_B
     */
    public void setActiveImage(int active) {

        if (componentImage != null) {
            componentImage.setActiveImage(active);
        }

        if (active == IMAGE_A) {
            displayMode = IMAGE_A;
            setTitle();
        }

        updateImages(false);
    }

    /**
     * Sets the alpha blending of parameter for two image displaying.
     *
     * @param  value  amount [0,100] that is the percentage of Image A to be displayed
     */
    public void setAlphaBlend(int value) {

        // imageA.setAlphaBlend(value);
        if (componentImage != null) {
            componentImage.setAlphaBlend(value);
        }
    }

    /**
     * Sets the menu and controls (i.e. toolbars) of the main frame! This puts the menus and controls needed to controls
     * the operations of this frame. Different image frames have different menu and controls. Notify this componentImage
     * that it needs to display highlight box, notifying user that this componentImage is the image being controlled
     *
     * @see  ViewJComponentEditImage#useHighlight(boolean)
     * @see  ViewJComponentEditImage#repaint()
     */
    public void setControls() {

        if (getImageB() != null) {
            controls.addActiveImageControl();
        } else {
            controls.removeActiveImageControl();
        }

        userInterface.getMainFrame().setJMenuBar(menuBar);
        userInterface.getMainFrame().getContentPane().add(controls, BorderLayout.CENTER);
        userInterface.getMainFrame().pack();

        // userInterface.getMessageFrame().setLogTab(getActiveImage().getLogPane(),
        // getActiveImage().getLogArea(),
        // getActiveImage().getImageName());
        componentImage.useHighlight(true); // the controls point to this componentImage.  Display the highlighter
        getActiveImage().notifyImageDisplayListeners(); // ie., componentImage.repaint();
    }


    /**
     * Controls whether or not the images/VOIs of the frame can be modified.
     *
     * @param  flag  if true the image/VOIs can be modified; if false image/VOIs can NOT be modified
     */
    public void setEnabled(boolean flag) {

        if (componentImage != null) {
            componentImage.setEnabled(flag);
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param  imageB  DOCUMENT ME!
     */
    public void setImageB(ModelImage imageB) { }

    /**
     * DOCUMENT ME!
     *
     * @param  uid  DOCUMENT ME!
     */
    public void setLastVOI_UID(int uid) {
        this.lastVOI_UID = uid;
    }

    /**
     * Sets the LUT for image A.
     *
     * @param  LUT  the LUT
     */
    public void setLUTa(ModelLUT LUT) {
        componentImage.setLUTa(LUT);
        super.setLUTa(LUT);
    }

    /**
     * Sets the LUT for image B.
     *
     * @param  LUT  the LUT
     */
    public void setLUTb(ModelLUT LUT) {
        componentImage.setLUTb(LUT);
        super.setLUTb(LUT);
    }

    /**
     * When switching the active image, copy the paintBitmap of the previous active image into the paintBitmap of the
     * new active image.
     *
     * @param  paintBitmapSwitch  if true do not getMask on a setActiveImage command
     */
    public void setPaintBitmapSwitch(boolean paintBitmapSwitch) {

        if (componentImage != null) {
            componentImage.setPaintBitmapSwitch(paintBitmapSwitch);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image A.
     *
     * @param  RGBT  the new RGB LUT to be applied to the image
     */
    public void setRGBTA(ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTA(RGBT);
        }
    }

    /**
     * Sets the RGB LUT table for ARGB image B.
     *
     * @param  RGBT  the new RGB LUT to be applied to the image
     */
    public void setRGBTB(ModelRGB RGBT) {

        if (componentImage != null) {
            componentImage.setRGBTB(RGBT);
        }
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     *
     * @param  slice  indicates image slice to be displayed
     */
    public void setSlice(int slice) {

        if (imageA.getNDims() <= 2) {
            return;
        }

        if (zSlice < imageA.getExtents()[2]) {
            zSlice = slice;
            updateImages(true);

            // livewire grad mag. should be recalculated for the new slice
            componentImage.getVOIHandler().resetLivewire();
            setTitle();

            if (linkFrame != null) {
                linkFrame.setSlice(slice);
            }

            if (infoDialog != null) {
                infoDialog.setSlice(zSlice, tSlice);
            }
        }
    }

    /**
     * Sets the slice to be displayed and updates title frame.
     *
     * @param  slice  indicates image time-slice (4th dimension) to be displayed
     */
    public void setTimeSlice(int slice) {

        if (imageA.getNDims() == 4) {

            if (tSlice < imageA.getExtents()[3]) {
                tSlice = slice;

                // livewire grad mag. should be recalculated for the new slice
                componentImage.getVOIHandler().resetLivewire();
                setTitle();
                updateImages(true);

                if (linkFrame != null) {
                    linkFrame.setTimeSlice(tSlice);
                }

                if (infoDialog != null) {
                    infoDialog.setSlice(zSlice, tSlice);
                }
            }
        } // if (imageA.getNDims() <= 3)
        else if ((imageB != null) && (imageB.getNDims() == 4)) {

            if (tSlice < imageB.getExtents()[3]) {
                tSlice = slice;

                // livewire grad mag. should be recalculated for the new slice
                componentImage.getVOIHandler().resetLivewire();
                setTitle();
                updateImages(true);

                if (linkFrame != null) {
                    linkFrame.setTimeSlice(tSlice);
                }

                if (infoDialog != null) {
                    infoDialog.setSlice(zSlice, tSlice);
                }
            }
        } // else if ((imageB != null) && (imageB.getNDims() == 4))
        else {
            return;
        }
    }

    /**
     * Sets the title of the frame with the image name and the slice location.
     */
    public void setTitle() {
        String str = makeTitle();

        setTitle(str);
        userInterface.getMainFrame().setTitle(str);
    }

    /**
     * Sets the magnification dialog to null.
     */
    public void setZoomDialogNull() {
        zoomDialog = null;
    }

    /**
     * Updates the this frame's size the components sizes. If the magnified image fits into the frame that will fit into
     * the screen then frame and image are sized appropriately. If the frame, to fit the image, exceeds the screen size
     * the frame remains the same size and the image magnified and placed in the scroll pane.
     *
     * @param  sX  zoom in the x dimension
     * @param  sY  zoom in the y dimension
     */
    public void updateFrame(float sX, float sY) {
        componentImage.setZoom(sX, sY);
        updateImages(false);

        if (((componentImage.getSize(null).width + 200) > xScreen) ||
                ((componentImage.getSize(null).height + 200) > yScreen)) {
            ;
        } else if ((getSize().width > componentImage.getSize(null).width) ||
                       (getSize().height > componentImage.getSize(null).height)) {
            removeComponentListener(this);
            scrollPane.setSize(getScrollPaneSize());
            scrollPane.setMaximumSize(getScrollPaneSize());
            scrollPane.setPreferredSize(getScrollPaneSize());

            Dimension size = getFrameSize();
            setSize(size.width, size.height);
            addComponentListener(this);
        } else {

            if (((componentImage.getSize(null).width + 200) < xScreen) &&
                    ((componentImage.getSize(null).height + 200) < yScreen)) {
                removeComponentListener(this);
                scrollPane.setSize(getScrollPaneSize());
                scrollPane.setMaximumSize(getScrollPaneSize());
                scrollPane.setPreferredSize(getScrollPaneSize());

                Dimension size = getFrameSize();
                setSize(size.width, size.height);
                addComponentListener(this);
            } else {
                removeComponentListener(this);
                scrollPane.setSize(getSize().width - getInsets().left - getInsets().right - 1,
                                   getSize().height - getInsets().top - getInsets().bottom - 1);
                addComponentListener(this);
            }
        }

        validate();
        setTitle();
        updateImages(false);
    }

    /**
     * This methods calls the componentImage's REPAINT method to redraw the screen. The extents on this image have
     * changed, so the extents need to be read in again and menus, panes and slide bars adjusted accordingly.
     *
     * @return  whether the image extents update was successful
     */
    public boolean updateImageExtents() {

        // update the image buffers since their sizes may have changed
        createBuffers();
        initExtentsVariables(imageA);

        componentImage.setBuffers(imageBufferA, null, pixBuffer, null);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }

        // reset the title, since dimensions may have changed
        setTitle();

        // update the image controls
        removeControls();

        // controls.setZSlider(zSlice);
        setControls();
        setSlice(zSlice);

        return true;

    } // end updateImageExtents()

    /**
     * This methods calls the componentImage's update method to redraw the screen - fastest of the three update methods.
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages() {

        if (componentImage == null) {
            return false;
        }

        try {
            componentImage.paintComponent(componentImage.getGraphics());
            // componentImage.repaint(); // problems with this method on some machines seems to eat lots of  memory on
            // JVM 1.3
        } catch (OutOfMemoryError error) {
            System.gc();
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen. Without LUT changes.
     *
     * @param   forceShow  forces show to re import image and calc. java image
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages(boolean forceShow) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(tSlice, zSlice, null, null, forceShow, -1) == false) {
            return false;
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * This methods calls the componentImage's update method to redraw the screen.
     *
     * @param   LUTa        LUT used to update imageA
     * @param   LUTb        LUT used to update imageB
     * @param   forceShow   forces show to re import image and calc. java image
     * @param   interpMode  image interpolation method (Nearest or Smooth)
     *
     * @return  boolean confirming successful update
     */
    public synchronized boolean updateImages(ModelLUT LUTa, ModelLUT LUTb, boolean forceShow, int interpMode) {

        if (componentImage == null) {
            return false;
        }

        if (componentImage.show(tSlice, zSlice, LUTa, LUTb, forceShow, interpMode) == false) {
            return false;
        }

        // update the luts in this frame
        if (LUTa != null) {
            setLUTa(LUTa);
        }

        if (LUTb != null) {
            setLUTb(LUTb);
        }

        ViewControlsImage myControls = getControls();

        if (myControls != null) {
            myControls.repaint();
        }

        return true;
    }

    /**
     * Closes window and disposes of frame and component.
     *
     * @param  event  Event that triggered function
     */
    public void windowClosing(WindowEvent event) {
        close();
    }

    /**
     * Get the extents of an image. (don't know why this is really needed...)
     *
     * @param   img  the image
     *
     * @return  the image's extents
     */
    protected static int[] initExtents(ModelImage img) {
        int[] extents = null;

        if (img.getNDims() == 2) {
            extents = new int[2];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
        } else if (img.getNDims() == 3) {
            extents = new int[3];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
            extents[2] = Math.round(img.getExtents()[2]);
        } else if (img.getNDims() == 4) {
            extents = new int[4];
            extents[0] = Math.round(img.getExtents()[0]);
            extents[1] = Math.round(img.getExtents()[1]);
            extents[2] = Math.round(img.getExtents()[2]);
            extents[3] = Math.round(img.getExtents()[3]);
        }

        return extents;
    }

    /**
     * Create the intensity buffer for an image.
     *
     * @param   extents  the extents of the image
     * @param   isColor  whether the image is in color
     *
     * @return  a buffer which is big enough to contain the image intensity data
     */
    protected static float[] initImageBuffer(int[] extents, boolean isColor) {
        int bufferFactor = 1;

        if (isColor) {
            bufferFactor = 4;
        }

        return new float[bufferFactor * extents[0] * extents[1]];
    }

    /**
     * Creates and initializes the LUT for an image.
     *
     * @param   img  the image to create a LUT for
     *
     * @return  a LUT for the image <code>img</code> (null if a color image)
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    public static ModelLUT initLUT(ModelImage img) throws OutOfMemoryError {
        ModelLUT newLUT = null;

        // only make a lut for non color images
        if (img.isColorImage() == false) {
            int[] dimExtentsLUT = new int[2];

            dimExtentsLUT[0] = 4;
            dimExtentsLUT[1] = 256;

            newLUT = new ModelLUT(ModelLUT.GRAY, 256, dimExtentsLUT);

            float min, max;

            if (img.getType() == ModelStorageBase.UBYTE) {
                min = 0;
                max = 255;
            } else if (img.getType() == ModelStorageBase.BYTE) {
                min = -128;
                max = 127;
            } else {
                min = (float) img.getMin();
                max = (float) img.getMax();
            }

            float imgMin = (float) img.getMin();
            float imgMax = (float) img.getMax();

            newLUT.resetTransferLine(min, imgMin, max, imgMax);
        }

        return newLUT;
    }

    /**
     * Get the total number of time slices and volume slices.
     *
     * @param   img  the image to get the slices of
     *
     * @return  an array containing the number of volume slices (in the first element) and the number of time slices in
     *          the image (in the second element)
     */
    protected static int[] initNumSlices(ModelImage img) {
        int[] numImages = new int[2];

        if (img.getNDims() == 4) {
            numImages[0] = img.getExtents()[2];
            numImages[1] = img.getExtents()[3];
        } else if (img.getNDims() == 3) {
            numImages[0] = img.getExtents()[2];
            numImages[1] = 0;
        } else {
            numImages[0] = 1;
            numImages[1] = 0;
        }

        return numImages;
    }

    /**
     * Create the pixel buffer for an image.
     *
     * @param   extents  the extents of the image
     *
     * @return  a buffer which is big enough to contain the image pixel data
     */
    protected static int[] initPixelBuffer(int[] extents) {
        return new int[extents[0] * extents[1]];
    }

    /**
     * Get the resolution correction needed for non-isotropic images.
     *
     * @param   imgResols  the image resolution
     * @param   imgUnits   the image units of measure
     *
     * @return  the resolution correction factor in the x (the first element) and y (the second element) dimensions
     */
    protected static float[] initResFactor(float[] imgResols, int[] imgUnits) {
        float[] resFactor = new float[2];

        resFactor[0] = 1.0f;
        resFactor[1] = 1.0f;

        if ((imgResols[1] >= imgResols[0]) && (imgResols[1] < (20.0f * imgResols[0])) && (imgUnits[0] == imgUnits[1])) {
            resFactor[1] = imgResols[1] / imgResols[0];
        } else if ((imgResols[0] > imgResols[1]) && (imgResols[0] < (20.0f * imgResols[1])) &&
                       (imgUnits[0] == imgUnits[1])) {
            resFactor[0] = imgResols[0] / imgResols[1];
        }

        return resFactor;
    }

    /**
     * DOCUMENT ME!
     *
     * @param   img  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    protected static float[] initResolutions(ModelImage img) {
        float[] res = img.getFileInfo(0).getResolutions();

        for (int r = 0; r < img.getNDims(); r++) {

            if (res[r] < 0) {
                res[r] = Math.abs(res[r]);
            } else if (res[r] == 0) {
                res[r] = 1.0f;
            }
        }

        return res;
    }

    /**
     * Get the initial time and volume slice positions.
     *
     * @param   img  the image to get the slice positions of
     *
     * @return  an array containing the slice in the volume (in the first element) and the time slice (in the second
     *          element)
     */
    protected static int[] initSlicePositions(ModelImage img) {
        int[] slices = new int[2];

        if (img.getNDims() == 4) {
            slices[0] = (img.getExtents()[2] - 1) / 2;
            slices[1] = 0;
        } else if (img.getNDims() == 3) {
            slices[0] = (img.getExtents()[2] - 1) / 2;
            slices[1] = 0;
        } else {
            slices[0] = 0;
            slices[1] = 0;
        }

        return slices;
    }

    /**
     * DOCUMENT ME!
     *
     * @param   img  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    protected static int[] initUnits(ModelImage img) {
        return img.getFileInfo(0).getUnitsOfMeasure();
    }

    /**
     * Initializes the zoom variables for an image.
     *
     * @param   img         the image to use to initialize the zoom
     * @param   xResFactor  correction factor in the x direction for images that are do not have isotropic voxels
     * @param   yResFactor  correction factor in the x direction for images that are do not have isotropic voxels
     *
     * @return  the initial zoom to use for this image
     */
    protected static float initZoom(ModelImage img, float xResFactor, float yResFactor) {

        float imgZoom;
        float zoomX = 1, zoomY = 1;

        if ((img.getExtents()[0] * xResFactor) > (xScreen - 300)) {
            zoomX = (xScreen - 300.0f) / (img.getExtents()[0] * xResFactor);
        }

        if ((img.getExtents()[1] * yResFactor) > (yScreen - 300)) {
            zoomY = (yScreen - 300.0f) / (img.getExtents()[1] * yResFactor);
        }

        imgZoom = Math.min(zoomX, zoomY);

        if (imgZoom < 1) {

            if (imgZoom > 0.5) {
                imgZoom = 0.5f;
            } else if (imgZoom > 0.25) {
                imgZoom = 0.25f;
            } else if (imgZoom > 0.125) {
                imgZoom = 0.125f;
            } else if (imgZoom > 0.0625) {
                imgZoom = 0.0625f;
            } else if (imgZoom > 0.03125) {
                imgZoom = 0.03125f;
            } else {
                imgZoom = 0.015625f;
            }
        }

        return imgZoom;

    } // end initZoom()

    /**
     * Create the buffers for imageA and imageB.
     *
     * @return  the extents of the buffers
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    protected int[] createBuffers() throws OutOfMemoryError {
        int[] extents = initExtents(imageA);

        imageBufferA = initImageBuffer(extents, imageA.isColorImage());
        pixBuffer = initPixelBuffer(extents);

        return extents;

    } // end createBuffers()

    /**
     * Get a power of 2 which is close to a given number.
     *
     * @param   dim  the number to get a power of 2 for
     *
     * @return  a power of 2
     */
    protected int dimPowerOfTwo(int dim) {

        // 128^3 x 4 is 8MB
        // 256^3 x 4 is 64MB
        if (dim <= 16) {
            return 16;
        } else if (dim <= 32) {
            return 32;
        } else if (dim <= 64) {

            if (dim > 40) {
                return 64;
            } else {
                return 32;
            }
        } else if (dim <= 128) {

            if (dim > 80) {
                return 128;
            } else {
                return 64;
            }
        } else if (dim <= 256) {

            if (dim > 160) {
                return 256;
            } else {
                return 128;
            }
        } else if (dim <= 512) {

            if (dim > 448) {
                return 512;
            } else {
                return 256;
            }
        } else {
            return 512;
        }
    }

    /**
     * Get the height of the scroll pane holding the component image.
     *
     * @return  the height of the component image scroll pane
     */
    protected int getScrollPaneHeight() {
        return componentImage.getSize(null).height + scrollPane.getInsets().top + scrollPane.getInsets().bottom;
    }

    /**
     * Get the size of the scroll pane holding the component image.
     *
     * @return  the size of the component image scroll pane
     */
    protected Dimension getScrollPaneSize() {
        return new Dimension(getScrollPaneWidth(), getScrollPaneHeight());
    }

    /**
     * Get the width of the scroll pane holding the component image.
     *
     * @return  the width of the component image scroll pane
     */
    protected int getScrollPaneWidth() {
        return componentImage.getSize(null).width + scrollPane.getInsets().left + scrollPane.getInsets().right;
    }

    /**
     * Initializes the variables based on the image extents. (i.e. number of slices, number of time slices, the initial
     * z-slice, etc.
     *
     * @param  img  the image to set the extent variables for
     */
    protected void initExtentsVariables(ModelImage img) {
        int[] slices = null;
        int[] numImages = null;

        slices = initSlicePositions(img);
        numImages = initNumSlices(img);

        zSlice = slices[0];
        tSlice = slices[1];

        nImage = numImages[0];
        nTImage = numImages[1];
    }

    /**
     * Creates and initializes the LUT for the first image (<code>imageA</code>) if it hasn't been already.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    protected void initLUT() throws OutOfMemoryError {

        if (LUTa == null) {
            LUTa = initLUT(imageA);
        }
    }

    /**
     * Initializes the resolutions and units from the image.
     */
    protected void initResolutions() {
        resols = initResolutions(imageA);
        units = initUnits(imageA);

        float[] factor = initResFactor(resols, units);

        widthResFactor = factor[0];
        heightResFactor = factor[1];
    } // end initResolutions()

    /**
     * Initializes the zoom variables for the first image (imageA).
     */
    protected void initZoom() {
        zoom = initZoom(imageA, widthResFactor, heightResFactor);
    } // end initZoom()

    /**
     * Constructs the title of the frame with the image name and the slice location.
     *
     * @return  the image frame title
     */
    protected String makeTitle() {
        String str;

        if (displayMode == IMAGE_A) {

            if (imageA.getNDims() == 4) { // Setup the title for 4D image
                str = imageA.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + "z  " +
                      String.valueOf(tSlice + 1) + "/" + String.valueOf(nTImage) + "t M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else if (imageA.getNDims() == 3) { // Setup the title for 3D image
                str = imageA.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + " M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else {
                str = imageA.getImageName() + "  M:" + makeString(componentImage.getZoomX(), 2);
            }
        } else {

            if (imageB.getNDims() == 4) { // Setup the title for 4D image of image B
                str = imageB.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + "z  " +
                      String.valueOf(tSlice + 1) + "/" + String.valueOf(nTImage) + "t M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else if (imageB.getNDims() == 3) { // Setup the title
                str = imageB.getImageName() + "  " + String.valueOf(zSlice + 1) + "/" + String.valueOf(nImage) + " M:" +
                      makeString(componentImage.getZoomX(), 2);
            } else {
                str = imageB.getImageName() + "  M:" + makeString(componentImage.getZoomX(), 2);
            }
        }

        return str;
    }

    /**
     * Tests that the entered parameter is in range.
     *
     * @param   str       the value entered by the user
     * @param   minValue  the minimum value this variable may be set to
     * @param   maxValue  the maximum value this variable may be set to
     *
     * @return  boolean result of test
     */
    protected boolean testParameter(String str, double minValue, double maxValue) {

        double tmp;

        try {
            tmp = Double.valueOf(str).doubleValue();

            if ((tmp > maxValue) || (tmp < minValue)) {
                MipavUtil.displayError("Value is out of range: " + String.valueOf(minValue) + " , " +
                                       String.valueOf(maxValue));

                return false;
            } else {
                return true;
            }
        } catch (NumberFormatException error) {
            MipavUtil.displayError("Must enter numeric value");

            return false;
        }
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     *
     * @param  imageAorB  whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     */
    protected void updateHistoLUTFrame(int imageAorB) {
        updateHistoLUTFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoLUT frame for a gray scale image.
     *
     * @param  imageAorB  whether to show the IMAGE_A, IMAGE_B or IMAGE_A_B lut frame
     * @param  compImg    the component image with the image histogram frames to update
     */
    protected void updateHistoLUTFrame(int imageAorB, ViewJComponentEditImage compImg) {
        updateImages(true);

        if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_A)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(), null, null,
                                                                  true);
        } else if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_B)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(null, null, compImg.getImageB(), compImg.getLUTb(),
                                                                  true);
        } else if ((compImg.getImageA().getHistoLUTFrame() != null) && (imageAorB == IMAGE_A_B)) {
            compImg.getImageA().getHistoLUTFrame().updateHistoLUT(compImg.getImageA(), compImg.getLUTa(),
                                                                  compImg.getImageB(), compImg.getLUTb(), true);
        }
    }

    /**
     * Displays histoRGB frame for an RGB image.
     *
     * @param  imageAorB  indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     */
    protected void updateHistoRGBFrame(int imageAorB) {
        updateHistoRGBFrame(imageAorB, componentImage);
    }

    /**
     * Displays histoRGB frame for an RGB image.
     *
     * @param  imageAorB  indicates whether to show IMAGE_A, IMAGE_B or IMAGE_A_B (both).
     * @param  compImg    the component image with the image histogram frames to update
     */
    protected void updateHistoRGBFrame(int imageAorB, ViewJComponentEditImage compImg) {
        updateImages(true);

        if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_A)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), null, true);
        } else if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_B)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(null, compImg.getImageB(), true);
        } else if ((compImg.getImageA().getHistoRGBFrame() != null) && (imageAorB == IMAGE_A_B)) {
            compImg.getImageA().getHistoRGBFrame().updateHistoRGB(compImg.getImageA(), compImg.getImageB(), true);
        }
    }

    /**
     * DOCUMENT ME!
     *
     * @param   type  DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    private boolean checkForVOICompatibility(int type) {

        int numVOI = getActiveImage().getVOIs().size();
        int lastType = -1;

        if (numVOI == 0) {
            return true;
        } else if (numVOI == 1) {
            lastType = ((VOI) (getActiveImage().getVOIs().elementAt(0))).getCurveType();
        } else {

            for (int i = 0; i < numVOI; i++) {

                if (((VOI) (getActiveImage().getVOIs().elementAt(i))).getUID() == lastVOI_UID) {
                    lastType = ((VOI) (getActiveImage().getVOIs().elementAt(i))).getCurveType();

                    break;
                }
            }
        }

        if (lastType == -1) {
            return true;
        }

        switch (type) {

            case VOI.CONTOUR:
            case VOI.POLYLINE:
                if ((lastType != VOI.CONTOUR) && (lastType != VOI.POLYLINE)) {
                    int id = (((VOI) (getActiveImage().getVOIs().lastElement())).getID() + 1);

                    getControls().setVOIColor(id);

                    return false;
                }

                break;

            default:
                if (type != lastType) {
                    int id = (((VOI) (getActiveImage().getVOIs().lastElement())).getID() + 1);

                    getControls().setVOIColor(id);

                    return false;
                }
        }

        return true;
    }

    /**
     * Initializes the frame and variables.
     *
     * @param   LUTa           LUT of the imageA (if null grayscale LUT is constructed)
     * @param   loc            location where image should be initially placed
     * @param   logMagDisplay  a boolean indicating if the log magnitude of image should be displayed.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for the GUI
     */
    private void init(ModelLUT LUTa, Dimension loc, boolean logMagDisplay) throws OutOfMemoryError {

        try {
            setIconImage(MipavUtil.getIconImage(Preferences.getIconName()));
        } catch (FileNotFoundException error) {
            Preferences.debug("Exception ocurred while getting <" + error.getMessage() +
                              ">.  Check that this file is available.\n");
        }

        setResizable(true);

        // initialize logMagDisplay
        this.logMagDisplay = logMagDisplay;
        this.LUTa = LUTa;

        initResolutions();
        initZoom();
        initLUT();

        int[] extents = createBuffers();

        initComponentImage(extents);
        initExtentsVariables(imageA);

        // create and build the menus and controls
        controls = new ViewControlsImage(this); // Build controls used in this frame
        menuBuilder = new ViewMenuBuilder(this);

        // build the menuBar based on the number of dimensions for imageA
        menuBarMaker = new ViewMenuBar(menuBuilder);
        menuBar = menuBarMaker.getMenuBar(this, imageA.getNDims(), imageA.getType(), imageA.isDicomImage());

        // imageA.

        controls.buildToolbar(menuBuilder.isMenuItemSelected("Image toolbar"), false, false, false,
                              componentImage.getVOIHandler().getVOI_ID());

        if (getActiveImage().getFileInfo(0).getFileFormat() == FileUtility.DICOM) {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", true);
            menuBuilder.setMenuItemEnabled("DICOM overlay options", true);
            menuBuilder.setMenuItemEnabled("Image overlay options", false);
        } else {

            // menuBuilder.setMenuItemEnabled("Show image/DICOM overlay", false);
            menuBuilder.setMenuItemEnabled("DICOM overlay options", false);
            menuBuilder.setMenuItemEnabled("Image overlay options", true);
        }

        setTitle();

        // The component image will be displayed in a scrollpane.
        scrollPane = new JScrollPane(componentImage, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                                     JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        getContentPane().add(scrollPane);

        // scrollPane.setPreferredSize(new Dimension(componentImage.getSize().width  + 3,
        // componentImage.getSize().height + 3));
        scrollPane.setBackground(Color.black);
        setBackground(Color.black);

        setSize(scrollPane.getSize().width + getInsets().left + getInsets().right + fudgeFactor,
                scrollPane.getSize().height + getInsets().top + getInsets().bottom + fudgeFactor);
        setLocation(loc.width, loc.height);

        addComponentListener(this);
        addKeyListener(this);

        // MUST register frame to image models
        imageA.addImageDisplayListener(this);

        if (imageB != null) {
            imageB.addImageDisplayListener(this);
        }

        windowLevel = new JDialogWinLevel[2];

        pack();

        if (userInterface.isAppFrameVisible()) {
            setVisible(true);
        } else {
            setVisible(false);
        }

        // User interface will have list of frames
        userInterface.registerFrame(this);
        updateImages(true);
        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

    } // end init()

    /**
     * Creates and initializes the component image for the given image.
     *
     * @param   extents  the image dimensionality.
     *
     * @throws  OutOfMemoryError  if enough memory cannot be allocated for this method
     */
    private void initComponentImage(int[] extents) throws OutOfMemoryError {

        componentImage = new ViewJComponentCardiology(this, imageA, LUTa, imageBufferA, pixBuffer, zoom, extents,
                                                      logMagDisplay, FileInfoBase.UNKNOWN_ORIENT);

        componentImage.setBuffers(imageBufferA, null, pixBuffer, null);

        if (resols[1] >= resols[0]) {
            componentImage.setResolutions(1, heightResFactor);
        } else {
            componentImage.setResolutions(widthResFactor, 1);
        }

        // if this is a color image, then update the RGB info in the component
        if (imageA.isColorImage()) {

            if (getRGBTA() == null) {
                int[] RGBExtents = new int[2];

                RGBExtents[0] = 4;
                RGBExtents[1] = 256;

                ModelRGB rgb = new ModelRGB(RGBExtents);

                setRGBTA(rgb);
            }
        } // end if image is an RGB type

    } // end initComponentImage()

    /**
     * Helper method to establish if there are other images so that a dialog can be created. Used by registration
     * methods, load frame, etc.
     *
     * @return  <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleImages() {
        Enumeration names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();

            if (!getActiveImage().getImageName().equals(name)) {
                createDialog = true;
            }
        }

        return createDialog;
    }

    /**
     * Helper method to establish if there are images of the same dimensionality so that a dialog can be created. Used
     * by image calculator, concat, etc.
     *
     * @param   isForCalculator  whether this call is being done before using the image calculator
     *
     * @return  <code>true</code> if there are images to operate on.
     */
    private boolean isMultipleSameSizeImages(boolean isForCalculator) {
        Enumeration names = userInterface.getRegisteredImageNames();
        boolean createDialog = false;
        boolean proceed = false;

        // Add images from user interface that have the same exact dimensionality
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();

            if (!getActiveImage().getImageName().equals(name)) {

                try {
                    ModelImage img = userInterface.getRegisteredImageByName(name);

                    if ((getActiveImage().getNDims() == img.getNDims()) ||
                            (isForCalculator && ((getActiveImage().getNDims() == 3) && (img.getNDims() == 2)))) {

                        if ((getActiveImage().getNDims() == 3) && (img.getNDims() == 3) &&
                                (getActiveImage().getExtents()[2] == img.getExtents()[2])) {
                            proceed = true;
                        } else if ((getActiveImage().getNDims() == 4) &&
                                       (getActiveImage().getExtents()[2] == img.getExtents()[2]) &&
                                       (getActiveImage().getExtents()[3] == img.getExtents()[3])) {
                            proceed = true;
                        } else if (getActiveImage().getNDims() == 2) {
                            proceed = true;
                        } else if ((getActiveImage().getNDims() == 3) && (img.getNDims() == 2) &&
                                       (getActiveImage().getExtents()[0] == img.getExtents()[0]) &&
                                       (getActiveImage().getExtents()[1] == img.getExtents()[1])) {
                            proceed = true;
                        }

                        if (proceed) {

                            if (isForCalculator && !createDialog) {
                                createDialog = (getActiveImage().isColorImage() == img.isColorImage());
                            } else {
                                createDialog = true;
                            }
                        }
                    }
                } catch (IllegalArgumentException iae) {

                    // MipavUtil.displayError("There was a problem with the supplied name.\n" );
                    Preferences.debug("Illegal Argument Exception in " +
                                      "ViewJFrameImage.isMultipleSameSizeImages(). " +
                                      "Somehow the Image list sent an incorrect name to " +
                                      "the image image hashtable. " + "\n", 1);
                    Preferences.debug("Bad argument.");
                }
            }
        }

        return createDialog;
    }

    /**
     * Method to prepare the second image to be of the same dimensions and same color type (color/gray).
     *
     * @param   image2load   the second image to prepare to be loaded
     * @param   lut          the lut of the second image
     * @param   isFromFrame  true if we're loading this image from another frame
     *
     * @return  did it go okay...
     */
    private ModelImage prepareImages(ModelImage image2load, ModelLUT lut, boolean isFromFrame) {

        ModelImage tempImage = null;

        int[] dims = new int[2];

        dims[0] = getActiveImage().getExtents()[0];
        dims[1] = getActiveImage().getExtents()[1];

        float[] res = new float[2];

        res[0] = getActiveImage().getResolutions(0)[0];
        res[1] = getActiveImage().getResolutions(0)[1];

        // check to see if image2load needs to be changed to to the componentImage's type (color or gray)

        if (getActiveImage().isColorImage() && !image2load.isColorImage()) {
            MipavUtil.displayInfo("Adjusted image will be changed to Color to match reference image");

            AlgorithmRGBConcat mathAlgo = null;

            // change image2load to color
            tempImage = new ModelImage(ModelImage.ARGB, image2load.getExtents(),
                                       JDialogBase.makeImageName(image2load.getImageName(), "_rgb"));

            // get some important information from imageA and put it in
            // the result image
            FileInfoBase fInfoBase = null;

            for (int n = 0; n < image2load.getFileInfo().length; n++) {
                fInfoBase = (FileInfoBase) (image2load.getFileInfo(n).clone());
                fInfoBase.setDataType(tempImage.getType());
                tempImage.setFileInfo(fInfoBase, n);
            }

            // Make algorithm
            mathAlgo = new AlgorithmRGBConcat(image2load, image2load, image2load, tempImage, true,true, 255.0f, true);
            mathAlgo.setRunningInSeparateThread(false);
            mathAlgo.run();

            if (!isFromFrame) {
                image2load.disposeLocal();
                image2load = tempImage;
                tempImage = null;
                image2load.calcMinMax();
            } else {
                tempImage.calcMinMax();
            }

        } else if (!getActiveImage().isColorImage() && image2load.isColorImage()) {
            MipavUtil.displayInfo("Adjusted image will be changed to Gray to match reference image");

            float redValue = 1.0f / 3.0f;
            float greenValue = 1.0f / 3.0f;
            float blueValue = 1.0f / 3.0f;
            float threshold = 1.0f;

            try {

                if (image2load.getType() == ModelStorageBase.ARGB) {
                    tempImage = new ModelImage(ModelImage.UBYTE, image2load.getExtents(),
                                               (image2load.getImageName() + "Gray"));
                } else if (image2load.getType() == ModelStorageBase.ARGB_USHORT) {
                    tempImage = new ModelImage(ModelImage.USHORT, image2load.getExtents(),
                                               (image2load.getImageName() + "Gray"));
                } else if (image2load.getType() == ModelStorageBase.ARGB_FLOAT) {
                    tempImage = new ModelImage(ModelImage.FLOAT, image2load.getExtents(),
                                               (image2load.getImageName() + "Gray"));
                }

                // get some important information from imageA and put it in
                // the result image
                FileInfoBase fInfoBase = null;

                for (int n = 0; n < image2load.getFileInfo().length; n++) {
                    fInfoBase = (FileInfoBase) (image2load.getFileInfo(n).clone());
                    fInfoBase.setDataType(tempImage.getType());
                    tempImage.setFileInfo(fInfoBase, n);
                }

                // Make algorithm
                AlgorithmRGBtoGray RGBAlgo = new AlgorithmRGBtoGray(tempImage, image2load, redValue, greenValue,
                                                                    blueValue, true, threshold, true);

                RGBAlgo.setRunningInSeparateThread(false);
                RGBAlgo.run();

                if (!isFromFrame) {
                    image2load.disposeLocal();
                    image2load = tempImage;
                    image2load.calcMinMax();
                    tempImage = null;
                } else {
                    tempImage.calcMinMax();
                }
            } catch (OutOfMemoryError x) {

                if (tempImage != null) {
                    tempImage.disposeLocal(); // Clean up memory of result image
                    tempImage = null;
                }

                System.gc();
                MipavUtil.displayError("PrepareImages for Registration: RGB to Gray: unable to allocate enough memory");

                return null;
            }
        }

        // dims and res mutch match up... otherwise convert
        if (((dims[0] != image2load.getExtents()[0]) || (dims[1] != image2load.getExtents()[1]))) {
            MipavUtil.displayInfo("Adjusted image will be resized to match reference image");

            TransMatrix xfrm;
            Vector3f center = image2load.getImageCentermm(false);

            xfrm = new TransMatrix(3);
            xfrm.MakeIdentity();

            xfrm.setTranslate(center.X, center.Y);
            xfrm.setTranslate(-center.X, -center.Y);

            AlgorithmTransform trans = null;

            if (!isFromFrame) {
                trans = new AlgorithmTransform(image2load, xfrm, AlgorithmTransform.BSPLINE3, res[0], res[1], dims[0],
                                               dims[1], false, false, false);
                trans.setRunningInSeparateThread(false);
                trans.run();
                image2load.disposeLocal();
                image2load = trans.getTransformedImage();
                image2load.calcMinMax();
                trans.finalize();
                trans = null;

                ViewJFrameImage newFrame = new ViewJFrameImage(image2load, lut);

                return image2load;
            } else {

                if (tempImage != null) {
                    trans = new AlgorithmTransform(tempImage, xfrm, AlgorithmTransform.BSPLINE3, res[0], res[1],
                                                   dims[0], dims[1], false, false, false);
                    trans.setRunningInSeparateThread(false);
                    trans.run();
                    tempImage.disposeLocal();
                } else {
                    trans = new AlgorithmTransform(image2load, xfrm, AlgorithmTransform.BSPLINE3, res[0], res[1],
                                                   dims[0], dims[1], false, false, false);
                    trans.setRunningInSeparateThread(false);
                    trans.run();
                }

                tempImage = trans.getTransformedImage();
                tempImage.calcMinMax();
                trans.finalize();
                trans = null;

                ViewJFrameImage newFrame = new ViewJFrameImage(tempImage, lut);

                return tempImage;
            }
        }

        return image2load;
    }

    /**
     * Subsample image to Power of 2.
     *
     * @param   _imageA  imageA for now.
     * @param   _imageB  the second image.
     *
     * @return  the subsampled image(s) in a new frame
     */
    private ViewJFrameCardiology subSampleImage(ModelImage _imageA, ModelImage _imageB) {
        int[] extents;
        float[] res;
        int[] volExtents = new int[3];
        float[] resols = new float[3];
        boolean forceResample = false;
        ViewJFrameCardiology tempFrame;
        ModelImage resultImgA = null, resultImgB = null;

        // Vector             frameList;
        // frameList = _imageA.getImageFrameVector();

        extents = _imageA.getExtents();
        res = _imageA.getFileInfo(0).getResolutions();

        for (int i = 0; i < extents.length; i++) {
            volExtents[i] = dimPowerOfTwo(extents[i]);
            resols[i] = (res[i] * extents[i]) / volExtents[i];
        }

        // check to see the image is Power of 2 or not.
        if (extents.length >= 3) {

            if ((extents[0] == volExtents[0]) && (extents[1] == volExtents[1])) {
                forceResample = false;
            } else {
                forceResample = true;
            }
        } else {

            if ((extents[0] == volExtents[0]) && (extents[1] == volExtents[1])) {
                forceResample = false;
            } else {
                forceResample = true;
            }
        }

        // is Power of 2, return.  Do not do resampling.
        if (!forceResample) {
            return null;
        }

        /*
         * xDim = dimPowerOfTwo(xDim); yDim = dimPowerOfTwo(yDim); zDim = dimPowerOfTwo(zDim);
         */
        AlgorithmTransform transformImg = new AlgorithmTransform(imageA, new TransMatrix(4),
                                                                 AlgorithmTransform.TRILINEAR, resols[0], resols[1],
                                                                 resols[2], volExtents[0], volExtents[1], volExtents[2],
                                                                 false, true, false);

        transformImg.setRunningInSeparateThread(false);
        transformImg.run();
        resultImgA = transformImg.getTransformedImage();
        resultImgA.calcMinMax();

        if (_imageB != null) {
            extents = _imageB.getExtents();
            res = _imageB.getFileInfo(0).getResolutions();

            for (int i = 0; i < extents.length; i++) {
                volExtents[i] = dimPowerOfTwo(extents[i]);
                resols[i] = (res[i] * extents[i]) / volExtents[i];
            }

            AlgorithmTransform transformImgB = new AlgorithmTransform(imageB, new TransMatrix(4),
                                                                      AlgorithmTransform.TRILINEAR, resols[0],
                                                                      resols[1], resols[2], volExtents[0],
                                                                      volExtents[1], volExtents[2], false, true, false);

            transformImgB.setRunningInSeparateThread(false);
            transformImgB.run();
            resultImgB = transformImgB.getTransformedImage();
            resultImgB.calcMinMax();
            transformImgB.finalize();
            transformImgB = null;
        }

        transformImg.finalize();
        transformImg = null;
        // show image frame

        return new ViewJFrameCardiology(resultImgA, null, new Dimension(200, 200));

    }

    //~ Inner Classes --------------------------------------------------------------------------------------------------

    /**
     * Pick up the selected color and call method to change the VOI color.
     */
    class OkColorListener implements ActionListener {

        /**
         * DOCUMENT ME!
         *
         * @param  e  DOCUMENT ME!
         */
        public void actionPerformed(ActionEvent e) {
            Color color = colorChooser.getColor();

            getActiveImage().notifyImageDisplayListeners(null, false);
        }
    }

}
