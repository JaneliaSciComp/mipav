void v_SurfaceExtract
(
    in float4        kModelPosition  : POSITION,
    in float3        kInBaseTCoord : TEXCOORD0,
    out float4       kClipPosition : POSITION,
    out float3       kOutBaseTCoord : TEXCOORD0,
    uniform float4x4 WVPMatrix)
{
    // Transform the position from model space to clip space.
    kClipPosition = mul(kModelPosition,WVPMatrix);

    // Pass through the texture coordinate.
    kOutBaseTCoord = kInBaseTCoord;
}

/**
 * Clip the volume based on the x,y,z axes.
 * returns 1 when the volume is clipped, 0 when not clipped.
 */
bool myClip(float3 vec,
            float clipX,
            float clipXInv,
            float clipY,
            float clipYInv,
            float clipZ,
            float clipZInv )
{
    if ( vec.x > clipX )
    {
        return 1;
    }
    if ( vec.x < clipXInv )
    {
        return 1;
    }
    if ( vec.y > clipY )
    {
        return 1;
    }
    if ( vec.y < clipYInv )
    {
        return 1;
    }
    if ( vec.z > clipZ )
    {
        return 1;
    }
    if ( vec.z < clipZInv )
    {
        return 1;
    }
    return 0;
}

void p_SurfaceExtract(  in float3 inTexCoord1    : TEXCOORD0,
                     out float4 kColor	    : COLOR0,
                     uniform sampler3D VolumeImageA : TEXUNIT1, 
                     uniform sampler1D OpacityMapA : TEXUNIT3, 
                        uniform sampler3D VolumeImageA_GM : TEXUNIT4, 
                        uniform sampler1D OpacityMapA_GM : TEXUNIT5, 
                        uniform float GradientMagnitude,
                     uniform float DoClip,
                     uniform float clipX,
                     uniform float clipXInv,
                     uniform float clipY,
                     uniform float clipYInv,
                     uniform float clipZ,
                     uniform float clipZInv,
                     uniform float4 clipArb,
                     uniform float4 clipEye,
                     uniform float4 clipEyeInv,
                     uniform float4x4 WVPMatrix)
{
    // current position along the ray: 
    float3 position = inTexCoord1;

    bool bClipped = false;
    float4 color = (0,0,0,0);
    float4 colorGM = (0,0,0,0);
    float opacity = 0;
    float opacityGM = 0;

    // axis-aligned clipping:
    if ( (DoClip != 0) && myClip( position, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
    {
        bClipped = true;
    }
    else
    {
        bClipped = false;
        if ( DoClip != 0 )
        {
            // eye clipping and arbitrary clipping:
            float4 aPosition = float4(0,0,0,0);
            aPosition.xyz = position.xyz - (.5,.5,.5);
            aPosition = mul( aPosition, WVPMatrix );
            aPosition.xyz = aPosition.xyz + (.5,.5,.5);
            float fDot = dot( aPosition.xyz, clipEye.xyz );
            float fDotInv = dot( aPosition.xyz, clipEyeInv.xyz );
            float fDotArb = dot( position.xyz, clipArb.xyz );
            if ( (fDot < clipEye.w) || (fDotInv > clipEyeInv.w) || (fDotArb > clipArb.w) )
            {
                bClipped = true;
            }
        }
    }
    kColor.a = 1;
    if ( bClipped )
    {
        kColor.r = 0;
        kColor.g = 0;
        kColor.b = 0;
    }
    // The value is not clipped, compute the color:
    else if ( !bClipped )
    {
        color = tex3D(VolumeImageA,position);
        opacity = tex1D(OpacityMapA,color.r).r;
        if ( GradientMagnitude != 0 )
        {
            colorGM = tex3D(VolumeImageA_GM,position);
            opacityGM = tex1D(OpacityMapA_GM,colorGM.r).r;
            opacity = opacity * opacityGM;
        }
        // If the opacity is not zero:
        if ( opacity > 0 )
        {
            kColor.r = 1;
            kColor.g = 1;
            kColor.b = 1;
        }
    }
}
