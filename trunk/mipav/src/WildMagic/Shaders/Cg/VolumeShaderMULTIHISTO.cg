/**
 * Clip the volume based on the x,y,z axes.
 * returns 1 when the volume is clipped, 0 when not clipped.
 */
bool myClip(float3 vec,
            float clipX,
            float clipXInv,
            float clipY,
            float clipYInv,
            float clipZ,
            float clipZInv )
{
    if ( vec.x > clipX )
    {
        return 1;
    }
    if ( vec.x < clipXInv )
    {
        return 1;
    }
    if ( vec.y > clipY )
    {
        return 1;
    }
    if ( vec.y < clipYInv )
    {
        return 1;
    }
    if ( vec.z > clipZ )
    {
        return 1;
    }
    if ( vec.z < clipZInv )
    {
        return 1;
    }
    return 0;
}
//----------------------------------------------------------------------------
float computeX( 
               in float         fY,
               uniform float4    LevLine )
{
    float x0 = LevLine.x;
    float y0 = LevLine.y;
    float x1 = LevLine.z;
    float y1 = LevLine.w;
    float t = (y0 - fY)/(y0 - y1);
    float x = x0 - x0 * t + x1 * t;
    return x;
}
//----------------------------------------------------------------------------
float computeAlpha( 
                   in float         fX,
                   in float         fY,
                   uniform float4    LevMidLine,
                   uniform float4    LevLeftLine,
                   uniform float4    LevRightLine )
{
    if ( (fY < LevLeftLine.y) || fY > LevLeftLine.w )
    {
        return 0;
    }
    float xMid = LevMidLine.x;
    float fShiftL = 0;
    float fShiftR = 0;
    float fShiftX = 0;
    float fIncr = 0;
    if ( LevMidLine.y != LevMidLine.w )
    {
        xMid = computeX( fY, LevMidLine );
    }
    else
    {
        fIncr = (LevMidLine.y - LevLeftLine.y)/(LevLeftLine.w-LevLeftLine.y);
        fIncr = fIncr * (LevRightLine.x - LevLeftLine.x);
        fShiftX = (LevMidLine.x - LevLeftLine.x)/(LevRightLine.x-LevLeftLine.x);
        fShiftL = (fShiftX)*fIncr;
        fShiftR = (1-fShiftX)*fIncr;
    }
    float xLeft = computeX( fY, LevLeftLine );
    float xRight = computeX( fY, LevRightLine );
    
    float fAlpha = 0.0;
    if ( (fX > (xMid - fShiftL)) && (fX < (xMid + fShiftR)) )
    {
        fAlpha = 1.0;
    }
    if ( (fX <= (xMid-fShiftL)) && (fX >= xLeft) )
    {
        fAlpha = (fX - xLeft) / ((xMid-fShiftL) - xLeft);
    }
    else if ( (fX >= (xMid+fShiftR)) && (fX <= xRight) )
    {
        fAlpha = (fX - xRight) / ((xMid+fShiftR) - xRight);
    }
    return fAlpha;
}
//----------------------------------------------------------------------------
void p_VolumeShaderMULTIHISTO(  in float3 inTexCoord1    : TEXCOORD0,
                         in float4 inPos,
                         out float4 kColor	    : COLOR0,
                         uniform sampler2D SceneImage : TEXUNIT0, 

                         uniform sampler3D VolumeImageA : TEXUNIT1, 
                         uniform sampler1D ColorMapA : TEXUNIT2, 
                         uniform sampler1D OpacityMapA : TEXUNIT3, 
                         uniform sampler3D NormalMapA: TEXUNIT4, 
                         uniform sampler3D VolumeImageGMA: TEXUNIT5, 
                         uniform sampler1D OpacityMapA_GM : TEXUNIT6, 
                         uniform sampler3D VolumeImageGMGMA: TEXUNIT7, 

                         uniform sampler3D VolumeImageB : TEXUNIT8, 
                         uniform sampler1D ColorMapB : TEXUNIT9, 
                         uniform sampler1D OpacityMapB : TEXUNIT10, 
                         uniform sampler3D NormalMapB: TEXUNIT11, 
                         uniform sampler3D VolumeImageGMB: TEXUNIT12, 
                         uniform sampler1D OpacityMapB_GM : TEXUNIT13, 
                         uniform sampler3D VolumeImageGMGMB: TEXUNIT14, 

                         uniform float ShowB,
                         uniform float ABBlend,

                                uniform float BoundaryEmphasis0,

                                uniform float4    LevColor0,
                                uniform float4    LevMidLine0,
                                uniform float4    LevLeftLine0,
                                uniform float4    LevRightLine0,

                                uniform float4    LevColor1,
                                uniform float4    LevMidLine1,
                                uniform float4    LevLeftLine1,
                                uniform float4    LevRightLine1,

                                uniform float4    LevColor2,
                                uniform float4    LevMidLine2,
                                uniform float4    LevLeftLine2,
                                uniform float4    LevRightLine2,

                                uniform float4    LevColor3,
                                uniform float4    LevMidLine3,
                                uniform float4    LevLeftLine3,
                                uniform float4    LevRightLine3,

                                uniform float4    LevColor4,
                                uniform float4    LevMidLine4,
                                uniform float4    LevLeftLine4,
                                uniform float4    LevRightLine4,

                                uniform float4    LevColor5,
                                uniform float4    LevMidLine5,
                                uniform float4    LevLeftLine5,
                                uniform float4    LevRightLine5,

                                uniform float4    LevColor6,
                                uniform float4    LevMidLine6,
                                uniform float4    LevLeftLine6,
                                uniform float4    LevRightLine6,

                                uniform float4    LevColor7,
                                uniform float4    LevMidLine7,
                                uniform float4    LevLeftLine7,
                                uniform float4    LevRightLine7,

                                uniform float4    LevColor8,
                                uniform float4    LevMidLine8,
                                uniform float4    LevLeftLine8,
                                uniform float4    LevRightLine8,

                                uniform float4    LevColor9,
                                uniform float4    LevMidLine9,
                                uniform float4    LevLeftLine9,
                                uniform float4    LevRightLine9,


                         uniform float blend,
                         uniform float stepsize,
                         uniform float4 steps,
                         uniform float IsColor,
                         uniform float DoClip,
                         uniform float4 BackgroundColor,
                         uniform float clipX,
                         uniform float clipXInv,
                         uniform float clipY,
                         uniform float clipYInv,
                         uniform float clipZ,
                         uniform float clipZInv,
                         uniform float4 clipArb,
                         uniform float4 clipEye,
                         uniform float4 clipEyeInv,
                         uniform float4x4 WVPMatrix)
{
    // find the right place to lookup in the backside buffer
    float2 texc = ((inPos.xy / inPos.w) + 1) / 2.0;
    float4 back_position  = tex2D(SceneImage, texc);

    // the start position of the ray is stored in the texture coordinate
    float3 start = inTexCoord1; 

    // the ray direction
    float3 dir = back_position.xyz - start;

    // the length from front to back is calculated and used to terminate the ray
    float len = length(dir.xyz); 

    // normalized direction vector:
    float3 norm_dir = normalize(dir);

    // current position along the ray: 
    float3 position = start.xyz;

    // The accumulated color and alpha values:
    float4 color_acc = float4(0,0,0,0);
    float alpha_acc = 0;

    // output color:
    kColor = BackgroundColor;
    if ( (back_position.x == 0) && (back_position.y == 0) && (back_position.z == 0) )
    {
        kColor.a = 0;
        return;
    }

    // limit the number of iterations to STEPS, make sure that the stepsize will
    // cover the entire ray:
//     if ( (len/stepsize) > steps[0] )
//     {
        stepsize = 1.732/steps[0];
//     }

    // The color at the current position along the ray:
    float4 color;
    color.r = 0;
    color.g = 0;
    color.b = 0;
    color.a = 0;
    float4 colorGM = color;
    float4 color2nd = color;

    // The opacity at the current position along the ray:
    float opacity = 0;

    float delta = stepsize;
    float3 delta_dir = norm_dir * delta;
    float delta_dir_len = length(delta_dir);
    float length_acc = 0;
    bool bClipped = false;

    float fMapX, fMapY;
    float fBoundary;

    // For some profiles the number of loop iterations must be determined at
    // compile time:
    for( int i = 0; i < 450; i++ )
    {
        // axis-aligned clipping:
        if ( (DoClip != 0) &&
             myClip( position, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
        {
            color = float4(0,0,0,0);
            opacity = 0;
        }
        else
        {
            bClipped = false;
            if ( DoClip != 0 )
            {
                // eye clipping and arbitrary clipping:
                float4 aPosition = float4(0,0,0,0);
                aPosition.xyz = position.xyz - (.5,.5,.5);
                aPosition = mul( aPosition, WVPMatrix );
                aPosition.xyz = aPosition.xyz + (.5,.5,.5);
                // eye clip:
                float fDot = dot( aPosition.xyz, clipEye.xyz );
                // eey inverse clip:
                float fDotInv = dot( aPosition.xyz, clipEyeInv.xyz );
                // arbitrary clip:
                float fDotArb = dot( position.xyz, clipArb.xyz );
                if ( (fDot < clipEye.w) ||
                     (fDotInv > clipEyeInv.w) ||
                     (fDotArb > clipArb.w) )
                {
                    color = float4(0,0,0,0);
                    opacity = 0;
                    bClipped = true;
                }
            }
            // The value is not clipped, compute the color:
            if ( !bClipped )
            {
                color = tex3D(VolumeImageA,position);
                colorGM = tex3D(VolumeImageGMA,position);
                color2nd = tex3D(VolumeImageGMGMA,position);

                fMapX = color.r;
                fMapY = colorGM.r;
                fBoundary = color2nd.r;

                opacity =
                    computeAlpha( fMapX, fMapY, LevMidLine0, LevLeftLine0, LevRightLine0 );
                color.r = LevColor0.r * opacity;
                color.g = LevColor0.g * opacity;
                color.b = LevColor0.b * opacity;
                opacity *= LevColor0.a;
                opacity *= (BoundaryEmphasis0*fBoundary);
                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

                opacity = computeAlpha( fMapX, fMapY, LevMidLine1, LevLeftLine1, LevRightLine1 );
                color.r = LevColor1.r * opacity;
                color.g = LevColor1.g * opacity;
                color.b = LevColor1.b * opacity;
                opacity *= LevColor1.a;
                
                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

                opacity = computeAlpha( fMapX, fMapY, LevMidLine2, LevLeftLine2, LevRightLine2 );
                color.r = LevColor2.r * opacity;
                color.g = LevColor2.g * opacity;
                color.b = LevColor2.b * opacity;
                opacity *= LevColor2.a;

                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

                opacity = computeAlpha( fMapX, fMapY, LevMidLine3, LevLeftLine3, LevRightLine3 );
                color.r = LevColor3.r * opacity;
                color.g = LevColor3.g * opacity;
                color.b = LevColor3.b * opacity;
                opacity *= LevColor3.a;

                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

                opacity = computeAlpha( fMapX, fMapY, LevMidLine4, LevLeftLine4, LevRightLine4 );
                color.r = LevColor4.r * opacity;
                color.g = LevColor4.g * opacity;
                color.b = LevColor4.b * opacity;
                opacity *= LevColor4.a;

                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

                opacity = computeAlpha( fMapX, fMapY, LevMidLine5, LevLeftLine5, LevRightLine5 );
                color.r = LevColor5.r * opacity;
                color.g = LevColor5.g * opacity;
                color.b = LevColor5.b * opacity;
                opacity *= LevColor5.a;

                // If the opacity is not zero:
                if ( opacity > 0 )
                {
                    color_acc += (1.0 - alpha_acc) * color * opacity;
                    alpha_acc += (1 - alpha_acc) * opacity;
                }

            }
        }

        // Increment position along the ray:
        position.x += delta_dir.x;
        position.y += delta_dir.y;
        position.z += delta_dir.z;
        length_acc += delta_dir_len;
        // Break when the end of the ray is reached
        if ( length_acc >= len )
        {
            break;
        }
        if ( alpha_acc >= 1.0 )
        {
            alpha_acc = 1.0;
            break;
        }
    } 

    // Blend with the background color:
    kColor.rgb = alpha_acc * color_acc.rgb + (1-alpha_acc)*BackgroundColor.rgb;
    kColor.a = blend * alpha_acc;
}
