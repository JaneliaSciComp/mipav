/**
 * Clip the volume based on the x,y,z axes.
 * returns 1 when the volume is clipped, 0 when not clipped.
 */
bool myClip(float3 vec,
            float clipX,
            float clipXInv,
            float clipY,
            float clipYInv,
            float clipZ,
            float clipZInv )
{
    if ( vec.x > clipX )
    {
        return 1;
    }
    if ( vec.x < clipXInv )
    {
        return 1;
    }
    if ( vec.y > clipY )
    {
        return 1;
    }
    if ( vec.y < clipYInv )
    {
        return 1;
    }
    if ( vec.z > clipZ )
    {
        return 1;
    }
    if ( vec.z < clipZInv )
    {
        return 1;
    }
    return 0;
}


/** Raycasting fragment program implementation */
void p_VolumeShaderMIP_MIP(  in float3 inTexCoord1    : TEXCOORD0,
                            in float4 inPos,
                            out float4 kColor	    : COLOR0,
                            uniform sampler2D tex, 
                            uniform sampler3D volume_texA, 
                            uniform sampler1D colormapA, 
                            uniform sampler1D opacitymapA, 
                            uniform sampler3D volume_texB, 
                            uniform sampler1D colormapB, 
                            uniform sampler1D opacitymapB, 
                                 uniform float stepsize,
								 uniform float4 steps,
                                 uniform float blend,
                                 uniform float IsColorA,
                                 uniform float IsColorB,
                                 uniform float DoClip,
                             uniform float4 BackgroundColor,
                             uniform float GradientMagnitude,
                                 uniform float clipX,
                                 uniform float clipXInv,
                                 uniform float clipY,
                                 uniform float clipYInv,
                                 uniform float clipZ,
                                 uniform float clipZInv,
                                 uniform float4 clipArb,
                                 uniform float4 clipEye,
                                 uniform float4 clipEyeInv,
                                 uniform float4x4 WVPMatrix)
{
    // find the right place to lookup in the backside buffer
    float2 texc = ((inPos.xy / inPos.w) + 1) / 2.0;
    float4 back_position  = tex2D(tex, texc);

    // the start position of the ray is stored in the texturecoordinate
    float3 start = inTexCoord1; 

    // the ray direction
    float3 dir = back_position.xyz - start;

    // the length from front to back is calculated and used to terminate the ray
    float len = length(dir.xyz); 

    // normalized direction vector:
    float3 norm_dir = normalize(dir);

    // current position along the ray: 
    float3 position = start.xyz;

    // output color:
    kColor = BackgroundColor;
    if ( (back_position.x == 0) && (back_position.y == 0) && (back_position.z == 0) )
    {
        return;
    }

    // limit the number of iterations to STEPS, make sure that the stepsize will
    // cover the entire ray:
    if ( (len/stepsize) > steps[0] )
    {
        stepsize = len/steps[0];
    }

    // The color at the current position along the ray:
    float4 colorA = (0,0,0,0);
    float4 colorB = (0,0,0,0);

    // The opacity at the current position along the ray:
    float opacityA = 0;
    float opacityB = 0;

    // Maximum value along the ray for MIP
    float fMaxA = 0;
    // Intensity value of color:
    float intensity_colorA = 0;
    // maximum color value along the ray
    float3 color_maxA = (0,0,0);

    // Maximum value along the ray for MIP
    float fMaxB = 0;
    // Intensity value of color:
    float intensity_colorB = 0;
    // maximum color value along the ray
    float3 color_maxB = (0,0,0);


    float delta = stepsize;
    float3 delta_dir = norm_dir * delta;
    float delta_dir_len = length(delta_dir);
    float length_acc = 0;
    bool bClipped = false;

    // For some profiles the number of loop iterations must be determined at
    // compile time:
    for( int i = 0; i < steps[0]; i++ )
    {
        // axis-aligned clipping:
        if ( (DoClip != 0) && myClip( position, clipX, clipXInv, clipY, clipYInv, clipZ, clipZInv ) )
        {
            colorA = (0,0,0,0);
            opacityA = 0;

            colorB = (0,0,0,0);
            opacityB = 0;
        }
        else
        {
            bClipped = false;
            if ( DoClip != 0 )
            {
                // eye clipping and arbitrary clipping:
                float4 aPosition = float4(0,0,0,0);
                aPosition.xyz = position.xyz - (.5,.5,.5);
                aPosition = mul( aPosition, WVPMatrix );
                aPosition.xyz = aPosition.xyz + (.5,.5,.5);
                float fDot = dot( aPosition.xyz, clipEye.xyz );
                float fDotInv = dot( aPosition.xyz, clipEyeInv.xyz );
                float fDotArb = dot( position.xyz, clipArb.xyz );
                if ( (fDot < clipEye.w) || (fDotInv > clipEyeInv.w) || (fDotArb > clipArb.w) )
                {
                    colorA = (0,0,0,0);
                    opacityA = 0;
                    
                    colorB = (0,0,0,0);
                    opacityB = 0;
                    bClipped = true;
                }
            }
            // The value is not clipped, compute the color:
            if ( !bClipped )
            {
                colorA = tex3D(volume_texA,position);
                opacityA = tex1D(opacitymapA,colorA.r).r;

                colorB = tex3D(volume_texB,position);
                opacityB = tex1D(opacitymapB,colorB.r).r;
            }
        }
        // If the opacity is not zero:
        if ( opacityA > 0 )
        {
            // MIP: Store the maximum value:
            intensity_colorA = dot(colorA.rgb, (.3,.3,.3));
            if ( intensity_colorA > fMaxA ) 
            {
                fMaxA = intensity_colorA;
                color_maxA.rgb = colorA.rgb;
            }
        }
        if ( opacityB > 0 )
        {
            // MIP: Store the maximum value:
            intensity_colorB = dot(colorB.rgb, (.3,.3,.3));
            if ( intensity_colorB > fMaxB ) 
            {
                fMaxB = intensity_colorB;
                color_maxB.rgb = colorB.rgb;
            }
        }
        // Break early if the max is >= 1
        if ( (fMaxA>=1) && (fMaxB>=1))
        {
            break;
        }
        // Increment position along the ray:
        position += delta_dir;
        length_acc += delta_dir_len;
        // Break when the end of the ray is reached, or if alpha >= 1;
        if ( length_acc >= len )
        {
            break;
        }
    } 

    if ( IsColorA != 0 )
    {
        kColor.r = blend * tex1D(colormapA,color_maxA.r).r;
        kColor.g = blend * tex1D(colormapA,color_maxA.g).g;
        kColor.b = blend * tex1D(colormapA,color_maxA.b).b;
    }
    else
    {
        kColor.rgb = blend * tex1D(colormapA,fMaxA).rgb;
    }


    if ( IsColorB != 0 )
    {
        kColor.r += (1 - blend) * tex1D(colormapB,color_maxB.r).r;
        kColor.g += (1 - blend) * tex1D(colormapB,color_maxB.g).g;
        kColor.b += (1 - blend) * tex1D(colormapB,color_maxB.b).b;
    }
    else
    {
        kColor.rgb += (1 - blend) * tex1D(colormapB,fMaxB).rgb;
    }
    float fMax = blend * fMaxA + (1 - blend) * fMaxB;
    kColor = fMax * kColor + (1 - fMax) * BackgroundColor;
    kColor.a = 1;
}
