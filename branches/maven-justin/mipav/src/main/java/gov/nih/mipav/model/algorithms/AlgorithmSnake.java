package gov.nih.mipav.model.algorithms;

import WildMagic.LibFoundation.Mathematics.Vector2f;
import WildMagic.LibFoundation.Mathematics.Vector3f;

import gov.nih.mipav.util.MipavMath;
import gov.nih.mipav.model.structures.*;

import gov.nih.mipav.view.*;

import java.awt.*;

import java.io.*;

import java.util.*;


/**
 * Snake-like algorithm deriviative. The algorithm is supplied a polygon (VOI - contour) and that polygon is allowed to
 * evolve to the edge of the object generated by calculating the gradient magnitude (i.e. the energy function) at scale
 * define by the user. The user/programmer supplies the sigmas (scales) at which to calculate the gradient magnitude. A
 * large scale slows the snake and causes the snake to conform to large scale structure. A small sigma value causes the
 * snake to conform to the small scale structure is therefore more sensitive to noise. The three-dimensional version is
 * really a two-and-half dimensional algorithm where the resultant contour in a slice is projected into the adjacent
 * slice and is used as an initialization to the evolution in the new slice.
 *
 * @version  0.1 Feb 11, 1998
 * @author   Matthew J. McAuliffe, Ph.D.
 * @see      AlgorithmBSpline
 * @see      GenerateGaussian
 * @see      AlgorithmVOISimplexOpt
 * @see      AlgorithmBSnake
 */
public class AlgorithmSnake extends AlgorithmBase {

    //~ Static fields/initializers -------------------------------------------------------------------------------------

    /** Do not propagate the VOI to any slices (2D). */
    public static final int PROP_SINGLE = 0;

    /** Propagate the source VOI to slices above its current slice in the volume. */
    public static final int PROP_NEXT = 1;

    /** Propagate the source VOI to slices below its current slice in the volume. */
    public static final int PROP_PREV = 2;

    /** Propagate the source VOI to slices above and below its current slice. */
    public static final int PROP_ALL = 3;

    /** Indicates boundary can move in or out. */
    public static final int ANY_DIR = 0;

    /** Indicates boundary can move in. */
    public static final int IN_DIR = 1;

    /** Indicates boundary can move out. */
    public static final int OUT_DIR = 2;

    /** The maximum ratio of change in the energy under the VOI after propagation. */
    private static final float PROP_THRESHOLD = 0.5f;

    //~ Instance fields ------------------------------------------------------------------------------------------------

    /** Maximum number of snake iterations. */
    private int boundaryIterations = 20;

    /** Indicates boundary how the VOI boundary can move - in and/or out. */
    private int evolveDirection = ANY_DIR;

    /** Storage location of the first derivative of the Gaussian in the X direction. */
    private float[] GxData;

    /** Storage location of the first derivative of the Gaussian in the Y direction. */
    private float[] GyData;

    /** Storage location of the first derivative of the Gaussian in the Z direction. */
    private float[] GzData;

    /** Dimensionality of the kernel. */
    private int[] kExtents;

    /** The VOI propagation mode to use. */
    private int propagationType = PROP_ALL;

    /** The resultant polygon and the evolution has completed. */
    private VOI resultVOI;

    /** Standard deviations of the gaussian used to calculate the kernels. */
    private float[] sigmas;

    /** The maximum angle we want to have between points in the result VOI. */
    private float smoothness;

    /** Source image. */
    private ModelImage srcImage;

    /** The initial VOI to initialize the evolution process. */
    private VOI srcVOI;

    //~ Constructors ---------------------------------------------------------------------------------------------------

    /**
     * Set up the snake algorithm so that it can be run.
     *
     * @param  _srcImg              2D or 3D source image
     * @param  _sigmas              describe the scale of the gaussian in each dimension
     * @param  _boundaryIterations  maximum number of snake iterations
     * @param  _smoothness          the boundary smoothness parameter
     * @param  srcVOI               VOI that is to be evolved
     * @param  boundDir             indicates the boundary direction (in and/or out)
     */
    public AlgorithmSnake(ModelImage _srcImg, float[] _sigmas, int _boundaryIterations, float _smoothness, VOI srcVOI,
            int boundDir) {

        srcImage = _srcImg;
        sigmas = _sigmas;
        boundaryIterations = _boundaryIterations;
        smoothness = _smoothness;
        evolveDirection = boundDir;

        this.srcVOI = srcVOI;

        if (srcImage.getNDims() == 2) {
            makeKernels2D();
            resultVOI = new VOI((short) srcImage.getVOIs().size(), "SnakeVOI", VOI.CONTOUR, -1.0f);

        } else if (srcImage.getNDims() > 2) {

            if (sigmas[2] == 0.0f) {
                makeKernels2D();
            } else {
                makeKernels3D();
            }

            resultVOI = new VOI((short) srcImage.getVOIs().size(), "snakeVOI", VOI.CONTOUR,
                    -1.0f);
        }
    }

    //~ Methods --------------------------------------------------------------------------------------------------------

    /**
     * Prepares this class for destruction.
     */
    public void finalize() {
        GxData = null;
        GyData = null;
        GzData = null;
        srcImage = null;
        sigmas = null;
        kExtents = null;
        super.finalize();
    }

    /**
     * Returns the resultant VOI.
     *
     * @return  resultant VOI that has localized to the boundaries of the object
     */
    public VOI getResultVOI() {
        return resultVOI;
    }

    /**
     * run - starts the snake algorithm.
     */
    public void runAlgorithm() {

        if (srcImage == null) {
            displayError("Source Image is null");

            return;
        }
        if (srcImage.getNDims() == 2) {
            calc2D();
        } else if (srcImage.getNDims() > 2) {
            calc3D();
        }
    }

    /**
     * Sets the propagation type.
     *
     * @param  type  if PROP_ALL, result contour from a slice is propagated to the adjacent slice and used to initialize
     *               the snake algorithm for that slice. If PROP_NEXT, result contour from the original slice is
     *               propagated to the next slice and used to initialize the snake algorithm for that slice. If
     *               PROP_PREV, result contour from the orginal slice is propagated to the previous slice. If
     *               PROP_SINGLE, the snake algorithm stops after optimizing the boundary in the present slice.
     */
    public void setPropagation(int type) {
        propagationType = type;
    }

    /**
     * Prepares the data and runs the algorithm for a 2D image.
     */
    private void calc2D() {

        float[] imgBuffer;
        int xDim, yDim, length;
        float[] xPoints = null;
        float[] yPoints = null;
        float[] zPoints = null;
        Vector<VOIBase> contours;
        int nContours;

        xDim = srcImage.getExtents()[0];
        yDim = srcImage.getExtents()[1];

        try {
            length = xDim * yDim;
            imgBuffer = new float[length];
            srcImage.exportData(0, length, imgBuffer); // locks and releases lock

            fireProgressStateChanged(srcImage.getImageName(), "Evolving boundary ...");

        } catch (IOException error) {
            displayError("Algorithm Snake: Image(s) locked");
            setCompleted(false);

            return;
        } catch (OutOfMemoryError e) {
            displayError("Algorithm Snake:  Out of Memory");
            setCompleted(false);

            return;
        }

        fireProgressStateChanged(25);

        contours = srcVOI.getCurves();
        nContours = contours.size();
        fireProgressStateChanged(30);

        for (int j = 0; j < nContours; j++) {
            if (((VOIContour) (contours.elementAt(j))).isActive()) {
                ((VOIContour) (contours.elementAt(j))).makeClockwise();

                int nPoints = contours.elementAt(j).size();
                xPoints = new float[nPoints + 2];
                yPoints = new float[nPoints + 2];
                zPoints = new float[nPoints + 2];
                setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));
                VOIContour resultContour = new VOIContour( false, true );
                runSnake(xPoints, yPoints, zPoints, imgBuffer, resultContour );
                resultContour.trimPoints(Preferences.getTrimVoi(),
                            Preferences.getTrimAdjacient());
                if ( resultContour.size() > 0 )
                {
                    resultContour.update();
                    resultVOI.importCurve(resultContour);
                }
            } else {
                resultVOI.importCurve(contours.elementAt(j));
            }

            fireProgressStateChanged(30 + (((j / nContours) - 1) * 70));
        }

        fireProgressStateChanged(100);


        setCompleted(true);

    }

    /**
     * Prepares the data and runs the algorithm for a 3D image.
     */
    private void calc3D() {
        float baseEnergy = 0;
        int baseNPts = 0;

        VOIContour resultContour;
        float[] xPoints, yPoints, zPoints;

        boolean failureFlag = false;

        Vector<VOIBase> contours = srcVOI.getCurves();
        fireProgressStateChanged(30);

        int length;
        float[] imgBuffer;
        try {
            length = srcImage.getSliceSize();
            imgBuffer = new float[length];

            fireProgressStateChanged(srcImage.getImageName(), "Bspline snake: Evolving boundary ...");
            
        } catch (OutOfMemoryError e) {
            displayError("Algorithm Bsnake: Out of memory");
            setCompleted(false);

            return;
        }
        
        int nContours = contours.size();
        for (int j = 0; j < nContours; j++) {
            if (((VOIContour) (contours.elementAt(j))).isActive()) {
                
                ((VOIContour) (contours.elementAt(j))).makeClockwise();
                int nPoints = contours.elementAt(j).size();
                xPoints = new float[nPoints + 2];
                yPoints = new float[nPoints + 2];
                zPoints = new float[nPoints + 2];
                setPoints(xPoints, yPoints, zPoints, contours.elementAt(j));

                try {
                    srcImage.exportData((int)zPoints[0] * length, length, imgBuffer);
                } catch (IOException error) {
                    displayError("Algorithm Bsnake: Image(s) locked");
                    setCompleted(false);

                    return;
                }
                
                resultContour = new VOIContour( false, true );
                baseEnergy = runSnake(xPoints, yPoints, zPoints, imgBuffer, resultContour );
                baseNPts = resultContour.size();
                System.err.println( baseNPts );
                
                
                resultContour.trimPoints(Preferences.getTrimVoi(),
                        Preferences.getTrimAdjacient());
                if ( resultContour.size() > 0 )
                {
                    resultContour.update();
                    resultVOI.importCurve(resultContour);
                }
                if (propagationType != PROP_SINGLE) {
                    propUp( resultContour, resultVOI, baseEnergy, baseNPts );
                    propDown( resultContour, resultVOI, baseEnergy, baseNPts  );
                }
            } else {
                resultVOI.importCurve(contours.elementAt(j));
            }
        }

        fireProgressStateChanged(100);

        if (!failureFlag) {
            setCompleted(true);
        }


    }

    /**
     * Removes points (vectors) that form sharp angles (i.e. smoothes boudnary) Also adds points separated by some
     * distance and removes adjacent points
     *
     * @param   xPts  x coords of points that define a contour
     * @param   yPts  y coords of points that define a contour
     *
     * @return  an ordered list of the points along the cleaned-up line
     */
    private Vector<Vector2f> cleanLine(float[] xPts, float[] yPts) {
        int i;
        double distance;
        float midX, midY;
        Vector<Vector2f> pts = new Vector<Vector2f>(50, 50);

        for (i = 0; i < xPts.length; i++) {
            pts.addElement(new Vector2f(xPts[i], yPts[i]));
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for (i = 1; i < (pts.size() - 1); i++) {

            distance = distance(((Vector2f) (pts.elementAt(i))).X, ((Vector2f) (pts.elementAt(i + 1))).X,
                    ((Vector2f) (pts.elementAt(i))).Y, ((Vector2f) (pts.elementAt(i + 1))).Y);

            if (distance > 3) {
                midX = (float) ((((Vector2f) (pts.elementAt(i))).X + ((Vector2f) (pts.elementAt(i + 1))).X) / 2.0);
                midY = (float) ((((Vector2f) (pts.elementAt(i))).Y + ((Vector2f) (pts.elementAt(i + 1))).Y) / 2.0);

                pts.insertElementAt(new Vector2f(midX, midY), i + 1);
                i--;
            } else if (distance > 1) { }
            else {
                pts.removeElementAt(i + 1);
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;

        end = pts.size() - 2;

        double magV1, magV2;
        double angle;
        double pt1x, pt1y, pt2x, pt2y, pt3x, pt3y;
        double v1x, v1y, v2x, v2y;

        while (flag == true) {
            flag = false;

            for (i = 0; i < end; i++) {

                pt1x = ((Vector2f) (pts.elementAt(i))).X;
                pt1y = ((Vector2f) (pts.elementAt(i))).Y;
                pt2x = ((Vector2f) (pts.elementAt(i + 1))).X;
                pt2y = ((Vector2f) (pts.elementAt(i + 1))).Y;
                pt3x = ((Vector2f) (pts.elementAt(i + 2))).X;
                pt3y = ((Vector2f) (pts.elementAt(i + 2))).Y;

                v1x = pt1x - pt2x;
                v1y = pt1y - pt2y;

                v2x = pt3x - pt2x;
                v2y = pt3y - pt2y;

                magV1 = Math.sqrt((v1x * v1x) + (v1y * v1y));
                v1x = v1x / magV1;
                v1y = v1y / magV1;

                magV2 = Math.sqrt((v2x * v2x) + (v2y * v2y));
                v2x = v2x / magV2;
                v2y = v2y / magV2;

                angle = Math.acos((v1x * v2x) + (v1y * v2y));

                // Smooth points
                if (angle < smoothness) {
                    pts.removeElementAt(i + 1);
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }


    private Vector<Vector3f> cleanLine(float[] xPts, float[] yPts, float[] zPts) {
        int i;
        double distance;
        float midX, midY, midZ;
        Vector<Vector3f> pts = new Vector<Vector3f>(50, 50);

        for (i = 0; i < xPts.length; i++) {
            pts.addElement(new Vector3f(xPts[i], yPts[i], zPts[i]));
        }

        // add points to contour where points are separated by a some distance
        // also remove adjacent points
        for (i = 1; i < (pts.size() - 1); i++) {

            distance = MipavMath.distance( pts.elementAt(i), pts.elementAt(i+1) );

            if (distance > 3) {
                midX = (float) ((((pts.elementAt(i))).X + ((pts.elementAt(i + 1))).X) / 2.0);
                midY = (float) ((((pts.elementAt(i))).Y + ((pts.elementAt(i + 1))).Y) / 2.0);
                midZ = (float) ((((pts.elementAt(i))).Z + ((pts.elementAt(i + 1))).Z) / 2.0);

                pts.insertElementAt(new Vector3f(midX, midY, midZ), i + 1);
                i--;
            } else if (distance > 1) { }
            else {
                pts.removeElementAt(i + 1);
                i--;
            }
        }

        // find angle -- remove points that have too sharp an angle, i.e. smooth boundary
        boolean flag = true;
        int end;

        end = pts.size() - 2;
        double angle;
        Vector3f v1 = new Vector3f();
        Vector3f v2 = new Vector3f();
        while (flag == true) {
            flag = false;

            for (i = 0; i < end; i++) {

                v1.copy( pts.elementAt(i) ).sub( pts.elementAt(i+1) );
                v2.copy( pts.elementAt(i+2) ).sub( pts.elementAt(i+1) );

                v1.normalize();
                v2.normalize();
                angle = Vector3f.angle(v1,v2);
                // Smooth points
                if (angle < smoothness) {
                    pts.removeElementAt(i + 1);
                    i--;
                    end = pts.size() - 2;
                    flag = true;
                }
            }
        }

        return pts;
    }



    /**
     * Calculates the euclidian distance between two points.
     *
     * @param   x1  first x coord.
     * @param   x2  seconde x coord.
     * @param   y1  first y1 coord.
     * @param   y2  seconde y2 coord.
     *
     * @return  the distance between the points <code>(x1,y1)</code> and <code>(x2,y2)</code>
     */
    @SuppressWarnings("unused")
    private double distance(int x1, int x2, int y1, int y2) {
        return Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
    }

    /**
     * Calculates the euclidian distance between two points.
     *
     * @param   x1  first x coord.
     * @param   x2  seconde x coord.
     * @param   y1  first y1 coord.
     * @param   y2  seconde y2 coord.
     *
     * @return  the distance between the points <code>(x1,y1)</code> and <code>(x2,y2)</code>
     */
    private double distance(float x1, float x2, float y1, float y2) {
        return Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
    }

    /**
     * Makes derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels2D() {
        int xkDim, ykDim;
        int[] derivOrder = new int[2];

        kExtents = new int[2];
        derivOrder[0] = 1;
        derivOrder[1] = 0;

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        GxData = new float[xkDim * ykDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);

        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        GyData = new float[xkDim * ykDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);

        Gy.calc(true);
    }

    /**
     * Makes derivative kernels to be used in the calculation of the gradient magnitude.
     */
    private void makeKernels3D() {
        int xkDim, ykDim, zkDim;
        int[] derivOrder = new int[3];

        kExtents = new int[3];

        xkDim = Math.round(5 * sigmas[0]);

        if ((xkDim % 2) == 0) {
            xkDim++;
        }

        kExtents[0] = xkDim;

        ykDim = Math.round(5 * sigmas[1]);

        if ((ykDim % 2) == 0) {
            ykDim++;
        }

        kExtents[1] = ykDim;

        zkDim = Math.round(5 * sigmas[2]);

        if ((zkDim % 2) == 0) {
            zkDim++;
        }

        kExtents[2] = zkDim;

        derivOrder[0] = 1;
        derivOrder[1] = 0;
        derivOrder[2] = 0;
        GxData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gx = new GenerateGaussian(GxData, kExtents, sigmas, derivOrder);

        Gx.calc(false);

        derivOrder[0] = 0;
        derivOrder[1] = 1;
        derivOrder[2] = 0;
        GyData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gy = new GenerateGaussian(GyData, kExtents, sigmas, derivOrder);

        Gy.calc(true);

        derivOrder[0] = 0;
        derivOrder[1] = 0;
        derivOrder[2] = 1;
        GzData = new float[xkDim * ykDim * zkDim];

        GenerateGaussian Gz = new GenerateGaussian(GzData, kExtents, sigmas, derivOrder);

        Gz.calc(true);
    }

    /**
     * Actual function that evolves the boundary by moving normal to the boundary.
     *
     * @param   xPoints    x coordinates that describe the contour
     * @param   yPoints    y coordinates that describe the contour
     * @param   image      image data
     * @param   resultGon  resultant polygon
     *
     * @return  the sum of the energy along the boundary of the <code>resultGon</code>
     */
    @SuppressWarnings("unused")
    private float runSnake(float[] xPoints, float[] yPoints, float[] image, Polygon resultGon) {
        int i, j;
        int nPts;
        Vector2f interpPt = new Vector2f();
        Vector2f inNormPt = new Vector2f();
        Vector2f outNormPt = new Vector2f();
        Vector2f tangentDir = new Vector2f();
        Vector2f normDir = new Vector2f();
        Vector2f normStep = new Vector2f();
        float[] newXPts = null, newYPts = null;
        float normLength;
        float stepPct = (float) 0.45;
        float ix, iy;
        float gradMag, inGradMag, outGradMag;
        float energy = 0, oldEnergy = 0;

        Vector<Vector2f> ptsArray;

        for (int s = 2; s >= 2.0; s--) {

            for (int z = 0; (z < boundaryIterations) && (!threadStopped); z++) {
                energy = 0;

                ptsArray = cleanLine(xPoints, yPoints);

                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];

                for (i = 0; i < ptsArray.size(); i++) {
                    xPoints[i] = ((Vector2f) (ptsArray.elementAt(i))).X;
                    yPoints[i] = ((Vector2f) (ptsArray.elementAt(i))).Y;
                }

                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];

                for (i = 1; i < (nPts - 1); i++) {

                    tangentDir.X = (xPoints[i] - xPoints[i - 1] + xPoints[i + 1] - xPoints[i]) / 2;
                    tangentDir.Y = (yPoints[i] - yPoints[i - 1] + yPoints[i + 1] - yPoints[i]) / 2;

                    interpPt.X = xPoints[i];
                    interpPt.Y = yPoints[i];

                    normLength = (float) Math.sqrt((tangentDir.X * tangentDir.X) + (tangentDir.Y * tangentDir.Y));
                    normDir.X = -tangentDir.Y / normLength;
                    normDir.Y = tangentDir.X / normLength;

                    normStep.X = stepPct * normDir.X;
                    normStep.Y = stepPct * normDir.Y;

                    outNormPt.X = -normStep.X + interpPt.X;
                    outNormPt.Y = -normStep.Y + interpPt.Y;

                    inNormPt.X = normStep.X + interpPt.X;
                    inNormPt.Y = normStep.Y + interpPt.Y;

                    ix = AlgorithmConvolver.convolve2DPt(interpPt, srcImage.getExtents(), image, kExtents, GxData);
                    iy = AlgorithmConvolver.convolve2DPt(interpPt, srcImage.getExtents(), image, kExtents, GyData);

                    // gradMag = (float)Math.sqrt(ix*ix + iy*iy);
                    gradMag = ((ix * ix) + (iy * iy));

                    if (evolveDirection == OUT_DIR) {
                        inGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt(inNormPt, srcImage.getExtents(), image, kExtents, GxData);
                        iy = AlgorithmConvolver.convolve2DPt(inNormPt, srcImage.getExtents(), image, kExtents, GyData);

                        // inGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        inGradMag = ((ix * ix) + (iy * iy));
                    }

                    if (evolveDirection == IN_DIR) {
                        outGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt(outNormPt, srcImage.getExtents(), image, kExtents, GxData);
                        iy = AlgorithmConvolver.convolve2DPt(outNormPt, srcImage.getExtents(), image, kExtents, GyData);

                        // outGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        outGradMag = ((ix * ix) + (iy * iy));
                    }

                    if ((outGradMag > gradMag) || (inGradMag > gradMag)) {

                        if (outGradMag > inGradMag) {
                            newXPts[i] = outNormPt.X;
                            newYPts[i] = outNormPt.Y;
                            energy += outGradMag;
                        } else {
                            newXPts[i] = inNormPt.X;
                            newYPts[i] = inNormPt.Y;
                            energy += inGradMag;
                        }
                    } else {
                        newXPts[i] = interpPt.X;
                        newYPts[i] = interpPt.Y;
                        energy += gradMag;
                    }
                }

                if (Math.abs((energy / oldEnergy) - 1) < 0.0001) {
                    break;
                }

                oldEnergy = energy;

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
            }

        }

        // resultGon = new Polygon();
        for (j = 1; j < (yPoints.length - 1); j++) {
            resultGon.addPoint(Math.round(xPoints[j]), Math.round(yPoints[j]));
        }

        return energy;
    }



    private float runSnake(float[] xPoints, float[] yPoints, float[] zPoints, float[] image, VOIBase contour) {
        int i, j;
        int nPts;
        Vector3f interpPt = new Vector3f();
        Vector3f inNormPt = new Vector3f();
        Vector3f outNormPt = new Vector3f();
        Vector3f tangentDir = new Vector3f();
        Vector3f normDir = new Vector3f();
        Vector3f normStep = new Vector3f();
        float normLength = 0;
        float[] newXPts = null, newYPts = null, newZPts = null;
        float stepPct = (float) 0.45;
        float ix = 1, iy = 1;
        float gradMag, inGradMag, outGradMag;
        float energy = 0, oldEnergy = 0;

        Vector<Vector3f> ptsArray;

        Vector3f kPlaneFactor = new Vector3f( 1, 1, 1 );
        if ( GxData == null ) kPlaneFactor.X = 0;
        if ( GyData == null ) kPlaneFactor.Y = 0;
        if ( GzData == null ) kPlaneFactor.Z = 0;

        for (int s = 2; s >= 2.0; s--) {

            for (int z = 0; (z < boundaryIterations) && (!threadStopped); z++) {
                energy = 0;

                ptsArray = cleanLine(xPoints, yPoints, zPoints);

                xPoints = new float[ptsArray.size()];
                yPoints = new float[ptsArray.size()];
                zPoints = new float[ptsArray.size()];

                for (i = 0; i < ptsArray.size(); i++) {
                    xPoints[i] = ((ptsArray.elementAt(i))).X;
                    yPoints[i] = ((ptsArray.elementAt(i))).Y;
                    zPoints[i] = ((ptsArray.elementAt(i))).Z;
                }

                nPts = xPoints.length;
                newXPts = new float[xPoints.length];
                newYPts = new float[xPoints.length];
                newZPts = new float[xPoints.length];

                for (i = 1; i < (nPts - 1); i++) {

                    tangentDir.X = (xPoints[i] - xPoints[i - 1] + xPoints[i + 1] - xPoints[i]) / 2;
                    tangentDir.Y = (yPoints[i] - yPoints[i - 1] + yPoints[i + 1] - yPoints[i]) / 2;

                    interpPt.X = xPoints[i];
                    interpPt.Y = yPoints[i];

                    normLength = (float) Math.sqrt((tangentDir.X * tangentDir.X) + (tangentDir.Y * tangentDir.Y));
                    normDir.X = -tangentDir.Y / normLength;
                    normDir.Y = tangentDir.X / normLength;

                    normStep.X = stepPct * normDir.X;
                    normStep.Y = stepPct * normDir.Y;

                    outNormPt.X = -normStep.X + interpPt.X;
                    outNormPt.Y = -normStep.Y + interpPt.Y;

                    inNormPt.X = normStep.X + interpPt.X;
                    inNormPt.Y = normStep.Y + interpPt.Y;

                    ix = AlgorithmConvolver.convolve2DPt( new Vector2f(interpPt.X, interpPt.Y), srcImage.getExtents(), image, kExtents, GxData);
                    iy = AlgorithmConvolver.convolve2DPt( new Vector2f(interpPt.X, interpPt.Y), srcImage.getExtents(), image, kExtents, GyData);

                    // gradMag = (float)Math.sqrt(ix*ix + iy*iy);
                    gradMag = ((ix * ix) + (iy * iy));

                    if (evolveDirection == OUT_DIR) {
                        inGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt(new Vector2f(inNormPt.X, inNormPt.Y), srcImage.getExtents(), image, kExtents, GxData);
                        iy = AlgorithmConvolver.convolve2DPt(new Vector2f(inNormPt.X, inNormPt.Y), srcImage.getExtents(), image, kExtents, GyData);

                        // inGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        inGradMag = ((ix * ix) + (iy * iy));
                    }

                    if (evolveDirection == IN_DIR) {
                        outGradMag = -1;
                    } else {
                        ix = AlgorithmConvolver.convolve2DPt(new Vector2f(outNormPt.X, outNormPt.Y), srcImage.getExtents(), image, kExtents, GxData);
                        iy = AlgorithmConvolver.convolve2DPt(new Vector2f(outNormPt.X, outNormPt.Y), srcImage.getExtents(), image, kExtents, GyData);

                        // outGradMag = (float)Math.sqrt(ix*ix + iy*iy);
                        outGradMag = ((ix * ix) + (iy * iy));
                    }

                    if ((outGradMag > gradMag) || (inGradMag > gradMag)) {

                        if (outGradMag > inGradMag) {
                            newXPts[i] = outNormPt.X;
                            newYPts[i] = outNormPt.Y;
                            energy += outGradMag;
                        } else {
                            newXPts[i] = inNormPt.X;
                            newYPts[i] = inNormPt.Y;
                            energy += inGradMag;
                        }
                    } else {
                        newXPts[i] = interpPt.X;
                        newYPts[i] = interpPt.Y;
                        energy += gradMag;
                    }
                    newZPts[i] = zPoints[i];
                }

                if (Math.abs((energy / oldEnergy) - 1) < 0.0001) {
                    break;
                }

                oldEnergy = energy;

                newXPts[0] = newXPts[i - 1];
                newYPts[0] = newYPts[i - 1];
                newZPts[0] = newZPts[i - 1];

                newXPts[i] = newXPts[1];
                newYPts[i] = newYPts[1];
                newZPts[i] = newZPts[1];

                xPoints = newXPts;
                yPoints = newYPts;
                zPoints = newZPts;
            }

        }

        // resultGon = new Polygon();
        for (j = 1; j < (yPoints.length - 1); j++) {
            contour.add( new Vector3f( Math.round(xPoints[j]), Math.round(yPoints[j]), Math.round(zPoints[j])) );
        }

        return energy;
    }

    private void propDown( VOIContour resultContour, VOI resultVOI, float baseEnergy, int baseNPts )
    {

        if (propagationType != PROP_NEXT) {
            VOIContour tempContour = new VOIContour(resultContour, -1);
            int slice = (int)tempContour.get(0).Z;
            resultContour = new VOIContour( false, true );

            VOIContour optContour = null;
            
            float tempEnergy = baseEnergy;

            float[] xPoints;
            float[] yPoints;
            float[] zPoints;
            resultContour = new VOIContour( false, true );

            int percent = 25;
            int increment = (100 - percent) / (srcImage.getExtents()[2]);
            fireProgressStateChanged(percent);

            boolean failureFlag = false;
            AlgorithmVOISimplexOpt voiSimplex = new AlgorithmVOISimplexOpt(srcImage, sigmas, AlgorithmVOISimplexOpt.MAXSUM);
            
            int[] extents = srcImage.getExtents();
            int length = extents[0] * extents[1];
            float[] sliceBuf = new float[length];

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, sliceBuf);
                } catch (IOException error) {
                    displayError("Algorithm Bsnake: Image(s) locked");
                    setCompleted(false);
                    return;
                }

                optContour = voiSimplex.goOptimize(sliceBuf, tempContour);
                percent += increment;
                fireProgressStateChanged(percent);
                // @todo + 5 in AlgorithmBSnake (why?)
                xPoints = new float[optContour.size() + 2];
                yPoints = new float[optContour.size() + 2];
                zPoints = new float[optContour.size() + 2];
                setPoints(xPoints, yPoints, zPoints, optContour);
                float energy = runSnake(xPoints, yPoints, zPoints, sliceBuf, resultContour);
                int nPts = resultContour.size();

                if ((nPts < 8) || (Math.abs((energy / tempEnergy) - 1) > PROP_THRESHOLD) ||
                        (Math.abs(((energy / nPts) / (baseEnergy / baseNPts)) - 1) > PROP_THRESHOLD)) {

                    // if the energy sum changed too much, then the single propagation that we wanted to do has failed
                    if (propagationType == PROP_PREV) {
                        setCompleted(false);
                        failureFlag = true;
                    }

                    break;
                }
                resultContour.trimPoints(Preferences.getTrimVoi(),
                        Preferences.getTrimAdjacient());
                resultVOI.importCurve(resultContour);

                tempContour = new VOIContour(resultContour, -1);
                resultContour = new VOIContour( false, true );
                tempEnergy = energy;
                slice--;

                if (slice < 0) {

                    // if we tried to propagate to the previous slice, which doesn't exist
                    if (propagationType == PROP_PREV) {
                        setCompleted(false);
                        failureFlag = true;
                    }

                    break;
                }

                // stop after propagating to one slice if PROP_PREV
                if (propagationType == PROP_PREV) {
                    fireProgressStateChanged(100);

                    if (!failureFlag) {
                        setCompleted(true);
                    }



                    return;
                }
            }

            if (threadStopped) {
                finalize();

                return;
            }
        }
    }

    private void propUp( VOIContour resultContour, VOI resultVOI, float baseEnergy, int baseNPts )
    {

        if (propagationType != PROP_PREV) {

            VOIContour tempContour = new VOIContour(resultContour, 1);
            int slice = (int)tempContour.get(0).Z;
            resultContour = new VOIContour( false, true );

            VOIContour optContour = null;

            float tempEnergy = baseEnergy;

            float[] xPoints;
            float[] yPoints;
            float[] zPoints;
            fireProgressStateChanged(25);

            int percent = 25;
            int increment = (100 - percent) / (srcImage.getExtents()[2]);

            boolean failureFlag = false;
            AlgorithmVOISimplexOpt voiSimplex = new AlgorithmVOISimplexOpt(srcImage, sigmas, AlgorithmVOISimplexOpt.MAXSUM);
            
            int[] extents = srcImage.getExtents();
            int length = extents[0] * extents[1];
            float[] sliceBuf = new float[length];

            while (!threadStopped) {

                try {
                    srcImage.exportData(slice * length, length, sliceBuf);
                } catch (IOException error) {
                    displayError("Algorithm Bsnake: Image(s) locked");
                    setCompleted(false);
                    return;
                }
                optContour = voiSimplex.goOptimize(sliceBuf, tempContour);
                percent += increment;
                fireProgressStateChanged(percent);
                // @todo + 5 in AlgorithmBSnake (why?)
                xPoints = new float[optContour.size() + 2];
                yPoints = new float[optContour.size() + 2];
                zPoints = new float[optContour.size() + 2];
                setPoints(xPoints, yPoints, zPoints, optContour);

                float energy = runSnake(xPoints, yPoints, zPoints, sliceBuf, resultContour);
                int nPts = resultContour.size();

                if ((nPts < 8) || (Math.abs((energy / tempEnergy) - 1) > PROP_THRESHOLD) ||
                        (Math.abs(((energy / nPts) / (baseEnergy / baseNPts)) - 1) > PROP_THRESHOLD)) {

                    // if the energy sum changed too much, then the single propagation that we wanted to do has failed
                    if (propagationType == PROP_NEXT) {
                        setCompleted(false);
                        failureFlag = true;
                    }

                    break;
                }
                resultContour.trimPoints(Preferences.getTrimVoi(),
                        Preferences.getTrimAdjacient());
                resultVOI.importCurve(resultContour);

                tempContour = new VOIContour(resultContour, 1);
                resultContour = new VOIContour( false, true );
                tempEnergy = energy;
                slice++;

                if (slice >= srcImage.getExtents()[2]) {

                    // if we tried to propagate to the next slice, which doesn't exist
                    if (propagationType == PROP_NEXT) {
                        setCompleted(false);
                        failureFlag = true;
                    }

                    break;
                }

                // stop after propagating to one slice if PROP_NEXT
                if (propagationType == PROP_NEXT) {
                    fireProgressStateChanged(100);

                    if (!failureFlag) {
                        setCompleted(true);
                    }



                    return;
                }
            }

            if (threadStopped) {
                finalize();

                return;
            }
        }

    }


    /**
     * Takes the polygon and forms two special arrays for use in runSnake.
     *
     * @param  xPoints  storage location of array of x coord. points
     * @param  yPoints  storage location array of y coord. points
     * @param  gon      initial polygon
     */
    @SuppressWarnings("unused")
    private void setPoints(float[] xPoints, float[] yPoints, Polygon gon) {
        int i;

        xPoints[0] = gon.xpoints[gon.npoints - 1];
        yPoints[0] = gon.ypoints[gon.npoints - 1];

        for (i = 0; i < gon.npoints; i++) {
            xPoints[i + 1] = gon.xpoints[i];
            yPoints[i + 1] = gon.ypoints[i];
        }

        xPoints[gon.npoints + 1] = gon.xpoints[0];
        yPoints[gon.npoints + 1] = gon.ypoints[0];
    }

    private void setPoints(float[] xPoints, float[] yPoints, float[] zPoints, VOIBase contour) {
        xPoints[0] = contour.get(contour.size() - 1).X;
        yPoints[0] = contour.get(contour.size() - 1).Y;
        zPoints[0] = contour.get(contour.size() - 1).Z;

        for (int i = 0; i < contour.size(); i++) {
            xPoints[i + 1] = contour.get(i).X;
            yPoints[i + 1] = contour.get(i).Y;
            zPoints[i + 1] = contour.get(i).Z;
        }

        xPoints[contour.size() + 1] = contour.get(0).X;
        yPoints[contour.size() + 1] = contour.get(0).Y;
        zPoints[contour.size() + 1] = contour.get(0).Z;
    }

}
